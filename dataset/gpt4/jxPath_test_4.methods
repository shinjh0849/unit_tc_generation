protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
protected String getFunctionName() { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return "last"; [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return "position"; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return "count"; [EOL]         case Compiler.FUNCTION_ID: [EOL]             return "id"; [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return "local-name"; [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return "namespace-uri"; [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return "name"; [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return "string"; [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return "concat"; [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return "starts-with"; [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return "contains"; [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return "substring-before"; [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return "substring-after"; [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return "substring"; [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return "string-length"; [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return "normalize-space"; [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return "translate"; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return "boolean"; [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return "not"; [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return "true"; [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return "false"; [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return "lang"; [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return "number"; [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return "sum"; [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return "floor"; [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return "ceiling"; [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return "round"; [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return "key"; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return "format-number"; [EOL]     } [EOL]     return "unknownFunction" + functionCode + "()"; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getFunctionName()); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getFunctionName()); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getFunctionName()); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public int getOrder() { [EOL]     return DYNAMIC_POINTER_FACTORY_ORDER; [EOL] }
public RootContext(JXPathContextReferenceImpl jxpathContext, NodePointer pointer) { [EOL]     super(null); [EOL]     this.jxpathContext = jxpathContext; [EOL]     this.pointer = pointer; [EOL]     if (pointer != null) { [EOL]         pointer.setNamespaceResolver(jxpathContext.getNamespaceResolver()); [EOL]     } [EOL] }
public JXPathContext getJXPathContext() { [EOL]     return jxpathContext; [EOL] }
public RootContext getRootContext() { [EOL]     return this; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     return pointer; [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public EvalContext getConstantContext(Object constant) { [EOL]     if (constant instanceof NodeSet) { [EOL]         return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant); [EOL]     } [EOL]     NodePointer pointer; [EOL]     if (constant instanceof NodePointer) { [EOL]         pointer = (NodePointer) constant; [EOL]     } else { [EOL]         pointer = NodePointer.newNodePointer(new QName(null, ""), constant, null); [EOL]     } [EOL]     return new InitialContext(new RootContext(jxpathContext, pointer)); [EOL] }
public EvalContext getVariableContext(QName variableName) { [EOL]     return new InitialContext(new RootContext(jxpathContext, jxpathContext.getVariablePointer(variableName))); [EOL] }
public EvalContext getVariableContext(QName variableName) { [EOL]     return new InitialContext(new RootContext(jxpathContext, jxpathContext.getVariablePointer(variableName))); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     return jxpathContext.getFunction(functionName, parameters); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     return jxpathContext.getFunction(functionName, parameters); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     return jxpathContext.getFunction(functionName, parameters); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (node instanceof Element) { [EOL]         if (parent instanceof JDOMNodePointer) { [EOL]             if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             String nsURI = getNamespaceURI(); [EOL]             String ln = JDOMNodePointer.getLocalName(node); [EOL]             if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                 buffer.append(ln); [EOL]                 buffer.append('['); [EOL]                 buffer.append(getRelativePositionByName()).append(']'); [EOL]             } else { [EOL]                 String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                 if (prefix != null) { [EOL]                     buffer.append(prefix); [EOL]                     buffer.append(':'); [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()); [EOL]                     buffer.append(']'); [EOL]                 } else { [EOL]                     buffer.append("node()"); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionOfElement()); [EOL]                     buffer.append(']'); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (node instanceof Text || node instanceof CDATA) { [EOL]         buffer.append("/text()"); [EOL]         buffer.append('[').append(getRelativePositionOfTextNode()).append(']'); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String target = ((ProcessingInstruction) node).getTarget(); [EOL]         buffer.append("/processing-instruction(\'").append(target).append("')"); [EOL]         buffer.append('[').append(getRelativePositionOfPI(target)).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private int getRelativePositionByName() { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (!(parent instanceof Element)) { [EOL]             return 1; [EOL]         } [EOL]         List children = ((Element) parent).getContent(); [EOL]         int count = 0; [EOL]         String name = ((Element) node).getQualifiedName(); [EOL]         for (int i = 0; i < children.size(); i++) { [EOL]             Object child = children.get(i); [EOL]             if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { [EOL]                 count++; [EOL]             } [EOL]             if (child == node) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         return count; [EOL]     } [EOL]     return 1; [EOL] }
private int getRelativePositionByName() { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (!(parent instanceof Element)) { [EOL]             return 1; [EOL]         } [EOL]         List children = ((Element) parent).getContent(); [EOL]         int count = 0; [EOL]         String name = ((Element) node).getQualifiedName(); [EOL]         for (int i = 0; i < children.size(); i++) { [EOL]             Object child = children.get(i); [EOL]             if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { [EOL]                 count++; [EOL]             } [EOL]             if (child == node) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         return count; [EOL]     } [EOL]     return 1; [EOL] }
private int getRelativePositionByName() { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (!(parent instanceof Element)) { [EOL]             return 1; [EOL]         } [EOL]         List children = ((Element) parent).getContent(); [EOL]         int count = 0; [EOL]         String name = ((Element) node).getQualifiedName(); [EOL]         for (int i = 0; i < children.size(); i++) { [EOL]             Object child = children.get(i); [EOL]             if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { [EOL]                 count++; [EOL]             } [EOL]             if (child == node) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         return count; [EOL]     } [EOL]     return 1; [EOL] }
private int getRelativePositionByName() { [EOL]     if (node instanceof Element) { [EOL]         Object parent = ((Element) node).getParent(); [EOL]         if (!(parent instanceof Element)) { [EOL]             return 1; [EOL]         } [EOL]         List children = ((Element) parent).getContent(); [EOL]         int count = 0; [EOL]         String name = ((Element) node).getQualifiedName(); [EOL]         for (int i = 0; i < children.size(); i++) { [EOL]             Object child = children.get(i); [EOL]             if ((child instanceof Element) && ((Element) child).getQualifiedName().equals(name)) { [EOL]                 count++; [EOL]             } [EOL]             if (child == node) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         return count; [EOL]     } [EOL]     return 1; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynaBeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynaBeanPointer other = (DynaBeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     return dynaBean == other.dynaBean; [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName_Without_CoreFunctions() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case NCName: [EOL]             jj_consume_token(NCName); [EOL]             break; [EOL]         case OR: [EOL]             jj_consume_token(OR); [EOL]             break; [EOL]         case AND: [EOL]             jj_consume_token(AND); [EOL]             break; [EOL]         case MOD: [EOL]             jj_consume_token(MOD); [EOL]             break; [EOL]         case DIV: [EOL]             jj_consume_token(DIV); [EOL]             break; [EOL]         default: [EOL]             jj_la1[1] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     nc1 = NCName(); [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             nc2 = NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[3] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     nc1 = NCName(); [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             nc2 = NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[3] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public void LocationStep(ArrayList steps) throws ParseException { [EOL]     Object t; [EOL]     Object s; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]             jj_consume_token(SLASH); [EOL]             break; [EOL]         case SLASHSLASH: [EOL]             jj_consume_token(SLASHSLASH); [EOL]             t = compiler.nodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL]             steps.add(compiler.step(Compiler.AXIS_DESCENDANT_OR_SELF, t, null)); [EOL]             break; [EOL]         default: [EOL]             jj_la1[9] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     NodeTest(steps); [EOL] }
final public void LocationStep(ArrayList steps) throws ParseException { [EOL]     Object t; [EOL]     Object s; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]             jj_consume_token(SLASH); [EOL]             break; [EOL]         case SLASHSLASH: [EOL]             jj_consume_token(SLASHSLASH); [EOL]             t = compiler.nodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL]             steps.add(compiler.step(Compiler.AXIS_DESCENDANT_OR_SELF, t, null)); [EOL]             break; [EOL]         default: [EOL]             jj_la1[9] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     NodeTest(steps); [EOL] }
final public void LocationStep(ArrayList steps) throws ParseException { [EOL]     Object t; [EOL]     Object s; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]             jj_consume_token(SLASH); [EOL]             break; [EOL]         case SLASHSLASH: [EOL]             jj_consume_token(SLASHSLASH); [EOL]             t = compiler.nodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL]             steps.add(compiler.step(Compiler.AXIS_DESCENDANT_OR_SELF, t, null)); [EOL]             break; [EOL]         default: [EOL]             jj_la1[9] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     NodeTest(steps); [EOL] }
final public void NodeTest(ArrayList steps) throws ParseException { [EOL]     int axis; [EOL]     int type = -1; [EOL]     String instruction = null; [EOL]     Object name = null; [EOL]     Object s; [EOL]     Object p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 86: [EOL]         case 88: [EOL]             axis = AxisSpecifier(); [EOL]             if (jj_2_3(2147483647)) { [EOL]                 type = NodeType(); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(81); [EOL]             } else if (jj_2_4(2147483647)) { [EOL]                 jj_consume_token(PI); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(Literal); [EOL]                 instruction = unescape(token.image.substring(1, token.image.length() - 1)); [EOL]                 jj_consume_token(81); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                     case 88: [EOL]                         name = WildcardName(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[10] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case 82: [EOL]             jj_consume_token(82); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case 83: [EOL]             jj_consume_token(83); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[11] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     label_3: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[12] = jj_gen; [EOL]                 break label_3; [EOL]         } [EOL]         p = Predicate(); [EOL]         ps.add(p); [EOL]     } [EOL]     if (name != null) { [EOL]         s = compiler.nodeNameTest(name); [EOL]     } else if (instruction != null) { [EOL]         s = compiler.processingInstructionTest(instruction); [EOL]     } else { [EOL]         s = compiler.nodeTypeTest(type); [EOL]     } [EOL]     steps.add(compiler.step(axis, s, ps.toArray())); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object Predicate() throws ParseException { [EOL]     Object ex; [EOL]     jj_consume_token(84); [EOL]     ex = Expression(); [EOL]     jj_consume_token(85); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object Predicate() throws ParseException { [EOL]     Object ex; [EOL]     jj_consume_token(84); [EOL]     ex = Expression(); [EOL]     jj_consume_token(85); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object Predicate() throws ParseException { [EOL]     Object ex; [EOL]     jj_consume_token(84); [EOL]     ex = Expression(); [EOL]     jj_consume_token(85); [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AbbreviatedAxisSpecifier() throws ParseException { [EOL]     int axis = Compiler.AXIS_CHILD; [EOL]     switch(jj_nt.kind) { [EOL]         case 86: [EOL]             jj_consume_token(86); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[15] = jj_gen; [EOL]             ; [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AbbreviatedAxisSpecifier() throws ParseException { [EOL]     int axis = Compiler.AXIS_CHILD; [EOL]     switch(jj_nt.kind) { [EOL]         case 86: [EOL]             jj_consume_token(86); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[15] = jj_gen; [EOL]             ; [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PrimaryExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case VARIABLE: [EOL]             ex = VariableReference(); [EOL]             break; [EOL]         case 80: [EOL]             jj_consume_token(80); [EOL]             ex = Expression(); [EOL]             jj_consume_token(81); [EOL]             break; [EOL]         case Literal: [EOL]             jj_consume_token(Literal); [EOL]             ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1))); [EOL]             break; [EOL]         case Number: [EOL]             jj_consume_token(Number); [EOL]             ex = compiler.number(token.image); [EOL]             break; [EOL]         default: [EOL]             jj_la1[16] = jj_gen; [EOL]             if (jj_2_5(2147483647)) { [EOL]                 ex = CoreFunctionCall(); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                         ex = FunctionCall(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[17] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FunctionCall() throws ParseException { [EOL]     Object name; [EOL]     ArrayList args; [EOL]     name = FunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(name, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(name, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FunctionCall() throws ParseException { [EOL]     Object name; [EOL]     ArrayList args; [EOL]     name = FunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(name, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(name, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FilterExpr() throws ParseException { [EOL]     Object ex, p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     boolean path = false; [EOL]     ArrayList steps = new ArrayList(); [EOL]     ex = PrimaryExpr(); [EOL]     label_6: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[22] = jj_gen; [EOL]                 break label_6; [EOL]         } [EOL]         p = Predicate(); [EOL]         path = true; [EOL]         ps.add(p); [EOL]     } [EOL]     label_7: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[23] = jj_gen; [EOL]                 break label_7; [EOL]         } [EOL]         LocationStep(steps); [EOL]         path = true; [EOL]     } [EOL]     if (path) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.expressionPath(ex, ps.toArray(), steps.toArray()); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return ex; [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object MultiplicativeExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = UnaryExpr(); [EOL]     label_14: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MOD: [EOL]             case DIV: [EOL]             case 88: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[32] = jj_gen; [EOL]                 break label_14; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case 88: [EOL]                 jj_consume_token(88); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.multiply(ex, r); [EOL]                 break; [EOL]             case DIV: [EOL]                 jj_consume_token(DIV); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.divide(ex, r); [EOL]                 break; [EOL]             case MOD: [EOL]                 jj_consume_token(MOD); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.mod(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[33] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object FunctionName() throws ParseException { [EOL]     Object qname; [EOL]     qname = QName_Without_CoreFunctions(); [EOL]     { [EOL]         if (true) [EOL]             return qname; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object VariableReference() throws ParseException { [EOL]     Object ex; [EOL]     jj_consume_token(VARIABLE); [EOL]     ex = QName(); [EOL]     { [EOL]         if (true) [EOL]             return compiler.variableReference(ex); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final private boolean jj_2_1(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_1(); [EOL]     jj_save(0, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_1(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_1(); [EOL]     jj_save(0, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_1(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_1(); [EOL]     jj_save(0, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_3(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_3(); [EOL]     jj_save(2, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_3(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_3(); [EOL]     jj_save(2, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_3(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_3(); [EOL]     jj_save(2, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_4(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_4(); [EOL]     jj_save(3, xla); [EOL]     return retval; [EOL] }
final private boolean jj_2_4(int xla) { [EOL]     jj_la = xla; [EOL]     jj_lastpos = jj_scanpos = token; [EOL]     boolean retval = !jj_3_4(); [EOL]     jj_save(3, xla); [EOL]     return retval; [EOL] }
final private boolean jj_3R_65() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_65() { [EOL]     if (jj_scan_token(FUNCTION_ID)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_63() { [EOL]     if (jj_scan_token(FUNCTION_POSITION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_18() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_62()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_63()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_64()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_65()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_66()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_67()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_68()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_69()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_70()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_71()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_72()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_73()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_74()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_75()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_76()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_77()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_78()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_79()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_80()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_81()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_82()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_83()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_84()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_85()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_86()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_87()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_88()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_89()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_90()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_91()) [EOL]                                                                                                                             return true; [EOL]                                                                                                                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_107() { [EOL]     if (jj_scan_token(NCName)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_107() { [EOL]     if (jj_scan_token(NCName)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_98() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_107()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_108()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_109()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_110()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_111()) [EOL]                         return true; [EOL]                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_152() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_151() { [EOL]     if (jj_scan_token(AXIS_PRECEDING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_20() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_20() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_20() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_20() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_140() { [EOL]     if (jj_scan_token(AXIS_SELF)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_159() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_164()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_165()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_166()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_167()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_167() { [EOL]     if (jj_scan_token(GTE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_158()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_4() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_3() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_101() { [EOL]     if (jj_scan_token(83)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_101() { [EOL]     if (jj_scan_token(83)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_101() { [EOL]     if (jj_scan_token(83)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_100() { [EOL]     if (jj_scan_token(82)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_100() { [EOL]     if (jj_scan_token(82)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_100() { [EOL]     if (jj_scan_token(82)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_61() { [EOL]     if (jj_scan_token(PI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_60() { [EOL]     if (jj_scan_token(COMMENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_59() { [EOL]     if (jj_scan_token(NODE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_58() { [EOL]     if (jj_scan_token(TEXT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_1() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_1() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_1() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3_1() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_17() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_58()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_59()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_60()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_61()) [EOL]                     return true; [EOL]                 if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_124() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_124() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_124() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_124() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_117() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_124()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_117() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_124()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_117() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_124()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_117() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_124()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_103() { [EOL]     if (jj_scan_token(VARIABLE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_117()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_91() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_91() { [EOL]     if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_89() { [EOL]     if (jj_scan_token(FUNCTION_ROUND)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_88() { [EOL]     if (jj_scan_token(FUNCTION_CEILING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_97() { [EOL]     if (jj_3R_106()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_87() { [EOL]     if (jj_scan_token(FUNCTION_FLOOR)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_86() { [EOL]     if (jj_scan_token(FUNCTION_SUM)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_92() { [EOL]     if (jj_3R_103()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_82() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_81() { [EOL]     if (jj_scan_token(FUNCTION_TRUE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_80() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_80() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_80() { [EOL]     if (jj_scan_token(FUNCTION_NOT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_78() { [EOL]     if (jj_scan_token(FUNCTION_TRANSLATE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_77() { [EOL]     if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_19() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_92()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_93()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_94()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_95()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_96()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_97()) [EOL]                             return true; [EOL]                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_76() { [EOL]     if (jj_scan_token(FUNCTION_STRING_LENGTH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_75() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_74() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_73() { [EOL]     if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_71() { [EOL]     if (jj_scan_token(FUNCTION_STARTS_WITH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_70() { [EOL]     if (jj_scan_token(FUNCTION_CONCAT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private Token jj_consume_token(int kind) throws ParseException { [EOL]     Token oldToken = token; [EOL]     if ((token = jj_nt).next != null) [EOL]         jj_nt = jj_nt.next; [EOL]     else [EOL]         jj_nt = jj_nt.next = token_source.getNextToken(); [EOL]     if (token.kind == kind) { [EOL]         jj_gen++; [EOL]         if (++jj_gc > 100) { [EOL]             jj_gc = 0; [EOL]             for (int i = 0; i < jj_2_rtns.length; i++) { [EOL]                 JJCalls c = jj_2_rtns[i]; [EOL]                 while (c != null) { [EOL]                     if (c.gen < jj_gen) [EOL]                         c.first = null; [EOL]                     c = c.next; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return token; [EOL]     } [EOL]     jj_nt = token; [EOL]     token = oldToken; [EOL]     jj_kind = kind; [EOL]     throw generateParseException(); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
final private boolean jj_scan_token(int kind) { [EOL]     if (jj_scanpos == jj_lastpos) { [EOL]         jj_la--; [EOL]         if (jj_scanpos.next == null) { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken(); [EOL]         } else { [EOL]             jj_lastpos = jj_scanpos = jj_scanpos.next; [EOL]         } [EOL]     } else { [EOL]         jj_scanpos = jj_scanpos.next; [EOL]     } [EOL]     if (jj_rescan) { [EOL]         int i = 0; [EOL]         Token tok = token; [EOL]         while (tok != null && tok != jj_scanpos) { [EOL]             i++; [EOL]             tok = tok.next; [EOL]         } [EOL]         if (tok != null) [EOL]             jj_add_error_token(kind, i); [EOL]     } [EOL]     return (jj_scanpos.kind != kind); [EOL] }
public QName(String prefix, String localName) { [EOL]     this.prefix = prefix; [EOL]     this.name = localName; [EOL] }
public QName(String prefix, String localName) { [EOL]     this.prefix = prefix; [EOL]     this.name = localName; [EOL] }
public QName(String prefix, String localName) { [EOL]     this.prefix = prefix; [EOL]     this.name = localName; [EOL] }
public QName(String prefix, String localName) { [EOL]     this.prefix = prefix; [EOL]     this.name = localName; [EOL] }
public String getPrefix() { [EOL]     return prefix; [EOL] }
public String getName() { [EOL]     return name; [EOL] }
public String toString() { [EOL]     if (prefix != null) { [EOL]         return prefix + ':' + name; [EOL]     } [EOL]     return name; [EOL] }
public String toString() { [EOL]     if (prefix != null) { [EOL]         return prefix + ':' + name; [EOL]     } [EOL]     return name; [EOL] }
private static NodePointer doStep(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (parent == null) { [EOL]         return null; [EOL]     } [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     if (parent instanceof PropertyOwnerPointer) { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } [EOL]     } else { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesStandard(context, parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesStandard(context, parent, steps, currentStep); [EOL]         } [EOL]     } [EOL] }
private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         return doStep(context, parentPointer, steps, currentStep + 1); [EOL]     } [EOL]     int bestQuality = 0; [EOL]     NodePointer bestMatch = null; [EOL]     NodeIterator it = getNodeIterator(context, parentPointer, step); [EOL]     if (it != null) { [EOL]         for (int i = 1; it.setPosition(i); i++) { [EOL]             NodePointer childPointer = it.getNodePointer(); [EOL]             if (steps.length == currentStep + 1) { [EOL]                 return childPointer; [EOL]             } [EOL]             NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL]             int quality = computeQuality(pointer); [EOL]             if (quality == PERFECT_MATCH) { [EOL]                 return pointer; [EOL]             } else if (quality > bestQuality) { [EOL]                 bestQuality = quality; [EOL]                 bestMatch = (NodePointer) pointer.clone(); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         return bestMatch; [EOL]     } [EOL]     return createNullPointer(context, parentPointer, steps, currentStep); [EOL] }
private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_SELF) { [EOL]         return doPredicate(context, parent, steps, currentStep, predicates, 0); [EOL]     } [EOL]     Expression predicate = predicates[0]; [EOL]     if (predicates.length == 1) { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         NodePointer pointer = null; [EOL]         if (it != null) { [EOL]             if (predicate instanceof NameAttributeTest) { [EOL]                 String key = keyFromPredicate(context, predicate); [EOL]                 for (int i = 1; it.setPosition(i); i++) { [EOL]                     NodePointer ptr = it.getNodePointer(); [EOL]                     if (isNameAttributeEqual(ptr, key)) { [EOL]                         pointer = ptr; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 int index = indexFromPredicate(context, predicate); [EOL]                 if (it.setPosition(index + 1)) { [EOL]                     pointer = it.getNodePointer(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (pointer != null) { [EOL]             return doStep(context, pointer, steps, currentStep + 1); [EOL]         } [EOL]     } else { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         if (it != null) { [EOL]             List list = new ArrayList(); [EOL]             for (int i = 1; it.setPosition(i); i++) { [EOL]                 list.add(it.getNodePointer()); [EOL]             } [EOL]             NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep); [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]         return pointer.childIterator(nodeTest, false, null); [EOL]     } else { [EOL]         if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL]             throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL]         } [EOL]         return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL]     } [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id(" + id + ")"; [EOL]     } [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "null()"; [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id(" + id + ")"; [EOL]     } [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "null()"; [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id(" + id + ")"; [EOL]     } [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "null()"; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public NullElementPointer(NodePointer parent, int index) { [EOL]     super(parent, (Object) null); [EOL]     this.index = index; [EOL] }
public NullElementPointer(NodePointer parent, int index) { [EOL]     super(parent, (Object) null); [EOL]     this.index = index; [EOL] }
public QName getName() { [EOL]     return null; [EOL] }
public NodePointer getValuePointer() { [EOL]     return new NullPointer(this, getName()); [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     return parent.createChild(context, null, index); [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         createPath(context); [EOL]         ValueUtils.setValue(getBaseValue(), index, value); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         createPath(context); [EOL]         ValueUtils.setValue(getBaseValue(), index, value); [EOL]     } [EOL]     return this; [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public JXPathContextFactoryReferenceImpl() { [EOL] }
public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError { [EOL]     return new JXPathContextReferenceImpl(parentContext, contextBean); [EOL] }
public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError { [EOL]     return new JXPathContextReferenceImpl(parentContext, contextBean); [EOL] }
public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError { [EOL]     return new JXPathContextReferenceImpl(parentContext, contextBean); [EOL] }
public EvalContext(EvalContext parentContext) { [EOL]     this.parentContext = parentContext; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public EvalContext(EvalContext parentContext) { [EOL]     this.parentContext = parentContext; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public JXPathContext getJXPathContext() { [EOL]     return getRootContext().getJXPathContext(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean isChildOrderingRequired() { [EOL]     if (getDocumentOrder() != 0) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object next() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.next(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         if (!constructIterator()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         return pointerIterator.next(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         if (done) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         hasPerformedIteratorStep = false; [EOL]         return getCurrentNodePointer(); [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
private boolean constructIterator() { [EOL]     HashSet set = new HashSet(); [EOL]     ArrayList list = new ArrayList(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             NodePointer pointer = getCurrentNodePointer(); [EOL]             if (!set.contains(pointer)) { [EOL]                 set.add(pointer); [EOL]                 list.add(pointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     if (getDocumentOrder() == 1) { [EOL]         Collections.sort(list); [EOL]     } else { [EOL]         Collections.sort(list, REVERSE_COMPARATOR); [EOL]     } [EOL]     pointerIterator = list.iterator(); [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public RootContext getRootContext() { [EOL]     if (rootContext == null) { [EOL]         rootContext = parentContext.getRootContext(); [EOL]     } [EOL]     return rootContext; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public RootContext getRootContext() { [EOL]     if (rootContext == null) { [EOL]         rootContext = parentContext.getRootContext(); [EOL]     } [EOL]     return rootContext; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public void reset() { [EOL]     position = 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public void reset() { [EOL]     position = 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public void reset() { [EOL]     position = 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getCurrentPosition() { [EOL]     return position; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean nextSet() { [EOL]     reset(); [EOL]     if (!startedSetIteration) { [EOL]         startedSetIteration = true; [EOL]         while (parentContext.nextSet()) { [EOL]             if (parentContext.nextNode()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (parentContext.nextNode()) { [EOL]         return true; [EOL]     } [EOL]     while (parentContext.nextSet()) { [EOL]         if (parentContext.nextNode()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Constant(Number number) { [EOL]     this.value = number; [EOL] }
public Constant(Number number) { [EOL]     this.value = number; [EOL] }
public Constant(String string) { [EOL]     this.value = string; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return value; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return value; [EOL] }
public boolean isContextDependent() { [EOL]     return false; [EOL] }
public String toString() { [EOL]     if (value instanceof Number) { [EOL]         double doubleValue = ((Number) value).doubleValue(); [EOL]         long longValue = ((Number) value).longValue(); [EOL]         if (doubleValue == longValue) { [EOL]             return String.valueOf(longValue); [EOL]         } else { [EOL]             return String.valueOf(doubleValue); [EOL]         } [EOL]     } else { [EOL]         return "'" + value + "'"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (value instanceof Number) { [EOL]         double doubleValue = ((Number) value).doubleValue(); [EOL]         long longValue = ((Number) value).longValue(); [EOL]         if (doubleValue == longValue) { [EOL]             return String.valueOf(longValue); [EOL]         } else { [EOL]             return String.valueOf(doubleValue); [EOL]         } [EOL]     } else { [EOL]         return "'" + value + "'"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (value instanceof Number) { [EOL]         double doubleValue = ((Number) value).doubleValue(); [EOL]         long longValue = ((Number) value).longValue(); [EOL]         if (doubleValue == longValue) { [EOL]             return String.valueOf(longValue); [EOL]         } else { [EOL]             return String.valueOf(doubleValue); [EOL]         } [EOL]     } else { [EOL]         return "'" + value + "'"; [EOL]     } [EOL] }
public int getOrder() { [EOL]     return BEAN_POINTER_FACTORY_ORDER; [EOL] }
protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL]     Object l = left.compute(context); [EOL]     Object r = right.compute(context); [EOL]     if (l instanceof InitialContext || l instanceof SelfContext) { [EOL]         l = ((EvalContext) l).getSingleNodePointer(); [EOL]     } [EOL]     if (r instanceof InitialContext || r instanceof SelfContext) { [EOL]         r = ((EvalContext) r).getSingleNodePointer(); [EOL]     } [EOL]     if (l instanceof Collection) { [EOL]         l = ((Collection) l).iterator(); [EOL]     } [EOL]     if (r instanceof Collection) { [EOL]         r = ((Collection) r).iterator(); [EOL]     } [EOL]     if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL]         return contains((Iterator) l, r); [EOL]     } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL]         return contains((Iterator) r, l); [EOL]     } else if (l instanceof Iterator && r instanceof Iterator) { [EOL]         return findMatch((Iterator) l, (Iterator) r); [EOL]     } [EOL]     return equal(l, r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         return true; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         return true; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType.isAssignableFrom(fromType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType == String.class) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof Boolean) { [EOL]         if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Number) { [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         if (toType.isPrimitive()) { [EOL]             return true; [EOL]         } [EOL]         if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (fromType.isArray()) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             int length = Array.getLength(object); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (Array.getLength(object) > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             while (it.hasNext()) { [EOL]                 Object value = it.next(); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (((Collection) object).size() > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return canConvert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return canConvert(((Pointer) object).getValue(), toType); [EOL]     } [EOL]     return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         if (toType.isPrimitive()) { [EOL]             return convertNullToPrimitive(toType); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         if (object instanceof NodeSet) { [EOL]             return convert(((NodeSet) object).getValues(), toType); [EOL]         } else if (object instanceof Pointer) { [EOL]             return convert(((Pointer) object).getValue(), toType); [EOL]         } [EOL]         return object; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL]         return object; [EOL]     } [EOL]     if (fromType.isArray()) { [EOL]         int length = Array.getLength(object); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 collection.add(Array.get(object, i)); [EOL]             } [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         int length = ((Collection) object).size(); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = it.next(); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             collection.addAll((Collection) object); [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return convert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return convert(((Pointer) object).getValue(), toType); [EOL]     } else if (toType == String.class) { [EOL]         return object.toString(); [EOL]     } else if (object instanceof Boolean) { [EOL]         if (toType == boolean.class) { [EOL]             return object; [EOL]         } [EOL]         boolean value = ((Boolean) object).booleanValue(); [EOL]         return allocateNumber(toType, value ? 1 : 0); [EOL]     } else if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         if (toType == boolean.class || toType == Boolean.class) { [EOL]             return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return allocateNumber(toType, value); [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return object; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         Object value = convertStringToPrimitive(object, toType); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     Converter converter = ConvertUtils.lookup(toType); [EOL]     if (converter != null) { [EOL]         return converter.convert(toType, object); [EOL]     } [EOL]     throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected boolean canCreateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         return true; [EOL]     } [EOL]     if (type == List.class) { [EOL]         return true; [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean canCreateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         return true; [EOL]     } [EOL]     if (type == List.class) { [EOL]         return true; [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean canCreateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         return true; [EOL]     } [EOL]     if (type == List.class) { [EOL]         return true; [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean canCreateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         return true; [EOL]     } [EOL]     if (type == List.class) { [EOL]         return true; [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected Collection allocateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         try { [EOL]             return (Collection) type.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathInvalidAccessException("Cannot create collection of type: " + type, ex); [EOL]         } [EOL]     } [EOL]     if (type == List.class) { [EOL]         return new ArrayList(); [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return new HashSet(); [EOL]     } [EOL]     throw new JXPathInvalidAccessException("Cannot create collection of type: " + type); [EOL] }
protected Collection allocateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         try { [EOL]             return (Collection) type.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathInvalidAccessException("Cannot create collection of type: " + type, ex); [EOL]         } [EOL]     } [EOL]     if (type == List.class) { [EOL]         return new ArrayList(); [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return new HashSet(); [EOL]     } [EOL]     throw new JXPathInvalidAccessException("Cannot create collection of type: " + type); [EOL] }
protected Collection allocateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         try { [EOL]             return (Collection) type.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathInvalidAccessException("Cannot create collection of type: " + type, ex); [EOL]         } [EOL]     } [EOL]     if (type == List.class) { [EOL]         return new ArrayList(); [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return new HashSet(); [EOL]     } [EOL]     throw new JXPathInvalidAccessException("Cannot create collection of type: " + type); [EOL] }
protected Collection allocateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         try { [EOL]             return (Collection) type.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathInvalidAccessException("Cannot create collection of type: " + type, ex); [EOL]         } [EOL]     } [EOL]     if (type == List.class) { [EOL]         return new ArrayList(); [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return new HashSet(); [EOL]     } [EOL]     throw new JXPathInvalidAccessException("Cannot create collection of type: " + type); [EOL] }
protected Collection allocateCollection(Class type) { [EOL]     if (!type.isInterface() && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) { [EOL]         try { [EOL]             return (Collection) type.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathInvalidAccessException("Cannot create collection of type: " + type, ex); [EOL]         } [EOL]     } [EOL]     if (type == List.class) { [EOL]         return new ArrayList(); [EOL]     } [EOL]     if (type == Set.class) { [EOL]         return new HashSet(); [EOL]     } [EOL]     throw new JXPathInvalidAccessException("Cannot create collection of type: " + type); [EOL] }
protected Collection unmodifiableCollection(Collection collection) { [EOL]     if (collection instanceof List) { [EOL]         return Collections.unmodifiableList((List) collection); [EOL]     } else if (collection instanceof Set) { [EOL]         return Collections.unmodifiableSet((Set) collection); [EOL]     } [EOL]     return collection; [EOL] }
protected Collection unmodifiableCollection(Collection collection) { [EOL]     if (collection instanceof List) { [EOL]         return Collections.unmodifiableList((List) collection); [EOL]     } else if (collection instanceof Set) { [EOL]         return Collections.unmodifiableSet((Set) collection); [EOL]     } [EOL]     return collection; [EOL] }
protected Collection unmodifiableCollection(Collection collection) { [EOL]     if (collection instanceof List) { [EOL]         return Collections.unmodifiableList((List) collection); [EOL]     } else if (collection instanceof Set) { [EOL]         return Collections.unmodifiableSet((Set) collection); [EOL]     } [EOL]     return collection; [EOL] }
public CoreOperationEqual(Expression arg1, Expression arg2) { [EOL]     super(arg1, arg2); [EOL] }
protected int getPrecedence() { [EOL]     return 2; [EOL] }
public String getSymbol() { [EOL]     return "="; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
public InitialContext(EvalContext parentContext) { [EOL]     super(parentContext); [EOL]     nodePointer = (NodePointer) parentContext.getCurrentNodePointer().clone(); [EOL]     if (nodePointer != null) { [EOL]         collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION); [EOL]     } [EOL] }
public InitialContext(EvalContext parentContext) { [EOL]     super(parentContext); [EOL]     nodePointer = (NodePointer) parentContext.getCurrentNodePointer().clone(); [EOL]     if (nodePointer != null) { [EOL]         collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION); [EOL]     } [EOL] }
public InitialContext(EvalContext parentContext) { [EOL]     super(parentContext); [EOL]     nodePointer = (NodePointer) parentContext.getCurrentNodePointer().clone(); [EOL]     if (nodePointer != null) { [EOL]         collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION); [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     return nodePointer; [EOL] }
public Object getValue() { [EOL]     return nodePointer.getValue(); [EOL] }
public boolean nextNode() { [EOL]     return setPosition(position + 1); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean nextSet() { [EOL]     if (started) { [EOL]         return false; [EOL]     } [EOL]     started = true; [EOL]     return true; [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Object compute(EvalContext context) { [EOL]     return computeValue(context); [EOL] }
public Object qname(String prefix, String name) { [EOL]     return new QName(prefix, name); [EOL] }
public Object qname(String prefix, String name) { [EOL]     return new QName(prefix, name); [EOL] }
public Object qname(String prefix, String name) { [EOL]     return new QName(prefix, name); [EOL] }
public Object qname(String prefix, String name) { [EOL]     return new QName(prefix, name); [EOL] }
public Object divide(Object left, Object right) { [EOL]     return new CoreOperationDivide((Expression) left, (Expression) right); [EOL] }
public Object greaterThanOrEqual(Object left, Object right) { [EOL]     return new CoreOperationGreaterThanOrEqual((Expression) left, (Expression) right); [EOL] }
public Object greaterThanOrEqual(Object left, Object right) { [EOL]     return new CoreOperationGreaterThanOrEqual((Expression) left, (Expression) right); [EOL] }
public Object greaterThanOrEqual(Object left, Object right) { [EOL]     return new CoreOperationGreaterThanOrEqual((Expression) left, (Expression) right); [EOL] }
public Object variableReference(Object qName) { [EOL]     return new VariableReference((QName) qName); [EOL] }
public Object function(Object name, Object[] args) { [EOL]     return new ExtensionFunction((QName) name, toExpressionArray(args)); [EOL] }
public Object function(Object name, Object[] args) { [EOL]     return new ExtensionFunction((QName) name, toExpressionArray(args)); [EOL] }
public Object function(Object name, Object[] args) { [EOL]     return new ExtensionFunction((QName) name, toExpressionArray(args)); [EOL] }
public Object expressionPath(Object expression, Object[] predicates, Object[] steps) { [EOL]     return new ExpressionPath((Expression) expression, toExpressionArray(predicates), toStepArray(steps)); [EOL] }
public Object nodeNameTest(Object qname) { [EOL]     return new NodeNameTest((QName) qname); [EOL] }
public Object nodeNameTest(Object qname) { [EOL]     return new NodeNameTest((QName) qname); [EOL] }
public Object nodeTypeTest(int nodeType) { [EOL]     return new NodeTypeTest(nodeType); [EOL] }
public Object nodeTypeTest(int nodeType) { [EOL]     return new NodeTypeTest(nodeType); [EOL] }
public Object step(int axis, Object nodeTest, Object[] predicates) { [EOL]     return new Step(axis, (NodeTest) nodeTest, toExpressionArray(predicates)); [EOL] }
private Step[] toStepArray(Object[] array) { [EOL]     Step[] stepArray = null; [EOL]     if (array != null) { [EOL]         stepArray = new Step[array.length]; [EOL]         for (int i = 0; i < stepArray.length; i++) { [EOL]             stepArray[i] = (Step) array[i]; [EOL]         } [EOL]     } [EOL]     return stepArray; [EOL] }
private Step[] toStepArray(Object[] array) { [EOL]     Step[] stepArray = null; [EOL]     if (array != null) { [EOL]         stepArray = new Step[array.length]; [EOL]         for (int i = 0; i < stepArray.length; i++) { [EOL]             stepArray[i] = (Step) array[i]; [EOL]         } [EOL]     } [EOL]     return stepArray; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public CoreOperationLessThan(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected int getPrecedence() { [EOL]     return 3; [EOL] }
protected boolean isSymmetric() { [EOL]     return false; [EOL] }
public String getSymbol() { [EOL]     return "<"; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     int axis = getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD) { [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         buffer.append('@'); [EOL]         buffer.append(nodeTest); [EOL]     } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append("."); [EOL]     } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]         buffer.append(".."); [EOL]     } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) { [EOL]         buffer.append(""); [EOL]     } else { [EOL]         buffer.append(axisToString(axis)); [EOL]         buffer.append("::"); [EOL]         buffer.append(nodeTest); [EOL]     } [EOL]     Expression[] predicates = getPredicates(); [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             buffer.append('['); [EOL]             buffer.append(predicates[i]); [EOL]             buffer.append(']'); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String axisToString(int axis) { [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_SELF: [EOL]             return "self"; [EOL]         case Compiler.AXIS_CHILD: [EOL]             return "child"; [EOL]         case Compiler.AXIS_PARENT: [EOL]             return "parent"; [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return "ancestor"; [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return "attribute"; [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return "namespace"; [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return "preceding"; [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return "following"; [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return "descendant"; [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return "ancestor-or-self"; [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return "following-sibling"; [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return "preceding-sibling"; [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return "descendant-or-self"; [EOL]     } [EOL]     return "UNKNOWN"; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     return defaultNamespaceURI; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     return defaultNamespaceURI; [EOL] }
public void registerDefaultNamespaceURI(String uri) { [EOL]     this.defaultNamespaceURI = uri; [EOL] }
public void seal() { [EOL]     sealed = true; [EOL]     if (parent != null) { [EOL]         parent.seal(); [EOL]     } [EOL] }
public void seal() { [EOL]     sealed = true; [EOL]     if (parent != null) { [EOL]         parent.seal(); [EOL]     } [EOL] }
private static JXPathContextFactory getContextFactory() { [EOL]     if (contextFactory == null) { [EOL]         contextFactory = JXPathContextFactory.newInstance(); [EOL]     } [EOL]     return contextFactory; [EOL] }
private static JXPathContextFactory getContextFactory() { [EOL]     if (contextFactory == null) { [EOL]         contextFactory = JXPathContextFactory.newInstance(); [EOL]     } [EOL]     return contextFactory; [EOL] }
public Object getContextBean() { [EOL]     return contextBean; [EOL] }
public Variables getVariables() { [EOL]     if (vars == null) { [EOL]         vars = new BasicVariables(); [EOL]     } [EOL]     return vars; [EOL] }
public Variables getVariables() { [EOL]     if (vars == null) { [EOL]         vars = new BasicVariables(); [EOL]     } [EOL]     return vars; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL]     lenientSet = true; [EOL] }
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL]     lenientSet = true; [EOL] }
public boolean isLenient() { [EOL]     if (!lenientSet && parentContext != null) { [EOL]         return parentContext.isLenient(); [EOL]     } [EOL]     return lenient; [EOL] }
public boolean isLenient() { [EOL]     if (!lenientSet && parentContext != null) { [EOL]         return parentContext.isLenient(); [EOL]     } [EOL]     return lenient; [EOL] }
public boolean isLenient() { [EOL]     if (!lenientSet && parentContext != null) { [EOL]         return parentContext.isLenient(); [EOL]     } [EOL]     return lenient; [EOL] }
public static CompiledExpression compile(String xpath) { [EOL]     if (compilationContext == null) { [EOL]         compilationContext = JXPathContext.newContext(null); [EOL]     } [EOL]     return compilationContext.compilePath(xpath); [EOL] }
public static CompiledExpression compile(String xpath) { [EOL]     if (compilationContext == null) { [EOL]         compilationContext = JXPathContext.newContext(null); [EOL]     } [EOL]     return compilationContext.compilePath(xpath); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object target; [EOL]         Object[] args; [EOL]         if (Modifier.isStatic(method.getModifiers())) { [EOL]             target = null; [EOL]             if (parameters == null) { [EOL]                 parameters = EMPTY_ARRAY; [EOL]             } [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             args = new Object[parameters.length + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 0; i < parameters.length; i++) { [EOL]                 args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]             } [EOL]         } else { [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL]             args = new Object[parameters.length - 1 + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 1; i < parameters.length; i++) { [EOL]                 args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL]             } [EOL]         } [EOL]         return method.invoke(target, args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL]     } [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new BeanAttributeIterator(this, name); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new BeanAttributeIterator(this, name); [EOL] }
protected boolean isSimpleStep(Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeTypeTest)) { [EOL]             return false; [EOL]         } [EOL]         int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL]         if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         if (((NodeNameTest) nodeTest).isWildcard()) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } [EOL]     return false; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(value, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(value, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     super.setIndex(index); [EOL]     valuePointer = null; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = null; [EOL]         if (actual) { [EOL]             value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, null, value); [EOL]         } else { [EOL]             return new NullPointer(this, getName()) { [EOL]  [EOL]                 public Object getImmediateNode() { [EOL]                     throw new JXPathException("Undefined variable: " + name); [EOL]                 } [EOL]             }; [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public int getLength() { [EOL]     if (actual) { [EOL]         Object value = getBaseValue(); [EOL]         if (value == null) { [EOL]             return 1; [EOL]         } [EOL]         return ValueUtils.getLength(value); [EOL]     } [EOL]     return 0; [EOL] }
public int getLength() { [EOL]     if (actual) { [EOL]         Object value = getBaseValue(); [EOL]         if (value == null) { [EOL]             return 1; [EOL]         } [EOL]         return ValueUtils.getLength(value); [EOL]     } [EOL]     return 0; [EOL] }
public int getLength() { [EOL]     if (actual) { [EOL]         Object value = getBaseValue(); [EOL]         if (value == null) { [EOL]             return 1; [EOL]         } [EOL]         return ValueUtils.getLength(value); [EOL]     } [EOL]     return 0; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return getValuePointer().childIterator(test, reverse, startWith); [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         NodePointer pointer = factories[i].createNodePointer(parent, name, bean); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         NodePointer pointer = factories[i].createNodePointer(parent, name, bean); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] }
protected NodePointer(NodePointer parent) { [EOL]     this.parent = parent; [EOL] }
public NamespaceResolver getNamespaceResolver() { [EOL]     if (namespaceResolver == null && parent != null) { [EOL]         namespaceResolver = parent.getNamespaceResolver(); [EOL]     } [EOL]     return namespaceResolver; [EOL] }
public NamespaceResolver getNamespaceResolver() { [EOL]     if (namespaceResolver == null && parent != null) { [EOL]         namespaceResolver = parent.getNamespaceResolver(); [EOL]     } [EOL]     return namespaceResolver; [EOL] }
public NamespaceResolver getNamespaceResolver() { [EOL]     if (namespaceResolver == null && parent != null) { [EOL]         namespaceResolver = parent.getNamespaceResolver(); [EOL]     } [EOL]     return namespaceResolver; [EOL] }
public void setNamespaceResolver(NamespaceResolver namespaceResolver) { [EOL]     this.namespaceResolver = namespaceResolver; [EOL] }
public int getIndex() { [EOL]     return index; [EOL] }
public void setIndex(int index) { [EOL]     this.index = index; [EOL] }
public NodePointer getValuePointer() { [EOL]     NodePointer ivp = getImmediateValuePointer(); [EOL]     if (ivp != this) { [EOL]         return ivp.getValuePointer(); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer getValuePointer() { [EOL]     NodePointer ivp = getImmediateValuePointer(); [EOL]     if (ivp != this) { [EOL]         return ivp.getValuePointer(); [EOL]     } [EOL]     return this; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     return this; [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] }
public Object getNode() { [EOL]     return getValuePointer().getImmediateNode(); [EOL] }
public Object clone() { [EOL]     try { [EOL]         NodePointer ptr = (NodePointer) super.clone(); [EOL]         if (parent != null) { [EOL]             ptr.parent = (NodePointer) parent.clone(); [EOL]         } [EOL]         return ptr; [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         ex.printStackTrace(); [EOL]     } [EOL]     return null; [EOL] }
public Object clone() { [EOL]     try { [EOL]         NodePointer ptr = (NodePointer) super.clone(); [EOL]         if (parent != null) { [EOL]             ptr.parent = (NodePointer) parent.clone(); [EOL]         } [EOL]         return ptr; [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         ex.printStackTrace(); [EOL]     } [EOL]     return null; [EOL] }
public String toString() { [EOL]     return asPath(); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
public int hashCode() { [EOL]     return System.identityHashCode(attr); [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public int getOrder() { [EOL]     return JDOM_POINTER_FACTORY_ORDER; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public int getDocumentOrder() { [EOL]     return -1; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean isLeaf() { [EOL]     return getValuePointer().isLeaf(); [EOL] }
public boolean isLeaf() { [EOL]     return getValuePointer().isLeaf(); [EOL] }
public boolean testNode(NodeTest nodeTest) { [EOL]     return getValuePointer().testNode(nodeTest); [EOL] }
public boolean testNode(NodeTest nodeTest) { [EOL]     return getValuePointer().testNode(nodeTest); [EOL] }
public boolean testNode(NodeTest nodeTest) { [EOL]     return getValuePointer().testNode(nodeTest); [EOL] }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL]     switch(pos) { [EOL]         case 0: [EOL]             if ((active1 & 0xc0000L) != 0L) [EOL]                 return 10; [EOL]             if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 1: [EOL]             if ((active0 & 0x8000008000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 1; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 2: [EOL]             if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 2; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 3: [EOL]             if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL]                 if (jjmatchedPos != 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 4: [EOL]             if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 4; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 5: [EOL]             if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL]                 if (jjmatchedPos != 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 6: [EOL]             if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 6; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 7: [EOL]             if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 7; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x802000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 8: [EOL]             if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 if (jjmatchedPos != 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 9: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 9; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 10: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 10; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 11: [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 11; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 12: [EOL]             if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 12; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 13: [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 13; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 14: [EOL]             if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x1000f00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 14; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 15: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xf00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 15; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 16: [EOL]             if ((active0 & 0xe00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 16; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 17: [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 17; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 18: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 18; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 19: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 19; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 20: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 20; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         default: [EOL]             return -1; [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjStartNfa_0(int pos, long active0, long active1) { [EOL]     return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(1, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(2, active0, active1); [EOL]         return 3; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x80000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 31, 12); [EOL]             else if ((active0 & 0x80000000000000L) != 0L) { [EOL]                 jjmatchedKind = 55; [EOL]                 jjmatchedPos = 3; [EOL]             } else if ((active1 & 0x10L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 68, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x80L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 71, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL]         case 108: [EOL]             if ((active1 & 0x40L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 70, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL]         case 116: [EOL]             if ((active0 & 0x100000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 32, 12); [EOL]             else if ((active0 & 0x1000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 48, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(2, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(3, active0, active1); [EOL]         return 4; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL]         case 100: [EOL]             if ((active1 & 0x1000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 76, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x20L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 69, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x400L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 74, 12); [EOL]             break; [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL]         case 116: [EOL]             if ((active0 & 0x4000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 50, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(3, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(3, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(4, active0, active1); [EOL]         return 5; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x800000000L) != 0L) [EOL]                 return jjStopAtPos(5, 35); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active0 & 0x100000000000000L) != 0L) { [EOL]                 jjmatchedKind = 56; [EOL]                 jjmatchedPos = 5; [EOL]             } [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x100L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 72, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 57, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(4, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(6, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(7, active0, active1); [EOL]         return 8; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x2L) != 0L) [EOL]                 return jjStartNfaWithStates_0(8, 65, 12); [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL]         case 103: [EOL]             if ((active0 & 0x4000000000000000L) != 0L) { [EOL]                 jjmatchedKind = 62; [EOL]                 jjmatchedPos = 8; [EOL]             } [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(7, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(8, active0, active1); [EOL]         return 9; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL]         case 58: [EOL]             if ((active0 & 0x4000000000L) != 0L) [EOL]                 return jjStopAtPos(9, 38); [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(9, 53, 12); [EOL]             break; [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(8, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(9, active0, active1); [EOL]         return 10; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x8000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 39); [EOL]             else if ((active0 & 0x10000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 40); [EOL]             else if ((active0 & 0x20000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 41); [EOL]             else if ((active0 & 0x40000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 42); [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(10, 58, 12); [EOL]             break; [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(9, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(10, active0, active1); [EOL]         return 11; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x80000000000L) != 0L) [EOL]                 return jjStopAtPos(11, 43); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(10, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(10, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(11, active0, active1); [EOL]         return 12; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x8000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 63, 12); [EOL]             break; [EOL]         case 105: [EOL]             if ((active0 & 0x40000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 54, 12); [EOL]             break; [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x2000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 77, 12); [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(11, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(11, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(12, active0, active1); [EOL]         return 13; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(12, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(12, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(13, active0, active1); [EOL]         return 14; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active1 & 0x1L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 64, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active0 & 0x2000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 61, 12); [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(13, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(13, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(14, active0, 0L); [EOL]         return 15; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(15, 60, 12); [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(14, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(14, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(15, active0, 0L); [EOL]         return 16; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(15, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(15, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(16, active0, 0L); [EOL]         return 17; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x100000000000L) != 0L) [EOL]                 return jjStopAtPos(17, 44); [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(16, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(16, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(17, active0, 0L); [EOL]         return 18; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x200000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 45); [EOL]             else if ((active0 & 0x400000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 46); [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(17, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa19_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(17, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(18, active0, 0L); [EOL]         return 19; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x800000000000L) != 0L) [EOL]                 return jjStopAtPos(19, 47); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa20_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(18, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveNfa_0(int startState, int curPos) { [EOL]     int[] nextStates; [EOL]     int startsAt = 0; [EOL]     jjnewStateCnt = 13; [EOL]     int i = 1; [EOL]     jjstateSet[0] = startState; [EOL]     int j, kind = 0x7fffffff; [EOL]     for (; ; ) { [EOL]         if (++jjround == 0x7fffffff) [EOL]             ReInitRounds(); [EOL]         if (curChar < 64) { [EOL]             long l = 1L << curChar; [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if ((0x3ff000000000000L & l) != 0L) { [EOL]                             if (kind > 20) [EOL]                                 kind = 20; [EOL]                             jjCheckNAddTwoStates(6, 7); [EOL]                         } else if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         else if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         else if (curChar == 34) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 1: [EOL]                         if ((0xfffffffbffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 2: [EOL]                         if (curChar == 34 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 3: [EOL]                         if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 4: [EOL]                         if ((0xffffff7fffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 5: [EOL]                         if (curChar == 39 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 6: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAddTwoStates(6, 7); [EOL]                         break; [EOL]                     case 7: [EOL]                         if (curChar != 46) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 8: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 9: [EOL]                         if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 10: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 12: [EOL]                         if ((0x3ff600000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjstateSet[jjnewStateCnt++] = 12; [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else if (curChar < 128) { [EOL]             long l = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                     case 12: [EOL]                         if ((0x7fffffe87fffffeL & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         jjAddStates(2, 3); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else { [EOL]             int hiByte = (int) (curChar >> 8); [EOL]             int i1 = hiByte >> 6; [EOL]             long l1 = 1L << (hiByte & 077); [EOL]             int i2 = (curChar & 0xff) >> 6; [EOL]             long l2 = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(2, 3); [EOL]                         break; [EOL]                     case 12: [EOL]                         if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } [EOL]         if (kind != 0x7fffffff) { [EOL]             jjmatchedKind = kind; [EOL]             jjmatchedPos = curPos; [EOL]             kind = 0x7fffffff; [EOL]         } [EOL]         ++curPos; [EOL]         if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL]             return curPos; [EOL]         try { [EOL]             curChar = input_stream.readChar(); [EOL]         } catch (java.io.IOException e) { [EOL]             return curPos; [EOL]         } [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     if (id != null) { [EOL]         return "id('" + escape(id) + "')"; [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     switch(node.getNodeType()) { [EOL]         case Node.ELEMENT_NODE: [EOL]             if (parent instanceof DOMNodePointer) { [EOL]                 if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]                     buffer.append('/'); [EOL]                 } [EOL]                 String ln = DOMNodePointer.getLocalName(node); [EOL]                 String nsURI = getNamespaceURI(); [EOL]                 if (equalStrings(nsURI, getNamespaceResolver().getDefaultNamespaceURI())) { [EOL]                     buffer.append(ln); [EOL]                     buffer.append('['); [EOL]                     buffer.append(getRelativePositionByName()).append(']'); [EOL]                 } else { [EOL]                     String prefix = getNamespaceResolver().getPrefix(nsURI); [EOL]                     if (prefix != null) { [EOL]                         buffer.append(prefix); [EOL]                         buffer.append(':'); [EOL]                         buffer.append(ln); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionByName()); [EOL]                         buffer.append(']'); [EOL]                     } else { [EOL]                         buffer.append("node()"); [EOL]                         buffer.append('['); [EOL]                         buffer.append(getRelativePositionOfElement()); [EOL]                         buffer.append(']'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Node.TEXT_NODE: [EOL]         case Node.CDATA_SECTION_NODE: [EOL]             buffer.append("/text()"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfTextNode()).append(']'); [EOL]             break; [EOL]         case Node.PROCESSING_INSTRUCTION_NODE: [EOL]             String target = ((ProcessingInstruction) node).getTarget(); [EOL]             buffer.append("/processing-instruction(\'"); [EOL]             buffer.append(target).append("')"); [EOL]             buffer.append('['); [EOL]             buffer.append(getRelativePositionOfPI(target)).append(']'); [EOL]             break; [EOL]         case Node.DOCUMENT_NODE: [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private int getRelativePositionByName() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             String nm = n.getNodeName(); [EOL]             if (nm.equals(node.getNodeName())) { [EOL]                 count++; [EOL]             } [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionByName() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             String nm = n.getNodeName(); [EOL]             if (nm.equals(node.getNodeName())) { [EOL]                 count++; [EOL]             } [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
private int getRelativePositionByName() { [EOL]     int count = 1; [EOL]     Node n = node.getPreviousSibling(); [EOL]     while (n != null) { [EOL]         if (n.getNodeType() == Node.ELEMENT_NODE) { [EOL]             String nm = n.getNodeName(); [EOL]             if (nm.equals(node.getNodeName())) { [EOL]                 count++; [EOL]             } [EOL]         } [EOL]         n = n.getPreviousSibling(); [EOL]     } [EOL]     return count; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(functionName); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(functionName); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(functionName); [EOL]     buffer.append('('); [EOL]     Expression[] args = getArguments(); [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (i > 0) { [EOL]                 buffer.append(", "); [EOL]             } [EOL]             buffer.append(args[i]); [EOL]         } [EOL]     } [EOL]     buffer.append(')'); [EOL]     return buffer.toString(); [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
public DOMAttributePointer(NodePointer parent, Attr attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public DOMAttributePointer(NodePointer parent, Attr attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public DOMAttributePointer(NodePointer parent, Attr attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public DOMAttributePointer(NodePointer parent, Attr attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public Object getValue() { [EOL]     String value = attr.getValue(); [EOL]     if (value == null) { [EOL]         return null; [EOL]     } [EOL]     if (value.equals("") && !attr.getSpecified()) { [EOL]         return null; [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     return attr; [EOL] }
public boolean isActual() { [EOL]     return true; [EOL] }
public ChildContext(EvalContext parentContext, NodeTest nodeTest, boolean startFromParentLocation, boolean reverse) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL]     this.startFromParentLocation = startFromParentLocation; [EOL]     this.reverse = reverse; [EOL] }
public ChildContext(EvalContext parentContext, NodeTest nodeTest, boolean startFromParentLocation, boolean reverse) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL]     this.startFromParentLocation = startFromParentLocation; [EOL]     this.reverse = reverse; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (iterator != null) { [EOL]         return iterator.getNodePointer(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (iterator != null) { [EOL]         return iterator.getNodePointer(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (iterator != null) { [EOL]         return iterator.getNodePointer(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (iterator != null) { [EOL]         return iterator.getNodePointer(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public boolean nextNode() { [EOL]     return setPosition(getCurrentPosition() + 1); [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     iterator = null; [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
private void prepare() { [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (startFromParentLocation) { [EOL]         NodePointer pointer = parent.getParent(); [EOL]         iterator = pointer.childIterator(nodeTest, reverse, parent); [EOL]     } else { [EOL]         iterator = parent.childIterator(nodeTest, reverse, null); [EOL]     } [EOL] }
public int getOrder() { [EOL]     return DOM_POINTER_FACTORY_ORDER; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer(parent, (Node) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer(parent, (Node) bean); [EOL]     } [EOL]     return null; [EOL] }
public static boolean canConvert(Object object, Class toType) { [EOL]     return typeConverter.canConvert(object, toType); [EOL] }
public static boolean canConvert(Object object, Class toType) { [EOL]     return typeConverter.canConvert(object, toType); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return new CollectionAttributeNodeIterator(this, name); [EOL]     } [EOL]     return getValuePointer().attributeIterator(name); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return new CollectionAttributeNodeIterator(this, name); [EOL]     } [EOL]     return getValuePointer().attributeIterator(name); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object[] args; [EOL]         if (parameters == null) { [EOL]             parameters = EMPTY_ARRAY; [EOL]         } [EOL]         int pi = 0; [EOL]         Class[] types = constructor.getParameterTypes(); [EOL]         if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]             pi = 1; [EOL]         } [EOL]         args = new Object[parameters.length + pi]; [EOL]         if (pi == 1) { [EOL]             args[0] = context; [EOL]         } [EOL]         for (int i = 0; i < parameters.length; i++) { [EOL]             args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]         } [EOL]         return constructor.newInstance(args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke constructor " + constructor, ex); [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new DOMAttributePointer(parent, (Attr) attributes.get(index)); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new DOMAttributePointer(parent, (Attr) attributes.get(index)); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new DOMAttributePointer(parent, (Attr) attributes.get(index)); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new DOMAttributePointer(parent, (Attr) attributes.get(index)); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
protected JXPathContextFactory() { [EOL] }
public static JXPathContextFactory newInstance() { [EOL]     if (factoryImplName == null) { [EOL]         factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS); [EOL]     } [EOL]     JXPathContextFactory factoryImpl; [EOL]     try { [EOL]         Class clazz = Class.forName(factoryImplName); [EOL]         factoryImpl = (JXPathContextFactory) clazz.newInstance(); [EOL]     } catch (ClassNotFoundException cnfe) { [EOL]         throw new JXPathContextFactoryConfigurationError(cnfe); [EOL]     } catch (IllegalAccessException iae) { [EOL]         throw new JXPathContextFactoryConfigurationError(iae); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new JXPathContextFactoryConfigurationError(ie); [EOL]     } [EOL]     return factoryImpl; [EOL] }
public static JXPathContextFactory newInstance() { [EOL]     if (factoryImplName == null) { [EOL]         factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS); [EOL]     } [EOL]     JXPathContextFactory factoryImpl; [EOL]     try { [EOL]         Class clazz = Class.forName(factoryImplName); [EOL]         factoryImpl = (JXPathContextFactory) clazz.newInstance(); [EOL]     } catch (ClassNotFoundException cnfe) { [EOL]         throw new JXPathContextFactoryConfigurationError(cnfe); [EOL]     } catch (IllegalAccessException iae) { [EOL]         throw new JXPathContextFactoryConfigurationError(iae); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new JXPathContextFactoryConfigurationError(ie); [EOL]     } [EOL]     return factoryImpl; [EOL] }
public static JXPathContextFactory newInstance() { [EOL]     if (factoryImplName == null) { [EOL]         factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS); [EOL]     } [EOL]     JXPathContextFactory factoryImpl; [EOL]     try { [EOL]         Class clazz = Class.forName(factoryImplName); [EOL]         factoryImpl = (JXPathContextFactory) clazz.newInstance(); [EOL]     } catch (ClassNotFoundException cnfe) { [EOL]         throw new JXPathContextFactoryConfigurationError(cnfe); [EOL]     } catch (IllegalAccessException iae) { [EOL]         throw new JXPathContextFactoryConfigurationError(iae); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new JXPathContextFactoryConfigurationError(ie); [EOL]     } [EOL]     return factoryImpl; [EOL] }
public static JXPathContextFactory newInstance() { [EOL]     if (factoryImplName == null) { [EOL]         factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS); [EOL]     } [EOL]     JXPathContextFactory factoryImpl; [EOL]     try { [EOL]         Class clazz = Class.forName(factoryImplName); [EOL]         factoryImpl = (JXPathContextFactory) clazz.newInstance(); [EOL]     } catch (ClassNotFoundException cnfe) { [EOL]         throw new JXPathContextFactoryConfigurationError(cnfe); [EOL]     } catch (IllegalAccessException iae) { [EOL]         throw new JXPathContextFactoryConfigurationError(iae); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new JXPathContextFactoryConfigurationError(ie); [EOL]     } [EOL]     return factoryImpl; [EOL] }
public static JXPathContextFactory newInstance() { [EOL]     if (factoryImplName == null) { [EOL]         factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS); [EOL]     } [EOL]     JXPathContextFactory factoryImpl; [EOL]     try { [EOL]         Class clazz = Class.forName(factoryImplName); [EOL]         factoryImpl = (JXPathContextFactory) clazz.newInstance(); [EOL]     } catch (ClassNotFoundException cnfe) { [EOL]         throw new JXPathContextFactoryConfigurationError(cnfe); [EOL]     } catch (IllegalAccessException iae) { [EOL]         throw new JXPathContextFactoryConfigurationError(iae); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new JXPathContextFactoryConfigurationError(ie); [EOL]     } [EOL]     return factoryImpl; [EOL] }
private static String findFactory(String property, String defaultFactory) { [EOL]     try { [EOL]         String systemProp = System.getProperty(property); [EOL]         if (systemProp != null) { [EOL]             if (debug) { [EOL]                 System.err.println("JXPath: found system property" + systemProp); [EOL]             } [EOL]             return systemProp; [EOL]         } [EOL]     } catch (SecurityException se) { [EOL]     } [EOL]     try { [EOL]         String javah = System.getProperty("java.home"); [EOL]         String configFile = javah + File.separator + "lib" + File.separator + "jxpath.properties"; [EOL]         File f = new File(configFile); [EOL]         if (f.exists()) { [EOL]             Properties props = new Properties(); [EOL]             props.load(new FileInputStream(f)); [EOL]             String factory = props.getProperty(property); [EOL]             if (factory != null) { [EOL]                 if (debug) { [EOL]                     System.err.println("JXPath: found java.home property " + factory); [EOL]                 } [EOL]                 return factory; [EOL]             } [EOL]         } [EOL]     } catch (Exception ex) { [EOL]         if (debug) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     String serviceId = "META-INF/services/" + property; [EOL]     try { [EOL]         ClassLoader cl = JXPathContextFactory.class.getClassLoader(); [EOL]         InputStream is = null; [EOL]         if (cl == null) { [EOL]             is = ClassLoader.getSystemResourceAsStream(serviceId); [EOL]         } else { [EOL]             is = cl.getResourceAsStream(serviceId); [EOL]         } [EOL]         if (is != null) { [EOL]             if (debug) { [EOL]                 System.err.println("JXPath: found  " + serviceId); [EOL]             } [EOL]             BufferedReader rd = new BufferedReader(new InputStreamReader(is)); [EOL]             String factory = rd.readLine(); [EOL]             rd.close(); [EOL]             if (factory != null && !"".equals(factory)) { [EOL]                 if (debug) { [EOL]                     System.err.println("JXPath: loaded from services: " + factory); [EOL]                 } [EOL]                 return factory; [EOL]             } [EOL]         } [EOL]     } catch (Exception ex) { [EOL]         if (debug) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return defaultFactory; [EOL] }
public int getOrder() { [EOL]     return CONTAINER_POINTER_FACTORY_ORDER; [EOL] }
public int getOrder() { [EOL]     return DYNA_BEAN_POINTER_FACTORY_ORDER; [EOL] }
public int getOrder() { [EOL]     return COLLECTION_POINTER_FACTORY_ORDER; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (ValueUtils.isCollection(bean)) { [EOL]         return new CollectionPointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public CoreOperationDivide(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationDivide(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected int getPrecedence() { [EOL]     return 5; [EOL] }
public String getSymbol() { [EOL]     return "div"; [EOL] }
private static void createNodeFactoryArray() { [EOL]     if (nodeFactoryArray == null) { [EOL]         nodeFactoryArray = (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[0]); [EOL]         Arrays.sort(nodeFactoryArray, new Comparator() { [EOL]  [EOL]             public int compare(Object a, Object b) { [EOL]                 int orderA = ((NodePointerFactory) a).getOrder(); [EOL]                 int orderB = ((NodePointerFactory) b).getOrder(); [EOL]                 return orderA - orderB; [EOL]             } [EOL]         }); [EOL]     } [EOL] }
private static void createNodeFactoryArray() { [EOL]     if (nodeFactoryArray == null) { [EOL]         nodeFactoryArray = (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[0]); [EOL]         Arrays.sort(nodeFactoryArray, new Comparator() { [EOL]  [EOL]             public int compare(Object a, Object b) { [EOL]                 int orderA = ((NodePointerFactory) a).getOrder(); [EOL]                 int orderB = ((NodePointerFactory) b).getOrder(); [EOL]                 return orderA - orderB; [EOL]             } [EOL]         }); [EOL]     } [EOL] }
public static NodePointerFactory[] getNodePointerFactories() { [EOL]     return nodeFactoryArray; [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
private Expression compileExpression(String xpath) { [EOL]     Expression expr; [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             expr = null; [EOL]             SoftReference ref = (SoftReference) compiled.get(xpath); [EOL]             if (ref != null) { [EOL]                 expr = (Expression) ref.get(); [EOL]             } [EOL]         } else { [EOL]             expr = (Expression) compiled.get(xpath); [EOL]         } [EOL]     } [EOL]     if (expr != null) { [EOL]         return expr; [EOL]     } [EOL]     expr = (Expression) Parser.parseExpression(xpath, getCompiler()); [EOL]     synchronized (compiled) { [EOL]         if (USE_SOFT_CACHE) { [EOL]             if (cleanupCount++ >= CLEANUP_THRESHOLD) { [EOL]                 Iterator it = compiled.entrySet().iterator(); [EOL]                 while (it.hasNext()) { [EOL]                     Entry me = (Entry) it.next(); [EOL]                     if (((SoftReference) me.getValue()).get() == null) { [EOL]                         it.remove(); [EOL]                     } [EOL]                 } [EOL]                 cleanupCount = 0; [EOL]             } [EOL]             compiled.put(xpath, new SoftReference(expr)); [EOL]         } else { [EOL]             compiled.put(xpath, expr); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] }
public Object getValue(String xpath) { [EOL]     Expression expression = compileExpression(xpath); [EOL]     return getValue(xpath, expression); [EOL] }
public Object getValue(String xpath) { [EOL]     Expression expression = compileExpression(xpath); [EOL]     return getValue(xpath, expression); [EOL] }
public Object getValue(String xpath) { [EOL]     Expression expression = compileExpression(xpath); [EOL]     return getValue(xpath, expression); [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Iterator iterate(String xpath) { [EOL]     return iterate(xpath, compileExpression(xpath)); [EOL] }
public Iterator iterate(String xpath, Expression expr) { [EOL]     return expr.iterate(getEvalContext()); [EOL] }
public Pointer getPointer(String xpath) { [EOL]     return getPointer(xpath, compileExpression(xpath)); [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Iterator iteratePointers(String xpath) { [EOL]     return iteratePointers(xpath, compileExpression(xpath)); [EOL] }
public Iterator iteratePointers(String xpath, Expression expr) { [EOL]     return expr.iteratePointers(getEvalContext()); [EOL] }
public Pointer getContextPointer() { [EOL]     return contextPointer; [EOL] }
public Pointer getContextPointer() { [EOL]     return contextPointer; [EOL] }
private EvalContext getEvalContext() { [EOL]     return new InitialContext(new RootContext(this, (NodePointer) getContextPointer())); [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public NodePointer getVariablePointer(QName name) { [EOL]     String varName = name.toString(); [EOL]     JXPathContext varCtx = this; [EOL]     Variables vars = null; [EOL]     while (varCtx != null) { [EOL]         vars = varCtx.getVariables(); [EOL]         if (vars.isDeclaredVariable(varName)) { [EOL]             break; [EOL]         } [EOL]         varCtx = varCtx.getParentContext(); [EOL]         vars = null; [EOL]     } [EOL]     if (vars != null) { [EOL]         return new VariablePointer(vars, name); [EOL]     } else { [EOL]         return new VariablePointer(name); [EOL]     } [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public Function getFunction(QName functionName, Object[] parameters) { [EOL]     String namespace = functionName.getPrefix(); [EOL]     String name = functionName.getName(); [EOL]     JXPathContext funcCtx = this; [EOL]     Function func = null; [EOL]     Functions funcs; [EOL]     while (funcCtx != null) { [EOL]         funcs = funcCtx.getFunctions(); [EOL]         if (funcs != null) { [EOL]             func = funcs.getFunction(namespace, name, parameters); [EOL]             if (func != null) { [EOL]                 return func; [EOL]             } [EOL]         } [EOL]         funcCtx = funcCtx.getParentContext(); [EOL]     } [EOL]     throw new JXPathFunctionNotFoundException("Undefined function: " + functionName.toString()); [EOL] }
public NamespaceResolver getNamespaceResolver() { [EOL]     namespaceResolver.seal(); [EOL]     namespaceResolver.registerDefaultNamespaceURI(getDefaultNamespaceURI()); [EOL]     return namespaceResolver; [EOL] }
public NamespaceResolver getNamespaceResolver() { [EOL]     namespaceResolver.seal(); [EOL]     namespaceResolver.registerDefaultNamespaceURI(getDefaultNamespaceURI()); [EOL]     return namespaceResolver; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public String getDefaultNamespaceURI() { [EOL]     if (defaultNamespaceURI != null) { [EOL]         return defaultNamespaceURI; [EOL]     } [EOL]     if (parentContext != null) { [EOL]         return parentContext.getDefaultNamespaceURI(); [EOL]     } [EOL]     return null; [EOL] }
public static Object allocateConditionally(String className, String existenceCheckClassName) { [EOL]     try { [EOL]         try { [EOL]             Class.forName(existenceCheckClassName); [EOL]         } catch (ClassNotFoundException ex) { [EOL]             return null; [EOL]         } [EOL]         Class cls = Class.forName(className); [EOL]         return cls.newInstance(); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot allocate " + className, ex); [EOL]     } [EOL] }
public static Object allocateConditionally(String className, String existenceCheckClassName) { [EOL]     try { [EOL]         try { [EOL]             Class.forName(existenceCheckClassName); [EOL]         } catch (ClassNotFoundException ex) { [EOL]             return null; [EOL]         } [EOL]         Class cls = Class.forName(className); [EOL]         return cls.newInstance(); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot allocate " + className, ex); [EOL]     } [EOL] }
public static Object allocateConditionally(String className, String existenceCheckClassName) { [EOL]     try { [EOL]         try { [EOL]             Class.forName(existenceCheckClassName); [EOL]         } catch (ClassNotFoundException ex) { [EOL]             return null; [EOL]         } [EOL]         Class cls = Class.forName(className); [EOL]         return cls.newInstance(); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot allocate " + className, ex); [EOL]     } [EOL] }
public Expression[] getArguments() { [EOL]     return args; [EOL] }
public Expression[] getArguments() { [EOL]     return args; [EOL] }
public Expression[] getArguments() { [EOL]     return args; [EOL] }
public SelfContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public SelfContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public Pointer getSingleNodePointer() { [EOL]     return parentContext.getSingleNodePointer(); [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return nodePointer; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return nodePointer; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return nodePointer; [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     startedSet = false; [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public boolean setPosition(int position) { [EOL]     if (position != 1) { [EOL]         return false; [EOL]     } [EOL]     super.setPosition(position); [EOL]     if (!startedSet) { [EOL]         startedSet = true; [EOL]         nodePointer = (NodePointer) parentContext.getCurrentNodePointer(); [EOL]     } [EOL]     if (nodePointer == null) { [EOL]         return false; [EOL]     } [EOL]     return nodeTest == null || nodePointer.testNode(nodeTest); [EOL] }
public CollectionAttributeNodeIterator(CollectionPointer pointer, QName name) { [EOL]     super(pointer, false, null); [EOL]     this.name = name; [EOL] }
public CollectionAttributeNodeIterator(CollectionPointer pointer, QName name) { [EOL]     super(pointer, false, null); [EOL]     this.name = name; [EOL] }
protected NodeIterator getElementNodeIterator(NodePointer elementPointer) { [EOL]     return elementPointer.attributeIterator(name); [EOL] }
