public void testIsAnnotationBundleWithJacksonAnnotationsInside() { [EOL] JacksonAnnotationsInside mockJacksonAnnotationsInside = mock(JacksonAnnotationsInside.class); [EOL] Annotation mockAnnotation = mock(Annotation.class); [EOL] when(mockAnnotation.annotationType()).thenReturn((Class) mockJacksonAnnotationsInside.getClass()); [EOL] boolean result = isAnnotationBundle(mockAnnotation); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAnnotationBundleWithoutJacksonAnnotationsInside() { [EOL] Annotation mockAnnotation = mock(Annotation.class); [EOL] when(mockAnnotation.annotationType()).thenReturn((Class) Object.class); [EOL] boolean result = isAnnotationBundle(mockAnnotation); [EOL] assertFalse(result); [EOL] }
public void testFindPropertiesToIgnoreWithIgnoreProperties() { [EOL] AnnotatedClass ac = createAnnotatedClassWithIgnorePropertiesAnnotation(new String[]{"prop1", "prop2"}); [EOL] String[] result = findPropertiesToIgnore(ac); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("prop1", result[0]); [EOL] assertEquals("prop2", result[1]); [EOL] }
public void testFindPropertiesToIgnoreWithoutIgnoreProperties() { [EOL] AnnotatedClass ac = createAnnotatedClassWithoutIgnorePropertiesAnnotation(); [EOL] String[] result = findPropertiesToIgnore(ac); [EOL] assertNull(result); [EOL] }
public void testFindIgnoreUnknownPropertiesWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonIgnoreProperties.class)).thenReturn(null); [EOL] Boolean result = findIgnoreUnknownProperties(ac); [EOL] assertNull(result); [EOL] }
public void testFindIgnoreUnknownPropertiesWithIgnoreUnknownTrue() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonIgnoreProperties ignore = mock(JsonIgnoreProperties.class); [EOL] when(ac.getAnnotation(JsonIgnoreProperties.class)).thenReturn(ignore); [EOL] when(ignore.ignoreUnknown()).thenReturn(true); [EOL] Boolean result = findIgnoreUnknownProperties(ac); [EOL] assertTrue(result); [EOL] }
public void testFindIgnoreUnknownPropertiesWithIgnoreUnknownFalse() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonIgnoreProperties ignore = mock(JsonIgnoreProperties.class); [EOL] when(ac.getAnnotation(JsonIgnoreProperties.class)).thenReturn(ignore); [EOL] when(ignore.ignoreUnknown()).thenReturn(false); [EOL] Boolean result = findIgnoreUnknownProperties(ac); [EOL] assertFalse(result); [EOL] }
public void testIsIgnorableTypeWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonIgnoreType.class)).thenReturn(null); [EOL] Boolean result = isIgnorableType(ac); [EOL] assertNull(result); [EOL] }
public void testIsIgnorableTypeWithFalseAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonIgnoreType ignore = mock(JsonIgnoreType.class); [EOL] when(ignore.value()).thenReturn(false); [EOL] when(ac.getAnnotation(JsonIgnoreType.class)).thenReturn(ignore); [EOL] Boolean result = isIgnorableType(ac); [EOL] assertFalse(result); [EOL] }
public void testIsIgnorableTypeWithTrueAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonIgnoreType ignore = mock(JsonIgnoreType.class); [EOL] when(ignore.value()).thenReturn(true); [EOL] when(ac.getAnnotation(JsonIgnoreType.class)).thenReturn(ignore); [EOL] Boolean result = isIgnorableType(ac); [EOL] assertTrue(result); [EOL] }
public void testFindFilterIdWithNonNullAnnotationAndNonEmptyId() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonFilter ann = mock(JsonFilter.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn("filterId"); [EOL] Object result = findFilterId(ac); [EOL] assertNotNull(result); [EOL] assertEquals("filterId", result); [EOL] }
public void testFindFilterIdWithNonNullAnnotationAndEmptyId() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonFilter ann = mock(JsonFilter.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn(""); [EOL] Object result = findFilterId(ac); [EOL] assertNull(result); [EOL] }
public void testFindFilterIdWithNullAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(null); [EOL] Object result = findFilterId(ac); [EOL] assertNull(result); [EOL] }
public void testFindReferenceTypeWithManagedReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonManagedReference ref1 = mock(JsonManagedReference.class); [EOL] when(member.getAnnotation(JsonManagedReference.class)).thenReturn(ref1); [EOL] when(ref1.value()).thenReturn("managedRef"); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNotNull(result); [EOL] assertTrue(result.isManagedReference()); [EOL] assertEquals("managedRef", result.getName()); [EOL] }
public void testFindReferenceTypeWithBackReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonBackReference ref2 = mock(JsonBackReference.class); [EOL] when(member.getAnnotation(JsonBackReference.class)).thenReturn(ref2); [EOL] when(ref2.value()).thenReturn("backRef"); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBackReference()); [EOL] assertEquals("backRef", result.getName()); [EOL] }
public void testFindReferenceTypeWithNoReference() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JsonManagedReference.class)).thenReturn(null); [EOL] when(member.getAnnotation(JsonBackReference.class)).thenReturn(null); [EOL] ReferenceProperty result = findReferenceType(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithNoAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(null); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithDisabledAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonUnwrapped ann = mock(JsonUnwrapped.class); [EOL] when(ann.enabled()).thenReturn(false); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(ann); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNull(result); [EOL] }
public void testFindUnwrappingNameTransformerWithEnabledAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonUnwrapped ann = mock(JsonUnwrapped.class); [EOL] when(ann.enabled()).thenReturn(true); [EOL] when(ann.prefix()).thenReturn("prefix_"); [EOL] when(ann.suffix()).thenReturn("_suffix"); [EOL] when(member.getAnnotation(JsonUnwrapped.class)).thenReturn(ann); [EOL] NameTransformer result = findUnwrappingNameTransformer(member); [EOL] assertNotNull(result); [EOL] assertEquals("prefix_", result.transform("name").substring(0, 7)); [EOL] assertTrue(result.transform("name").endsWith("_suffix")); [EOL] }
public void testHasRequiredMarkerWithRequiredProperty() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(member.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.required()).thenReturn(true); [EOL] Boolean result = hasRequiredMarker(member); [EOL] assertNotNull(result); [EOL] assertTrue(result); [EOL] }
public void testHasRequiredMarkerWithNonRequiredProperty() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(member.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.required()).thenReturn(false); [EOL] Boolean result = hasRequiredMarker(member); [EOL] assertNotNull(result); [EOL] assertFalse(result); [EOL] }
public void testHasRequiredMarkerWithNoAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] Boolean result = hasRequiredMarker(member); [EOL] assertNull(result); [EOL] }
public void testFindPropertyTypeResolverWithContainerType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.isContainerType()).thenReturn(true); [EOL] TypeResolverBuilder<?> result = findPropertyTypeResolver(config, am, baseType); [EOL] assertNull(result); [EOL] }
public void testFindPropertyTypeResolverWithNonContainerType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.isContainerType()).thenReturn(false); [EOL] TypeResolverBuilder<?> expectedResolverBuilder = mock(TypeResolverBuilder.class); [EOL] when(_findTypeResolver(config, am, baseType)).thenReturn(expectedResolverBuilder); [EOL] TypeResolverBuilder<?> result = findPropertyTypeResolver(config, am, baseType); [EOL] assertSame(expectedResolverBuilder, result); [EOL] }
public void testFindPropertyContentTypeResolverWithNonContainerType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] JavaType nonContainerType = mock(JavaType.class); [EOL] when(nonContainerType.isContainerType()).thenReturn(false); [EOL] TypeResolverBuilder<?> builder = new ObjectMapper().getDeserializationConfig().getDefaultTyper(nonContainerType); [EOL] try { [EOL] builder.findPropertyContentTypeResolver(config, am, nonContainerType); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Must call method with a container type (got " + nonContainerType + ")", e.getMessage()); [EOL] } [EOL] }
public void testFindPropertyContentTypeResolverWithContainerType() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] JavaType containerType = mock(JavaType.class); [EOL] when(containerType.isContainerType()).thenReturn(true); [EOL] TypeResolverBuilder<?> expectedBuilder = mock(TypeResolverBuilder.class); [EOL] when(config.getDefaultTyper(containerType)).thenReturn(expectedBuilder); [EOL] TypeResolverBuilder<?> actualBuilder = new ObjectMapper().getDeserializationConfig().getDefaultTyper(containerType); [EOL] assertSame(expectedBuilder, actualBuilder.findPropertyContentTypeResolver(config, am, containerType)); [EOL] }
public void testFindSubtypesWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(null); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSubtypesWithEmptyTypes() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSubTypes jsonSubTypes = mock(JsonSubTypes.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(jsonSubTypes); [EOL] when(jsonSubTypes.value()).thenReturn(new JsonSubTypes.Type[0]); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindSubtypesWithNonEmptyTypes() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSubTypes jsonSubTypes = mock(JsonSubTypes.class); [EOL] JsonSubTypes.Type typeMock = mock(JsonSubTypes.Type.class); [EOL] when(annotated.getAnnotation(JsonSubTypes.class)).thenReturn(jsonSubTypes); [EOL] when(jsonSubTypes.value()).thenReturn(new JsonSubTypes.Type[]{typeMock}); [EOL] when(typeMock.value()).thenReturn(SomeClass.class); [EOL] when(typeMock.name()).thenReturn("SomeName"); [EOL] List<NamedType> result = findSubtypes(annotated); [EOL] assertEquals(1, result.size()); [EOL] NamedType namedType = result.get(0); [EOL] assertEquals(SomeClass.class, namedType.getType()); [EOL] assertEquals("SomeName", namedType.getName()); [EOL] }
public void testFindTypeNameWithAnnotationPresent() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonTypeName jsonTypeName = mock(JsonTypeName.class); [EOL] when(ac.getAnnotation(JsonTypeName.class)).thenReturn(jsonTypeName); [EOL] when(jsonTypeName.value()).thenReturn("TypeName"); [EOL] String result = findTypeName(ac); [EOL] assertEquals("TypeName", result); [EOL] }
public void testFindTypeNameWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonTypeName.class)).thenReturn(null); [EOL] String result = findTypeName(ac); [EOL] assertNull(result); [EOL] }
public void testFindSerializerWithJsonSerializeUsingNonNull() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.using()).thenReturn((Class)CustomSerializer.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomSerializer.class, result); [EOL] }
public void testFindSerializerWithJsonSerializeUsingNone() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.using()).thenReturn((Class)JsonSerializer.None.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializerWithJsonRawValueTrue() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonRawValue jsonRawValue = mock(JsonRawValue.class); [EOL] when(annotated.getAnnotation(JsonRawValue.class)).thenReturn(jsonRawValue); [EOL] when(jsonRawValue.value()).thenReturn(true); [EOL] when(annotated.getRawType()).thenReturn((Class)Object.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof RawSerializer); [EOL] }
public void testFindSerializerWithJsonRawValueFalse() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonRawValue jsonRawValue = mock(JsonRawValue.class); [EOL] when(annotated.getAnnotation(JsonRawValue.class)).thenReturn(jsonRawValue); [EOL] when(jsonRawValue.value()).thenReturn(false); [EOL] Object result = findSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializerWithNoAnnotations() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonRawValue.class)).thenReturn(null); [EOL] Object result = findSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithAnnotationPresentAndSerializerSpecified() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)CustomSerializer.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomSerializer.class, result); [EOL] }
public void testFindContentSerializerWithAnnotationPresentAndNoSerializerSpecified() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentUsing()).thenReturn((Class)JsonSerializer.None.class); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentSerializerWithNoAnnotationPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonSerializerResolver resolver = new JsonSerializerResolver(); [EOL] Class<? extends JsonSerializer<?>> result = resolver.findContentSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationInclusionWithJsonInclude() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(JsonInclude.Include.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeAlways() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonNull() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_NULL); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_NULL, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_DEFAULT); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_DEFAULT, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonEmpty() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_EMPTY); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_EMPTY, result); [EOL] }
public void testFindSerializationInclusionWithDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.USE_DEFAULTS, result); [EOL] }
public void testFindSerializationTypeWithAnnotationPresentAndAsIsNotNoClass() { [EOL] AnnotatedMock am = new AnnotatedMock(JsonSerialize.class); [EOL] am.setAnnotationData(new JsonSerializeImpl(NonNullClass.class)); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNotNull(result); [EOL] assertEquals(NonNullClass.class, result); [EOL] }
public void testFindSerializationTypeWithAnnotationPresentAndAsIsNoClass() { [EOL] AnnotatedMock am = new AnnotatedMock(JsonSerialize.class); [EOL] am.setAnnotationData(new JsonSerializeImpl(NoClass.class)); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNull(result); [EOL] }
public void testFindSerializationTypeWithNoAnnotationPresent() { [EOL] AnnotatedMock am = new AnnotatedMock(null); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNull(result); [EOL] }
public void testFindSerializationKeyTypeWithNonNullAnnotationAndKeyAsNoClass() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertNull(result); [EOL] }
public void testFindSerializationKeyTypeWithNonNullAnnotationAndKeyAsSpecificClass() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] Class<?> expectedClass = String.class; [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.keyAs()).thenReturn(expectedClass); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertEquals(expectedClass, result); [EOL] }
public void testFindSerializationKeyTypeWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Class<?> result = findSerializationKeyType(annotated, baseType); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentTypeWithAnnotationPresent() { [EOL] AnnotatedMock am = new AnnotatedMock(JsonSerialize.class); [EOL] JavaType baseType = new JavaTypeMock(); [EOL] Class<?> result = findSerializationContentType(am, baseType); [EOL] assertNotNull(result); [EOL] assertEquals(ExpectedClass.class, result); [EOL] } [EOL] public void testFindSerializationContentTypeWithNoAnnotation() { [EOL] AnnotatedMock am = new AnnotatedMock(null); [EOL] JavaType baseType = new JavaTypeMock(); [EOL] Class<?> result = findSerializationContentType(am, baseType); [EOL] assertNull(result); [EOL] } [EOL] public void testFindSerializationContentTypeWithNoClass() { [EOL] AnnotatedMock am = new AnnotatedMock(JsonSerialize.class, NoClass.class); [EOL] JavaType baseType = new JavaTypeMock(); [EOL] Class<?> result = findSerializationContentType(am, baseType); [EOL] assertNull(result); [EOL] }

public void testFindSerializationTypingWithNoAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] assertNull(findSerializationTyping(annotated)); [EOL] }
public void testFindSerializationTypingWithAnnotationPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.typing()).thenReturn(JsonSerialize.Typing.STATIC); [EOL] assertEquals(JsonSerialize.Typing.STATIC, findSerializationTyping(annotated)); [EOL] }
public void testFindSerializationConverterWithNonNullConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn((Class)DummyConverter.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(DummyConverter.class, result); [EOL] }
public void testFindSerializationConverterWithNoneClassConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithNoAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentConverterWithNonNullConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentConverter()).thenReturn((Class)DummyConverter.class); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNotNull(result); [EOL] assertEquals(DummyConverter.class, result); [EOL] }
public void testFindSerializationContentConverterWithNoneClassConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.contentConverter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindSerializationContentConverterWithNoAnnotation() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(annotatedMember.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Object result = findSerializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindViewsWhenAnnotationPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonView jsonView = mock(JsonView.class); [EOL] Class<?>[] classes = new Class<?>[] {Object.class, String.class}; [EOL] when(annotated.getAnnotation(JsonView.class)).thenReturn(jsonView); [EOL] when(jsonView.value()).thenReturn(classes); [EOL] Class<?>[] result = findViews(annotated); [EOL] assertNotNull(result); [EOL] assertArrayEquals(classes, result); [EOL] }
public void testFindViewsWhenAnnotationNotPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonView.class)).thenReturn(null); [EOL] Class<?>[] result = findViews(annotated); [EOL] assertNull(result); [EOL] }
public void testIsTypeIdWithJsonTypeIdAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.hasAnnotation(JsonTypeId.class)).thenReturn(true); [EOL] assertTrue(isTypeId(member)); [EOL] }
public void testIsTypeIdWithoutJsonTypeIdAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.hasAnnotation(JsonTypeId.class)).thenReturn(false); [EOL] assertFalse(isTypeId(member)); [EOL] }
public void testFindObjectReferenceInfoWithNonNullRef() { [EOL] Annotated ann = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] JsonIdentityReference ref = mock(JsonIdentityReference.class); [EOL] when(ann.getAnnotation(JsonIdentityReference.class)).thenReturn(ref); [EOL] when(ref.alwaysAsId()).thenReturn(true); [EOL] when(objectIdInfo.withAlwaysAsId(anyBoolean())).thenReturn(objectIdInfo); [EOL] ObjectIdInfo result = findObjectReferenceInfo(ann, objectIdInfo); [EOL] verify(ann).getAnnotation(JsonIdentityReference.class); [EOL] verify(ref).alwaysAsId(); [EOL] verify(objectIdInfo).withAlwaysAsId(true); [EOL] assertSame(objectIdInfo, result); [EOL] }
public void testFindObjectReferenceInfoWithNullRef() { [EOL] Annotated ann = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ann.getAnnotation(JsonIdentityReference.class)).thenReturn(null); [EOL] ObjectIdInfo result = findObjectReferenceInfo(ann, objectIdInfo); [EOL] verify(ann).getAnnotation(JsonIdentityReference.class); [EOL] assertSame(objectIdInfo, result); [EOL] }
public void testFindNameForSerializationWithAnnotatedField() { [EOL] AnnotatedField annotatedField = createAnnotatedFieldWithName("fieldName"); [EOL] PropertyName result = findNameForSerialization(annotatedField); [EOL] assertNotNull(result); [EOL] assertEquals("fieldName", result.getSimpleName()); [EOL] } [EOL] public void testFindNameForSerializationWithAnnotatedMethod() { [EOL] AnnotatedMethod annotatedMethod = createAnnotatedMethodWithName("methodName"); [EOL] PropertyName result = findNameForSerialization(annotatedMethod); [EOL] assertNotNull(result); [EOL] assertEquals("methodName", result.getSimpleName()); [EOL] } [EOL] public void testFindNameForSerializationWithEmptyName() { [EOL] AnnotatedField annotatedField = createAnnotatedFieldWithName(""); [EOL] PropertyName result = findNameForSerialization(annotatedField); [EOL] assertSame(PropertyName.USE_DEFAULT, result); [EOL] } [EOL] public void testFindNameForSerializationWithNull() { [EOL] Annotated notAnnotatedFieldOrMethod = createNotAnnotatedFieldOrMethod(); [EOL] PropertyName result = findNameForSerialization(notAnnotatedFieldOrMethod); [EOL] assertNull(result); [EOL] }

public void testFindSerializationNameWithJsonGetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonGetter jsonGetter = mock(JsonGetter.class); [EOL] when(am.getAnnotation(JsonGetter.class)).thenReturn(jsonGetter); [EOL] when(jsonGetter.value()).thenReturn("getterName"); [EOL] String result = findSerializationName(am); [EOL] assertEquals("getterName", result); [EOL] }
public void testFindSerializationNameWithJsonProperty() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(am.getAnnotation(JsonGetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.value()).thenReturn("propertyName"); [EOL] String result = findSerializationName(am); [EOL] assertEquals("propertyName", result); [EOL] }
public void testFindSerializationNameWithJsonSerializeOrJsonView() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonGetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonSerialize.class)).thenReturn(true); [EOL] String result = findSerializationName(am); [EOL] assertEquals("", result); [EOL] }
public void testFindSerializationNameWithNoRelevantAnnotations() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonGetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonSerialize.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] String result = findSerializationName(am); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerWithNonNullAnnotationAndValidDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.using()).thenReturn((Class)CustomDeserializer.class); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomDeserializer.class, result); [EOL] }
public void testFindDeserializerWithNonNullAnnotationAndNoneDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.using()).thenReturn((Class)JsonDeserializer.None.class); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentDeserializerWithNonNullAnnotationAndNonDefaultDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentUsing()).thenReturn((Class)CustomJsonDeserializer.class); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomJsonDeserializer.class, result); [EOL] }
public void testFindContentDeserializerWithNonNullAnnotationAndDefaultDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentUsing()).thenReturn(JsonDeserializer.None.class); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindContentDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends JsonDeserializer<?>> result = findContentDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationTypeWithNonNullAnnotationAndValidClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(String.class); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindDeserializationTypeWithNonNullAnnotationAndNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(NoClass.class); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationTypeWithNullAnnotation() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationKeyTypeWithNonNullAnnotationAndKeyAsNotNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseKeyType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.keyAs()).thenReturn(String.class); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindDeserializationKeyTypeWithNonNullAnnotationAndKeyAsNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseKeyType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.keyAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationKeyTypeWithNullAnnotation() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseKeyType = mock(JavaType.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentTypeWithAnnotationPresentAndValidClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.contentAs()).thenReturn(String.class); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindDeserializationContentTypeWithAnnotationPresentAndNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.contentAs()).thenReturn(NoClass.class); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentTypeWithNoAnnotation() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseContentType = mock(JavaType.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<?> result = findDeserializationContentType(am, baseContentType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNonNullConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.converter()).thenReturn((Class)StringConverter.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(StringConverter.class, result); [EOL] }
public void testFindDeserializationConverterWithNoneConverter() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.converter()).thenReturn((Class)Converter.None.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNoAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndValidConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn(ValidConverter.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNotNull(result); [EOL] assertEquals(ValidConverter.class, result); [EOL] }
public void testFindDeserializationContentConverterWithNonNullAnnotationAndNoneConverter() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.contentConverter()).thenReturn(Converter.None.class); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationContentConverterWithNullAnnotation() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(annotatedMember.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Object result = findDeserializationContentConverter(annotatedMember); [EOL] assertNull(result); [EOL] }
public void testFindValueInstantiatorWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonValueInstantiator.class)).thenReturn(null); [EOL] Object result = findValueInstantiator(ac); [EOL] assertNull(result); [EOL] }
public void testFindValueInstantiatorWithAnnotationPresent() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonValueInstantiator ann = mock(JsonValueInstantiator.class); [EOL] when(ac.getAnnotation(JsonValueInstantiator.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn(new Object()); [EOL] Object result = findValueInstantiator(ac); [EOL] assertNotNull(result); [EOL] }
public void testFindNameForDeserializationWithAnnotatedField() { [EOL] AnnotatedField annotatedField = createMockAnnotatedFieldWithName("fieldName"); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertNotNull(result); [EOL] assertEquals("fieldName", result.getSimpleName()); [EOL] } [EOL] public void testFindNameForDeserializationWithAnnotatedMethod() { [EOL] AnnotatedMethod annotatedMethod = createMockAnnotatedMethodWithName("methodName"); [EOL] PropertyName result = findNameForDeserialization(annotatedMethod); [EOL] assertNotNull(result); [EOL] assertEquals("methodName", result.getSimpleName()); [EOL] } [EOL] public void testFindNameForDeserializationWithAnnotatedParameter() { [EOL] AnnotatedParameter annotatedParameter = createMockAnnotatedParameterWithName("paramName"); [EOL] PropertyName result = findNameForDeserialization(annotatedParameter); [EOL] assertNotNull(result); [EOL] assertEquals("paramName", result.getSimpleName()); [EOL] } [EOL] public void testFindNameForDeserializationWithEmptyName() { [EOL] AnnotatedField annotatedField = createMockAnnotatedFieldWithName(""); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertEquals(PropertyName.USE_DEFAULT, result); [EOL] } [EOL] public void testFindNameForDeserializationWithNull() { [EOL] Annotated notAnnotated = createMockNotAnnotated(); [EOL] PropertyName result = findNameForDeserialization(notAnnotated); [EOL] assertNull(result); [EOL] }

public void testFindDeserializationNameWithJsonSetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonSetter jsonSetter = mock(JsonSetter.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(jsonSetter); [EOL] when(jsonSetter.value()).thenReturn("setterValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("setterValue", result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonSetter jsonSetter = mock(JsonSetter.class); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.value()).thenReturn("propertyValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("propertyValue", result); [EOL] }
public void testFindDeserializationNameWithEmptyValue() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNull() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(am); [EOL] assertNull(result); [EOL] }
public void testHasAnySetterAnnotationWithJsonAnySetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.hasAnnotation(JsonAnySetter.class)).thenReturn(true); [EOL] assertTrue(hasAnySetterAnnotation(am)); [EOL] }
public void testHasAnySetterAnnotationWithoutJsonAnySetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.hasAnnotation(JsonAnySetter.class)).thenReturn(false); [EOL] assertFalse(hasAnySetterAnnotation(am)); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL] TypeResolverBuilder<?> b; [EOL] JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL] JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL] if (resAnn != null) { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL] } else { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] if (info.use() == JsonTypeInfo.Id.NONE) { [EOL] return _constructNoTypeResolverBuilder(); [EOL] } [EOL] b = _constructStdTypeResolverBuilder(); [EOL] } [EOL] JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL] TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL] if (idRes != null) { [EOL] idRes.init(baseType); [EOL] } [EOL] b = b.init(info.use(), idRes); [EOL] JsonTypeInfo.As inclusion = info.include(); [EOL] if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL] inclusion = JsonTypeInfo.As.PROPERTY; [EOL] } [EOL] b = b.inclusion(inclusion); [EOL] b = b.typeProperty(info.property()); [EOL] Class<?> defaultImpl = info.defaultImpl(); [EOL] if (defaultImpl != JsonTypeInfo.None.class) { [EOL] b = b.defaultImpl(defaultImpl); [EOL] } [EOL] b = b.typeIdVisibility(info.visible()); [EOL] return b; [EOL] }
protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() { [EOL] return new StdTypeResolverBuilder(); [EOL] }
protected StdScalarSerializer(Class<T> t) { [EOL] super(t); [EOL] }
public void testDeserializationContextCopyConstructor() { [EOL] DeserializerFactory factory = new JsonFactory().getCodec().getFactory(); [EOL] DeserializationContext original = new ObjectMapper().getDeserializationContext(); [EOL] DeserializationContext copy = new DeserializationContext(original, factory); [EOL] assertNotNull(copy._cache); [EOL] assertSame(original._cache, copy._cache); [EOL] assertSame(factory, copy._factory); [EOL] assertSame(original._config, copy._config); [EOL] assertEquals(original._featureFlags, copy._featureFlags); [EOL] assertSame(original._view, copy._view); [EOL] assertSame(original._parser, copy._parser); [EOL] assertSame(original._injectableValues, copy._injectableValues); [EOL] }
public void testGetTypeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testGetNodeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNodeFactory factory = mapper.getNodeFactory(); [EOL] assertNotNull(factory); [EOL] }
public void testGetLocale() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Locale expectedLocale = Locale.getDefault(); [EOL] assertEquals(expectedLocale, mapper.getSerializationConfig().getLocale()); [EOL] }
public void testGetLocaleWithDifferentLocale() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Locale differentLocale = new Locale("fr", "FR"); [EOL] mapper.setLocale(differentLocale); [EOL] assertEquals(differentLocale, mapper.getSerializationConfig().getLocale()); [EOL] }
public Class<?> findClassTest_withValidClassName() throws ClassNotFoundException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String validClassName = "java.lang.String"; [EOL] Class<?> clazz = mapper.findClass(validClassName); [EOL] assertNotNull(clazz); [EOL] assertEquals(String.class, clazz); [EOL] }
public Class<?> findClassTest_withInvalidClassName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String invalidClassName = "com.nonexistent.FakeClass"; [EOL] try { [EOL] mapper.findClass(invalidClassName); [EOL] fail("ClassNotFoundException should have been thrown"); [EOL] } catch (ClassNotFoundException e) { [EOL] } [EOL] }
public void testConstructCalendarWithNonNullDate() { [EOL] Date date = new Date(); [EOL] StdDateFormat format = new StdDateFormat(); [EOL] Calendar calendar = format.constructCalendar(date); [EOL] assertNotNull(calendar); [EOL] assertEquals(date, calendar.getTime()); [EOL] }
public void testConstructCalendarWithTimeZone() { [EOL] Date date = new Date(); [EOL] StdDateFormat format = new StdDateFormat(); [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] format.setTimeZone(timeZone); [EOL] Calendar calendar = format.constructCalendar(date); [EOL] assertNotNull(calendar); [EOL] assertEquals(timeZone, calendar.getTimeZone()); [EOL] }
public void testHandleUnknownPropertyWithNullHandlers() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] boolean result = context.handleUnknownProperty(jp, deser, instanceOrClass, propName); [EOL] assertFalse(result); [EOL] }
public void testHandleUnknownPropertyWithNonNullHandlersReturningTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] DeserializationProblemHandler handler = mock(DeserializationProblemHandler.class); [EOL] when(handler.handleUnknownProperty(any(DeserializationContext.class), any(JsonParser.class), any(JsonDeserializer.class), any(), anyString())).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addHandler(handler); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] boolean result = context.handleUnknownProperty(jp, deser, instanceOrClass, propName); [EOL] assertTrue(result); [EOL] }
public void testHandleUnknownPropertyWithNonNullHandlersReturningFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] Object instanceOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] DeserializationProblemHandler handler = mock(DeserializationProblemHandler.class); [EOL] when(handler.handleUnknownProperty(any(DeserializationContext.class), any(JsonParser.class), any(JsonDeserializer.class), any(), anyString())).thenReturn(false); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addHandler(handler); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] boolean result = context.handleUnknownProperty(jp, deser, instanceOrClass, propName); [EOL] assertFalse(result); [EOL] }
public void testReportUnknownPropertyWithFeatureDisabled() { [EOL] DeserializationContext context = createDeserializationContext(); [EOL] context.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL] Object instance = new Object(); [EOL] String fieldName = "unknownField"; [EOL] JsonDeserializer<?> deser = null; [EOL] try { [EOL] context.reportUnknownProperty(instance, fieldName, deser); [EOL] } catch (JsonMappingException e) { [EOL] fail("No exception should be thrown when FAIL_ON_UNKNOWN_PROPERTIES is disabled"); [EOL] } [EOL] }
public void testReportUnknownPropertyWithFeatureEnabledAndDeserializerNull() { [EOL] DeserializationContext context = createDeserializationContext(); [EOL] context.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL] Object instance = new Object(); [EOL] String fieldName = "unknownField"; [EOL] JsonDeserializer<?> deser = null; [EOL] try { [EOL] context.reportUnknownProperty(instance, fieldName, deser); [EOL] fail("UnrecognizedPropertyException expected"); [EOL] } catch (UnrecognizedPropertyException e) { [EOL] assertEquals(fieldName, e.getPropertyName()); [EOL] assertNull(e.getKnownPropertyIds()); [EOL] } catch (JsonMappingException e) { [EOL] fail("UnrecognizedPropertyException expected, but got JsonMappingException"); [EOL] } [EOL] }
public void testReportUnknownPropertyWithFeatureEnabledAndDeserializerNonNull() { [EOL] DeserializationContext context = createDeserializationContext(); [EOL] context.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL] Object instance = new Object(); [EOL] String fieldName = "unknownField"; [EOL] JsonDeserializer<?> deser = createJsonDeserializerWithKnownProperties("knownField"); [EOL] try { [EOL] context.reportUnknownProperty(instance, fieldName, deser); [EOL] fail("UnrecognizedPropertyException expected"); [EOL] } catch (UnrecognizedPropertyException e) { [EOL] assertEquals(fieldName, e.getPropertyName()); [EOL] assertNotNull(e.getKnownPropertyIds()); [EOL] assertTrue(e.getKnownPropertyIds().contains("knownField")); [EOL] } catch (JsonMappingException e) { [EOL] fail("UnrecognizedPropertyException expected, but got JsonMappingException"); [EOL] } [EOL] }
public void testWeirdKeyExceptionWithValidInput() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = null; [EOL] try { [EOL] mapper.weirdKeyException(Integer.class, "123", "not a valid integer key"); [EOL] } catch (JsonMappingException e) { [EOL] exception = e; [EOL] } [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct Map key of type java.lang.Integer from String")); [EOL] assertTrue(exception.getMessage().contains("not a valid integer key")); [EOL] assertEquals(Integer.class, exception.getTargetType()); [EOL] }
public void testWeirdKeyExceptionWithNullKeyClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = null; [EOL] try { [EOL] mapper.weirdKeyException(null, "123", "key class is null"); [EOL] } catch (JsonMappingException e) { [EOL] exception = e; [EOL] } [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct Map key of type null from String")); [EOL] assertTrue(exception.getMessage().contains("key class is null")); [EOL] assertNull(exception.getTargetType()); [EOL] }
public void testWeirdKeyExceptionWithEmptyKeyValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = null; [EOL] try { [EOL] mapper.weirdKeyException(Integer.class, "", "empty string key"); [EOL] } catch (JsonMappingException e) { [EOL] exception = e; [EOL] } [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct Map key of type java.lang.Integer from String")); [EOL] assertTrue(exception.getMessage().contains("empty string key")); [EOL] assertEquals(Integer.class, exception.getTargetType()); [EOL] }
public void testWrongTokenExceptionWithExpectedTokenAndMessage() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String expectedMessage = "Unexpected token (VALUE_STRING), expected VALUE_NUMBER_INT: Test message"; [EOL] try { [EOL] throw wrongTokenException(jp, JsonToken.VALUE_NUMBER_INT, "Test message"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(expectedMessage, e.getOriginalMessage()); [EOL] } [EOL] }
public void testWrongTokenExceptionWithNullExpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String expectedMessage = "Unexpected token (VALUE_STRING), expected null: Test message"; [EOL] try { [EOL] throw wrongTokenException(jp, null, "Test message"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(expectedMessage, e.getOriginalMessage()); [EOL] } [EOL] }
public void testWrongTokenExceptionWithNullCurrentToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] String expectedMessage = "Unexpected token (null), expected VALUE_NUMBER_INT: Test message"; [EOL] try { [EOL] throw wrongTokenException(jp, JsonToken.VALUE_NUMBER_INT, "Test message"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals(expectedMessage, e.getOriginalMessage()); [EOL] } [EOL] }
public void testGetDateFormatWithNonNullDateFormat() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] DateFormat initialFormat = new SimpleDateFormat(); [EOL] objectMapper.setDateFormat(initialFormat); [EOL] DateFormat resultFormat = objectMapper.getDateFormat(); [EOL] assertSame("Expected the same DateFormat instance", initialFormat, resultFormat); [EOL] }
public void testGetDateFormatWithNullDateFormat() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setDateFormat(null); [EOL] DateFormat resultFormat = objectMapper.getDateFormat(); [EOL] assertNotNull("Expected a non-null DateFormat instance", resultFormat); [EOL] DateFormat defaultFormat = objectMapper.getSerializationConfig().getDateFormat(); [EOL] assertNotSame("Expected a cloned instance of DateFormat", defaultFormat, resultFormat); [EOL] }
public void testParseWithValidDate() { [EOL] String validDateStr = "2020-01-01T12:00:00Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = parse(validDateStr, pos); [EOL] assertNotNull(result); [EOL] assertEquals(validDateStr.length(), pos.getIndex()); [EOL] }
public void testParseWithInvalidDate() { [EOL] String invalidDateStr = "invalid-date"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] try { [EOL] parse(invalidDateStr, pos); [EOL] fail("Should have thrown an exception for invalid date format"); [EOL] } catch (ParseException e) { [EOL] } [EOL] assertEquals(0, pos.getIndex()); [EOL] }
protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory) { [EOL] super(src, factory); [EOL] }
public void testKeyDeserializerInstanceWithNull() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializer() { [EOL] KeyDeserializer expectedDeserializer = new MyKeyDeserializer(); [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, expectedDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testKeyDeserializerInstanceWithInvalidType() { [EOL] Object invalidDeserDef = new Object(); [EOL] try { [EOL] instance.keyDeserializerInstance(null, invalidDeserDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned key deserializer definition of type java.lang.Object; expected type KeyDeserializer or Class<KeyDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithNoneClass() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, KeyDeserializer.None.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNoClass() { [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNonKeyDeserializerClass() { [EOL] try { [EOL] instance.keyDeserializerInstance(null, String.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<KeyDeserializer>", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializerSubclass() { [EOL] Class<?> deserClass = MyKeyDeserializerSubclass.class; [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyKeyDeserializerSubclass); [EOL] }
public void testKeyDeserializerInstanceWithResolvableDeserializer() { [EOL] Class<?> deserClass = MyResolvableKeyDeserializer.class; [EOL] KeyDeserializer result = instance.keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyResolvableKeyDeserializer); [EOL] assertTrue(((MyResolvableKeyDeserializer) result).isResolved()); [EOL] }
protected Impl(Impl src, DeserializerFactory factory) { [EOL] super(src, factory); [EOL] }
public void testWithNonNullFactory() { [EOL] DeserializerFactory factory = new JsonFactory(); [EOL] DefaultDeserializationContext context = new DefaultDeserializationContext.Impl(new ObjectMapper()._deserializationContext, factory); [EOL] DefaultDeserializationContext newContext = context.with(factory); [EOL] assertNotNull(newContext); [EOL] assertNotSame(context, newContext); [EOL] assertEquals(Impl.class, newContext.getClass()); [EOL] }
public void testWithNullFactory() { [EOL] DeserializerFactory factory = null; [EOL] DefaultDeserializationContext context = new DefaultDeserializationContext.Impl(new ObjectMapper()._deserializationContext, new JsonFactory()); [EOL] try { [EOL] context.with(factory); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testJsonValueSerializerWithNonNullMethodAndSerializer() { [EOL] Method valueMethod = String.class.getMethod("toString"); [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] JsonValueSerializer jsonValueSerializer = new JsonValueSerializer(valueMethod, serializer); [EOL] assertNotNull(jsonValueSerializer); [EOL] }
public void testJsonValueSerializerWithNullMethod() { [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] try { [EOL] new JsonValueSerializer(null, serializer); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testJsonValueSerializerWithNullSerializer() { [EOL] Method valueMethod = String.class.getMethod("toString"); [EOL] try { [EOL] new JsonValueSerializer(valueMethod, null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testJsonValueSerializerWithNonNullPropertyAndSerializer() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] JsonValueSerializer src = new JsonValueSerializer(null, null, null, false); [EOL] JsonValueSerializer result = new JsonValueSerializer(src, property, serializer, true); [EOL] assertNotNull(result); [EOL] assertEquals(property, result.getProperty()); [EOL] assertEquals(serializer, result.getValueSerializer()); [EOL] assertTrue(result.isForceTypeInformation()); [EOL] }
public void testJsonValueSerializerWithNullPropertyAndSerializer() { [EOL] JsonValueSerializer src = new JsonValueSerializer(null, null, null, false); [EOL] JsonValueSerializer result = new JsonValueSerializer(src, null, null, false); [EOL] assertNotNull(result); [EOL] assertNull(result.getProperty()); [EOL] assertNull(result.getValueSerializer()); [EOL] assertFalse(result.isForceTypeInformation()); [EOL] }
public void testNotNullClassWithNullInput() { [EOL] Class<Object> result = _notNullClass(null); [EOL] assertEquals(Object.class, result); [EOL] }
public void testNotNullClassWithNonNullInput() { [EOL] Class<Object> result = _notNullClass(String.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testWithResolvedSameValues() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] JsonValueSerializer original = new JsonValueSerializer(null, property, serializer, true); [EOL] JsonValueSerializer result = original.withResolved(property, serializer, true); [EOL] assertSame(original, result); [EOL] }
public void testWithResolvedDifferentProperty() { [EOL] BeanProperty property1 = mock(BeanProperty.class); [EOL] BeanProperty property2 = mock(BeanProperty.class); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] JsonValueSerializer original = new JsonValueSerializer(null, property1, serializer, true); [EOL] JsonValueSerializer result = original.withResolved(property2, serializer, true); [EOL] assertNotSame(original, result); [EOL] }
public void testWithResolvedDifferentSerializer() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> serializer1 = mock(JsonSerializer.class); [EOL] JsonSerializer<?> serializer2 = mock(JsonSerializer.class); [EOL] JsonValueSerializer original = new JsonValueSerializer(null, property, serializer1, true); [EOL] JsonValueSerializer result = original.withResolved(property, serializer2, true); [EOL] assertNotSame(original, result); [EOL] }
public void testWithResolvedDifferentForceTypeInfo() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] JsonValueSerializer original = new JsonValueSerializer(null, property, serializer, true); [EOL] JsonValueSerializer result = original.withResolved(property, serializer, false); [EOL] assertNotSame(original, result); [EOL] }
public void testCreateContextualWithNullSerializerAndStaticTypingEnabled() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(provider.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] when(_accessorMethod.getReturnType().getModifiers()).thenReturn(Modifier.PUBLIC); [EOL] when(provider.constructType(_accessorMethod.getGenericReturnType())).thenReturn(mock(JavaType.class)); [EOL] when(provider.findTypedValueSerializer(any(JavaType.class), eq(false), eq(_property))).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNonNullSerializerAndContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer ser = mock(ContextualSerializer.class); [EOL] _valueSerializer = ser; [EOL] when(ser.createContextual(provider, property)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] assertNotSame(ser, result); [EOL] }
public void testCreateContextualWithNonNullSerializerAndNonContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] _valueSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNullSerializerAndStaticTypingDisabledAndNonFinalReturnType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(provider.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(false); [EOL] when(_accessorMethod.getReturnType().getModifiers()).thenReturn(0); // Not final [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testSerializeWithNullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] bean.getClass(), null, new BeanPropertyWriter[0], new BeanPropertyWriter[0] [EOL] ) { [EOL] @Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException { [EOL] _accessorMethod = accessorMethod; [EOL] _valueSerializer = valueSerializer; [EOL] super.serialize(bean, jgen, prov); [EOL] } [EOL] }; [EOL] when(accessorMethod.invoke(bean)).thenReturn(null); [EOL] serializer.serialize(bean, jgen, prov); [EOL] verify(prov).defaultSerializeNull(jgen); [EOL] }
public void testSerializeWithValueSerializerNotNull() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] bean.getClass(), null, new BeanPropertyWriter[0], new BeanPropertyWriter[0] [EOL] ) { [EOL] @Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException { [EOL] _accessorMethod = accessorMethod; [EOL] _valueSerializer = valueSerializer; [EOL] super.serialize(bean, jgen, prov); [EOL] } [EOL] }; [EOL] Object value = new Object(); [EOL] when(accessorMethod.invoke(bean)).thenReturn(value); [EOL] serializer.serialize(bean, jgen, prov); [EOL] verify(valueSerializer).serialize(value, jgen, prov); [EOL] }
public void testSerializeWithIOException() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] bean.getClass(), null, new BeanPropertyWriter[0], new BeanPropertyWriter[0] [EOL] ) { [EOL] @Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException { [EOL] _accessorMethod = accessorMethod; [EOL] _valueSerializer = valueSerializer; [EOL] super.serialize(bean, jgen, prov); [EOL] } [EOL] }; [EOL] IOException ioException = new IOException(); [EOL] when(accessorMethod.invoke(bean)).thenThrow(ioException); [EOL] try { [EOL] serializer.serialize(bean, jgen, prov); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] assertSame(ioException, e); [EOL] } [EOL] }
public void testSerializeWithInvocationTargetException() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] bean.getClass(), null, new BeanPropertyWriter[0], new BeanPropertyWriter[0] [EOL] ) { [EOL] @Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException { [EOL] _accessorMethod = accessorMethod; [EOL] _valueSerializer = valueSerializer; [EOL] super.serialize(bean, jgen, prov); [EOL] } [EOL] }; [EOL] InvocationTargetException ite = new InvocationTargetException(new RuntimeException("test exception")); [EOL] when(accessorMethod.invoke(bean)).thenThrow(ite); [EOL] try { [EOL] serializer.serialize(bean, jgen, prov); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] Throwable cause = e.getCause(); [EOL] assertNotNull(cause); [EOL] assertEquals("test exception", cause.getMessage()); [EOL] } [EOL] }
public void testSerializeWithError() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] bean.getClass(), null, new BeanPropertyWriter[0], new BeanPropertyWriter[0] [EOL] ) { [EOL] @Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException { [EOL] _accessorMethod = accessorMethod; [EOL] _valueSerializer = valueSerializer; [EOL] super.serialize(bean, jgen, prov); [EOL] } [EOL] }; [EOL] Error error = new Error("test error"); [EOL] InvocationTargetException ite = new InvocationTargetException(error); [EOL] when(accessorMethod.invoke(bean)).thenThrow(ite); [EOL] try { [EOL] serializer.serialize(bean, jgen, prov); [EOL] fail("Error expected"); [EOL] } catch (Error e) { [EOL] assertSame(error, e); [EOL] } [EOL] }
public void testSerializeWithType_NullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn(null); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeWithType_NonNullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn("test"); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(valueSerializer); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(valueSerializer).serializeWithType("test", jgen, provider, typeSer); [EOL] }
public void testSerializeWithType_ForceTypeInformation() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenReturn("test"); [EOL] MySerializer serializer = new MySerializer(accessorMethod, valueSerializer, true); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForScalar(bean, jgen); [EOL] verify(valueSerializer).serialize("test", jgen, provider); [EOL] verify(typeSer).writeTypeSuffixForScalar(bean, jgen); [EOL] }
public void testSerializeWithType_IOException() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenThrow(new IOException()); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] assertThrows(IOException.class, () -> { [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] }); [EOL] }
public void testSerializeWithType_OtherException() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Method accessorMethod = Object.class.getMethod("toString"); [EOL] when(accessorMethod.invoke(bean)).thenThrow(new IllegalAccessException()); [EOL] MySerializer serializer = new MySerializer(accessorMethod, null, false); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] }); [EOL] }
public void testIsNaturalTypeWithStdHandling_primitiveInteger() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Integer.TYPE, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_primitiveBoolean() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Boolean.TYPE, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_primitiveDouble() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Double.TYPE, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_primitiveNonStandard() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Byte.TYPE, serializer); [EOL] assert !result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_nonPrimitiveString() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(String.class, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_nonPrimitiveInteger() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Integer.class, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_nonPrimitiveBoolean() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Boolean.class, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_nonPrimitiveDouble() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Double.class, serializer); [EOL] assert result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_nonPrimitiveNonStandard() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(Byte.class, serializer); [EOL] assert !result; [EOL] } [EOL] public void testIsNaturalTypeWithStdHandling_defaultSerializer() { [EOL] JsonSerializer<?> serializer = getDefaultSerializer(); [EOL] boolean result = isNaturalTypeWithStdHandling(String.class, serializer); [EOL] assert result == isDefaultSerializer(serializer); [EOL] } [EOL] private JsonSerializer<?> getDefaultSerializer() { [EOL] return new DefaultSerializer(); [EOL] } [EOL] private boolean isDefaultSerializer(JsonSerializer<?> serializer) { [EOL] return serializer instanceof DefaultSerializer; [EOL] } [EOL] private static class DefaultSerializer extends JsonSerializer<Object> { [EOL] }
public void testGetInternalName() { [EOL] MyClass obj = new MyClass("expectedInternalName"); [EOL] String internalName = obj.getInternalName(); [EOL] assertEquals("expectedInternalName", internalName); [EOL] }
public void testGetGetterWithNullGetters() { [EOL] MyClass instance = new MyClass(); [EOL] instance._getters = null; [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertNull(result); [EOL] }
public void testGetGetterWithSingleGetter() { [EOL] MyClass instance = new MyClass(); [EOL] AnnotatedMethod mockGetter = createMockAnnotatedMethod(); [EOL] instance._getters = new Linked<>(mockGetter, null); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter, result); [EOL] }
public void testGetGetterWithMultipleGettersSameClass() { [EOL] MyClass instance = new MyClass(); [EOL] AnnotatedMethod mockGetter1 = createMockAnnotatedMethod(); [EOL] AnnotatedMethod mockGetter2 = createMockAnnotatedMethod(); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null)); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn(SomeClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn(SomeClass.class); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter1, result); [EOL] }
public void testGetGetterWithMultipleGettersDifferentClasses() { [EOL] MyClass instance = new MyClass(); [EOL] AnnotatedMethod mockGetter1 = createMockAnnotatedMethod(); [EOL] AnnotatedMethod mockGetter2 = createMockAnnotatedMethod(); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null)); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn(ParentClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn(ChildClass.class); [EOL] when(ChildClass.class.isAssignableFrom(ParentClass.class)).thenReturn(false); [EOL] when(ParentClass.class.isAssignableFrom(ChildClass.class)).thenReturn(true); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter2, result); [EOL] }
public void testGetGetterWithConflictingGetters() { [EOL] MyClass instance = new MyClass(); [EOL] AnnotatedMethod mockGetter1 = createMockAnnotatedMethod(); [EOL] AnnotatedMethod mockGetter2 = createMockAnnotatedMethod(); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null)); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn(ParentClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn(UnrelatedClass.class); [EOL] when(UnrelatedClass.class.isAssignableFrom(ParentClass.class)).thenReturn(false); [EOL] when(ParentClass.class.isAssignableFrom(UnrelatedClass.class)).thenReturn(false); [EOL] when(mockGetter1.getFullName()).thenReturn("ParentClass.getter"); [EOL] when(mockGetter2.getFullName()).thenReturn("UnrelatedClass.getter"); [EOL] when(instance.getName()).thenReturn("propertyName"); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] instance.getGetter(); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Conflicting getter definitions for property \"propertyName\": ParentClass.getter vs UnrelatedClass.getter")); [EOL] }
public void testGetConstructorParameter_WithNullCtorParameters() { [EOL] MyClass testInstance = new MyClass(null); [EOL] AnnotatedParameter result = testInstance.getConstructorParameter(); [EOL] assertNull(result); [EOL] }
public void testGetConstructorParameter_WithNonConstructorOwner() { [EOL] Linked<AnnotatedParameter> nonConstructorParam = new Linked<>( [EOL] new AnnotatedParameter(new Object(), null, null, null), null); [EOL] MyClass testInstance = new MyClass(nonConstructorParam); [EOL] AnnotatedParameter result = testInstance.getConstructorParameter(); [EOL] assertSame(nonConstructorParam.value, result); [EOL] }
public void testGetConstructorParameter_WithConstructorOwner() { [EOL] AnnotatedConstructor owner = new AnnotatedConstructor(null, null, null, null); [EOL] AnnotatedParameter constructorParam = new AnnotatedParameter(owner, null, null, null); [EOL] Linked<AnnotatedParameter> constructorParamLinked = new Linked<>(constructorParam, null); [EOL] MyClass testInstance = new MyClass(constructorParamLinked); [EOL] AnnotatedParameter result = testInstance.getConstructorParameter(); [EOL] assertSame(constructorParam, result); [EOL] }
public void testFindRenamedWithNullNode() { [EOL] Linked<AnnotatedMember> result = findRenamed(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testFindRenamedWithSingleNodeNoRename() { [EOL] Linked<AnnotatedMember> node = new Linked<>(new AnnotatedMemberDummy(), null, null, false); [EOL] Linked<AnnotatedMember> result = findRenamed(node, null); [EOL] assertNull(result); [EOL] } [EOL] public void testFindRenamedWithSingleNodeAndRename() { [EOL] Linked<AnnotatedMember> node = new Linked<>(new AnnotatedMemberDummy(), null, "rename", false); [EOL] Linked<AnnotatedMember> result = findRenamed(node, null); [EOL] assertNotNull(result); [EOL] assertEquals("rename", result.explicitName); [EOL] } [EOL] public void testFindRenamedWithMultipleNodesNoConflicts() { [EOL] Linked<AnnotatedMember> node1 = new Linked<>(new AnnotatedMemberDummy(), null, "rename1", false); [EOL] Linked<AnnotatedMember> node2 = new Linked<>(new AnnotatedMemberDummy(), node1, "rename2", false); [EOL] Linked<AnnotatedMember> result = findRenamed(node2, null); [EOL] assertNotNull(result); [EOL] assertEquals("rename2", result.explicitName); [EOL] } [EOL] public void testFindRenamedWithMultipleNodesWithConflict() { [EOL] Linked<AnnotatedMember> node1 = new Linked<>(new AnnotatedMemberDummy(), null, "rename", false); [EOL] Linked<AnnotatedMember> node2 = new Linked<>(new AnnotatedMemberDummy(), node1, "rename", false); [EOL] try { [EOL] findRenamed(node2, null); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testDoubleNodeConstructor() { [EOL] double testValue = 10.0; [EOL] DoubleNode node = new DoubleNode(testValue); [EOL] assertEquals(testValue, node._value, 0.0); [EOL] }
public void testValueOf_PositiveDouble() { [EOL] double input = 123.456; [EOL] DoubleNode result = DoubleNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.doubleValue(), 0.0); [EOL] }
public void testValueOf_NegativeDouble() { [EOL] double input = -123.456; [EOL] DoubleNode result = DoubleNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.doubleValue(), 0.0); [EOL] }
public void testValueOf_Zero() { [EOL] double input = 0.0; [EOL] DoubleNode result = DoubleNode.valueOf(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.doubleValue(), 0.0); [EOL] }
public void testAsToken() { [EOL] MyJsonNode node = new MyJsonNode(); [EOL] JsonToken token = node.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, token); [EOL] }
protected PropertyBasedCreator(ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps, Object[] defaultValues) { [EOL] _valueInstantiator = valueInstantiator; [EOL] _properties = new HashMap<String, SettableBeanProperty>(); [EOL] SettableBeanProperty[] propertiesWithInjectables = null; [EOL] final int len = creatorProps.length; [EOL] _propertyCount = len; [EOL] for (int i = 0; i < len; ++i) { [EOL] SettableBeanProperty prop = creatorProps[i]; [EOL] _properties.put(prop.getName(), prop); [EOL] Object injectableValueId = prop.getInjectableValueId(); [EOL] if (injectableValueId != null) { [EOL] if (propertiesWithInjectables == null) { [EOL] propertiesWithInjectables = new SettableBeanProperty[len]; [EOL] } [EOL] propertiesWithInjectables[i] = prop; [EOL] } [EOL] } [EOL] _defaultValues = defaultValues; [EOL] _propertiesWithInjectables = propertiesWithInjectables; [EOL] }
public void testConstructWithEmptyProperties() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty[] srcProps = new SettableBeanProperty[0]; [EOL] PropertyBasedCreator result = PropertyBasedCreator.construct(ctxt, valueInstantiator, srcProps); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.properties().length); [EOL] }
public void testConstructWithNonNullPropertiesAndNoValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.hasValueDeserializer()).thenReturn(false); [EOL] when(prop.getType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(SettableBeanProperty.class))).thenReturn(mock(JsonDeserializer.class)); [EOL] SettableBeanProperty[] srcProps = new SettableBeanProperty[] { prop }; [EOL] PropertyBasedCreator result = PropertyBasedCreator.construct(ctxt, valueInstantiator, srcProps); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.properties().length); [EOL] }
public void testConstructWithNonNullPropertiesAndPrimitiveType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(prop.hasValueDeserializer()).thenReturn(false); [EOL] when(prop.getType()).thenReturn(javaType); [EOL] when(javaType.isPrimitive()).thenReturn(true); [EOL] when(javaType.getRawClass()).thenReturn(int.class); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(SettableBeanProperty.class))).thenReturn(mock(JsonDeserializer.class)); [EOL] SettableBeanProperty[] srcProps = new SettableBeanProperty[] { prop }; [EOL] PropertyBasedCreator result = PropertyBasedCreator.construct(ctxt, valueInstantiator, srcProps); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.properties().length); [EOL] assertNotNull(result.defaultValues()); [EOL] assertEquals(1, result.defaultValues().length); [EOL] assertEquals(0, result.defaultValues()[0]); [EOL] }
public void testConstructWithNonNullPropertiesAndNonNullDefaultValue() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] when(prop.hasValueDeserializer()).thenReturn(true); [EOL] when(prop.getValueDeserializer()).thenReturn(deser); [EOL] when(deser.getNullValue()).thenReturn("default"); [EOL] when(prop.getType()).thenReturn(mock(JavaType.class)); [EOL] SettableBeanProperty[] srcProps = new SettableBeanProperty[] { prop }; [EOL] PropertyBasedCreator result = PropertyBasedCreator.construct(ctxt, valueInstantiator, srcProps); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.properties().length); [EOL] assertNotNull(result.defaultValues()); [EOL] assertEquals(1, result.defaultValues().length); [EOL] assertEquals("default", result.defaultValues()[0]); [EOL] }
public void testPropertiesNonNull() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new LinkedHashMap<String, SettableBeanProperty>()); [EOL] Collection<SettableBeanProperty> properties = beanPropertyMap.properties(); [EOL] assertNotNull(properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testPropertiesWithContent() { [EOL] LinkedHashMap<String, SettableBeanProperty> propMap = new LinkedHashMap<>(); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] propMap.put("testProperty", property); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, propMap); [EOL] Collection<SettableBeanProperty> properties = beanPropertyMap.properties(); [EOL] assertNotNull(properties); [EOL] assertFalse(properties.isEmpty()); [EOL] assertEquals(1, properties.size()); [EOL] assertTrue(properties.contains(property)); [EOL] }
public void testFindCreatorPropertyWithExistingProperty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new LinkedHashMap<>()); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] String propertyName = "testProperty"; [EOL] beanPropertyMap.put(propertyName, property); [EOL] SettableBeanProperty result = beanPropertyMap.findCreatorProperty(propertyName); [EOL] assertSame("The returned property should be the one that was put in.", property, result); [EOL] }
public void testFindCreatorPropertyWithNonExistingProperty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, new LinkedHashMap<>()); [EOL] String propertyName = "nonExistingProperty"; [EOL] SettableBeanProperty result = beanPropertyMap.findCreatorProperty(propertyName); [EOL] assertNull("The returned property should be null for a non-existing property name.", result); [EOL] }
public void testStartBuildingWithInjectables() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader oir = mock(ObjectIdReader.class); [EOL] PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, 2, oir); [EOL] Map<Object, Object> injectables = new HashMap<>(); [EOL] injectables.put("key", "value"); [EOL] buffer.inject(injectables); [EOL] assertEquals("value", buffer.getInjectableValue("key")); [EOL] }
public void testStartBuildingWithoutInjectables() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader oir = null; // Assuming ObjectIdReader can be null [EOL] PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, 2, oir); [EOL] assertNull(buffer.getInjectableValue("key")); [EOL] }
public void testBuildWithEmptyBuffer() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object beanMock = new Object(); [EOL] when(buffer.getParameters(any())).thenReturn(new Object[0]); [EOL] when(valueInstantiator.createFromObjectWith(eq(ctxt), any())).thenReturn(beanMock); [EOL] when(buffer.handleIdValue(eq(ctxt), eq(beanMock))).thenReturn(beanMock); [EOL] when(buffer.buffered()).thenReturn(null); [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(valueInstantiator, null); [EOL] Object bean = creator.build(ctxt, buffer); [EOL] assertNotNull(bean); [EOL] verify(buffer, times(1)).getParameters(any()); [EOL] verify(valueInstantiator, times(1)).createFromObjectWith(eq(ctxt), any()); [EOL] verify(buffer, times(1)).handleIdValue(eq(ctxt), eq(beanMock)); [EOL] verify(buffer, times(1)).buffered(); [EOL] }
public void testBuildWithNonEmptyBuffer() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object beanMock = new Object(); [EOL] PropertyValue propertyValueMock = mock(PropertyValue.class); [EOL] when(buffer.getParameters(any())).thenReturn(new Object[0]); [EOL] when(valueInstantiator.createFromObjectWith(eq(ctxt), any())).thenReturn(beanMock); [EOL] when(buffer.handleIdValue(eq(ctxt), eq(beanMock))).thenReturn(beanMock); [EOL] when(buffer.buffered()).thenReturn(propertyValueMock).thenReturn(null); [EOL] doNothing().when(propertyValueMock).assign(any()); [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(valueInstantiator, null); [EOL] Object bean = creator.build(ctxt, buffer); [EOL] assertNotNull(bean); [EOL] verify(buffer, times(1)).getParameters(any()); [EOL] verify(valueInstantiator, times(1)).createFromObjectWith(eq(ctxt), any()); [EOL] verify(buffer, times(1)).handleIdValue(eq(ctxt), eq(beanMock)); [EOL] verify(buffer, times(2)).buffered(); [EOL] verify(propertyValueMock, times(1)).assign(eq(beanMock)); [EOL] }
public void testIsArray_NodeTypeArray() { [EOL] JsonNode node = new ArrayNode(JsonNodeFactory.instance); [EOL] assertTrue(node.isArray()); [EOL] }
public void testIsArray_NodeTypeNotArray() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(node.isArray()); [EOL] }
public void testIsObject_NodeTypeIsObject() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] assertTrue(node.isObject()); [EOL] }
public void testIsObject_NodeTypeIsNotObject() { [EOL] JsonNode node = new TextNode("text"); [EOL] assertFalse(node.isObject()); [EOL] }
public void testIsFloatingPointNumber() { [EOL] JsonNode node = new NumericNode(); [EOL] assertFalse(node.isFloatingPointNumber()); [EOL] }
public void testIsTextual_NodeTypeString() { [EOL] JsonNode node = new TextNode("test"); [EOL] assertTrue(node.isTextual()); [EOL] }
public void testIsTextual_NodeTypeNotString() { [EOL] JsonNode node = new IntNode(123); [EOL] assertFalse(node.isTextual()); [EOL] }
public void testHasWithExistingField() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] ((ObjectNode) node).set(fieldName, TextNode.valueOf("testValue")); [EOL] boolean result = node.has(fieldName); [EOL] assertTrue(result); [EOL] }
public void testHasWithNonExistingField() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "nonExistingField"; [EOL] boolean result = node.has(fieldName); [EOL] assertFalse(result); [EOL] }
public void testIterator() { [EOL] JsonNode node = createJsonNodeWithData(); [EOL] Iterator<JsonNode> iterator = node.iterator(); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(expectedFirstElement, iterator.next()); [EOL] }
public void testFindValuesWhenResultIsNull() { [EOL] JsonNode rootNode = createNodeWithNoMatchingField(); // Implement this method to create a JsonNode without the field [EOL] List<JsonNode> result = rootNode.findValues("nonExistingField"); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testFindValuesWhenResultIsNotNull() { [EOL] JsonNode rootNode = createNodeWithMatchingField(); // Implement this method to create a JsonNode with the field [EOL] List<JsonNode> result = rootNode.findValues("existingField"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindParentsWhenResultIsNull() { [EOL] JsonNode rootNode = createRootNodeWithNoMatchingChildren(); // Implement this to create a node with no children matching the fieldName [EOL] List<JsonNode> result = rootNode.findParents("nonExistingField"); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testFindParentsWhenResultIsNotNull() { [EOL] JsonNode rootNode = createRootNodeWithMatchingChildren(); // Implement this to create a node with children matching the fieldName [EOL] List<JsonNode> result = rootNode.findParents("existingField"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindClassWithPrimitiveInt() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("int"); [EOL] assertEquals(Integer.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveLong() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("long"); [EOL] assertEquals(Long.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveFloat() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("float"); [EOL] assertEquals(Float.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveDouble() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("double"); [EOL] assertEquals(Double.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveBoolean() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("boolean"); [EOL] assertEquals(Boolean.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveByte() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("byte"); [EOL] assertEquals(Byte.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveChar() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("char"); [EOL] assertEquals(Character.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveShort() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("short"); [EOL] assertEquals(Short.TYPE, result); [EOL] }
public void testFindClassWithPrimitiveVoid() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("void"); [EOL] assertEquals(Void.TYPE, result); [EOL] }
public void testFindClassWithExistingClass() throws ClassNotFoundException { [EOL] Class<?> result = YourClass.findClass("java.lang.String"); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindClassWithNonExistingClass() { [EOL] Exception exception = assertThrows(ClassNotFoundException.class, () -> { [EOL] YourClass.findClass("non.existing.ClassName"); [EOL] }); [EOL] assertNotNull(exception.getMessage()); [EOL] }
public void testGetRootCauseWithNullCause() { [EOL] Throwable throwable = new Throwable(); [EOL] Throwable result = YourClass.getRootCause(throwable); [EOL] assertEquals(throwable, result); [EOL] }
public void testGetRootCauseWithOneLevelCause() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable throwable = new Throwable(cause); [EOL] Throwable result = YourClass.getRootCause(throwable); [EOL] assertEquals(cause, result); [EOL] }
public void testGetRootCauseWithMultipleLevelCauses() { [EOL] Throwable causeLevel3 = new Throwable(); [EOL] Throwable causeLevel2 = new Throwable(causeLevel3); [EOL] Throwable causeLevel1 = new Throwable(causeLevel2); [EOL] Throwable throwable = new Throwable(causeLevel1); [EOL] Throwable result = YourClass.getRootCause(throwable); [EOL] assertEquals(causeLevel3, result); [EOL] }
public void testThrowAsIAEWithRuntimeException() { [EOL] Exception runtimeException = new RuntimeException("Runtime exception"); [EOL] try { [EOL] JacksonDatabindUtils.throwAsIAE(runtimeException, "Error occurred"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testThrowAsIAEWithError() { [EOL] Error error = new Error("Error occurred"); [EOL] try { [EOL] JacksonDatabindUtils.throwAsIAE(error, "Error occurred"); [EOL] } catch (Error e) { [EOL] assertEquals("Error occurred", e.getMessage()); [EOL] } [EOL] }
public void testThrowAsIAEWithOtherThrowable() { [EOL] Throwable throwable = new Throwable("Other throwable"); [EOL] try { [EOL] JacksonDatabindUtils.throwAsIAE(throwable, "Error occurred"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Error occurred", e.getMessage()); [EOL] assertSame(throwable, e.getCause()); [EOL] } [EOL] }
public void testUnwrapAndThrowAsIAE_WithRootCause() { [EOL] Exception rootCause = new Exception("Root cause"); [EOL] Throwable t = new RuntimeException(new IllegalStateException(rootCause)); [EOL] try { [EOL] JacksonDatabind.unwrapAndThrowAsIAE(t, "Test message"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Test message", e.getMessage()); [EOL] assertEquals(rootCause, e.getCause()); [EOL] } [EOL] }
public void testUnwrapAndThrowAsIAE_WithNoCause() { [EOL] Throwable t = new RuntimeException("No cause"); [EOL] try { [EOL] JacksonDatabind.unwrapAndThrowAsIAE(t, "Test message"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Test message", e.getMessage()); [EOL] assertEquals("No cause", e.getCause().getMessage()); [EOL] } [EOL] }
public void testCreateInstanceWithValidClassAndCanFixAccessTrue() { [EOL] class DummyClass { [EOL] public DummyClass() { [EOL] } [EOL] } [EOL] try { [EOL] DummyClass instance = JacksonDatabind.createInstance(DummyClass.class, true); [EOL] assertNotNull("Instance should not be null", instance); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("IllegalArgumentException should not be thrown for a class with a default constructor"); [EOL] } [EOL] }
public void testCreateInstanceWithValidClassAndCanFixAccessFalse() { [EOL] class DummyClass { [EOL] public DummyClass() { [EOL] } [EOL] } [EOL] try { [EOL] DummyClass instance = JacksonDatabind.createInstance(DummyClass.class, false); [EOL] assertNotNull("Instance should not be null", instance); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("IllegalArgumentException should not be thrown for a class with a default constructor"); [EOL] } [EOL] }
public void testCreateInstanceWithInvalidClass() { [EOL] class NoDefaultConstructorClass { [EOL] public NoDefaultConstructorClass(String arg) { [EOL] } [EOL] } [EOL] try { [EOL] JacksonDatabind.createInstance(NoDefaultConstructorClass.class, true); [EOL] fail("IllegalArgumentException should be thrown for a class without a default constructor"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Class " + NoDefaultConstructorClass.class.getName() + " has no default (no arg) constructor", e.getMessage()); [EOL] } [EOL] }
public void testCreateInstanceWithConstructorException() { [EOL] class ConstructorExceptionClass { [EOL] public ConstructorExceptionClass() throws Exception { [EOL] throw new Exception("Constructor failed"); [EOL] } [EOL] } [EOL] try { [EOL] JacksonDatabind.createInstance(ConstructorExceptionClass.class, true); [EOL] fail("IllegalArgumentException should be thrown when constructor throws an exception"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue("Exception message should contain the failed class name and problem description", e.getMessage().contains("Failed to instantiate class " + ConstructorExceptionClass.class.getName())); [EOL] } [EOL] }
public void testFindConstructorWithAccessibleConstructorAndCanFixAccess() { [EOL] class TestClass { [EOL] public TestClass() {} [EOL] } [EOL] Constructor<TestClass> constructor = JacksonDatabindUtils.findConstructor(TestClass.class, true); [EOL] assertNotNull(constructor); [EOL] assertTrue(Modifier.isPublic(constructor.getModifiers())); [EOL] }
public void testFindConstructorWithInaccessibleConstructorAndCanFixAccess() { [EOL] class TestClass { [EOL] private TestClass() {} [EOL] } [EOL] Constructor<TestClass> constructor = JacksonDatabindUtils.findConstructor(TestClass.class, true); [EOL] assertNotNull(constructor); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] }
public void testFindConstructorWithAccessibleConstructorAndCannotFixAccess() { [EOL] class TestClass { [EOL] public TestClass() {} [EOL] } [EOL] Constructor<TestClass> constructor = JacksonDatabindUtils.findConstructor(TestClass.class, false); [EOL] assertNotNull(constructor); [EOL] assertTrue(Modifier.isPublic(constructor.getModifiers())); [EOL] }
public void testFindConstructorWithInaccessibleConstructorAndCannotFixAccess() { [EOL] class TestClass { [EOL] private TestClass() {} [EOL] } [EOL] try { [EOL] JacksonDatabindUtils.findConstructor(TestClass.class, false); [EOL] fail("Expected IllegalArgumentException for inaccessible constructor"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindConstructorWithNoDefaultConstructor() { [EOL] class TestClass { [EOL] private TestClass(int value) {} [EOL] } [EOL] Constructor<TestClass> constructor = JacksonDatabindUtils.findConstructor(TestClass.class, true); [EOL] assertNull(constructor); [EOL] }
public void testWrapperTypeWithIntegerPrimitive() { [EOL] Class<?> result = wrapperType(Integer.TYPE); [EOL] assertEquals(Integer.class, result); [EOL] }
public void testWrapperTypeWithLongPrimitive() { [EOL] Class<?> result = wrapperType(Long.TYPE); [EOL] assertEquals(Long.class, result); [EOL] }
public void testWrapperTypeWithBooleanPrimitive() { [EOL] Class<?> result = wrapperType(Boolean.TYPE); [EOL] assertEquals(Boolean.class, result); [EOL] }
public void testWrapperTypeWithDoublePrimitive() { [EOL] Class<?> result = wrapperType(Double.TYPE); [EOL] assertEquals(Double.class, result); [EOL] }
public void testWrapperTypeWithFloatPrimitive() { [EOL] Class<?> result = wrapperType(Float.TYPE); [EOL] assertEquals(Float.class, result); [EOL] }
public void testWrapperTypeWithBytePrimitive() { [EOL] Class<?> result = wrapperType(Byte.TYPE); [EOL] assertEquals(Byte.class, result); [EOL] }
public void testWrapperTypeWithShortPrimitive() { [EOL] Class<?> result = wrapperType(Short.TYPE); [EOL] assertEquals(Short.class, result); [EOL] }
public void testWrapperTypeWithCharacterPrimitive() { [EOL] Class<?> result = wrapperType(Character.TYPE); [EOL] assertEquals(Character.class, result); [EOL] }
public void testWrapperTypeWithInvalidType() { [EOL] try { [EOL] wrapperType(String.class); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Class java.lang.String is not a primitive type", e.getMessage()); [EOL] } [EOL] }
public void testCheckAndFixAccessWithAccessibleMember() { [EOL] Member member = mock(Member.class); [EOL] AccessibleObject ao = mock(AccessibleObject.class); [EOL] when(member.getDeclaringClass()).thenReturn((Class) Object.class); [EOL] doNothing().when(ao).setAccessible(true); [EOL] when((AccessibleObject) member).thenReturn(ao); [EOL] JacksonDatabindUtils.checkAndFixAccess(member); [EOL] verify(ao).setAccessible(true); [EOL] }
public void testCheckAndFixAccessWithInaccessibleMember() { [EOL] Member member = mock(Member.class); [EOL] AccessibleObject ao = mock(AccessibleObject.class); [EOL] when(member.getDeclaringClass()).thenReturn((Class) Object.class); [EOL] doThrow(new SecurityException("Test")).when(ao).setAccessible(true); [EOL] when((AccessibleObject) member).thenReturn(ao); [EOL] when(ao.isAccessible()).thenReturn(false); [EOL] try { [EOL] JacksonDatabindUtils.checkAndFixAccess(member); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not access " + member + " (from class " + Object.class.getName() + "; failed to set access: Test", e.getMessage()); [EOL] } [EOL] }
public void testEnumSetSerializerWithNonNullElemTypeAndProperty() { [EOL] JavaType elemType = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] EnumSetSerializer serializer = new EnumSetSerializer(elemType, property); [EOL] assertNotNull(serializer); [EOL] }
public void testEnumSetSerializerWithNullElemTypeAndProperty() { [EOL] EnumSetSerializer serializer = new EnumSetSerializer(null, null); [EOL] assertNotNull(serializer); [EOL] }
public void testEnumSetSerializerWithNullParameters() { [EOL] EnumSetSerializer src = new EnumSetSerializer(null, null, null, null); [EOL] EnumSetSerializer serializer = new EnumSetSerializer(src, null, null, null); [EOL] assertNotNull(serializer); [EOL] }
public void testEnumSetSerializerWithNonNullParameters() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] EnumSetSerializer src = new EnumSetSerializer(null, property, typeSerializer, valueSerializer); [EOL] EnumSetSerializer serializer = new EnumSetSerializer(src, property, typeSerializer, valueSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testWithResolvedNullPropertyNullTypeSerializerNullElementSerializer() { [EOL] EnumSetSerializer original = new EnumSetSerializer(null, null, null, false); [EOL] EnumSetSerializer result = original.withResolved(null, null, null); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] }
public void testWithResolvedNonNullPropertyNonNullTypeSerializerNonNullElementSerializer() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] EnumSetSerializer original = new EnumSetSerializer(null, null, null, false); [EOL] EnumSetSerializer result = original.withResolved(property, typeSerializer, elementSerializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] }
public void testStdDelegatingDeserializerWithNonNullConverterAndDelegateDeserializer() { [EOL] Converter<Object, String> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] StdDelegatingDeserializer<String> deserializer = new StdDelegatingDeserializer<>(converter, delegateType, delegateDeserializer); [EOL] assertNotNull(deserializer); [EOL] assertSame(converter, deserializer._converter); [EOL] assertSame(delegateType, deserializer._delegateType); [EOL] assertSame(delegateDeserializer, deserializer._delegateDeserializer); [EOL] }
public void testResolveWithDelegateDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ResolvableDeserializer delegateDeserializer = mock(ResolvableDeserializer.class); [EOL] CustomResolver resolver = new CustomResolver(delegateDeserializer); [EOL] resolver.resolve(ctxt); [EOL] verify(delegateDeserializer).resolve(ctxt); [EOL] }
public void testResolveWithNonResolvableDelegateDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] CustomResolver resolver = new CustomResolver(delegateDeserializer); [EOL] resolver.resolve(ctxt); [EOL] verify(delegateDeserializer, never()).resolve(any(DeserializationContext.class)); [EOL] }
public void testResolveWithNullDelegateDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CustomResolver resolver = new CustomResolver(null); [EOL] resolver.resolve(ctxt); [EOL] }
public void testCreateContextualWithNonNullDelegateDeserializerAndContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] StdDelegatingDeserializer<?> delegatingDeserializer = new StdDelegatingDeserializer<>(_converter); [EOL] delegatingDeserializer._delegateDeserializer = (JsonDeserializer)contextualDeserializer; [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(delegateDeserializer); [EOL] when(delegateDeserializer.equals(contextualDeserializer)).thenReturn(false); [EOL] JsonDeserializer<?> result = delegatingDeserializer.createContextual(ctxt, property); [EOL] assertNotSame("Expected a different deserializer", delegateDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullDelegateDeserializerButNonContextual() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> delegateDeserializer = mock(JsonDeserializer.class); [EOL] StdDelegatingDeserializer<?> delegatingDeserializer = new StdDelegatingDeserializer<>(_converter); [EOL] delegatingDeserializer._delegateDeserializer = delegateDeserializer; [EOL] JsonDeserializer<?> result = delegatingDeserializer.createContextual(ctxt, property); [EOL] assertSame("Expected the same deserializer", delegatingDeserializer, result); [EOL] }
public void testCreateContextualWithNullDelegateDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] StdDelegatingDeserializer<?> delegatingDeserializer = new StdDelegatingDeserializer<>(converter); [EOL] when(converter.getInputType(ctxt.getTypeFactory())).thenReturn(delegateType); [EOL] when(ctxt.findContextualValueDeserializer(delegateType, property)).thenReturn(valueDeserializer); [EOL] JsonDeserializer<?> result = delegatingDeserializer.createContextual(ctxt, property); [EOL] assertNotNull("Expected non-null deserializer", result); [EOL] }
public void testDeserializeWithNonNullDelegateValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object delegateValue = new Object(); [EOL] Object expectedValue = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateValue); [EOL] when(this.convertValue(delegateValue)).thenReturn(expectedValue); [EOL] Object result = this.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertSame(expectedValue, result); [EOL] }
public void testDeserializeWithNullDelegateValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(null); [EOL] Object result = this.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
protected T convertValue(Object delegateValue) { [EOL] return _converter.convert(delegateValue); [EOL] }
public void testGetSchemaWithNonParameterizedType() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonNode result = getSchema(provider, String.class); [EOL] assertTrue(result.isObject()); [EOL] assertFalse(result.has("properties")); [EOL] }
public void testGetSchemaWithParameterizedTypeAndOneTypeArg() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[]{String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertFalse(result.has("properties")); [EOL] }
public void testGetSchemaWithParameterizedTypeAndTwoTypeArgs() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[]{DayOfWeek.class, String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return Map.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] when(provider.constructType(any(Type.class))).thenAnswer(invocation -> TypeFactory.defaultInstance().constructType(invocation.getArgument(0))); [EOL] when(provider.getConfig()).thenReturn(new SerializationConfig(null, null, null, null, null, null, null)); [EOL] when(provider.findValueSerializer(any(Class.class), any(BeanProperty.class))).thenReturn(new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) { [EOL] } [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL] return JsonNodeFactory.instance.objectNode(); [EOL] } [EOL] }); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("properties")); [EOL] ObjectNode propertiesNode = (ObjectNode) result.get("properties"); [EOL] for (DayOfWeek day : DayOfWeek.values()) { [EOL] assertTrue(propertiesNode.has(day.toString())); [EOL] } [EOL] }
public void testSerializerFactoryConfigWithNullArguments() { [EOL] Serializers[] allAdditionalSerializers = null; [EOL] Serializers[] allAdditionalKeySerializers = null; [EOL] BeanSerializerModifier[] modifiers = null; [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(allAdditionalSerializers, allAdditionalKeySerializers, modifiers); [EOL] assertNotNull(config); [EOL] assertArrayEquals(SerializerFactoryConfig.NO_SERIALIZERS, config.additionalSerializers()); [EOL] assertArrayEquals(SerializerFactoryConfig.NO_SERIALIZERS, config.additionalKeySerializers()); [EOL] assertArrayEquals(SerializerFactoryConfig.NO_MODIFIERS, config.modifiers()); [EOL] }
public void testSerializerFactoryConfigWithNonNullArguments() { [EOL] Serializers[] allAdditionalSerializers = new Serializers[]{/* instance of Serializers */}; [EOL] Serializers[] allAdditionalKeySerializers = new Serializers[]{/* instance of Serializers */}; [EOL] BeanSerializerModifier[] modifiers = new BeanSerializerModifier[]{/* instance of BeanSerializerModifier */}; [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(allAdditionalSerializers, allAdditionalKeySerializers, modifiers); [EOL] assertNotNull(config); [EOL] assertSame(allAdditionalSerializers, config.additionalSerializers()); [EOL] assertSame(allAdditionalKeySerializers, config.additionalKeySerializers()); [EOL] assertSame(modifiers, config.modifiers()); [EOL] }
public void testWithSerializerModifier_NullModifier_ThrowsException() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] try { [EOL] config.withSerializerModifier(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null modifier", e.getMessage()); [EOL] } [EOL] }
public void testWithSerializerModifier_ValidModifier_ReturnsNewConfig() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] BeanSerializerModifier modifier = new BeanSerializerModifier() { [EOL] }; [EOL] SerializerFactoryConfig newConfig = config.withSerializerModifier(modifier); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testSerializerModifiersWithNonNullModifiers() { [EOL] BeanSerializerModifier[] modifiers = new BeanSerializerModifier[] { new BeanSerializerModifier() {/* custom implementation */}, new BeanSerializerModifier() {/* custom implementation */} }; [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(null, null, modifiers); [EOL] Iterable<BeanSerializerModifier> result = config.serializerModifiers(); [EOL] assertNotNull(result); [EOL] assertTrue(result.iterator().hasNext()); [EOL] assertEquals(modifiers[0], result.iterator().next()); [EOL] }
public void testSerializerModifiersWithNullModifiers() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(null, null, null); [EOL] Iterable<BeanSerializerModifier> result = config.serializerModifiers(); [EOL] assertNotNull(result); [EOL] assertFalse(result.iterator().hasNext()); [EOL] }
It appears that the provided input text is for a constructor of a class named `SimpleSerializers` that does not contain any executable code. Since the constructor is empty, there are no lines of code to cover with unit tests. Therefore, no unit test cases are necessary or possible to achieve line coverage for this specific constructor. [EOL] If there were executable lines of code within the constructor, I would provide test cases to cover those lines. However, in this case, there is nothing to test, so no test cases can be generated.
public void testAddSerializerWithValidArguments() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] module.addSerializer(Object.class, serializer); [EOL] assertNotNull(module.getSerializerMap().get(new TypeKey(Object.class, false))); [EOL] }
public void testAddSerializerWithNullType() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] try { [EOL] module.addSerializer(null, serializer); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddSerializerWithNullSerializer() { [EOL] SimpleModule module = new SimpleModule(); [EOL] try { [EOL] module.addSerializer(Object.class, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddSerializerWithInterface() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] provider._addSerializer(MyInterface.class, serializer); [EOL] assertNotNull(provider._interfaceMappings); [EOL] assertTrue(provider._interfaceMappings.containsKey(new ClassKey(MyInterface.class))); [EOL] assertEquals(serializer, provider._interfaceMappings.get(new ClassKey(MyInterface.class))); [EOL] }
public void testAddSerializerWithClass() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] provider._addSerializer(MyClass.class, serializer); [EOL] assertNotNull(provider._classMappings); [EOL] assertTrue(provider._classMappings.containsKey(new ClassKey(MyClass.class))); [EOL] assertEquals(serializer, provider._classMappings.get(new ClassKey(MyClass.class))); [EOL] }
public void testFindSerializerWithInterface() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MyInterface.class); [EOL] BeanDescription beanDesc = new BeanDescription(MyInterface.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithClass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MyClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(MyClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithSuperclass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MySubclass.class); [EOL] BeanDescription beanDesc = new BeanDescription(MySubclass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithNoMapping() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(UnmappedClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(UnmappedClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testFindArraySerializerWithNonNullTypeSerializer() { [EOL] SerializationConfig config = new SerializationConfig(null, null, null, null); [EOL] ArrayType type = ArrayType.construct(SimpleType.constructUnsafe(String[].class), null, null); [EOL] BeanDescription beanDesc = new BeanDescription(null); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<Object>() {}; [EOL] JsonSerializer<?> result = findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testFindArraySerializerWithNullTypeSerializer() { [EOL] SerializationConfig config = new SerializationConfig(null, null, null, null); [EOL] ArrayType type = ArrayType.construct(SimpleType.constructUnsafe(String[].class), null, null); [EOL] BeanDescription beanDesc = new BeanDescription(null); [EOL] JsonSerializer<?> result = findArraySerializer(config, type, beanDesc, null, null); [EOL] assertNotNull(result); [EOL] }
public void testFindMapSerializerWithNonNullParams() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] MapType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] JsonSerializer<Object> keySerializer = ...; // Provide actual initialization [EOL] TypeSerializer elementTypeSerializer = ...; // Provide actual initialization [EOL] JsonSerializer<Object> elementValueSerializer = ...; // Provide actual initialization [EOL] JsonSerializer<?> result = findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testGetSchemaWithNullTypeHintAndNullElementType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNull(result.get("items")); [EOL] }
public void testGetSchemaWithNonNullTypeHintAndNullContentType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = new TypeReference<List<String>>() {}.getType(); [EOL] when(provider.constructType(typeHint)).thenReturn(TypeFactory.defaultInstance().constructType(typeHint)); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNotNull(result.get("items")); [EOL] }
public void testGetSchemaWithNonNullTypeHintAndNonNullContentType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = new TypeReference<List<String>>() {}.getType(); [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(typeHint); [EOL] when(provider.constructType(typeHint)).thenReturn(javaType); [EOL] when(javaType.getContentType()).thenReturn(TypeFactory.defaultInstance().constructType(String.class)); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNotNull(result.get("items")); [EOL] }
public void testGetSchemaWithParameterizedTypeHint() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ParameterizedType typeHint = mock(ParameterizedType.class); [EOL] Type[] typeArgs = new Type[] {String.class}; [EOL] when(typeHint.getActualTypeArguments()).thenReturn(typeArgs); [EOL] when(provider.constructType(typeArgs[0])).thenReturn(TypeFactory.defaultInstance().constructType(typeArgs[0])); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNotNull(result.get("items")); [EOL] }
public void testGetSchemaWithNonNullElementType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] setElementType(elementType); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNotNull(result.get("items")); [EOL] }
public void testGetSchemaWithNonNullContentTypeNotObjectClass() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType contentType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(contentType, _property)).thenReturn(ser); [EOL] when(ser instanceof SchemaAware).thenReturn(true); [EOL] JsonNode schemaNode = mock(JsonNode.class); [EOL] when(((SchemaAware) ser).getSchema(provider, null)).thenReturn(schemaNode); [EOL] setElementType(contentType); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertSame(schemaNode, result.get("items")); [EOL] }
public void testGetSchemaWithNonNullContentTypeObjectClass() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType contentType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] setElementType(contentType); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNotNull(result.get("items")); [EOL] }
protected BaseSettings getBaseSettings() { [EOL] return _base; [EOL] }
public void testWithoutWhenFeatureIsEnabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; // Example feature [EOL] config = config.with(feature); // Ensure the feature is enabled [EOL] DeserializationConfig newConfig = config.without(feature); [EOL] assertNotSame(config, newConfig); [EOL] assertFalse(newConfig.isEnabled(feature)); [EOL] }
public void testWithoutWhenFeatureIsDisabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary arguments [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; // Example feature [EOL] DeserializationConfig newConfig = config.without(feature); [EOL] assertSame(config, newConfig); [EOL] }
public void testParseWithValidInput() { [EOL] String canonical = "int"; [EOL] JavaType result = instance.parse(canonical); [EOL] assertNotNull(result); [EOL] assertEquals("int", result.toString()); [EOL] } [EOL] public void testParseWithExtraTokens() { [EOL] String canonical = "int extra"; [EOL] try { [EOL] instance.parse(canonical); [EOL] fail("Should have thrown IllegalArgumentException due to extra tokens"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseWithWhitespace() { [EOL] String canonical = "   int   "; [EOL] JavaType result = instance.parse(canonical); [EOL] assertNotNull(result); [EOL] assertEquals("int", result.toString()); [EOL] } [EOL] public void testParseWithEmptyString() { [EOL] String canonical = ""; [EOL] try { [EOL] instance.parse(canonical); [EOL] fail("Should have thrown IllegalArgumentException due to empty input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseTypeWithEndOfString() throws IllegalArgumentException { [EOL] MyTokenizer tokens = new MyTokenizer(""); [EOL] try { [EOL] parseType(tokens); [EOL] fail("Expected IllegalArgumentException due to end-of-string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseTypeWithValidClassNoGenerics() throws IllegalArgumentException { [EOL] MyTokenizer tokens = new MyTokenizer("java.lang.String"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result.getRawClass()); [EOL] }
public void testParseTypeWithValidClassAndGenerics() throws IllegalArgumentException { [EOL] MyTokenizer tokens = new MyTokenizer("java.util.List<java.lang.String>"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(List.class, result.getRawClass()); [EOL] assertEquals(String.class, result.containedType(0).getRawClass()); [EOL] }
public void testParseTypeWithValidClassAndNestedGenerics() throws IllegalArgumentException { [EOL] MyTokenizer tokens = new MyTokenizer("java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(Map.class, result.getRawClass()); [EOL] assertEquals(String.class, result.containedType(0).getRawClass()); [EOL] assertEquals(List.class, result.containedType(1).getRawClass()); [EOL] assertEquals(Integer.class, result.containedType(1).containedType(0).getRawClass()); [EOL] }
public void testFindClassWithValidClassName() { [EOL] MyTokenizer tokens = new MyTokenizer("validClassName"); [EOL] String className = "java.lang.String"; [EOL] Class<?> clazz = null; [EOL] try { [EOL] clazz = findClass(className, tokens); [EOL] } catch (Exception e) { [EOL] fail("Should not throw an exception for a valid class name"); [EOL] } [EOL] assertNotNull("Class should be found", clazz); [EOL] assertEquals("Class should be java.lang.String", String.class, clazz); [EOL] }
public void testFindClassWithInvalidClassName() { [EOL] MyTokenizer tokens = new MyTokenizer("invalidClassName"); [EOL] String className = "non.existent.ClassName"; [EOL] try { [EOL] findClass(className, tokens); [EOL] fail("Should have thrown an exception for an invalid class name"); [EOL] } catch (RuntimeException e) { [EOL] } catch (Exception e) { [EOL] fail("Should throw RuntimeException instead of generic Exception"); [EOL] } [EOL] }
public void testMyTokenizerWithEmptyString() { [EOL] MyTokenizer tokenizer = new MyTokenizer(""); [EOL] assertNotNull(tokenizer); [EOL] assertEquals("", tokenizer._input); [EOL] }
public void testMyTokenizerWithNonEmptyString() { [EOL] MyTokenizer tokenizer = new MyTokenizer("test<string>"); [EOL] assertNotNull(tokenizer); [EOL] assertEquals("test<string>", tokenizer._input); [EOL] }
public void testHasMoreTokensWithPushbackTokenNotNull() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null, false); // Assuming TokenBuffer is the class where hasMoreTokens() is defined [EOL] tokenBuffer._pushbackToken = new JsonToken(); // Assuming JsonToken is a valid token type for this context [EOL] boolean result = tokenBuffer.hasMoreTokens(); [EOL] assertTrue(result); [EOL] }
public void testHasMoreTokensWithPushbackTokenNullAndSuperHasMoreTokens() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null, false); [EOL] tokenBuffer._pushbackToken = null; [EOL] tokenBuffer.append("token"); // This is a hypothetical method to add a token [EOL] boolean result = tokenBuffer.hasMoreTokens(); [EOL] assertTrue(result); [EOL] }
public void testHasMoreTokensWithPushbackTokenNullAndSuperHasNoMoreTokens() { [EOL] TokenBuffer tokenBuffer = new TokenBuffer(null, false); [EOL] tokenBuffer._pushbackToken = null; [EOL] tokenBuffer.init(""); // This is a hypothetical method to initialize without tokens [EOL] boolean result = tokenBuffer.hasMoreTokens(); [EOL] assertFalse(result); [EOL] }
public void testNextTokenWithPushbackTokenNotNull() { [EOL] YourObjectUnderTest obj = new YourObjectUnderTest("initialPushbackToken"); [EOL] String result = obj.nextToken(); [EOL] assertEquals("initialPushbackToken", result); [EOL] assertNull(obj._pushbackToken); [EOL] assertEquals(result.length(), obj._index); [EOL] }
public void testNextTokenWithPushbackTokenNull() { [EOL] YourObjectUnderTest obj = new YourObjectUnderTest(null); [EOL] String superToken = "superToken"; // This should be the token returned by super.nextToken() [EOL] String result = obj.nextToken(); [EOL] assertEquals(superToken, result); [EOL] assertEquals(result.length(), obj._index); [EOL] }
public void testReadableObjectIdWithNonNullId() { [EOL] Object id = new Object(); [EOL] ReadableObjectId readableObjectId = new ReadableObjectId(id); [EOL] assertNotNull(readableObjectId.id); [EOL] assertEquals(id, readableObjectId.id); [EOL] }
public void testReadableObjectIdWithNullId() { [EOL] ReadableObjectId readableObjectId = new ReadableObjectId(null); [EOL] assertNull(readableObjectId.id); [EOL] }
public void bindItemTestWithNonNullItemThrowsException() { [EOL] YourClass instance = new YourClass(); [EOL] Object initialItem = new Object(); [EOL] instance.bindItem(initialItem); // Assuming this is a valid call to set the initial item [EOL] Object newItem = new Object(); [EOL] try { [EOL] instance.bindItem(newItem); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Already had POJO for id (" + initialItem.getClass().getName() + ") [" + initialItem + "]", e.getMessage()); [EOL] } [EOL] }
public void bindItemTestWithNullItemBindsSuccessfully() { [EOL] YourClass instance = new YourClass(); [EOL] Object newItem = new Object(); [EOL] instance.bindItem(newItem); [EOL] assertEquals(newItem, instance.getItem()); // Assuming there is a method to retrieve the bound item [EOL] }
public void testIsUnwrappingSerializer() { [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] boolean result = serializer.isUnwrappingSerializer(); [EOL] assertFalse(result); [EOL] }
public void testStdDateFormatWithTimeZoneConstructor() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(tz); [EOL] assertEquals(tz, stdDateFormat.getTimeZone()); [EOL] }
public void testStdDateFormatDefaultConstructor() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] assertNull(stdDateFormat.getTimeZone()); [EOL] }
public void testStdDateFormatWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat newStdDateFormat = stdDateFormat.withTimeZone(tz); [EOL] assertEquals(tz, newStdDateFormat.getTimeZone()); [EOL] }
public void testStdDateFormatClone() throws Exception { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] StdDateFormat clonedStdDateFormat = stdDateFormat.clone(); [EOL] assertNotSame(stdDateFormat, clonedStdDateFormat); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat blueprintISO8601Format = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(blueprintISO8601Format); [EOL] }
public void testGetISO8601Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat iso8601Format = StdDateFormat.getISO8601Format(tz); [EOL] assertEquals(tz, iso8601Format.getTimeZone()); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat blueprintRFC1123Format = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(blueprintRFC1123Format); [EOL] }
public void testGetRFC1123Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat rfc1123Format = StdDateFormat.getRFC1123Format(tz); [EOL] assertEquals(tz, rfc1123Format.getTimeZone()); [EOL] }
public void testSetTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] stdDateFormat.setTimeZone(tz); [EOL] assertEquals(tz, stdDateFormat.getTimeZone()); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] Date parsedDate = stdDateFormat.parse(dateStr); [EOL] assertNotNull(parsedDate); [EOL] }
public void testParseStringWithParsePosition() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parse(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer formattedDate = stdDateFormat.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(formattedDate); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(dateStr); [EOL] assertTrue(result); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "2023-04-01T12:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String dateStr = "Sat, 01 Apr 2023 12:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date parsedDate = stdDateFormat.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(parsedDate); [EOL] }
public void testHasTimeZone() { [EOL] String dateStrWithTimeZone = "2023-04-01T12:00:00.000+0000"; [EOL] assertTrue(StdDateFormat.hasTimeZone(dateStrWithTimeZone)); [EOL] String dateStrWithoutTimeZone = "2023-04-01T12:00:00.000"; [EOL] assertFalse(StdDateFormat.hasTimeZone(dateStrWithoutTimeZone)); [EOL] }
public void testCloneFormatWithTimeZone() { [EOL] DateFormat originalFormat = StdDateFormat.getBlueprintISO8601Format(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clonedFormat = StdDateFormat._cloneFormat(originalFormat, tz); [EOL] assertEquals(tz, clonedFormat.getTimeZone()); [EOL] }
public void testWithTimeZoneWithNull() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] TimeZone defaultTz = StdDateFormat.getDefaultTimeZone(); [EOL] StdDateFormat updatedFormat = format.withTimeZone(null); [EOL] assertNotSame(format, updatedFormat); [EOL] assertEquals(defaultTz, updatedFormat.getTimeZone()); [EOL] }
public void testWithTimeZoneWithNonNull() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] TimeZone nonDefaultTz = TimeZone.getTimeZone("GMT+1"); [EOL] StdDateFormat updatedFormat = format.withTimeZone(nonDefaultTz); [EOL] assertNotSame(format, updatedFormat); [EOL] assertEquals(nonDefaultTz, updatedFormat.getTimeZone()); [EOL] }
public void testParseWithISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String iso8601DateStr = "2023-03-15T16:42:00.000+0000"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(iso8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithNonISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String nonISO8601DateStr = "Wed, 15 Mar 2023 16:42:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(nonISO8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithAllDigits() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String allDigitsDateStr = "1234567890123"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(allDigitsDateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithInvalidAllDigits() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String invalidAllDigitsDateStr = "123"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(invalidAllDigitsDateStr, pos); [EOL] assertNull(result); [EOL] }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL] int len = dateStr.length(); [EOL] char c = dateStr.charAt(len - 1); [EOL] DateFormat df; [EOL] if (len <= 10 && Character.isDigit(c)) { [EOL] df = _formatPlain; [EOL] if (df == null) { [EOL] df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL] } [EOL] } else if (c == 'Z') { [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] if (dateStr.charAt(len - 4) == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 1, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] } else { [EOL] if (hasTimeZone(dateStr)) { [EOL] c = dateStr.charAt(len - 3); [EOL] if (c == ':') { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.delete(len - 3, len - 2); [EOL] dateStr = sb.toString(); [EOL] } else if (c == '+' || c == '-') { [EOL] dateStr += "00"; [EOL] } [EOL] len = dateStr.length(); [EOL] c = dateStr.charAt(len - 9); [EOL] if (Character.isDigit(c)) { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] sb.insert(len - 5, ".000"); [EOL] dateStr = sb.toString(); [EOL] } [EOL] df = _formatISO8601; [EOL] if (_formatISO8601 == null) { [EOL] df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL] } [EOL] } else { [EOL] StringBuilder sb = new StringBuilder(dateStr); [EOL] int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL] if (timeLen <= 8) { [EOL] sb.append(".000"); [EOL] } [EOL] sb.append('Z'); [EOL] dateStr = sb.toString(); [EOL] df = _formatISO8601_z; [EOL] if (df == null) { [EOL] df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL] } [EOL] } [EOL] } [EOL] return df.parse(dateStr, pos); [EOL] } [EOL] public StdDateFormat(); [EOL] public StdDateFormat(TimeZone tz); [EOL] public static TimeZone getDefaultTimeZone(); [EOL] public StdDateFormat withTimeZone(TimeZone tz); [EOL] public StdDateFormat clone(); [EOL] public static DateFormat getBlueprintISO8601Format(); [EOL] public static DateFormat getISO8601Format(TimeZone tz); [EOL] public static DateFormat getBlueprintRFC1123Format(); [EOL] public static DateFormat getRFC1123Format(TimeZone tz); [EOL] public void setTimeZone(TimeZone tz); [EOL] public Date parse(String dateStr) throws ParseException; [EOL] public Date parse(String dateStr, ParsePosition pos); [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); [EOL] protected boolean looksLikeISO8601(String dateStr); [EOL] protected Date parseAsISO8601(String dateStr, ParsePosition pos); [EOL] protected Date parseAsRFC1123(String dateStr, ParsePosition pos); [EOL] private static final boolean hasTimeZone(String str); [EOL] private final DateFormat _cloneFormat(DateFormat df); [EOL] private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); [EOL] String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; [EOL] String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; [EOL] String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; [EOL] String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; [EOL] String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }];
public void testHasTimeZoneWithPlusSign() { [EOL] assertTrue(hasTimeZone("2023-04-01T12:00:00+0100")); [EOL] }
public void testHasTimeZoneWithMinusSign() { [EOL] assertTrue(hasTimeZone("2023-04-01T12:00:00-0700")); [EOL] }
public void testHasTimeZoneWithoutTimeZone() { [EOL] assertFalse(hasTimeZone("2023-04-01T12:00:00")); [EOL] }
public void testHasTimeZoneWithZ() { [EOL] assertFalse(hasTimeZone("2023-04-01T12:00:00Z")); [EOL] }
public void testHasTimeZoneWithShortInput() { [EOL] assertFalse(hasTimeZone("12345")); [EOL] }
public void testHasTimeZoneWithInvalidPositionPlus() { [EOL] assertFalse(hasTimeZone("2023-04-01T12:00+00")); [EOL] }
public void testHasTimeZoneWithInvalidPositionMinus() { [EOL] assertFalse(hasTimeZone("2023-04-01T12:00-00")); [EOL] }
public void testSimpleBeanPropertyFilterConstructor() { [EOL] SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter(); [EOL] assertNotNull(filter); [EOL] }
public void testSerializeAllExceptWithEmptyArray() { [EOL] String[] propertyArray = {}; [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(propertyArray); [EOL] assertNotNull(filter); [EOL] assertTrue(filter instanceof SerializeExceptFilter); [EOL] }
public void testSerializeAllExceptWithSingleElement() { [EOL] String[] propertyArray = {"property1"}; [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(propertyArray); [EOL] assertNotNull(filter); [EOL] assertTrue(filter instanceof SerializeExceptFilter); [EOL] assertTrue(((SerializeExceptFilter) filter).doesNotContainProperty("property1")); [EOL] }
public void testSerializeAllExceptWithMultipleElements() { [EOL] String[] propertyArray = {"property1", "property2"}; [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(propertyArray); [EOL] assertNotNull(filter); [EOL] assertTrue(filter instanceof SerializeExceptFilter); [EOL] assertTrue(((SerializeExceptFilter) filter).doesNotContainProperty("property1")); [EOL] assertTrue(((SerializeExceptFilter) filter).doesNotContainProperty("property2")); [EOL] }
public void testSerializeAsFieldWithInclude() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.include(bean)).thenReturn(true); [EOL] CustomSerializer serializer = new CustomSerializer(); [EOL] serializer.serializeAsField(bean, jgen, provider, writer); [EOL] verify(writer).serializeAsField(bean, jgen, provider); [EOL] } [EOL] public void testSerializeAsFieldWithoutInclude() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.include(bean)).thenReturn(false); [EOL] CustomSerializer serializer = new CustomSerializer(); [EOL] serializer.serializeAsField(bean, jgen, provider, writer); [EOL] verify(writer, never()).serializeAsField(bean, jgen, provider); [EOL] }
public void testDepositSchemaPropertyWithIncludeTrue() throws JsonMappingException { [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] ObjectNode propertiesNode = mock(ObjectNode.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(include(writer)).thenReturn(true); [EOL] depositSchemaProperty(writer, propertiesNode, provider); [EOL] verify(writer).depositSchemaProperty(propertiesNode, provider); [EOL] }
public void testDepositSchemaPropertyWithIncludeFalse() throws JsonMappingException { [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] ObjectNode propertiesNode = mock(ObjectNode.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(include(writer)).thenReturn(false); [EOL] depositSchemaProperty(writer, propertiesNode, provider); [EOL] verify(writer, never()).depositSchemaProperty(propertiesNode, provider); [EOL] }
public void testIncludeWithExistingProperty() { [EOL] Set<String> propertiesToInclude = new HashSet<>(); [EOL] propertiesToInclude.add("existingProperty"); [EOL] PropertyFilterUnderTest filter = new PropertyFilterUnderTest(propertiesToInclude); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.getName()).thenReturn("existingProperty"); [EOL] boolean result = filter.include(writer); [EOL] assertTrue(result); [EOL] }
public void testIncludeWithNonExistingProperty() { [EOL] Set<String> propertiesToInclude = new HashSet<>(); [EOL] propertiesToInclude.add("existingProperty"); [EOL] PropertyFilterUnderTest filter = new PropertyFilterUnderTest(propertiesToInclude); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.getName()).thenReturn("nonExistingProperty"); [EOL] boolean result = filter.include(writer); [EOL] assertFalse(result); [EOL] }
public void testSerializeExceptFilterWithNonNullProperties() { [EOL] Set<String> properties = new HashSet<>(); [EOL] properties.add("property1"); [EOL] properties.add("property2"); [EOL] SerializeExceptFilter filter = new SerializeExceptFilter(properties); [EOL] assertNotNull(filter._propertiesToExclude); [EOL] assertTrue(filter._propertiesToExclude.contains("property1")); [EOL] assertTrue(filter._propertiesToExclude.contains("property2")); [EOL] }
public void testSerializeExceptFilterWithEmptyProperties() { [EOL] Set<String> properties = new HashSet<>(); [EOL] SerializeExceptFilter filter = new SerializeExceptFilter(properties); [EOL] assertNotNull(filter._propertiesToExclude); [EOL] assertTrue(filter._propertiesToExclude.isEmpty()); [EOL] }
public void testSerializeExceptFilterWithNullProperties() { [EOL] SerializeExceptFilter filter = new SerializeExceptFilter(null); [EOL] assertNull(filter._propertiesToExclude); [EOL] }
public void testIncludeWithExcludedProperty() { [EOL] Set<String> propertiesToExclude = new HashSet<>(); [EOL] propertiesToExclude.add("excludedProperty"); [EOL] ExclusionStrategy strategy = new ExclusionStrategy(propertiesToExclude); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.getName()).thenReturn("excludedProperty"); [EOL] boolean result = strategy.include(writer); [EOL] assertFalse(result); [EOL] }
public void testIncludeWithNonExcludedProperty() { [EOL] Set<String> propertiesToExclude = new HashSet<>(); [EOL] propertiesToExclude.add("excludedProperty"); [EOL] ExclusionStrategy strategy = new ExclusionStrategy(propertiesToExclude); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] when(writer.getName()).thenReturn("includedProperty"); [EOL] boolean result = strategy.include(writer); [EOL] assertTrue(result); [EOL] }
public void testGetContextAnnotationWithExistingClass() { [EOL] Class<SomeAnnotation> annotationClass = SomeAnnotation.class; [EOL] SomeAnnotation expectedAnnotation = mock(SomeAnnotation.class); [EOL] AnnotationIntrospector introspector = new AnnotationIntrospector() { [EOL] @Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL] return acls.cast(expectedAnnotation); [EOL] } [EOL] }; [EOL] SomeAnnotation actualAnnotation = introspector.getContextAnnotation(annotationClass); [EOL] assertEquals(expectedAnnotation, actualAnnotation); [EOL] }
public void testGetContextAnnotationWithNonExistingClass() { [EOL] Class<SomeOtherAnnotation> annotationClass = SomeOtherAnnotation.class; [EOL] AnnotationIntrospector introspector = new AnnotationIntrospector() { [EOL] @Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL] return null; [EOL] } [EOL] }; [EOL] SomeOtherAnnotation actualAnnotation = introspector.getContextAnnotation(annotationClass); [EOL] assertNull(actualAnnotation); [EOL] }
public void testMethodPropertyWithNonNullValues() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedMethod method = mock(AnnotatedMethod.class); [EOL] when(method.getAnnotated()).thenReturn(mock(Method.class)); [EOL] MethodProperty methodProperty = new MethodProperty(propDef, type, typeDeser, contextAnnotations, method); [EOL] assertNotNull(methodProperty); [EOL] assertEquals(method, methodProperty.getMember()); [EOL] assertNotNull(methodProperty.getSetter()); [EOL] }
public void testMethodPropertyWithNullMethod() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = null; // Assuming TypeDeserializer can be null [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedMethod method = null; [EOL] try { [EOL] MethodProperty methodProperty = new MethodProperty(propDef, type, typeDeser, contextAnnotations, method); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMethodPropertyCopyConstructorWithNonNullDeserializer() { [EOL] AnnotatedMethod annotatedMethod = mock(AnnotatedMethod.class); [EOL] Method setterMethod = SomeClass.class.getMethod("someMethod", SomeParameter.class); [EOL] when(annotatedMethod.getAnnotated()).thenReturn(setterMethod); [EOL] JsonDeserializer<Object> originalDeserializer = mock(JsonDeserializer.class); [EOL] MethodProperty original = new MethodProperty( [EOL] null, null, null, null, annotatedMethod, null, originalDeserializer, null [EOL] ); [EOL] JsonDeserializer<Object> newDeserializer = mock(JsonDeserializer.class); [EOL] MethodProperty copy = new MethodProperty(original, newDeserializer); [EOL] assertSame("Annotated method should be the same in the copied object", [EOL] original._annotated, copy._annotated); [EOL] assertSame("Setter method should be the same in the copied object", [EOL] original._setter, copy._setter); [EOL] assertNotSame("Deserializer should be different in the copied object", [EOL] original.getValueDeserializer(), copy.getValueDeserializer()); [EOL] }
public void testMethodPropertyCopyConstructorWithNullDeserializer() { [EOL] AnnotatedMethod annotatedMethod = mock(AnnotatedMethod.class); [EOL] Method setterMethod = SomeClass.class.getMethod("someMethod", SomeParameter.class); [EOL] when(annotatedMethod.getAnnotated()).thenReturn(setterMethod); [EOL] MethodProperty original = new MethodProperty( [EOL] null, null, null, null, annotatedMethod, null, null, null [EOL] ); [EOL] MethodProperty copy = new MethodProperty(original, null); [EOL] assertSame("Annotated method should be the same in the copied object", [EOL] original._annotated, copy._annotated); [EOL] assertSame("Setter method should be the same in the copied object", [EOL] original._setter, copy._setter); [EOL] assertNull("Deserializer should be null in the copied object", [EOL] copy.getValueDeserializer()); [EOL] }
public void testWithValueDeserializerNonNull() { [EOL] MethodProperty original = new MethodProperty(/* provide necessary arguments */); [EOL] JsonDeserializer<?> deserializer = /* instantiate a JsonDeserializer or mock it */; [EOL] MethodProperty result = original.withValueDeserializer(deserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(deserializer, result.getValueDeserializer()); [EOL] }
public void testWithValueDeserializerNull() { [EOL] MethodProperty original = new MethodProperty(/* provide necessary arguments */); [EOL] MethodProperty result = original.withValueDeserializer(null); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertNull(result.getValueDeserializer()); [EOL] }
public void testGetMember() { [EOL] AnnotatedMember annotatedMember = new AnnotatedMemberImpl(); [EOL] PropertyImpl property = new PropertyImpl(annotatedMember); [EOL] AnnotatedMember result = property.getMember(); [EOL] assertNotNull(result); [EOL] assertEquals(annotatedMember, result); [EOL] }
public void testDeserializeAndSet_NullInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = null; [EOL] try { [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeAndSet_ValidInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] verify(instance).set(eq(instance), any()); [EOL] }
public void testSetWithValidArguments() throws Exception { [EOL] Object instance = new MyClass(); [EOL] Object value = "someValue"; [EOL] _setter = MyClass.class.getMethod("setMyField", String.class); [EOL] set(instance, value); [EOL] Method getter = MyClass.class.getMethod("getMyField"); [EOL] Object result = getter.invoke(instance); [EOL] assertEquals("The setter method did not set the expected value", value, result); [EOL] }
public void testSetWithInvalidArguments() { [EOL] Object instance = new MyClass(); [EOL] Object value = new Object(); // Invalid type to cause an exception [EOL] _setter = MyClass.class.getMethod("setMyField", String.class); [EOL] try { [EOL] set(instance, value); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertNotNull("An IOException should have been thrown due to invalid arguments", e); [EOL] } [EOL] }
public void testWriteAsFieldWithNameNotNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] ObjectIdWriter mockObjectIdWriter = mock(ObjectIdWriter.class); [EOL] SerializedString mockName = mock(SerializedString.class); [EOL] JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class); [EOL] Object id = new Object(); [EOL] when(mockObjectIdWriter.propertyName).thenReturn(mockName); [EOL] when(mockObjectIdWriter.serializer).thenReturn(mockSerializer); [EOL] when(mockObjectIdWriter.id).thenReturn(id); [EOL] SomeClass instance = new SomeClass(); [EOL] instance.writeAsField(mockJsonGenerator, mockProvider, mockObjectIdWriter); [EOL] verify(mockJsonGenerator).writeFieldName(mockName); [EOL] verify(mockSerializer).serialize(id, mockJsonGenerator, mockProvider); [EOL] assertTrue(instance.idWritten); [EOL] }
public void testWriteAsFieldWithNameNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] ObjectIdWriter mockObjectIdWriter = mock(ObjectIdWriter.class); [EOL] JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class); [EOL] Object id = new Object(); [EOL] when(mockObjectIdWriter.propertyName).thenReturn(null); [EOL] when(mockObjectIdWriter.serializer).thenReturn(mockSerializer); [EOL] when(mockObjectIdWriter.id).thenReturn(id); [EOL] SomeClass instance = new SomeClass(); [EOL] instance.writeAsField(mockJsonGenerator, mockProvider, mockObjectIdWriter); [EOL] verify(mockJsonGenerator, never()).writeFieldName(any(SerializedString.class)); [EOL] verify(mockSerializer, never()).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertTrue(instance.idWritten); [EOL] }
public void testGetDeclaringClass() { [EOL] Field field = String.class.getDeclaredField("value"); [EOL] FieldProperty fieldProperty = new FieldProperty(field, null, null); [EOL] Class<?> declaringClass = fieldProperty.getDeclaringClass(); [EOL] assertEquals(String.class, declaringClass); [EOL] }
public void testGetFullName_WithDeclaringClassAndName() { [EOL] Member member = Mockito.mock(Member.class); [EOL] Class<?> declaringClass = Mockito.mock(Class.class); [EOL] Mockito.when(declaringClass.getName()).thenReturn("com.example.MyClass"); [EOL] Mockito.when(member.getDeclaringClass()).thenReturn(declaringClass); [EOL] Mockito.when(member.getName()).thenReturn("myMethod"); [EOL] String fullName = member.getFullName(); [EOL] assertEquals("com.example.MyClass#myMethod", fullName); [EOL] }
public void testToStringReturnsCorrectFormat() { [EOL] Field field = new Field(); [EOL] when(field.getFullName()).thenReturn("ExampleField"); [EOL] String result = field.toString(); [EOL] assertEquals("[field ExampleField]", result); [EOL] }
public void testSerializeWithObjectId() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithObjectId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] } [EOL] public void testSerializeFieldsFiltered() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithPropertyFilterId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] } [EOL] public void testSerializeFields() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithoutPropertyFilterId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] }

public void testAsExternalTypeSerializerWithNonNullValues() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] String propName = "typeName"; [EOL] AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(idRes, property, propName); [EOL] assertNotNull(serializer); [EOL] assertEquals("typeName", serializer._typePropertyName); [EOL] }
public void testAsExternalTypeSerializerWithNullValues() { [EOL] AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(null, null, null); [EOL] assertNotNull(serializer); [EOL] assertNull(serializer._typePropertyName); [EOL] }
public void writeTypePrefixForObject_withValidObjectAndGenerator_callsWriteObjectPrefix() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException { [EOL] _writeObjectPrefix(value, jgen); [EOL] } [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] serializer.writeTypePrefixForObject(value, jgen); [EOL] verify(serializer).writeTypePrefixForObject(value, jgen); [EOL] }
public void writeTypeSuffixForObject_withValidInput_shouldCallWriteObjectSuffix() throws IOException, JsonProcessingException { [EOL] TypeNameIdResolver resolver = mock(TypeNameIdResolver.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] String id = "testId"; [EOL] when(resolver.idFromValue(value)).thenReturn(id); [EOL] TypeNameIdResolver.TypeIdResolverAsProperty typeResolver = new TypeNameIdResolver.TypeIdResolverAsProperty(resolver, null, null); [EOL] typeResolver.writeTypeSuffixForObject(value, jgen); [EOL] verify(resolver).idFromValue(value); [EOL] verify(resolver)._writeObjectSuffix(value, jgen, id); [EOL] }
public void testWriteCustomTypePrefixForObject_NullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.writeCustomTypePrefixForObject(null, mockJsonGenerator, "typeId"); [EOL] verify(mockJsonGenerator, never()).writeStartObject(); [EOL] }
public void testWriteCustomTypePrefixForObject_NonNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] Object value = new Object(); [EOL] instance.writeCustomTypePrefixForObject(value, mockJsonGenerator, "typeId"); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] }
public void testWriteCustomTypeSuffixForObject() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] String typeId = "customType"; [EOL] writeCustomTypeSuffixForObject(value, jgen, typeId); [EOL] verify(jgen).writeEndObject(); // Assuming _writeObjectSuffix calls jgen.writeEndObject() [EOL] }
protected final void _writeObjectPrefix(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL] jgen.writeStartObject(); [EOL] }
public void testWriteObjectSuffixWithNonNullTypeId() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = "testType"; [EOL] _writeObjectSuffix(new Object(), mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] verify(mockJsonGenerator).writeStringField(anyString(), eq(typeId)); [EOL] }
public void testWriteObjectSuffixWithNullTypeId() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = null; [EOL] _writeObjectSuffix(new Object(), mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] verify(mockJsonGenerator).writeStringField(anyString(), eq(typeId)); [EOL] }
public void testExternalTypeHandlerConstructorWithNonNullValues() { [EOL] ExtTypedProperty[] properties = new ExtTypedProperty[0]; [EOL] HashMap<String, Integer> nameToPropertyIndex = new HashMap<>(); [EOL] String[] typeIds = new String[0]; [EOL] TokenBuffer[] tokens = new TokenBuffer[0]; [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(properties, nameToPropertyIndex, typeIds, tokens); [EOL] assertNotNull(handler); [EOL] }
public void testExternalTypeHandlerConstructorWithNullValues() { [EOL] ExternalTypeHandler handler = new ExternalTypeHandler(null, null, null, null); [EOL] assertNotNull(handler); [EOL] }
public void testExternalTypeHandlerCopyConstructor() { [EOL] ExternalTypeHandler original = new ExternalTypeHandler(); [EOL] original.addProperty(someProperty, someIndex); [EOL] original.addNameToPropertyIndex(someName, someIndex); [EOL] ExternalTypeHandler copy = new ExternalTypeHandler(original); [EOL] assertEquals(original._properties.length, copy._properties.length); [EOL] for (int i = 0; i < original._properties.length; i++) { [EOL] assertEquals(original._properties[i], copy._properties[i]); [EOL] } [EOL] assertEquals(original._nameToPropertyIndex, copy._nameToPropertyIndex); [EOL] assertNotNull(copy._typeIds); [EOL] assertNotNull(copy._tokens); [EOL] assertEquals(original._properties.length, copy._typeIds.length); [EOL] assertEquals(original._properties.length, copy._tokens.length); [EOL] }
public void testStartCreatesNewInstance() { [EOL] ExternalTypeHandler initialHandler = new ExternalTypeHandler(); [EOL] ExternalTypeHandler newHandler = initialHandler.start(); [EOL] assertNotNull(newHandler); [EOL] assertNotSame(initialHandler, newHandler); [EOL] }
public void testHandleTypePropertyValueWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "unknownProperty"; [EOL] Object bean = new Object(); [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertFalse(result); [EOL] }
public void testHandleTypePropertyValueWithKnownPropertyAndNoBean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "knownProperty"; [EOL] Object bean = null; [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] }
public void testHandleTypePropertyValueWithKnownPropertyAndBean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "knownProperty"; [EOL] Object bean = new Object(); [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] }
public void testHandlePropertyValueWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "unknownProperty"; [EOL] Object bean = new Object(); [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertFalse(result); [EOL] }
public void testHandlePropertyValueWithTypePropertyName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "typePropertyName"; [EOL] Object bean = new Object(); [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(1); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(true); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] _properties[1] = prop; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertEquals("typeId", _typeIds[1]); [EOL] assertNull(_tokens[1]); [EOL] }
public void testHandlePropertyValueWithRegularProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "regularProperty"; [EOL] Object bean = new Object(); [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(2); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(false); [EOL] _properties[2] = prop; [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] _typeIds[2] = "typeId"; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertNotNull(_tokens[2]); [EOL] assertNull(_typeIds[2]); [EOL] }
public void testHandlePropertyValueWithNullBean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "propertyWithNullBean"; [EOL] Object bean = null; [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(3); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(false); [EOL] _properties[3] = prop; [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] _typeIds[3] = "typeId"; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertNull(_tokens[3]); [EOL] assertEquals("typeId", _typeIds[3]); [EOL] }
public void testCompleteWithEmptyProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler underTest = new ExternalTypeHandler(new ExternalTypeHandler.ExtTypedProperty[0], new String[0], new TokenBuffer[0], new String[0]); [EOL] Object result = underTest.complete(jp, ctxt, bean); [EOL] assertSame("The bean should be returned as is", bean, result); [EOL] }
public void testCompleteWithNullTypeIdsAndTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(mock(SettableBeanProperty.class)); [EOL] TokenBuffer[] tokens = { null }; [EOL] String[] typeIds = { null }; [EOL] ExternalTypeHandler underTest = new ExternalTypeHandler(properties, typeIds, tokens, new String[1]); [EOL] Object result = underTest.complete(jp, ctxt, bean); [EOL] assertSame("The bean should be returned as is", bean, result); [EOL] }
public void testCompleteWithNonNullTokenButMissingTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(mock(SettableBeanProperty.class)); [EOL] when(properties[0].hasDefaultType()).thenReturn(false); [EOL] when(properties[0].getTypePropertyName()).thenReturn("typeProperty"); [EOL] TokenBuffer[] tokens = { mock(TokenBuffer.class) }; [EOL] when(tokens[0].firstToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String[] typeIds = { null }; [EOL] ExternalTypeHandler underTest = new ExternalTypeHandler(properties, typeIds, tokens, new String[1]); [EOL] assertThrows(JsonMappingException.class, () -> underTest.complete(jp, ctxt, bean)); [EOL] }
public void testCompleteWithNonNullTokenAndTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ExternalTypeHandler.ExtTypedProperty[] properties = new ExternalTypeHandler.ExtTypedProperty[1]; [EOL] properties[0] = mock(ExternalTypeHandler.ExtTypedProperty.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(properties[0].getProperty()).thenReturn(prop); [EOL] when(properties[0].getTypePropertyName()).thenReturn("typeProperty"); [EOL] TokenBuffer[] tokens = { mock(TokenBuffer.class) }; [EOL] when(tokens[0].firstToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String[] typeIds = { "typeId" }; [EOL] ExternalTypeHandler underTest = new ExternalTypeHandler(properties, typeIds, tokens, new String[1]); [EOL] underTest.complete(jp, ctxt, bean); [EOL] verify(prop, times(1)).set(eq(bean), any()); [EOL] }
public void testCompleteWithAllPropertiesAndTypeIds() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] ExternalTypeHandler underTest = createUnderTestWithPropertiesAndTypeIds(); [EOL] Object result = underTest.complete(jp, ctxt, buffer, creator); [EOL] assertNotNull(result); [EOL] verify(buffer, times(1)).assignParameter(anyInt(), any()); [EOL] verify(creator, times(1)).build(ctxt, buffer); [EOL] verify(creator, atLeastOnce()).findCreatorProperty(anyString()); [EOL] }
public void testCompleteWithMissingTypeIdAndNoDefault() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] ExternalTypeHandler underTest = createUnderTestWithPropertiesAndMissingTypeIds(); [EOL] assertThrows(JsonMappingException.class, () -> underTest.complete(jp, ctxt, buffer, creator)); [EOL] }
public void testCompleteWithMissingPropertyForTypeId() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] ExternalTypeHandler underTest = createUnderTestWithPropertiesAndTypeIdsButMissingProperty(); [EOL] assertThrows(JsonMappingException.class, () -> underTest.complete(jp, ctxt, buffer, creator)); [EOL] }
public void testDeserializeWithValidIndexAndTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] int index = 0; [EOL] String typeId = "typeId"; [EOL] TokenBuffer[] tokens = new TokenBuffer[1]; [EOL] tokens[0] = mock(TokenBuffer.class); [EOL] JsonParser p2 = mock(JsonParser.class); [EOL] when(jp.getCodec()).thenReturn(null); [EOL] when(tokens[0].asParser(jp)).thenReturn(p2); [EOL] when(p2.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] PropertyBasedCreator properties = mock(PropertyBasedCreator.class); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] when(properties.getProperty()).thenReturn(property); [EOL] when(property.deserialize(p2, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt, index, typeId); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithInvalidIndex() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] int index = 1; // Assuming the tokens array has only one element [EOL] String typeId = "typeId"; [EOL] TokenBuffer[] tokens = new TokenBuffer[1]; [EOL] tokens[0] = mock(TokenBuffer.class); [EOL] JsonParser p2 = mock(JsonParser.class); [EOL] when(jp.getCodec()).thenReturn(null); [EOL] when(tokens[0].asParser(jp)).thenReturn(p2); [EOL] when(p2.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] PropertyBasedCreator properties = mock(PropertyBasedCreator.class); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] when(properties.getProperty()).thenReturn(property); [EOL] when(property.deserialize(p2, ctxt)).thenReturn(new Object()); [EOL] assertThrows(ArrayIndexOutOfBoundsException.class, () -> { [EOL] _deserialize(jp, ctxt, index, typeId); [EOL] }); [EOL] }
public void testDeserializeAndSetWithValidTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] String typeId = "typeId"; [EOL] TokenBuffer[] tokens = new TokenBuffer[1]; [EOL] tokens[0] = mock(TokenBuffer.class); [EOL] JsonParser p2 = mock(JsonParser.class); [EOL] SettableBeanProperty[] properties = new SettableBeanProperty[1]; [EOL] properties[0] = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] when(tokens[0].asParser(jp)).thenReturn(p2); [EOL] when(p2.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(properties[0].getProperty()).thenReturn(property); [EOL] _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL] verify(p2).nextToken(); [EOL] verify(property).deserializeAndSet(p2, ctxt, bean); [EOL] }
public void testDeserializeAndSetWithInvalidIndex() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] int index = 1; // Assuming the tokens array has only one element [EOL] String typeId = "typeId"; [EOL] TokenBuffer[] tokens = new TokenBuffer[1]; [EOL] tokens[0] = mock(TokenBuffer.class); [EOL] SettableBeanProperty[] properties = new SettableBeanProperty[1]; [EOL] properties[0] = mock(SettableBeanProperty.class); [EOL] try { [EOL] _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL] fail("Expected ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddExternalWithNewProperty() { [EOL] ExternalTypeHandler.Builder builder = new ExternalTypeHandler.Builder(); [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(property.getName()).thenReturn("propertyName"); [EOL] when(typeDeser.getPropertyName()).thenReturn("typeDeserName"); [EOL] builder.addExternal(property, typeDeser); [EOL] assertEquals(1, builder._properties.size()); [EOL] assertNotNull(builder._nameToPropertyIndex.get("propertyName")); [EOL] assertNotNull(builder._nameToPropertyIndex.get("typeDeserName")); [EOL] }
public void testAddExternalWithExistingProperty() { [EOL] ExternalTypeHandler.Builder builder = new ExternalTypeHandler.Builder(); [EOL] SettableBeanProperty property1 = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty property2 = mock(SettableBeanProperty.class); [EOL] TypeDeserializer typeDeser1 = mock(TypeDeserializer.class); [EOL] TypeDeserializer typeDeser2 = mock(TypeDeserializer.class); [EOL] when(property1.getName()).thenReturn("propertyName"); [EOL] when(typeDeser1.getPropertyName()).thenReturn("typeDeserName"); [EOL] when(property2.getName()).thenReturn("propertyName"); [EOL] when(typeDeser2.getPropertyName()).thenReturn("typeDeserName2"); [EOL] builder.addExternal(property1, typeDeser1); [EOL] builder.addExternal(property2, typeDeser2); [EOL] assertEquals(2, builder._properties.size()); [EOL] assertEquals(builder._nameToPropertyIndex.get("propertyName"), builder._nameToPropertyIndex.get("typeDeserName")); [EOL] assertNotEquals(builder._nameToPropertyIndex.get("propertyName"), builder._nameToPropertyIndex.get("typeDeserName2")); [EOL] }
public void testBuildWithEmptyProperties() { [EOL] ExternalTypeHandler.Builder builder = new ExternalTypeHandler.Builder(); [EOL] ExternalTypeHandler handler = builder.build(); [EOL] assertNotNull(handler); [EOL] assertEquals(0, handler.getPropertyCount()); [EOL] }
public void testBuildWithNonEmptyProperties() { [EOL] ExternalTypeHandler.Builder builder = new ExternalTypeHandler.Builder(); [EOL] builder.addExternal(new ExtTypedProperty("property1", String.class, true, null)); [EOL] builder.addExternal(new ExtTypedProperty("property2", Integer.class, false, null)); [EOL] ExternalTypeHandler handler = builder.build(); [EOL] assertNotNull(handler); [EOL] assertEquals(2, handler.getPropertyCount()); [EOL] }
public void testExtTypedPropertyWithNonNullValues() { [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(typeDeser.getPropertyName()).thenReturn("typeProperty"); [EOL] ExtTypedProperty extTypedProperty = new ExtTypedProperty(property, typeDeser); [EOL] assertNotNull(extTypedProperty._property); [EOL] assertNotNull(extTypedProperty._typeDeserializer); [EOL] assertEquals("typeProperty", extTypedProperty._typePropertyName); [EOL] }
public void testExtTypedPropertyWithTypeDeserializerNull() { [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] ExtTypedProperty extTypedProperty = new ExtTypedProperty(property, null); [EOL] assertNotNull(extTypedProperty._property); [EOL] assertNull(extTypedProperty._typeDeserializer); [EOL] assertNull(extTypedProperty._typePropertyName); [EOL] }
public void testHasTypePropertyNameTrue() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, "typeName"); [EOL] assertTrue(resolver.hasTypePropertyName("typeName")); [EOL] }
public void testHasTypePropertyNameFalse() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, "typeName"); [EOL] assertFalse(resolver.hasTypePropertyName("differentName")); [EOL] }
public void testGetProperty() { [EOL] SettableBeanProperty property = new SettableBeanPropertyMock(); [EOL] PropertyBasedCreator creator = new PropertyBasedCreatorMock(property); [EOL] SettableBeanProperty result = creator.getProperty(); [EOL] assertNotNull(result); [EOL] assertSame(property, result); [EOL] }
public void testGetLocale() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Locale expectedLocale = Locale.getDefault(); [EOL] Locale actualLocale = mapper.getSerializationConfig().getLocale(); [EOL] assertEquals(expectedLocale, actualLocale); [EOL] }
public void testTypeResolverBuilderInstanceWithNonNullHandlerInstantiatorAndNonNullBuilder() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeResolverBuilder<?>> builderClass = mock(Class.class); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] TypeResolverBuilder<?> expectedBuilder = mock(TypeResolverBuilder.class); [EOL] when(hi.typeResolverBuilderInstance(any(), eq(annotated), eq(builderClass))).thenReturn(expectedBuilder); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setHandlerInstantiator(hi); [EOL] TypeResolverBuilder<?> actualBuilder = objectMapper.typeResolverBuilderInstance(annotated, builderClass); [EOL] assertSame(expectedBuilder, actualBuilder); [EOL] }
public void testTypeResolverBuilderInstanceWithNonNullHandlerInstantiatorAndNullBuilder() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeResolverBuilder<?>> builderClass = mock(Class.class); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(hi.typeResolverBuilderInstance(any(), eq(annotated), eq(builderClass))).thenReturn(null); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setHandlerInstantiator(hi); [EOL] TypeResolverBuilder<?> actualBuilder = objectMapper.typeResolverBuilderInstance(annotated, builderClass); [EOL] assertNotNull(actualBuilder); [EOL] }
public void testTypeResolverBuilderInstanceWithNullHandlerInstantiator() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] Class<? extends TypeResolverBuilder<?>> builderClass = mock(Class.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] TypeResolverBuilder<?> actualBuilder = objectMapper.typeResolverBuilderInstance(annotated, builderClass); [EOL] assertNotNull(actualBuilder); [EOL] }
public void testNullProviderWithPrimitiveType() { [EOL] JavaType primitiveType = TypeFactory.defaultInstance().constructType(int.class); [EOL] Object nullValue = 0; [EOL] NullProvider provider = new NullProvider(primitiveType, nullValue); [EOL] assertEquals("Expected null value to be the same as passed in constructor", 0, provider.nullValue()); [EOL] assertTrue("Expected _isPrimitive to be true for primitive type", provider.isPrimitive()); [EOL] assertEquals("Expected _rawType to be the same as the primitive type", int.class, provider.getRawClass()); [EOL] }
public void testNullProviderWithNonPrimitiveType() { [EOL] JavaType nonPrimitiveType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Object nullValue = null; [EOL] NullProvider provider = new NullProvider(nonPrimitiveType, nullValue); [EOL] assertNull("Expected null value to be null for non-primitive type", provider.nullValue()); [EOL] assertFalse("Expected _isPrimitive to be false for non-primitive type", provider.isPrimitive()); [EOL] assertEquals("Expected _rawType to be the same as the non-primitive type", String.class, provider.getRawClass()); [EOL] }
public void testValueNodeConstructor() { [EOL] ValueNode valueNode = new ValueNode(); [EOL] assertNotNull(valueNode); [EOL] }
public void testFindValuesWithNullList() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] List<JsonNode> result = node.findValues("fieldName", null); [EOL] assertNull(result); [EOL] }
public void testFindValuesWithEmptyList() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] List<JsonNode> result = node.findValues("fieldName", foundSoFar); [EOL] assertSame(foundSoFar, result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesWithNonEmptyList() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] JsonNode childNode = new TextNode("value"); [EOL] foundSoFar.add(childNode); [EOL] List<JsonNode> result = node.findValues("fieldName", foundSoFar); [EOL] assertSame(foundSoFar, result); [EOL] assertEquals(1, result.size()); [EOL] assertSame(childNode, result.get(0)); [EOL] }
public void testFindParentsReturnsGivenList() { [EOL] List<JsonNode> initialList = new ArrayList<>(); [EOL] List<JsonNode> resultList = findParents("anyFieldName", initialList); [EOL] assertSame(initialList, resultList); [EOL] }
public void testBuildTypeSerializerWithIdNone() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.NONE; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeSerializerWithWrapperArray() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id and triggers WRAPPER_ARRAY [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_ARRAY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id and triggers PROPERTY [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.PROPERTY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithWrapperObject() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id and triggers WRAPPER_OBJECT [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_OBJECT; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithExternalProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id and triggers EXTERNAL_PROPERTY [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.EXTERNAL_PROPERTY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithIllegalStateException() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id and triggers an unknown _includeAs [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.OTHER; // Assuming OTHER is an invalid As and triggers the exception [EOL] try { [EOL] buildTypeSerializer(config, baseType, subtypes); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Do not know how to construct standard type serializer for inclusion type: " + _includeAs, e.getMessage()); [EOL] } [EOL] }
public void testBuildTypeDeserializerWithIdTypeNone() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NONE, null); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeDeserializerWithWrapperArray() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithWrapperObject() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_OBJECT); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithExternalProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithIllegalStateException() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(null); // This should trigger the default case and throw an IllegalStateException [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] }); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL] if (_customIdResolver != null) { [EOL] return _customIdResolver; [EOL] } [EOL] if (_idType == null) { [EOL] throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL] } [EOL] switch(_idType) { [EOL] case CLASS: [EOL] return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL] case MINIMAL_CLASS: [EOL] return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL] case NAME: [EOL] return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL] case NONE: [EOL] return null; [EOL] case CUSTOM: [EOL] } [EOL] throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
public void testRegisterSubtypesWithNullInitialSet() { [EOL] registerSubtypes(new NamedType(MyClass.class, "MyClass")); [EOL] assertTrue(_registeredSubtypes.contains(new NamedType(MyClass.class, "MyClass"))); [EOL] }
public void testRegisterSubtypesWithNonNullInitialSet() { [EOL] _registeredSubtypes = new LinkedHashSet<NamedType>(); [EOL] _registeredSubtypes.add(new NamedType(AnotherClass.class, "AnotherClass")); [EOL] registerSubtypes(new NamedType(MyClass.class, "MyClass")); [EOL] assertTrue(_registeredSubtypes.contains(new NamedType(MyClass.class, "MyClass"))); [EOL] assertTrue(_registeredSubtypes.contains(new NamedType(AnotherClass.class, "AnotherClass"))); [EOL] }
public void testRegisterSubtypesWithEmptyVarargs() { [EOL] registerSubtypes(); [EOL] assertNotNull(_registeredSubtypes); [EOL] assertTrue(_registeredSubtypes.isEmpty()); [EOL] }
public void testRegisterSubtypesWithSingleClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.registerSubtypes(SomeClass.class); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] Collection<NamedType> subtypes = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), mapper.constructType(SomeClass.class)); [EOL] boolean found = false; [EOL] for (NamedType type : subtypes) { [EOL] if (type.getType().equals(SomeClass.class)) { [EOL] found = true; [EOL] break; [EOL] } [EOL] } [EOL] assertTrue(found); [EOL] }
public void testRegisterSubtypesWithMultipleClasses() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.registerSubtypes(SomeClass.class, AnotherClass.class); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] Collection<NamedType> subtypesSomeClass = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), mapper.constructType(SomeClass.class)); [EOL] Collection<NamedType> subtypesAnotherClass = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), mapper.constructType(AnotherClass.class)); [EOL] boolean foundSomeClass = false; [EOL] boolean foundAnotherClass = false; [EOL] for (NamedType type : subtypesSomeClass) { [EOL] if (type.getType().equals(SomeClass.class)) { [EOL] foundSomeClass = true; [EOL] break; [EOL] } [EOL] } [EOL] for (NamedType type : subtypesAnotherClass) { [EOL] if (type.getType().equals(AnotherClass.class)) { [EOL] foundAnotherClass = true; [EOL] break; [EOL] } [EOL] } [EOL] assertTrue(foundSomeClass); [EOL] assertTrue(foundAnotherClass); [EOL] }
public void testRegisterSubtypesWithNoClasses() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.registerSubtypes(new Class<?>[0]); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] Collection<NamedType> subtypes = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), mapper.constructType(Object.class)); [EOL] assertTrue(subtypes.isEmpty()); [EOL] }
public void testCollectAndResolveSubtypesWithNullBaseTypeAndNoRegisteredSubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = null; [EOL] when(property.getRawType()).thenReturn(Object.class); [EOL] SubtypeResolver resolver = new StdSubtypeResolver(); [EOL] Collection<NamedType> result = resolver.collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCollectAndResolveSubtypesWithNonNullBaseTypeAndRegisteredSubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Class<?> rawBase = Object.class; [EOL] when(baseType.getRawClass()).thenReturn(rawBase); [EOL] when(ai.findSubtypes(property)).thenReturn(null); [EOL] StdSubtypeResolver resolver = new StdSubtypeResolver(); [EOL] resolver.registerSubtypes(new NamedType(String.class), new NamedType(Integer.class)); [EOL] Collection<NamedType> result = resolver.collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertEquals(2, result.size()); [EOL] }
public void testCollectAndResolveSubtypesWithPropertySubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Class<?> rawBase = Object.class; [EOL] when(baseType.getRawClass()).thenReturn(rawBase); [EOL] when(property.getRawType()).thenReturn(rawBase); [EOL] List<NamedType> subtypes = Arrays.asList(new NamedType(String.class), new NamedType(Integer.class)); [EOL] when(ai.findSubtypes(property)).thenReturn(subtypes); [EOL] StdSubtypeResolver resolver = new StdSubtypeResolver(); [EOL] Collection<NamedType> result = resolver.collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertEquals(2, result.size()); [EOL] }
public void testCollectAndResolveNamedTypeWithName() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(namedType)); [EOL] } [EOL] public void testCollectAndResolveNamedTypeWithoutNameButAnnotated() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithName("AnnotatedName"); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(new NamedType(SomeClass.class, "AnnotatedName"))); [EOL] } [EOL] public void testCollectAndResolveNamedTypeWithoutNameAndNotAnnotated() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithoutName(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(namedType)); [EOL] } [EOL] public void testCollectAndResolveWithExistingNonNamedSubtype() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class, "SomeName"); [EOL] NamedType nonNamedSubtype = new NamedType(SomeOtherClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospector(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] collectedSubtypes.put(nonNamedSubtype, nonNamedSubtype); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertTrue(collectedSubtypes.containsKey(namedType)); [EOL] assertTrue(collectedSubtypes.get(nonNamedSubtype).hasName()); [EOL] } [EOL] public void testCollectAndResolveWithSubtypes() { [EOL] AnnotatedClass annotatedType = createAnnotatedClass(); [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] MapperConfig<?> config = createMapperConfig(); [EOL] AnnotationIntrospector ai = createAnnotationIntrospectorWithSubtypes(); [EOL] HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); [EOL] _collectAndResolve(annotatedType, namedType, config, ai, collectedSubtypes); [EOL] assertFalse(collectedSubtypes.isEmpty()); [EOL] }
private AnnotatedClass createAnnotatedClass() { [EOL] return null; [EOL] } [EOL] private MapperConfig<?> createMapperConfig() { [EOL] return null; [EOL] } [EOL] private AnnotationIntrospector createAnnotationIntrospector() { [EOL] return null; [EOL] } [EOL] private AnnotationIntrospector createAnnotationIntrospectorWithName(String name) { [EOL] return null; [EOL] } [EOL] private AnnotationIntrospector createAnnotationIntrospectorWithoutName() { [EOL] return null; [EOL] } [EOL] private AnnotationIntrospector createAnnotationIntrospectorWithSubtypes() { [EOL] return null; [EOL] }
public void testSerializeBigDecimalAsPlain() throws IOException { [EOL] BigDecimal bigDecimalValue = new BigDecimal("12345.6789"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)).thenReturn(true); [EOL] new NumberSerializer().serialize(bigDecimalValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(bigDecimalValue.toPlainString()); [EOL] }
public void testSerializeBigDecimalNotAsPlain() throws IOException { [EOL] BigDecimal bigDecimalValue = new BigDecimal("12345.6789"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)).thenReturn(false); [EOL] new NumberSerializer().serialize(bigDecimalValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(bigDecimalValue); [EOL] }
public void testSerializeBigInteger() throws IOException { [EOL] BigInteger bigIntegerValue = new BigInteger("123456789"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(bigIntegerValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(bigIntegerValue); [EOL] }
public void testSerializeInteger() throws IOException { [EOL] Integer integerValue = 123; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(integerValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(integerValue.intValue()); [EOL] }
public void testSerializeLong() throws IOException { [EOL] Long longValue = 123L; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(longValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(longValue.longValue()); [EOL] }
public void testSerializeDouble() throws IOException { [EOL] Double doubleValue = 123.45; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(doubleValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(doubleValue.doubleValue()); [EOL] }
public void testSerializeFloat() throws IOException { [EOL] Float floatValue = 123.45f; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(floatValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(floatValue.floatValue()); [EOL] }
public void testSerializeByte() throws IOException { [EOL] Byte byteValue = 123; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(byteValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(byteValue.intValue()); [EOL] }
public void testSerializeShort() throws IOException { [EOL] Short shortValue = 123; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(shortValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(shortValue.intValue()); [EOL] }
public void testSerializeUnknownNumberType() throws IOException { [EOL] AtomicLong atomicLongValue = new AtomicLong(123L); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(atomicLongValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(atomicLongValue.toString()); [EOL] }
public void testUnwrappingBeanSerializerWithNullTransformer() { [EOL] BeanSerializerBase src = mock(BeanSerializerBase.class); [EOL] NameTransformer transformer = null; [EOL] UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(src, transformer); [EOL] assertNull(serializer._nameTransformer); [EOL] }
public void testUnwrappingBeanSerializerWithNonNullTransformer() { [EOL] BeanSerializerBase src = mock(BeanSerializerBase.class); [EOL] NameTransformer transformer = mock(NameTransformer.class); [EOL] UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(src, transformer); [EOL] assertNotNull(serializer._nameTransformer); [EOL] }
public void testIsUnwrappingSerializer() { [EOL] JsonSerializer<?> serializer = new MyCustomSerializer(); [EOL] assertTrue(serializer.isUnwrappingSerializer()); [EOL] }
public void testSerializeWithObjectId() throws IOException, JsonGenerationException { [EOL] BeanSerializerBase serializer = createSerializerWithObjectId(); // Mock or create an instance with _objectIdWriter not null [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); // Mock or create a JsonGenerator instance [EOL] SerializerProvider provider = createSerializerProvider(); // Mock or create a SerializerProvider instance [EOL] serializer.serialize(bean, jgen, provider); [EOL] }
public void testSerializeFieldsFiltered() throws IOException, JsonGenerationException { [EOL] BeanSerializerBase serializer = createSerializerWithPropertyFilterId(); // Mock or create an instance with _propertyFilterId not null and _objectIdWriter null [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); // Mock or create a JsonGenerator instance [EOL] SerializerProvider provider = createSerializerProvider(); // Mock or create a SerializerProvider instance [EOL] serializer.serialize(bean, jgen, provider); [EOL] }
public void testSerializeFields() throws IOException, JsonGenerationException { [EOL] BeanSerializerBase serializer = createSerializer(); // Mock or create an instance with _objectIdWriter and _propertyFilterId null [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); // Mock or create a JsonGenerator instance [EOL] SerializerProvider provider = createSerializerProvider(); // Mock or create a SerializerProvider instance [EOL] serializer.serialize(bean, jgen, provider); [EOL] }
public void testStringArraySerializerWithNonNullSerializer() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] StringArraySerializer src = new StringArraySerializer(); [EOL] StringArraySerializer serializer = new StringArraySerializer(src, prop, ser); [EOL] assertNotNull(serializer); [EOL] }
public void testStringArraySerializerWithNullSerializer() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] StringArraySerializer src = new StringArraySerializer(); [EOL] StringArraySerializer serializer = new StringArraySerializer(src, prop, null); [EOL] assertNotNull(serializer); [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDefinition() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinition() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<?> serializerInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(new Object()); [EOL] when(provider.serializerInstance(member, new Object())).thenReturn(serializerInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinitionButDefaultSerializer() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<?> serializerInstance = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(new Object()); [EOL] when(provider.serializerInstance(member, new Object())).thenReturn(serializerInstance); [EOL] when(isDefaultSerializer(serializerInstance)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinitionAndContextualSerializer() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(new Object()); [EOL] when(provider.serializerInstance(member, new Object())).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(contextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDefinitionAndNonContextualSerializer() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<?> nonContextualSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(new Object()); [EOL] when(provider.serializerInstance(member, new Object())).thenReturn(nonContextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] String[] value = new String[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] String[] value = new String[]{"a", "b", "c"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(elementSerializer, times(value.length)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] String[] value = new String[]{null}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeContentsWithNonNullElements() throws IOException { [EOL] String[] value = new String[]{"a", "b"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeString("a"); [EOL] verify(jgen).writeString("b"); [EOL] }
public void testSerializeContentsSlowWithNullValues() throws IOException { [EOL] String[] value = new String[]{"first", null, "third"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsSlow(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(ser).serialize(eq("first"), eq(jgen), eq(provider)); [EOL] verify(ser).serialize(eq("third"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsSlowWithNonNullValues() throws IOException { [EOL] String[] value = new String[]{"first", "second", "third"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsSlow(value, jgen, provider, ser); [EOL] verify(ser, times(3)).serialize(anyString(), eq(jgen), eq(provider)); [EOL] }
public void testTextNodeWithNull() { [EOL] TextNode node = new TextNode(null); [EOL] assertNull(node.textValue()); [EOL] }
public void testTextNodeWithEmptyString() { [EOL] TextNode node = new TextNode(""); [EOL] assertEquals("", node.textValue()); [EOL] }
public void testTextNodeWithRegularString() { [EOL] String testString = "test"; [EOL] TextNode node = new TextNode(testString); [EOL] assertEquals(testString, node.textValue()); [EOL] }
public void testValueOfWithNull() { [EOL] TextNode result = TextNode.valueOf(null); [EOL] assertNull(result); [EOL] } [EOL] public void testValueOfWithEmptyString() { [EOL] TextNode result = TextNode.valueOf(""); [EOL] assertSame(TextNode.EMPTY_STRING_NODE, result); [EOL] } [EOL] public void testValueOfWithNonEmptyString() { [EOL] String nonEmpty = "non-empty"; [EOL] TextNode result = TextNode.valueOf(nonEmpty); [EOL] assertNotNull(result); [EOL] assertEquals(nonEmpty, result.textValue()); [EOL] }
public void testGetNodeType() { [EOL] TextNode node = new TextNode("test"); [EOL] assertEquals(JsonNodeType.STRING, node.getNodeType()); [EOL] }
public void testTextValueWhenValueIsNull() { [EOL] TextNode node = new TextNode(null); [EOL] String result = node.textValue(); [EOL] assertNull(result); [EOL] }
public void testTextValueWhenValueIsNotNull() { [EOL] TextNode node = new TextNode("test"); [EOL] String result = node.textValue(); [EOL] assertEquals("test", result); [EOL] }
public void testGetBinaryValueWithValidInput() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String validBase64String = "TWFu"; // "Man" in Base64 [EOL] TextNode textNode = new TextNode(validBase64String); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77, 97, 110}; // "Man" in bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testGetBinaryValueWithPadding() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String base64StringWithPadding = "TQ=="; // "M" with padding in Base64 [EOL] TextNode textNode = new TextNode(base64StringWithPadding); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77}; // "M" in bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testGetBinaryValueWithInvalidChar() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String invalidBase64String = "T$"; // Invalid Base64 character [EOL] TextNode textNode = new TextNode(invalidBase64String); [EOL] assertThrows(IOException.class, () -> textNode.getBinaryValue(b64variant)); [EOL] }
public void testGetBinaryValueWithIncompletePadding() { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] String incompletePaddingBase64String = "TQ="; // Incomplete padding in Base64 [EOL] TextNode textNode = new TextNode(incompletePaddingBase64String); [EOL] assertThrows(IOException.class, () -> textNode.getBinaryValue(b64variant)); [EOL] }
public void testGetBinaryValueWithNoPaddingVariant() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getMimeNoLinefeedsVariant(); [EOL] String base64StringNoPadding = "TWFu"; // "Man" in Base64 without padding [EOL] TextNode textNode = new TextNode(base64StringNoPadding); [EOL] byte[] binaryValue = textNode.getBinaryValue(b64variant); [EOL] byte[] expectedValue = new byte[]{77, 97, 110}; // "Man" in bytes [EOL] assertArrayEquals(expectedValue, binaryValue); [EOL] }
public void testAsTextWithNonNullValue() { [EOL] TextNode node = new TextNode("testValue"); [EOL] String result = node.asText(); [EOL] assertEquals("testValue", result); [EOL] }
public void testAsTextWithEmptyValue() { [EOL] TextNode node = new TextNode(""); [EOL] String result = node.asText(); [EOL] assertEquals("", result); [EOL] }
public void testEquals_sameObject() { [EOL] TextNode node = new TextNode("test"); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] TextNode node = new TextNode("test"); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] TextNode node = new TextNode("test"); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_equalObjects() { [EOL] TextNode node1 = new TextNode("test"); [EOL] TextNode node2 = new TextNode("test"); [EOL] assertTrue(node1.equals(node2)); [EOL] } [EOL] public void testEquals_unequalObjects() { [EOL] TextNode node1 = new TextNode("test"); [EOL] TextNode node2 = new TextNode("different"); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testDeserializeWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("java.lang.String"); [EOL] when(ctxt.findClass("java.lang.String")).thenReturn(String.class); [EOL] Class<?> result = deserialize(jp, ctxt); [EOL] assertEquals(String.class, result); [EOL] }
public void testDeserializeWithException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid.ClassName"); [EOL] when(ctxt.findClass("invalid.ClassName")).thenThrow(new ClassNotFoundException()); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithNonStringValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testPrimitiveArrayBuilderConstructor() { [EOL] try { [EOL] PrimitiveArrayBuilder builder = new PrimitiveArrayBuilder(); [EOL] assertNotNull(builder); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testResetAndStartWithNullFreeBuffer() { [EOL] YourClass instance = new YourClass(); [EOL] instance._freeBuffer = null; // Set _freeBuffer to null to test this condition [EOL] T result = instance.resetAndStart(); [EOL] assertNotNull(result); // Assert that the result should not be null [EOL] assertEquals(YourClass.INITIAL_CHUNK_SIZE, result.length); // Check if the array has the INITIAL_CHUNK_SIZE length [EOL] }
public void testResetAndStartWithNonNullFreeBuffer() { [EOL] YourClass instance = new YourClass(); [EOL] instance._freeBuffer = new YourType[YourClass.INITIAL_CHUNK_SIZE]; // Set _freeBuffer to a non-null value [EOL] instance._reset(); // Reset any state if necessary [EOL] T result = instance.resetAndStart(); [EOL] assertSame(instance._freeBuffer, result); // Assert that the result is the same as _freeBuffer [EOL] }
public void testCompleteAndClearBufferWithEmptyBuffer() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 3; [EOL] Integer[] result = handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(3, result.length); [EOL] assertArrayEquals(new Integer[]{1, 2, 3}, result); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBuffer() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] handler.append(4); // Assuming append method exists to add to the buffer [EOL] handler.append(5); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 3; [EOL] Integer[] result = handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(5, result.length); [EOL] assertArrayEquals(new Integer[]{4, 5, 1, 2, 3}, result); [EOL] }
public void testCompleteAndClearBufferWithIncorrectTotalSize() { [EOL] BufferHandler<Integer> handler = new BufferHandler<>(); [EOL] handler.append(4); [EOL] handler.append(5); [EOL] Integer[] lastChunk = new Integer[]{1, 2, 3}; [EOL] int lastChunkEntries = 2; // Intentionally incorrect to trigger the exception [EOL] try { [EOL] handler.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Should have gotten 4 entries, got 5", e.getMessage()); [EOL] } [EOL] }
public void testResetWithNonNullBufferTail() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._bufferTail = new BufferSegment(); [EOL] gen._bufferTail.setData(new char[]{'a', 'b', 'c'}); [EOL] gen._reset(); [EOL] assertNull(gen._bufferHead); [EOL] assertNull(gen._bufferTail); [EOL] assertEquals(0, gen._bufferedEntryCount); [EOL] assertNotNull(gen._freeBuffer); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c'}, gen._freeBuffer); [EOL] }
public void testResetWithNullBufferTail() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._bufferTail = null; [EOL] gen._reset(); [EOL] assertNull(gen._bufferHead); [EOL] assertNull(gen._bufferTail); [EOL] assertEquals(0, gen._bufferedEntryCount); [EOL] assertNull(gen._freeBuffer); [EOL] }
public void testContainedTypeCount() { [EOL] YourType obj = new YourType(); [EOL] int count = obj.containedTypeCount(); [EOL] assertEquals(2, count); [EOL] }
public void testSimpleModuleConstructor() { [EOL] SimpleModule module = new SimpleModule(); [EOL] assertNotNull(module); [EOL] assertTrue(module.getName().startsWith("SimpleModule-")); [EOL] assertEquals(Version.unknownVersion(), module.version()); [EOL] }
public void testAddSerializerWithNonNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] module.addSerializer(Object.class, serializer); [EOL] assertNotNull(module.getSerializers()); [EOL] }
public void testAddSerializerWithNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] module.addSerializer(Object.class, serializer); [EOL] assertNotNull(module.getSerializers()); [EOL] }
public void testAddDeserializerWithNonNullDeserializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module._deserializers = new SimpleDeserializers(); // Assuming this is accessible or can be set through a constructor or method [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] module.addDeserializer(String.class, deserializer); [EOL] assertNotNull(module._deserializers); [EOL] assertTrue(module._deserializers.hasDeserializer(String.class)); [EOL] }
public void testAddDeserializerWithNullDeserializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] module.addDeserializer(String.class, deserializer); [EOL] assertNotNull(module._deserializers); [EOL] assertTrue(module._deserializers.hasDeserializer(String.class)); [EOL] }
public void testRegisterSubtypesWithNullSubtypes() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module.registerSubtypes((Class<?>[]) null); [EOL] assertTrue(module.getSubtypes().isEmpty()); [EOL] }
public void testRegisterSubtypesWithEmptySubtypes() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module.registerSubtypes(new Class<?>[0]); [EOL] assertTrue(module.getSubtypes().isEmpty()); [EOL] }
public void testRegisterSubtypesWithOneSubtype() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module.registerSubtypes(String.class); [EOL] assertEquals(1, module.getSubtypes().size()); [EOL] assertTrue(module.getSubtypes().contains(new NamedType(String.class))); [EOL] }
public void testRegisterSubtypesWithMultipleSubtypes() { [EOL] SimpleModule module = new SimpleModule(); [EOL] module.registerSubtypes(Integer.class, Boolean.class); [EOL] assertEquals(2, module.getSubtypes().size()); [EOL] assertTrue(module.getSubtypes().contains(new NamedType(Integer.class))); [EOL] assertTrue(module.getSubtypes().contains(new NamedType(Boolean.class))); [EOL] }
public void testSetupModuleWithAllFieldsNull() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context, never()).registerSubtypes((NamedType[]) any()); [EOL] verify(context, never()).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullFields() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_serializers != null).thenReturn(true); [EOL] when(_deserializers != null).thenReturn(true); [EOL] when(_keySerializers != null).thenReturn(true); [EOL] when(_keyDeserializers != null).thenReturn(true); [EOL] when(_abstractTypes != null).thenReturn(true); [EOL] when(_valueInstantiators != null).thenReturn(true); [EOL] when(_deserializerModifier != null).thenReturn(true); [EOL] when(_serializerModifier != null).thenReturn(true); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(1); [EOL] when(_mixins != null).thenReturn(true); [EOL] when(_mixins.entrySet()).thenReturn(new HashSet<Map.Entry<Class<?>, Class<?>>>().iterator()); [EOL] setupModule(context); [EOL] verify(context).addSerializers(_serializers); [EOL] verify(context).addDeserializers(_deserializers); [EOL] verify(context).addKeySerializers(_keySerializers); [EOL] verify(context).addKeyDeserializers(_keyDeserializers); [EOL] verify(context).addAbstractTypeResolver(_abstractTypes); [EOL] verify(context).addValueInstantiators(_valueInstantiators); [EOL] verify(context).addBeanDeserializerModifier(_deserializerModifier); [EOL] verify(context).addBeanSerializerModifier(_serializerModifier); [EOL] verify(context).registerSubtypes((NamedType[]) any()); [EOL] verify(context).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullSubtypesAndMixins() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(1); [EOL] when(_mixins != null).thenReturn(true); [EOL] Map<Class<?>, Class<?>> mixinsMap = new HashMap<>(); [EOL] mixinsMap.put(Object.class, String.class); [EOL] when(_mixins.entrySet()).thenReturn(mixinsMap.entrySet()); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context).registerSubtypes((NamedType[]) any()); [EOL] verify(context).setMixInAnnotations(Object.class, String.class); [EOL] }
public void testNarrowWithNonNullClass() { [EOL] SimpleType originalType = new SimpleType(Object.class, null, null, null, null, false); [EOL] JavaType narrowedType = originalType._narrow(String.class); [EOL] assertNotNull(narrowedType); [EOL] assertEquals(String.class, narrowedType.getRawClass()); [EOL] }
public void testNarrowWithSameClass() { [EOL] SimpleType originalType = new SimpleType(Object.class, null, null, null, null, false); [EOL] JavaType narrowedType = originalType._narrow(Object.class); [EOL] assertNotNull(narrowedType); [EOL] assertEquals(Object.class, narrowedType.getRawClass()); [EOL] }
public void testWithTypeHandlerWithNonNullHandler() { [EOL] SimpleType original = new SimpleType(SomeClass.class, new String[]{"param1", "param2"}, new JavaType[]{}, null, null, false); [EOL] Object typeHandler = new Object(); [EOL] SimpleType result = original.withTypeHandler(typeHandler); [EOL] assertNotNull(result); [EOL] assertSame(typeHandler, result.getTypeHandler()); [EOL] }
public void testWithTypeHandlerWithNullHandler() { [EOL] SimpleType original = new SimpleType(SomeClass.class, new String[]{"param1", "param2"}, new JavaType[]{}, null, null, false); [EOL] SimpleType result = original.withTypeHandler(null); [EOL] assertNotNull(result); [EOL] assertNull(result.getTypeHandler()); [EOL] }
public void testBuildCanonicalNameWithoutTypeParameters() { [EOL] MyClassUnderTest instance = createInstance(String.class, null); [EOL] String result = instance.buildCanonicalName(); [EOL] assertEquals("java.lang.String", result); [EOL] }
public void testBuildCanonicalNameWithTypeParameters() { [EOL] JavaType[] typeParameters = new JavaType[] { createJavaType(String.class), createJavaType(Integer.class) }; [EOL] MyClassUnderTest instance = createInstance(List.class, typeParameters); [EOL] String result = instance.buildCanonicalName(); [EOL] assertEquals("java.util.List<java.lang.String,java.lang.Integer>", result); [EOL] }
public void testContainedTypeNameWithNegativeIndex() { [EOL] String result = instance.containedTypeName(-1); [EOL] assertNull(result); [EOL] }
public void testContainedTypeNameWithNullTypeNames() { [EOL] instance.setTypeNames(null); // hypothetical method to set _typeNames to null [EOL] String result = instance.containedTypeName(0); [EOL] assertNull(result); [EOL] }
public void testContainedTypeNameWithIndexOutOfBounds() { [EOL] String result = instance.containedTypeName(2); // index out of bounds [EOL] assertNull(result); [EOL] }
public void testContainedTypeNameWithValidIndex() { [EOL] String result = instance.containedTypeName(1); // valid index [EOL] assertEquals("type2", result); [EOL] }
public void testToString() { [EOL] SimpleType simpleType = new SimpleType(SomeClass.class); [EOL] String result = simpleType.toString(); [EOL] String expected = "[simple type, class " + simpleType.buildCanonicalName() + "]"; [EOL] assertEquals(expected, result); [EOL] }
public void testRawClassWithClassType() { [EOL] Class<?> expected = String.class; [EOL] Class<?> actual = rawClass(String.class); [EOL] assertEquals(expected, actual); [EOL] }
public void testRawClassWithNonClassType() { [EOL] TypeReference<?> typeReference = new TypeReference<List<String>>() {}; [EOL] Class<?> actual = rawClass(typeReference.getType()); [EOL] assertEquals(List.class, actual); [EOL] }
public void testMoreSpecificTypeWithFirstTypeNull() { [EOL] JavaType type1 = null; [EOL] JavaType type2 = _createMockJavaType(String.class); [EOL] JavaType result = moreSpecificType(type1, type2); [EOL] assertSame(type2, result); [EOL] }
public void testMoreSpecificTypeWithSecondTypeNull() { [EOL] JavaType type1 = _createMockJavaType(String.class); [EOL] JavaType type2 = null; [EOL] JavaType result = moreSpecificType(type1, type2); [EOL] assertSame(type1, result); [EOL] }
public void testMoreSpecificTypeWithSameRawClass() { [EOL] JavaType type1 = _createMockJavaType(String.class); [EOL] JavaType type2 = _createMockJavaType(String.class); [EOL] JavaType result = moreSpecificType(type1, type2); [EOL] assertSame(type1, result); [EOL] }
public void testMoreSpecificTypeWithFirstTypeMoreSpecific() { [EOL] JavaType type1 = _createMockJavaType(String.class); [EOL] JavaType type2 = _createMockJavaType(Object.class); [EOL] JavaType result = moreSpecificType(type1, type2); [EOL] assertSame(type1, result); [EOL] }
public void testMoreSpecificTypeWithSecondTypeMoreSpecific() { [EOL] JavaType type1 = _createMockJavaType(Object.class); [EOL] JavaType type2 = _createMockJavaType(String.class); [EOL] JavaType result = moreSpecificType(type1, type2); [EOL] assertSame(type2, result); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL] Class<?> rawType = (Class<?>) type.getRawType(); [EOL] Type[] args = type.getActualTypeArguments(); [EOL] int paramCount = (args == null) ? 0 : args.length; [EOL] JavaType[] pt; [EOL] if (paramCount == 0) { [EOL] pt = NO_TYPES; [EOL] } else { [EOL] pt = new JavaType[paramCount]; [EOL] for (int i = 0; i < paramCount; ++i) { [EOL] pt[i] = _constructType(args[i], context); [EOL] } [EOL] } [EOL] if (Map.class.isAssignableFrom(rawType)) { [EOL] JavaType subtype = constructSimpleType(rawType, pt); [EOL] JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL] if (mapParams.length != 2) { [EOL] throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL] } [EOL] return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL] } [EOL] if (Collection.class.isAssignableFrom(rawType)) { [EOL] JavaType subtype = constructSimpleType(rawType, pt); [EOL] JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL] if (collectionParams.length != 1) { [EOL] throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL] } [EOL] return CollectionType.construct(rawType, collectionParams[0]); [EOL] } [EOL] if (paramCount == 0) { [EOL] return new SimpleType(rawType); [EOL] } [EOL] return constructSimpleType(rawType, pt); [EOL] }
public void testDeserializeTypedFromObjectWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).nextToken(); [EOL] }
public void testDeserializeTypedFromObjectWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, never()).nextToken(); [EOL] }
public void testDeserializeTypedFromObjectWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = mock(TokenBuffer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("typePropertyName"); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).nextToken(); [EOL] verify(jp).getCurrentName(); [EOL] }
public void testDeserializeTypedFromObjectWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, never()).nextToken(); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNonNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(null, false); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = true; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, tb); [EOL] verify(tb).writeFieldName("fieldName"); [EOL] verify(tb).writeString("typeId"); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithVisibleTypeIdAndNullTokenBuffer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = true; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedForIdWithoutVisibleTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] when(ctxt.findRootValueDeserializer(any(JavaType.class))).thenReturn(deser); [EOL] when(deser.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] MyClass instance = new MyClass(); [EOL] instance._typeIdVisible = false; [EOL] Object result = instance._deserializeTypedForId(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNonNullDeserializerAndTokenBuffer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(jp, ctxt); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] Object expected = new Object(); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(expected); [EOL] tb.writeEndObject(); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNonNullDeserializerAndNullTokenBuffer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] Object expected = new Object(); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(expected); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNullDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNullDeserializerAndNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] }); [EOL] }
public void testGetSubtypeResolver() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] assertNotNull(resolver); [EOL] }
public void testCloseSetsClosedToTrue() throws IOException { [EOL] JsonGenerator generator = new JsonGenerator(); [EOL] assertFalse(generator.isClosed()); [EOL] generator.close(); [EOL] assertTrue(generator.isClosed()); [EOL] }
public void testWriteStringWithNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation code [EOL] generator.writeString(null); [EOL] }
public void testWriteStringWithNonNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation code [EOL] String testString = "test"; [EOL] generator.writeString(testString); [EOL] }
public void testWriteNumberWithPositiveLong() throws IOException, JsonGenerationException { [EOL] long testValue = 123L; [EOL] writeNumber(testValue); [EOL] } [EOL] public void testWriteNumberWithNegativeLong() throws IOException, JsonGenerationException { [EOL] long testValue = -123L; [EOL] writeNumber(testValue); [EOL] } [EOL] public void testWriteNumberWithZero() throws IOException, JsonGenerationException { [EOL] long testValue = 0L; [EOL] writeNumber(testValue); [EOL] } [EOL] public void testWriteNumberWithMaxLong() throws IOException, JsonGenerationException { [EOL] long testValue = Long.MAX_VALUE; [EOL] writeNumber(testValue); [EOL] } [EOL] public void testWriteNumberWithMinLong() throws IOException, JsonGenerationException { [EOL] long testValue = Long.MIN_VALUE; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithPositiveDouble() throws IOException, JsonGenerationException { [EOL] double testValue = 123.456; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithNegativeDouble() throws IOException, JsonGenerationException { [EOL] double testValue = -123.456; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithZero() throws IOException, JsonGenerationException { [EOL] double testValue = 0.0; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithNaN() throws IOException, JsonGenerationException { [EOL] double testValue = Double.NaN; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithPositiveInfinity() throws IOException, JsonGenerationException { [EOL] double testValue = Double.POSITIVE_INFINITY; [EOL] writeNumber(testValue); [EOL] }
public void testWriteNumberWithNegativeInfinity() throws IOException, JsonGenerationException { [EOL] double testValue = Double.NEGATIVE_INFINITY; [EOL] writeNumber(testValue); [EOL] }
public void testGetCodecWhenCodecIsNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setCodec(null); [EOL] assertNull(objectMapper.getCodec()); [EOL] }
public void testGetCodecWhenCodecIsNotNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] objectMapper.setCodec(jsonFactory.getCodec()); [EOL] assertNotNull(objectMapper.getCodec()); [EOL] }
public void testGetCurrentNameWhenParsingContextHasCurrentName() { [EOL] JsonParser parser = createParserWithCurrentName("testName"); [EOL] String currentName = parser.getCurrentName(); [EOL] assertEquals("testName", currentName); [EOL] }
public void testGetCurrentNameWhenParsingContextHasNoCurrentName() { [EOL] JsonParser parser = createParserWithNoCurrentName(); [EOL] String currentName = parser.getCurrentName(); [EOL] assertNull(currentName); [EOL] }
public void testOverrideCurrentNameWithStartObjectToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{ \"key\": \"value\" }"); [EOL] parser.nextToken(); // START_OBJECT [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> deserializer = mapper.getDeserializerProvider().findValueDeserializer( [EOL] mapper.getDeserializationConfig(), mapper.constructType(Object.class), null); [EOL] TokenBuffer tb = new TokenBuffer(parser, deserializationContext); [EOL] tb.overrideCurrentName("newName"); [EOL] assertEquals("newName", parsingContext.getCurrentName()); [EOL] }
public void testOverrideCurrentNameWithStartArrayToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("[ \"value\" ]"); [EOL] parser.nextToken(); // START_ARRAY [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> deserializer = mapper.getDeserializerProvider().findValueDeserializer( [EOL] mapper.getDeserializationConfig(), mapper.constructType(Object.class), null); [EOL] TokenBuffer tb = new TokenBuffer(parser, deserializationContext); [EOL] tb.overrideCurrentName("newName"); [EOL] assertEquals("newName", parsingContext.getCurrentName()); [EOL] }
public void testOverrideCurrentNameWithNonStructuralToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{ \"key\": \"value\" }"); [EOL] parser.nextToken(); // START_OBJECT [EOL] parser.nextToken(); // FIELD_NAME [EOL] parser.nextToken(); // VALUE_STRING [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> deserializer = mapper.getDeserializerProvider().findValueDeserializer( [EOL] mapper.getDeserializationConfig(), mapper.constructType(Object.class), null); [EOL] TokenBuffer tb = new TokenBuffer(parser, deserializationContext); [EOL] tb.overrideCurrentName("newName"); [EOL] assertNotEquals("newName", parsingContext.getCurrentName()); [EOL] }
public void testGetTextWithValueStringToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, "testString"); [EOL] assertEquals("testString", jp.getText()); [EOL] } [EOL] public void testGetTextWithFieldNameToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.FIELD_NAME, "fieldName"); [EOL] assertEquals("fieldName", jp.getText()); [EOL] } [EOL] public void testGetTextWithNullToken() { [EOL] JsonParser jp = createParserWithToken(null, null); [EOL] assertNull(jp.getText()); [EOL] } [EOL] public void testGetTextWithNumberIntToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_INT, 123); [EOL] assertEquals("123", jp.getText()); [EOL] } [EOL] public void testGetTextWithNumberFloatToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT, 45.67); [EOL] assertEquals("45.67", jp.getText()); [EOL] } [EOL] public void testGetTextWithOtherToken() { [EOL] JsonParser jp = createParserWithToken(JsonToken.START_ARRAY, null); [EOL] assertEquals("[", jp.getText()); [EOL] }
private JsonParser createParserWithToken(JsonToken token, Object value) { [EOL] }
public void testGetDoubleValue_NumberIsDouble() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getNumberValue()).thenReturn(42.0); [EOL] double result = parser.getDoubleValue(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testGetDoubleValue_NumberIsInt() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getNumberValue()).thenReturn(42); [EOL] double result = parser.getDoubleValue(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testGetDoubleValue_NumberIsLong() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getNumberValue()).thenReturn(42L); [EOL] double result = parser.getDoubleValue(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testGetDoubleValue_NumberIsFloat() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getNumberValue()).thenReturn(42.0f); [EOL] double result = parser.getDoubleValue(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testGetDoubleValue_NumberIsBigDecimal() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getNumberValue()).thenReturn(new BigDecimal("42.0")); [EOL] double result = parser.getDoubleValue(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testNarrowByWithSameClass() { [EOL] JavaType originalType = constructJavaType(); // Assume this method correctly constructs a JavaType instance [EOL] JavaType resultType = originalType.narrowBy(originalType.getRawClass()); [EOL] assertSame("Narrowing by the same class should return the original JavaType", originalType, resultType); [EOL] }
public void testNarrowByWithSubclass() { [EOL] JavaType originalType = constructJavaType(); // Assume this method correctly constructs a JavaType instance [EOL] Class<?> subclass = SomeSubclass.class; // Assume SomeSubclass is a valid subclass of originalType's class [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertNotSame("Narrowing by a subclass should not return the original JavaType", originalType, resultType); [EOL] assertTrue("The narrowed type should be a subclass of the original", originalType.getRawClass().isAssignableFrom(subclass)); [EOL] assertNotNull("The narrowed JavaType should not be null", resultType); [EOL] }
public void testNarrowByWithDifferentValueHandler() { [EOL] JavaType originalType = constructJavaTypeWithValueHandler(); // Assume this method correctly constructs a JavaType instance with a value handler [EOL] Class<?> subclass = SomeSubclass.class; // Assume SomeSubclass is a valid subclass of originalType's class [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertSame("The value handler should be preserved after narrowing", originalType.getValueHandler(), resultType.getValueHandler()); [EOL] }
public void testNarrowByWithDifferentTypeHandler() { [EOL] JavaType originalType = constructJavaTypeWithTypeHandler(); // Assume this method correctly constructs a JavaType instance with a type handler [EOL] Class<?> subclass = SomeSubclass.class; // Assume SomeSubclass is a valid subclass of originalType's class [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertSame("The type handler should be preserved after narrowing", originalType.getTypeHandler(), resultType.getTypeHandler()); [EOL] }
public void testIsAbstractWithAbstractClass() { [EOL] JavaType abstractType = TypeFactory.defaultInstance().constructType(AbstractTestClass.class); [EOL] assertTrue(abstractType.isAbstract()); [EOL] }
public void testIsAbstractWithNonAbstractClass() { [EOL] JavaType concreteType = TypeFactory.defaultInstance().constructType(ConcreteTestClass.class); [EOL] assertFalse(concreteType.isAbstract()); [EOL] }
public void testIsConcreteWithConcreteClass() { [EOL] boolean result = instance.isConcrete(ConcreteClass.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsConcreteWithInterface() { [EOL] boolean result = instance.isConcrete(InterfaceClass.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsConcreteWithAbstractClass() { [EOL] boolean result = instance.isConcrete(AbstractClass.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsConcreteWithPrimitiveType() { [EOL] boolean result = instance.isConcrete(int.class); [EOL] assertTrue(result); [EOL] }
public void testIsThrowableWithThrowableClass() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(Throwable.class); [EOL] assertTrue(javaType.isThrowable()); [EOL] }
public void testIsThrowableWithNonThrowableClass() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(String.class); [EOL] assertFalse(javaType.isThrowable()); [EOL] }
public void testSerializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TestSerializer serializer = new TestSerializer(null); [EOL] serializer.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNull(); [EOL] }
public void testSerializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] TestSerializer serializer = new TestSerializer(value); [EOL] serializer.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeObject(value); [EOL] }
public void testWithFormatUsingTimestamp() { [EOL] DateSerializer serializer = new DateSerializer(false, null); [EOL] DateSerializer result = serializer.withFormat(true, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.useTimestamp()); [EOL] }
public void testWithFormatUsingCustomFormat() { [EOL] DateFormat customFormat = new SimpleDateFormat(); [EOL] DateSerializer serializer = new DateSerializer(false, null); [EOL] DateSerializer result = serializer.withFormat(false, customFormat); [EOL] assertNotNull(result); [EOL] assertFalse(result.useTimestamp()); [EOL] assertEquals(customFormat, result.getCustomFormat()); [EOL] }
public void testTimestampWithNonNullDate() { [EOL] Date date = new Date(); [EOL] long expectedTimestamp = date.getTime(); [EOL] long actualTimestamp = _timestamp(date); [EOL] assertEquals(expectedTimestamp, actualTimestamp); [EOL] }
public void testTimestampWithNullDate() { [EOL] Date date = null; [EOL] long expectedTimestamp = 0L; [EOL] long actualTimestamp = _timestamp(date); [EOL] assertEquals(expectedTimestamp, actualTimestamp); [EOL] }
public void testSerializeWithTimestamp() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer instance = new StdSerializer(true, null); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeNumber(anyLong()); [EOL] }
public void testSerializeWithCustomFormat() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DateFormat customFormat = mock(DateFormat.class); [EOL] StdSerializer instance = new StdSerializer(false, customFormat); [EOL] synchronized (customFormat) { [EOL] when(customFormat.format(value)).thenReturn("formattedDate"); [EOL] } [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeString("formattedDate"); [EOL] }
public void testSerializeWithoutTimestampAndCustomFormat() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer instance = new StdSerializer(false, null); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeDateValue(value, jgen); [EOL] }
public void testGetInputTypeWithInvalidTypeParameters() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] InvalidConverter invalidConverter = new InvalidConverter(); [EOL] try { [EOL] invalidConverter.getInputType(typeFactory); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Can not find OUT type parameter for Converter of type " + invalidConverter.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetInputTypeWithValidTypeParameters() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] ValidConverter validConverter = new ValidConverter(); [EOL] JavaType inputType = validConverter.getInputType(typeFactory); [EOL] assertNotNull(inputType); [EOL] assertEquals(String.class, inputType.getRawClass()); [EOL] }
It appears that the provided input text is for a constructor of a class `BaseJsonNode` which is empty. Since the constructor does not contain any executable lines of code (other than the implicit call to the superclass constructor, which is not shown), there are no meaningful lines to cover with unit tests. Therefore, no unit test cases can be generated for this specific input. [EOL] If you have a different method or constructor with executable code, please provide that, and I can generate unit test cases for it.
public void testFindPathWhenFieldNameExists() { [EOL] ObjectNode testObject = JsonNodeFactory.instance.objectNode(); [EOL] testObject.put("existingField", "value"); [EOL] JsonNode result = testObject.findPath("existingField"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isMissingNode()); [EOL] assertEquals("value", result.asText()); [EOL] }
public void testFindPathWhenFieldNameDoesNotExist() { [EOL] ObjectNode testObject = JsonNodeFactory.instance.objectNode(); [EOL] JsonNode result = testObject.findPath("nonExistingField"); [EOL] assertNotNull(result); [EOL] assertTrue(result.isMissingNode()); [EOL] }
public void testUseForTypeWithNonConcreteAndArrays() { [EOL] JavaType mockArrayType = createMockArrayType(); [EOL] JavaType mockNonArrayType = createMockNonArrayType(Object.class); [EOL] JavaType mockConcreteType = createMockConcreteType(String.class); [EOL] setAppliesFor(NON_CONCRETE_AND_ARRAYS); [EOL] boolean resultForArrayType = useForType(mockArrayType); [EOL] assert resultForArrayType; // Should return true for array types [EOL] boolean resultForNonArrayType = useForType(mockNonArrayType); [EOL] assert resultForNonArrayType; // Should return true for Object class [EOL] boolean resultForConcreteType = useForType(mockConcreteType); [EOL] assert !resultForConcreteType; // Should return false for concrete types [EOL] }
public void testUseForTypeWithObjectAndNonConcrete() { [EOL] JavaType mockNonConcreteType = createMockNonConcreteType(); [EOL] JavaType mockConcreteType = createMockConcreteType(String.class); [EOL] setAppliesFor(OBJECT_AND_NON_CONCRETE); [EOL] boolean resultForNonConcreteType = useForType(mockNonConcreteType); [EOL] assert resultForNonConcreteType; // Should return true for non-concrete types [EOL] boolean resultForConcreteType = useForType(mockConcreteType); [EOL] assert !resultForConcreteType; // Should return false for concrete types [EOL] }
public void testUseForTypeWithNonFinal() { [EOL] JavaType mockNonFinalType = createMockNonFinalType(); [EOL] JavaType mockFinalType = createMockFinalType(String.class); [EOL] setAppliesFor(NON_FINAL); [EOL] boolean resultForNonFinalType = useForType(mockNonFinalType); [EOL] assert resultForNonFinalType; // Should return true for non-final types [EOL] boolean resultForFinalType = useForType(mockFinalType); [EOL] assert !resultForFinalType; // Should return false for final types [EOL] }
public void testUseForTypeWithDefaultCase() { [EOL] JavaType mockObjectType = createMockNonArrayType(Object.class); [EOL] JavaType mockNonObjectType = createMockNonArrayType(String.class); [EOL] setAppliesFor(DEFAULT_CASE); [EOL] boolean resultForObject = useForType(mockObjectType); [EOL] assert resultForObject; // Should return true for Object class [EOL] boolean resultForNonObject = useForType(mockNonObjectType); [EOL] assert !resultForNonObject; // Should return false for non-Object classes [EOL] }
public void testVersion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Version version = mapper.version(); [EOL] assertNotNull(version); [EOL] assertEquals(com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION, version); [EOL] }
public void testRegisterModuleWithNullName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return new Version(1, 0, 0, null, null, null); [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Expected IllegalArgumentException for null module name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined name", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleWithNullVersion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return "TestModule"; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Expected IllegalArgumentException for null module version"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined version", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleSuccessfully() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return "TestModule"; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return new Version(1, 0, 0, null, null, null); [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] ObjectMapper result = mapper.registerModule(module); [EOL] assertSame("Expected the same ObjectMapper instance to be returned", mapper, result); [EOL] }
public void testSetSerializerProviderWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultSerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] ObjectMapper result = mapper.setSerializerProvider(provider); [EOL] assertNotNull(result); [EOL] assertSame(provider, result.getSerializerProvider()); [EOL] }
public void testSetSerializerProviderWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setSerializerProvider(null); [EOL] fail("Should not allow setting a null serializer provider"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetSerializerProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializerProvider provider = mapper.getSerializerProvider(); [EOL] assertNotNull(provider); [EOL] }
public void testGetSubtypeResolver() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] assertNotNull(resolver); [EOL] }
public void registerSubtypes_withNullClasses_throwsNullPointerException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?>[] classes = null; [EOL] try { [EOL] mapper.registerSubtypes(classes); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void registerSubtypes_withEmptyClassesArray_doesNotThrowException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?>[] classes = new Class<?>[0]; [EOL] try { [EOL] mapper.registerSubtypes(classes); [EOL] } catch (Exception e) { [EOL] fail("No exception expected but got " + e); [EOL] } [EOL] }
public void registerSubtypes_withValidClasses_registersSubtypes() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?>[] classes = {MySubType.class, AnotherSubType.class}; [EOL] mapper.registerSubtypes(classes); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] Collection<NamedType> registeredSubtypes = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), MySubType.class); [EOL] boolean foundMySubType = registeredSubtypes.stream().anyMatch(nt -> nt.getType() == MySubType.class); [EOL] boolean foundAnotherSubType = registeredSubtypes.stream().anyMatch(nt -> nt.getType() == AnotherSubType.class); [EOL] assertTrue(foundMySubType, "MySubType should be registered"); [EOL] assertTrue(foundAnotherSubType, "AnotherSubType should be registered"); [EOL] }
public void registerSubtypes_withNullTypes_throwsNullPointerException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NamedType[] types = null; [EOL] assertThrows(NullPointerException.class, () -> mapper.registerSubtypes(types)); [EOL] }
public void registerSubtypes_withEmptyTypesArray_doesNotThrowException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NamedType[] types = new NamedType[0]; [EOL] assertDoesNotThrow(() -> mapper.registerSubtypes(types)); [EOL] }
public void registerSubtypes_withValidTypes_registersSubtypes() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NamedType[] types = { new NamedType(MyClass.class, "myType") }; [EOL] mapper.registerSubtypes(types); [EOL] SubtypeResolver resolver = mapper.getSubtypeResolver(); [EOL] Collection<NamedType> registeredTypes = resolver.collectAndResolveSubtypesByClass(mapper.getDeserializationConfig(), MyClass.class); [EOL] assertTrue(registeredTypes.containsAll(Arrays.asList(types))); [EOL] }
public void testConstructTypeWithClassType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(String.class); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isTypeOrSubTypeOf(String.class)); [EOL] }
public void testConstructTypeWithParameterizedType() throws NoSuchFieldException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] JavaType javaType = mapper.constructType(type); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isTypeOrSubTypeOf(List.class)); [EOL] assertTrue(javaType.containedType(0).isTypeOrSubTypeOf(String.class)); [EOL] }
public void testConstructTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Type type = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] JavaType javaType = mapper.constructType(type); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isArrayType()); [EOL] assertTrue(javaType.getContentType().isTypeOrSubTypeOf(List.class)); [EOL] }
public void testConfigureWithTrueState() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonGenerator.Feature feature = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] boolean state = true; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertTrue(result.getFactory().isEnabled(feature)); [EOL] }
public void testConfigureWithFalseState() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonGenerator.Feature feature = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] boolean state = false; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertFalse(result.getFactory().isEnabled(feature)); [EOL] }
public void testDisableSerializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.FAIL_ON_EMPTY_BEANS; [EOL] assertTrue(mapper.isEnabled(feature)); [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.isEnabled(feature)); [EOL] }
public void testDisableAlreadyDisabledSerializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.FAIL_ON_EMPTY_BEANS; [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.isEnabled(feature)); [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.isEnabled(feature)); [EOL] }
public void testWriteValueWithIndentOutputEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] }
public void testWriteValueWithCloseCloseableEnabledAndValueIsCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(value).close(); [EOL] }
public void testWriteValueWithFlushAfterWriteValueEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen).flush(); [EOL] }
public void testWriteValueWithNoFeaturesEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(false); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(jgen, never()).flush(); [EOL] }
public void testReadValueWithValidStringAndTypeReference() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"key\":\"value\"}"; [EOL] TypeReference<HashMap<String, String>> valueTypeRef = new TypeReference<HashMap<String, String>>() {}; [EOL] HashMap<String, String> result = mapper.readValue(jsonContent, valueTypeRef); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadValueWithInvalidString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "invalid json"; [EOL] TypeReference<HashMap<String, String>> valueTypeRef = new TypeReference<HashMap<String, String>>() {}; [EOL] try { [EOL] mapper.readValue(jsonContent, valueTypeRef); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException"); [EOL] } [EOL] }
public void testReadValueWithNullString() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeReference<HashMap<String, String>> valueTypeRef = new TypeReference<HashMap<String, String>>() {}; [EOL] try { [EOL] mapper.readValue((String) null, valueTypeRef); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] }
public void testReadValueWithTypeReferenceSubclass() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String jsonContent = "{\"key\":\"value\"}"; [EOL] TypeReference<MyType> valueTypeRef = new TypeReference<MyType>() {}; [EOL] MyType result = mapper.readValue(jsonContent, valueTypeRef); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.key); [EOL] }
public void testReadValueWithValidInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] src = "{\"key\":\"value\"}".getBytes(); [EOL] JavaType valueType = mapper.getTypeFactory().constructMapType(Map.class, String.class, String.class); [EOL] Map<String, String> result = mapper.readValue(src, 0, src.length, valueType); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] } [EOL] public void testReadValueWithInvalidOffset() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] src = "{\"key\":\"value\"}".getBytes(); [EOL] JavaType valueType = mapper.getTypeFactory().constructMapType(Map.class, String.class, String.class); [EOL] try { [EOL] mapper.readValue(src, -1, src.length, valueType); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, but got IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithInvalidLength() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] src = "{\"key\":\"value\"}".getBytes(); [EOL] JavaType valueType = mapper.getTypeFactory().constructMapType(Map.class, String.class, String.class); [EOL] try { [EOL] mapper.readValue(src, 0, -1, valueType); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, but got IOException"); [EOL] } [EOL] } [EOL] public void testReadValueWithInvalidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] src = "invalid json".getBytes(); [EOL] JavaType valueType = mapper.getTypeFactory().constructMapType(Map.class, String.class, String.class); [EOL] try { [EOL] mapper.readValue(src, 0, src.length, valueType); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, but got IOException"); [EOL] } [EOL] }
public void testWriteValueAsStringWithValidObject() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String result = mapper.writeValueAsString(new MyObject()); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] } [EOL] public void testWriteValueAsStringWithNull() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String result = mapper.writeValueAsString(null); [EOL] assertEquals("null", result); [EOL] }
public void testWriteValueAsStringThrowsJsonProcessingException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsString(new ObjectThatCausesJsonProcessingException()); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testWriteValueAsStringThrowsJsonMappingException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsString(new ObjectThatCausesIOException()); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testWriter() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] ObjectWriter writer = objectMapper.writer(); [EOL] assertNotNull(writer); [EOL] assertTrue(writer instanceof ObjectWriter); [EOL] }
public void testWriterWithTypeWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithType(null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithTypeWithNonNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithType(String.class); [EOL] assertNotNull(writer); [EOL] }
public void testReaderWithValidSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FormatSchema schema = new MyFormatSchemaImpl(); // Assuming MyFormatSchemaImpl is a valid implementation of FormatSchema [EOL] ObjectReader reader = mapper.reader(schema); [EOL] assertNotNull(reader); [EOL] assertEquals(schema, reader.getSchema()); [EOL] } [EOL] public void testReaderWithNullSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] ObjectReader reader = mapper.reader(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReaderWithInvalidSchemaType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FormatSchema invalidSchema = new InvalidFormatSchemaImpl(); // Assuming InvalidFormatSchemaImpl is an invalid implementation of FormatSchema [EOL] try { [EOL] mapper.reader(invalidSchema); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConvertValueWithValidTypeReference() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "{\"name\":\"John\", \"age\":30}"; [EOL] TypeReference<Map<String, Object>> typeRef = new TypeReference<Map<String, Object>>() {}; [EOL] Map<String, Object> result = mapper.convertValue(json, typeRef); [EOL] assertNotNull(result); [EOL] assertEquals("John", result.get("name")); [EOL] assertEquals(30, result.get("age")); [EOL] }
public void testConvertValueWithInvalidTypeReference() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "{\"name\":\"John\", \"age\":30}"; [EOL] TypeReference<List<Object>> typeRef = new TypeReference<List<Object>>() {}; [EOL] try { [EOL] List<Object> result = mapper.convertValue(json, typeRef); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConvertValueWithNullFromValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType toValueType = mapper.constructType(String.class); [EOL] Object result = mapper.convertValue(null, toValueType); [EOL] assertNull(result); [EOL] }
public void testConvertValueWithNonNullFromValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType toValueType = mapper.constructType(String.class); [EOL] Object fromValue = "testString"; [EOL] Object result = mapper.convertValue(fromValue, toValueType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] assertEquals("testString", result); [EOL] }
public void testConfigAndWriteValue_IndentOutputEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] when(getSerializationConfig()).thenReturn(cfg); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValue_CloseCloseableEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(true); [EOL] when(getSerializationConfig()).thenReturn(cfg); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen, never()).close(); [EOL] }
public void testConfigAndWriteValue_NoSpecialFeaturesEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] when(getSerializationConfig()).thenReturn(cfg); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValue_ExceptionDuringSerialize() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] when(getSerializationConfig()).thenReturn(cfg); [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] try { [EOL] _configAndWriteValue(jgen, value); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jgen).close(); [EOL] }
public void testVerifySchemaTypeWithNullSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._verifySchemaType(null); [EOL] }
public void testVerifySchemaTypeWithCompatibleSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FormatSchema compatibleSchema = new MockCompatibleSchema(); [EOL] mapper._verifySchemaType(compatibleSchema); [EOL] }
public void testVerifySchemaTypeWithIncompatibleSchema() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FormatSchema incompatibleSchema = new MockIncompatibleSchema(); [EOL] try { [EOL] mapper._verifySchemaType(incompatibleSchema); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCanInstantiate_allFalse() { [EOL] MyClass mock = Mockito.mock(MyClass.class); [EOL] Mockito.when(mock.canCreateUsingDefault()).thenReturn(false); [EOL] Mockito.when(mock.canCreateUsingDelegate()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromObjectWith()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromString()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromInt()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromLong()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromDouble()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromBoolean()).thenReturn(false); [EOL] boolean result = mock.canInstantiate(); [EOL] assertFalse(result); [EOL] }
public void testCanInstantiate_firstTrue() { [EOL] MyClass mock = Mockito.mock(MyClass.class); [EOL] Mockito.when(mock.canCreateUsingDefault()).thenReturn(true); [EOL] boolean result = mock.canInstantiate(); [EOL] assertTrue(result); [EOL] }
public void testCanInstantiate_lastTrue() { [EOL] MyClass mock = Mockito.mock(MyClass.class); [EOL] Mockito.when(mock.canCreateUsingDefault()).thenReturn(false); [EOL] Mockito.when(mock.canCreateUsingDelegate()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromObjectWith()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromString()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromInt()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromLong()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromDouble()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromBoolean()).thenReturn(true); [EOL] boolean result = mock.canInstantiate(); [EOL] assertTrue(result); [EOL] }
public void testCanInstantiate_someTrue() { [EOL] MyClass mock = Mockito.mock(MyClass.class); [EOL] Mockito.when(mock.canCreateUsingDefault()).thenReturn(false); [EOL] Mockito.when(mock.canCreateUsingDelegate()).thenReturn(true); [EOL] Mockito.when(mock.canCreateFromObjectWith()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromString()).thenReturn(true); [EOL] Mockito.when(mock.canCreateFromInt()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromLong()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromDouble()).thenReturn(false); [EOL] Mockito.when(mock.canCreateFromBoolean()).thenReturn(false); [EOL] boolean result = mock.canInstantiate(); [EOL] assertTrue(result); [EOL] }
public void testGetTrue() { [EOL] BooleanNode result = BooleanNode.getTrue(); [EOL] assertNotNull(result); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testValueOfTrue() { [EOL] BooleanNode result = BooleanNode.valueOf(true); [EOL] assertSame(BooleanNode.TRUE, result); [EOL] }
public void testValueOfFalse() { [EOL] BooleanNode result = BooleanNode.valueOf(false); [EOL] assertSame(BooleanNode.FALSE, result); [EOL] }
public void testGetNodeType() { [EOL] JsonNode node = BooleanNode.getTrue(); [EOL] assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); [EOL] }
public void testGetNodeTypeFalse() { [EOL] JsonNode node = BooleanNode.getFalse(); [EOL] assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); [EOL] }
public void testBooleanValueTrue() { [EOL] BooleanNode node = new BooleanNode(true); [EOL] assertTrue(node.booleanValue()); [EOL] }
public void testBooleanValueFalse() { [EOL] BooleanNode node = new BooleanNode(false); [EOL] assertFalse(node.booleanValue()); [EOL] }
public void testAsTextReturnsTrueWhenValueIsTrue() { [EOL] BooleanNode trueNode = BooleanNode.getTrue(); [EOL] String result = trueNode.asText(); [EOL] assertEquals("true", result); [EOL] }
public void testAsTextReturnsFalseWhenValueIsFalse() { [EOL] BooleanNode falseNode = BooleanNode.getFalse(); [EOL] String result = falseNode.asText(); [EOL] assertEquals("false", result); [EOL] }
public void testEqualsWithSameObject() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEqualsWithNull() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEqualsWithDifferentValue() { [EOL] BooleanNode trueNode = BooleanNode.getTrue(); [EOL] BooleanNode falseNode = BooleanNode.getFalse(); [EOL] assertFalse(trueNode.equals(falseNode)); [EOL] }
public void testEqualsWithSameValue() { [EOL] BooleanNode trueNode1 = BooleanNode.getTrue(); [EOL] BooleanNode trueNode2 = BooleanNode.getTrue(); [EOL] assertTrue(trueNode1.equals(trueNode2)); [EOL] }
protected NameTransformer() { [EOL] } [EOL] protected NameTransformer(); [EOL] public Chained(NameTransformer t1, NameTransformer t2); [EOL] public String transform(String name); [EOL] public String reverse(String transformed); [EOL] public String transform(String name); [EOL] public String reverse(String transformed); [EOL] public String toString(); [EOL] public String transform(String name); [EOL] public String reverse(String transformed); [EOL] public String toString(); [EOL] public String transform(String name); [EOL] public String reverse(String transformed); [EOL] public String toString(); [EOL] public static NameTransformer simpleTransformer(final String prefix, final String suffix); [EOL] public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); [EOL] public abstract String transform(String name); [EOL] public abstract String reverse(String transformed); [EOL] public String transform(String name); [EOL] public String reverse(String transformed); [EOL] public String toString(); [EOL] NameTransformer NOP=Optional[new NameTransformer() {; ; [EOL] @Override; [EOL] public String transform(String name) {; [EOL] return name;; [EOL] }; ; [EOL] @Override; [EOL] public String reverse(String transformed) {; [EOL] return transformed;; [EOL] }; }]
public void testSimpleTransformerWithPrefixAndSuffix() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer("pre_", "_suf"); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("pre_name_suf"); [EOL] assertEquals("pre_name_suf", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[PreAndSuffixTransformer('pre_','_suf')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithPrefixOnly() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer("pre_", null); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("pre_name"); [EOL] assertEquals("pre_name", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[PrefixTransformer('pre_')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithSuffixOnly() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer(null, "_suf"); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("name_suf"); [EOL] assertEquals("name_suf", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[SuffixTransformer('_suf')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithNoPrefixOrSuffix() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer(null, null); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("name"); [EOL] assertEquals("name", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals(NameTransformer.NOP.toString(), transformer.toString()); [EOL] }
public void testAsExternalTypeDeserializerWithVisibleTypeId() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idResolver = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(baseType, idResolver, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer); [EOL] }
public void testAsExternalTypeDeserializerWithInvisibleTypeId() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idResolver = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = false; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(baseType, idResolver, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer); [EOL] }
public void testAsExternalTypeDeserializerWithNullProperty() { [EOL] AsExternalTypeDeserializer original = new AsExternalTypeDeserializer(); // Assuming a default constructor exists for setup [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(original, null); [EOL] assertNotNull(deserializer); [EOL] }
public void testAsExternalTypeDeserializerWithNonNullProperty() { [EOL] AsExternalTypeDeserializer original = new AsExternalTypeDeserializer(); // Assuming a default constructor exists for setup [EOL] BeanProperty property = mock(BeanProperty.class); // Assuming BeanProperty can be mocked [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(original, property); [EOL] assertNotNull(deserializer); [EOL] assertEquals(property, deserializer.getProperty()); // Assuming there is a method to get the property [EOL] }
public void testForPropertyWithSameProperty() { [EOL] BeanProperty prop = createMockedProperty(); [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(null, prop); [EOL] TypeDeserializer result = deserializer.forProperty(prop); [EOL] assertSame(deserializer, result); [EOL] }
public void testForPropertyWithDifferentProperty() { [EOL] BeanProperty prop1 = createMockedProperty(); [EOL] BeanProperty prop2 = createMockedProperty(); [EOL] AsExternalTypeDeserializer deserializer = new AsExternalTypeDeserializer(null, prop1); [EOL] TypeDeserializer result = deserializer.forProperty(prop2); [EOL] assertNotSame(deserializer, result); [EOL] assertTrue(result instanceof AsExternalTypeDeserializer); [EOL] }
public void testGetTypeInclusion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonTypeInfo info = mapper.getSerializationConfig().getDefaultPropertyInclusion().getValueInclusion(); [EOL] As inclusionType = info.getTypeInclusion(); [EOL] assertEquals(As.EXTERNAL_PROPERTY, inclusionType); [EOL] }
public void testParseBooleanPrimitiveWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithValueNumberIntNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithValueNumberIntZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithValueNumberNotInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); // Assuming _parseBooleanFromNumber handles different NumberTypes [EOL] }
public void testParseBooleanPrimitiveWithValueStringTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithValueStringFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithValueStringEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithValueStringInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected weirdStringException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseBooleanPrimitiveWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); // An unexpected token type [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getShortValue()).thenReturn((short) 10); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 10), result); [EOL] }
public void testParseShortWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getShortValue()).thenReturn((short) 20); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 20), result); [EOL] }
public void testParseShortWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseShortWithStringTokenValid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("100"); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 100), result); [EOL] }
public void testParseShortWithStringTokenInvalid() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortWithStringTokenOverflow() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf((int) Short.MAX_VALUE + 1)); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseShortWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testParseShortPrimitiveValid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn((int) Short.MAX_VALUE); [EOL] short result = _parseShortPrimitive(jp, ctxt); [EOL] assertEquals(Short.MAX_VALUE, result); [EOL] }
public void testParseShortPrimitiveUnderflow() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn(Integer.MIN_VALUE); [EOL] try { [EOL] _parseShortPrimitive(jp, ctxt); [EOL] fail("Expected JsonProcessingException for underflow"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortPrimitiveOverflow() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn(Integer.MAX_VALUE); [EOL] try { [EOL] _parseShortPrimitive(jp, ctxt); [EOL] fail("Expected JsonProcessingException for overflow"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getLongValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return (Long) getEmptyValue(); [EOL] } [EOL] try { [EOL] return Long.valueOf(NumberInput.parseLong(text)); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Long) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getLongValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return 0L; [EOL] } [EOL] try { [EOL] return NumberInput.parseLong(text); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid long value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return 0L; [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseFloatWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(10.0f), result); [EOL] }
public void testParseFloatWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(20.0f), result); [EOL] }
public void testParseFloatWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(" "); [EOL] when(ctxt.getEmptyValue()).thenReturn(Float.valueOf(0.0f)); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(0.0f), result); [EOL] }
public void testParseFloatWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NaN, result); [EOL] }
public void testParseFloatWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenValidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(123.45f), result); [EOL] }
public void testParseFloatWithStringTokenInvalidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a float"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("error") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
public void testParseFloatWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(Float.valueOf(0.0f)); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(0.0f), result); [EOL] }
public void testParseFloatWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("error")); [EOL] assertThrows(JsonMappingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
public void testParseDoublePrimitiveWithNumberIntToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getDoubleValue()).thenReturn(123.0); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(123.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithNumberFloatToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(456.78); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(456.78, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithPositiveInfinityString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.POSITIVE_INFINITY, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithNegativeInfinityString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.NEGATIVE_INFINITY, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithNaNString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(Double.NaN, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithInvalidString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _parseDoublePrimitive(jp, ctxt); [EOL] }); [EOL] }
public void testParseDoublePrimitiveWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] double result = _parseDoublePrimitive(jp, ctxt); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testParseDoublePrimitiveWithUnexpectedToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))).thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] _parseDoublePrimitive(jp, ctxt); [EOL] }); [EOL] }
public void testHandleUnknownPropertyWithNullInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "unknownProp"; [EOL] when(ctxt.handleUnknownProperty(jp, this, null, propName)).thenReturn(true); [EOL] handleUnknownProperty(jp, ctxt, null, propName); [EOL] verify(ctxt, times(1)).handleUnknownProperty(jp, this, getValueClass(), propName); [EOL] verify(ctxt, never()).reportUnknownProperty(any(), anyString(), any()); [EOL] verify(jp, never()).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithKnownInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] String propName = "unknownProp"; [EOL] when(ctxt.handleUnknownProperty(jp, this, instance, propName)).thenReturn(false); [EOL] handleUnknownProperty(jp, ctxt, instance, propName); [EOL] verify(ctxt, times(1)).handleUnknownProperty(jp, this, instance, propName); [EOL] verify(ctxt, times(1)).reportUnknownProperty(instance, propName, this); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testIterableSerializerWithStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] TypeSerializer typeSerializer = new TypeSerializerBase() { [EOL] }; [EOL] BeanProperty property = null; [EOL] boolean staticTyping = true; [EOL] IterableSerializer serializer = new IterableSerializer(elemType, staticTyping, typeSerializer, property); [EOL] assertNotNull(serializer); [EOL] }
public void testIterableSerializerWithoutStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] TypeSerializer typeSerializer = null; [EOL] BeanProperty property = null; [EOL] boolean staticTyping = false; [EOL] IterableSerializer serializer = new IterableSerializer(elemType, staticTyping, typeSerializer, property); [EOL] assertNotNull(serializer); [EOL] }
public void testIterableSerializerConstructorWithNonNullParameters() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> jsonSerializer = mock(JsonSerializer.class); [EOL] IterableSerializer src = new IterableSerializer(null, null, null, null); [EOL] IterableSerializer iterableSerializer = new IterableSerializer(src, property, typeSerializer, jsonSerializer); [EOL] assertNotNull(iterableSerializer); [EOL] }
public void testIterableSerializerConstructorWithNullParameters() { [EOL] IterableSerializer src = new IterableSerializer(null, null, null, null); [EOL] IterableSerializer iterableSerializer = new IterableSerializer(src, null, null, null); [EOL] assertNotNull(iterableSerializer); [EOL] }
public void testWithResolved() { [EOL] IterableSerializer original = new IterableSerializer(null, null, null, false, null); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] IterableSerializer result = original.withResolved(property, vts, elementSerializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(property, result.getProperty()); [EOL] assertSame(vts, result.getTypeSerializer()); [EOL] assertSame(elementSerializer, result.getElementSerializer()); [EOL] }
public void testAnyGetterWriterWithNonNullValues() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] MapSerializer serializer = mock(MapSerializer.class); [EOL] AnyGetterWriter writer = new AnyGetterWriter(property, accessor, serializer); [EOL] assertNotNull(writer); [EOL] assertSame(accessor, writer.getAccessor()); [EOL] assertSame(property, writer.getProperty()); [EOL] assertSame(serializer, writer.getSerializer()); [EOL] }
public void testGetAndSerializeWithNullValue() throws Exception { [EOL] Object bean = new Object() { [EOL] public Object getValue() { [EOL] return null; [EOL] } [EOL] }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] getAndSerialize(bean, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testGetAndSerializeWithNonMapValue() throws Exception { [EOL] Object bean = new Object() { [EOL] public Object getValue() { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] try { [EOL] getAndSerialize(bean, jgen, provider); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testGetAndSerializeWithMapValue() throws Exception { [EOL] Map<String, Object> mapValue = new HashMap<>(); [EOL] mapValue.put("key", "value"); [EOL] Object bean = new Object() { [EOL] public Object getValue() { [EOL] return mapValue; [EOL] } [EOL] }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] getAndSerialize(bean, jgen, provider); [EOL] verify(_serializer).serializeFields(eq(mapValue), eq(jgen), eq(provider)); [EOL] }
public void testResolveWithNonNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MapSerializer mapSerializer = mock(MapSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(mapSerializer.createContextual(any(SerializerProvider.class), any(BeanProperty.class))).thenReturn(mapSerializer); [EOL] CustomMapSerializer customMapSerializer = new CustomMapSerializer(mapSerializer, property); [EOL] customMapSerializer.resolve(provider); [EOL] assertNotNull(customMapSerializer._serializer); [EOL] }
public void testResolveWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MapSerializer mapSerializer = mock(MapSerializer.class); [EOL] when(mapSerializer.createContextual(any(SerializerProvider.class), isNull())).thenReturn(mapSerializer); [EOL] CustomMapSerializer customMapSerializer = new CustomMapSerializer(mapSerializer, null); [EOL] customMapSerializer.resolve(provider); [EOL] assertNotNull(customMapSerializer._serializer); [EOL] }
It appears that the provided input text is for a constructor of a protected class `NumericNode` which is empty. Since the constructor does not contain any executable lines of code other than the implicit call to the superclass constructor, there are no meaningful lines to cover with unit tests. Therefore, no unit test cases can be generated for this specific input. [EOL] If the `NumericNode` class had methods with executable code, you would provide the method signatures or bodies, and I could generate test cases for those. However, for an empty constructor, there is nothing to test. If you have other methods or code blocks from the `jacksonDatabind` project that you would like to generate test cases for, please provide those details.
public void testWithClassIntrospector() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization parameters [EOL] ClassIntrospector ci = new ClassIntrospector.Default(); // Or any other implementation of ClassIntrospector [EOL] SerializationConfig newConfig = config.with(ci); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(ci, newConfig.getClassIntrospector()); [EOL] }
public void testWithPropertyNamingStrategyNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] PropertyNamingStrategy pns = PropertyNamingStrategy.SNAKE_CASE; [EOL] SerializationConfig newConfig = config.with(pns); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(pns, newConfig.getPropertyNamingStrategy()); [EOL] }
public void testWithPropertyNamingStrategyNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] SerializationConfig newConfig = config.with((PropertyNamingStrategy) null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertNull(newConfig.getPropertyNamingStrategy()); [EOL] }
public void testWithTimeZoneNull() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] TimeZone tz = null; [EOL] SerializationConfig newConfig = config.with(tz); [EOL] assertNotNull(newConfig); [EOL] assertNull(newConfig.getTimeZone()); [EOL] }
public void testWithTimeZoneNonNull() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] SerializationConfig newConfig = config.with(tz); [EOL] assertNotNull(newConfig); [EOL] assertEquals(tz, newConfig.getTimeZone()); [EOL] }
public void testToString() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization parameters [EOL] String result = config.toString(); [EOL] assertTrue(result.startsWith("[SerializationConfig: flags=0x")); [EOL] assertTrue(result.endsWith("]")); [EOL] }
public void testFindWithUnlistedClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(String.class, "java.lang.String"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithURI() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "java.net.URI"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URIDeserializer); [EOL] }
public void testFindWithURL() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URL.class, "java.net.URL"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URLDeserializer); [EOL] }
public void testFindWithFile() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(File.class, "java.io.File"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FileDeserializer); [EOL] }
public void testFindWithUUID() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(UUID.class, "java.util.UUID"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof UUIDDeserializer); [EOL] }
public void testFindWithCurrency() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Currency.class, "java.util.Currency"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CurrencyDeserializer); [EOL] }
public void testFindWithPattern() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Pattern.class, "java.util.regex.Pattern"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof PatternDeserializer); [EOL] }
public void testFindWithLocale() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Locale.class, "java.util.Locale"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LocaleDeserializer); [EOL] }
public void testFindWithInetAddress() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(InetAddress.class, "java.net.InetAddress"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof InetAddressDeserializer); [EOL] }
public void testFindWithCharset() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Charset.class, "java.nio.charset.Charset"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharsetDeserializer); [EOL] }
public void testFindWithClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Class.class, "java.lang.Class"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ClassDeserializer); [EOL] }
public void testFindWithStackTraceElement() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(StackTraceElement.class, "java.lang.StackTraceElement"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StackTraceElementDeserializer); [EOL] }
public void testFindWithAtomicBoolean() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(AtomicBoolean.class, "java.util.concurrent.atomic.AtomicBoolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof AtomicBooleanDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testURLDeserializerConstructor() { [EOL] URLDeserializer deserializer = new URLDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeValidUrl() throws IOException { [EOL] String validUrl = "http://www.example.com"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] URL result = _deserialize(validUrl, ctxt); [EOL] assertEquals(new URL(validUrl), result); [EOL] }
public void testDeserializeInvalidUrl() { [EOL] String invalidUrl = "invalid_url"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] try { [EOL] _deserialize(invalidUrl, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCharsetDeserializer() { [EOL] CharsetDeserializer deserializer = new CharsetDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeValidCharset() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CharsetDeserializer deserializer = new CharsetDeserializer(); [EOL] Charset result = deserializer._deserialize("UTF-8", ctxt); [EOL] assertEquals(Charset.forName("UTF-8"), result); [EOL] }
public void testDeserializeInvalidCharset() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CharsetDeserializer deserializer = new CharsetDeserializer(); [EOL] try { [EOL] deserializer._deserialize("INVALID_CHARSET", ctxt); [EOL] fail("Expected IOException for invalid charset"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithNumericShape() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.NUMBER); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumericSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithPattern() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn("yyyy-MM-dd"); [EOL] when(format.getLocale()).thenReturn(null); [EOL] when(prov.getLocale()).thenReturn(Locale.US); [EOL] when(format.getTimeZone()).thenReturn(null); [EOL] when(prov.getTimeZone()).thenReturn(TimeZone.getTimeZone("UTC")); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PatternSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithTimeZone() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] DateFormat stdDateFormat = mock(StdDateFormat.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn(""); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("UTC")); [EOL] when(prov.getConfig().getDateFormat()).thenReturn(stdDateFormat); [EOL] when(stdDateFormat.getClass()).thenReturn(StdDateFormat.class); [EOL] when(StdDateFormat.getISO8601Format(any(TimeZone.class))).thenReturn(stdDateFormat); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullFormat() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(prov, null); [EOL] assertSame(this, result); [EOL] }
public void testGetAnnotationWithValidClass() { [EOL] Annotation expectedAnnotation = mock(Annotation.class); [EOL] when(_annotated.getAnnotation(Annotation.class)).thenReturn(expectedAnnotation); [EOL] Annotation result = instance.getAnnotation(Annotation.class); [EOL] assertEquals(expectedAnnotation, result); [EOL] }
public void testGetAnnotationWithNullClass() { [EOL] try { [EOL] instance.getAnnotation(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveWithCanCreateFromObjectWithAndExternalProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(_valueInstantiator.getFromObjectArguments(any())).thenReturn(creatorProps); [EOL] when(_propertyBasedCreator.properties()).thenReturn(creatorProps); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.hasValueTypeDeserializer()).thenReturn(true); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(prop.getValueTypeDeserializer()).thenReturn(typeDeser); [EOL] when(typeDeser.getTypeInclusion()).thenReturn(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] resolve(ctxt); [EOL] assertNotNull(_externalTypeIdHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] assertFalse(_vanillaProcessing); [EOL] }
public void testResolveWithCanCreateFromObjectWithAndNonExternalProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(_valueInstantiator.getFromObjectArguments(any())).thenReturn(creatorProps); [EOL] when(_propertyBasedCreator.properties()).thenReturn(creatorProps); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.hasValueTypeDeserializer()).thenReturn(true); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(prop.getValueTypeDeserializer()).thenReturn(typeDeser); [EOL] when(typeDeser.getTypeInclusion()).thenReturn(JsonTypeInfo.As.PROPERTY); [EOL] resolve(ctxt); [EOL] assertNull(_externalTypeIdHandler); [EOL] assertFalse(_nonStandardCreation); [EOL] assertTrue(_vanillaProcessing); [EOL] }
public void testResolveWithUnwrappedProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] SettableBeanProperty origProp = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty unwrappedProp = mock(SettableBeanProperty.class); [EOL] when(_beanProperties.iterator()).thenReturn(Arrays.asList(origProp).iterator()); [EOL] when(_resolveUnwrappedProperty(ctxt, origProp)).thenReturn(unwrappedProp); [EOL] resolve(ctxt); [EOL] assertNotNull(_unwrappedPropertyHandler); [EOL] assertTrue(_nonStandardCreation); [EOL] assertFalse(_vanillaProcessing); [EOL] }
public void testResolveWithDelegateTypeNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any())).thenReturn(null); [EOL] assertThrows(IllegalArgumentException.class, () -> resolve(ctxt)); [EOL] }
public void testResolveWithValidDelegateType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(_valueInstantiator.getDelegateType(any())).thenReturn(delegateType); [EOL] AnnotatedWithParams delegateCreator = mock(AnnotatedWithParams.class); [EOL] when(_valueInstantiator.getDelegateCreator()).thenReturn(delegateCreator); [EOL] resolve(ctxt); [EOL] assertNotNull(_delegateDeserializer); [EOL] }
public void testResolveWithAnySetterWithoutValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_anySetter.hasValueDeserializer()).thenReturn(false); [EOL] resolve(ctxt); [EOL] assertNotNull(_anySetter); [EOL] }
public void testResolveWithAllPropertiesHavingValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] SettableBeanProperty origProp = mock(SettableBeanProperty.class); [EOL] when(origProp.hasValueDeserializer()).thenReturn(true); [EOL] when(_beanProperties.iterator()).thenReturn(Arrays.asList(origProp).iterator()); [EOL] resolve(ctxt); [EOL] assertNull(_externalTypeIdHandler); [EOL] assertNull(_unwrappedPropertyHandler); [EOL] assertTrue(_vanillaProcessing); [EOL] }
public void testResolveManagedReferencePropertyWithNullRefName() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNullRefName(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertSame("Expected the same property to be returned when refName is null", prop, result); [EOL] } [EOL] public void testResolveManagedReferencePropertyWithBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializerBase(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Expected a non-null property when BeanDeserializerBase is used", result); [EOL] assertTrue("Expected result to be an instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndInvalidContentDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithContainerDeserializerBase(); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithContainerDeserializerBaseAndBeanDeserializerBase(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Expected a non-null property when ContainerDeserializerBase with BeanDeserializerBase is used", result); [EOL] assertTrue("Expected result to be an instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithAbstractDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithAbstractDeserializer(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Expected a non-null property when AbstractDeserializer is used", result); [EOL] assertTrue("Expected result to be an instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithInvalidDeserializerType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithInvalidDeserializerType(); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithNoBackReferenceProperty() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNoBackReferenceProperty(); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("Expected IllegalArgumentException to be thrown for no back reference property"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithIncompatibleTypes() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithIncompatibleTypes(); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("Expected IllegalArgumentException to be thrown for incompatible types"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveInnerClassValuedPropertyWithNonBeanDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNonBeanDeserializer(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when deserializer is not BeanDeserializerBase", prop, result); [EOL] } [EOL] public void testResolveInnerClassValuedPropertyWithBeanDeserializerButNoDefaultCreator() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializerNoDefaultCreator(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when ValueInstantiator cannot create using default", prop, result); [EOL] } [EOL] public void testResolveInnerClassValuedPropertyWithBeanDeserializerAndDefaultCreator() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializerAndDefaultCreator(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when no enclosing class matches", prop, result); [EOL] } [EOL] public void testResolveInnerClassValuedPropertyWithEnclosingClassMatch() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithEnclosingClassMatch(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertNotSame("Property should change when enclosing class matches", prop, result); [EOL] assertTrue("Result should be an instance of InnerClassProperty", result instanceof InnerClassProperty); [EOL] } [EOL] public void testResolveInnerClassValuedPropertyWithEnclosingClassMatchAndAccessibleOverride() { [EOL] DeserializationContext ctxt = createDeserializationContextWithAccessibleOverride(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithEnclosingClassMatch(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertNotSame("Property should change when enclosing class matches and access override is allowed", prop, result); [EOL] assertTrue("Result should be an instance of InnerClassProperty", result instanceof InnerClassProperty); [EOL] }

public void testGetKnownPropertyNamesEmpty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList(), null); [EOL] Collection<Object> names = beanPropertyMap.getKnownPropertyNames(); [EOL] assertTrue(names.isEmpty()); [EOL] }
public void testGetKnownPropertyNamesWithProperties() { [EOL] List<SettableBeanProperty> properties = new ArrayList<>(); [EOL] SettableBeanProperty prop1 = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty prop2 = mock(SettableBeanProperty.class); [EOL] when(prop1.getName()).thenReturn("prop1"); [EOL] when(prop2.getName()).thenReturn("prop2"); [EOL] properties.add(prop1); [EOL] properties.add(prop2); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, properties, null); [EOL] Collection<Object> names = beanPropertyMap.getKnownPropertyNames(); [EOL] assertEquals(2, names.size()); [EOL] assertTrue(names.contains("prop1")); [EOL] assertTrue(names.contains("prop2")); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object delegateDeserializedValue = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateDeserializedValue); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateDeserializedValue)).thenReturn(new Object()); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_delegateDeserializer).deserialize(jp, ctxt); [EOL] verify(_valueInstantiator).createUsingDelegate(ctxt, delegateDeserializedValue); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] when(_propertyBasedCreator).thenReturn(propertyBasedCreator); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_propertyBasedCreator).deserializeFromObject(jp, ctxt); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithAbstractBeanType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] when(_beanType.toString()).thenReturn("abstractBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] String expectedMessage = "Can not instantiate abstract type abstractBeanType (need to add/enable type information?)"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithNoSuitableConstructor() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_beanType.toString()).thenReturn("noConstructorBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] String expectedMessage = "No suitable constructor found for type noConstructorBeanType: can not instantiate from JSON object (need to add/enable type information?)"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testDeserializeFromNumberWithObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerAndInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] when(_valueInstantiator.createFromInt(ctxt, jp.getIntValue())).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerAndLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] when(_valueInstantiator.createFromLong(ctxt, jp.getLongValue())).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerNoNumberType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new Object()); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromNumberThrowsException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] Exception exception = assertThrows(JsonProcessingException.class, () -> { [EOL] deserializeFromNumber(jp, ctxt); [EOL] }); [EOL] assertNotNull(exception); [EOL] }
public void testConstructWithNullViews() { [EOL] ViewMatcher result = ViewMatcher.construct(null); [EOL] assertTrue(result instanceof ViewMatcher.Empty); [EOL] }
public void testConstructWithEmptyViewsArray() { [EOL] ViewMatcher result = ViewMatcher.construct(new Class<?>[0]); [EOL] assertTrue(result instanceof ViewMatcher.Empty); [EOL] }
public void testConstructWithSingleView() { [EOL] Class<?>[] singleView = {Object.class}; [EOL] ViewMatcher result = ViewMatcher.construct(singleView); [EOL] assertTrue(result instanceof ViewMatcher.Single); [EOL] assertEquals(Object.class, ((ViewMatcher.Single) result).getView()); [EOL] }
public void testConstructWithMultipleViews() { [EOL] Class<?>[] multipleViews = {Object.class, String.class}; [EOL] ViewMatcher result = ViewMatcher.construct(multipleViews); [EOL] assertTrue(result instanceof ViewMatcher.Multi); [EOL] assertArrayEquals(multipleViews, ((ViewMatcher.Multi) result).getViews()); [EOL] }
public void testIsVisibleForView() { [EOL] MyVisibilityChecker checker = new MyVisibilityChecker(); [EOL] boolean result = checker.isVisibleForView(SomeViewClass.class); [EOL] assertFalse(result); [EOL] }
public void testSingleConstructorWithNonNullClass() { [EOL] Class<?> viewClass = Object.class; [EOL] Single singleInstance = new Single(viewClass); [EOL] assertNotNull(singleInstance); [EOL] assertEquals(viewClass, singleInstance._view); [EOL] }
public void testSingleConstructorWithNullClass() { [EOL] Single singleInstance = new Single(null); [EOL] assertNotNull(singleInstance); [EOL] assertNull(singleInstance._view); [EOL] }
public void testIsVisibleForView_SameClass() { [EOL] VisibilityChecker checker = new VisibilityChecker(SomeViewClass.class); [EOL] boolean result = checker.isVisibleForView(SomeViewClass.class); [EOL] assert result; [EOL] } [EOL] public void testIsVisibleForView_Subclass() { [EOL] VisibilityChecker checker = new VisibilityChecker(SomeViewClass.class); [EOL] boolean result = checker.isVisibleForView(SubclassOfSomeViewClass.class); [EOL] assert result; [EOL] } [EOL] public void testIsVisibleForView_UnrelatedClass() { [EOL] VisibilityChecker checker = new VisibilityChecker(SomeViewClass.class); [EOL] boolean result = checker.isVisibleForView(UnrelatedClass.class); [EOL] assert !result; [EOL] } [EOL] public void testIsVisibleForView_Null() { [EOL] VisibilityChecker checker = new VisibilityChecker(SomeViewClass.class); [EOL] boolean result = checker.isVisibleForView(null); [EOL] assert !result; [EOL] }
public void testJsonNodeDeserializerConstructor() { [EOL] JsonNodeDeserializer deserializer = new JsonNodeDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testGetDeserializerWithObjectNodeClass() { [EOL] JsonDeserializer<? extends JsonNode> deserializer = JacksonDatabind.getDeserializer(ObjectNode.class); [EOL] assertTrue(deserializer instanceof ObjectDeserializer); [EOL] }
public void testGetDeserializerWithArrayNodeClass() { [EOL] JsonDeserializer<? extends JsonNode> deserializer = JacksonDatabind.getDeserializer(ArrayNode.class); [EOL] assertTrue(deserializer instanceof ArrayDeserializer); [EOL] }
public void testGetDeserializerWithOtherNodeClass() { [EOL] JsonDeserializer<? extends JsonNode> deserializer = JacksonDatabind.getDeserializer(JsonNode.class); [EOL] assertNotNull(deserializer); [EOL] assertFalse(deserializer instanceof ObjectDeserializer); [EOL] assertFalse(deserializer instanceof ArrayDeserializer); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] JsonNodeDeserializer deserializer = new JsonNodeDeserializer(); [EOL] JsonNode result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt).getNodeFactory(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] JsonNodeDeserializer deserializer = new JsonNodeDeserializer(); [EOL] JsonNode result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt).getNodeFactory(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithOtherToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] JsonNodeDeserializer deserializer = new JsonNodeDeserializer(); [EOL] JsonNode result = deserializer.deserialize(jp, ctxt); [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt).getNodeFactory(); [EOL] assertNotNull(result); [EOL] }
It appears that the provided input text is for a constructor of an `ObjectDeserializer` class that is empty. Since the constructor does not contain any executable lines of code other than the constructor declaration itself, there is no logic to test within this constructor. Therefore, no unit test cases can be generated that would cover any lines of code, as there are no lines of executable code present. [EOL] However, if you would like to see a template for how a test case might look for a non-empty constructor or method, please let me know, and I can provide an example based on a hypothetical scenario.
public void testGetInstance() { [EOL] ObjectDeserializer instance1 = ObjectDeserializer.getInstance(); [EOL] assertNotNull(instance1); [EOL] ObjectDeserializer instance2 = ObjectDeserializer.getInstance(); [EOL] assertSame(instance1, instance2); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] ObjectNode result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(ctxt.getNodeFactory()).thenReturn(nodeFactory); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] ObjectNode result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testBaseNodeDeserializerConstructor() { [EOL] BaseNodeDeserializer deserializer = new BaseNodeDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(JsonNode.class, deserializer.handledType()); [EOL] }
public void testDeserializeObjectWithStartObjectToken() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("field"); [EOL] when(jp.getText()).thenReturn("value"); [EOL] ObjectNode result = deserializeObject(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("field").asText()); [EOL] }
public void testDeserializeObjectWithStartArrayToken() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.START_ARRAY).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("array"); [EOL] ArrayNode arrayNode = nodeFactory.arrayNode(); [EOL] when(deserializeArray(jp, ctxt, nodeFactory)).thenReturn(arrayNode); [EOL] ObjectNode result = deserializeObject(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertEquals(arrayNode, result.get("array")); [EOL] }
public void testDeserializeObjectWithNestedObjectToken() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(null).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("nested").thenReturn("field"); [EOL] when(jp.getText()).thenReturn("value"); [EOL] ObjectNode nestedNode = nodeFactory.objectNode(); [EOL] nestedNode.put("field", "value"); [EOL] when(deserializeObject(jp, ctxt, nodeFactory)).thenReturn(nestedNode); [EOL] ObjectNode result = deserializeObject(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertEquals(nestedNode, result.get("nested")); [EOL] }
public void testDeserializeObjectWithDuplicateField() throws IOException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("field").thenReturn("field"); [EOL] when(jp.getText()).thenReturn("value1").thenReturn("value2"); [EOL] ObjectNode result = deserializeObject(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertEquals("value2", result.get("field").asText()); [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL] ArrayNode node = nodeFactory.arrayNode(); [EOL] while (true) { [EOL] JsonToken t = jp.nextToken(); [EOL] if (t == null) { [EOL] throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL] } [EOL] switch(t) { [EOL] case START_OBJECT: [EOL] node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case START_ARRAY: [EOL] node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case END_ARRAY: [EOL] return node; [EOL] case VALUE_STRING: [EOL] node.add(nodeFactory.textNode(jp.getText())); [EOL] break; [EOL] default: [EOL] node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL] break; [EOL] } [EOL] } [EOL] }
public void testDeserializeAnyWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void testDeserializeAnyWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(data); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBinary()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectPOJO() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] Object pojo = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(pojo); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isPojo()); [EOL] }
public void testDeserializeAnyWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isTextual()); [EOL] assertEquals("test", result.textValue()); [EOL] }
public void testDeserializeAnyWithValueNumberInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(42); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isInt()); [EOL] assertEquals(42, result.intValue()); [EOL] }
public void testDeserializeAnyWithValueNumberFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(42.0); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isDouble()); [EOL] assertEquals(42.0, result.doubleValue(), 0.0); [EOL] }
public void testDeserializeAnyWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithDefaultCase() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] try { [EOL] deserializeAny(jp, ctxt, nodeFactory); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testMaterializeAbstractTypeWithNonNullConcreteType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] JavaType type = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] DeserializerFactoryConfig factoryConfig = createMockFactoryConfig(); [EOL] AbstractTypeResolver resolver = createMockAbstractTypeResolver(); [EOL] JavaType concreteType = createMockJavaType(); [EOL] when(beanDesc.getType()).thenReturn(type); [EOL] when(factoryConfig.abstractTypeResolvers()).thenReturn(Collections.singletonList(resolver)); [EOL] when(resolver.resolveAbstractType(any(), eq(type))).thenReturn(concreteType); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(factoryConfig); [EOL] JavaType result = factory.materializeAbstractType(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(concreteType, result); [EOL] }
public void testMaterializeAbstractTypeWithNullConcreteType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createMockDeserializationContext(); [EOL] JavaType type = createMockJavaType(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] DeserializerFactoryConfig factoryConfig = createMockFactoryConfig(); [EOL] AbstractTypeResolver resolver = createMockAbstractTypeResolver(); [EOL] when(beanDesc.getType()).thenReturn(type); [EOL] when(factoryConfig.abstractTypeResolvers()).thenReturn(Collections.singletonList(resolver)); [EOL] when(resolver.resolveAbstractType(any(), eq(type))).thenReturn(null); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(factoryConfig); [EOL] JavaType result = factory.materializeAbstractType(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testBuildBeanDeserializerWithAbstractTypeAndCannotInstantiate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(type.isAbstract()).thenReturn(true); [EOL] when(valueInstantiator.canInstantiate()).thenReturn(false); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(builder.buildAbstract()).thenReturn(mock(JsonDeserializer.class)); [EOL] when(builder.build()).thenReturn(null); // to cover else branch [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(null); [EOL] JsonDeserializer<Object> deserializer = factory.buildBeanDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] verify(builder).buildAbstract(); [EOL] verify(builder, never()).build(); [EOL] }
public void testBuildBeanDeserializerWithConcreteType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(type.isAbstract()).thenReturn(false); [EOL] when(valueInstantiator.canInstantiate()).thenReturn(true); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(builder.build()).thenReturn(mock(JsonDeserializer.class)); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(null); [EOL] JsonDeserializer<Object> deserializer = factory.buildBeanDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] verify(builder).build(); [EOL] }
public void testBuildBeanDeserializerWithDeserializerModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(builder.build()).thenReturn(mock(JsonDeserializer.class)); [EOL] when(builder.buildAbstract()).thenReturn(null); // to cover else branch [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = factoryConfig.withDeserializerModifier(modifier); [EOL] when(modifier.updateBuilder(any(), any(), any())).thenReturn(builder); [EOL] when(modifier.modifyDeserializer(any(), any(), any())).thenReturn(mock(JsonDeserializer.class)); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<Object> deserializer = factory.buildBeanDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] verify(modifier).updateBuilder(config, beanDesc, builder); [EOL] verify(modifier).modifyDeserializer(config, beanDesc, deserializer); [EOL] }
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL] final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] boolean ignoreAny = false; [EOL] { [EOL] Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL] if (B != null) { [EOL] ignoreAny = B.booleanValue(); [EOL] builder.setIgnoreUnknownProperties(ignoreAny); [EOL] } [EOL] } [EOL] Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL] for (String propName : ignored) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL] if (anySetter != null) { [EOL] builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL] } [EOL] if (anySetter == null) { [EOL] Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL] if (ignored2 != null) { [EOL] for (String propName : ignored2) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] } [EOL] } [EOL] final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL] List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL] } [EOL] } [EOL] for (BeanPropertyDefinition propDef : propDefs) { [EOL] SettableBeanProperty prop = null; [EOL] if (propDef.hasConstructorParameter()) { [EOL] final String name = propDef.getName(); [EOL] if (creatorProps != null) { [EOL] for (SettableBeanProperty cp : creatorProps) { [EOL] if (name.equals(cp.getName())) { [EOL] prop = cp; [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (prop == null) { [EOL] throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL] } [EOL] builder.addCreatorProperty(prop); [EOL] continue; [EOL] } [EOL] if (propDef.hasSetter()) { [EOL] Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (propDef.hasField()) { [EOL] Type propertyType = propDef.getField().getGenericType(); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL] AnnotatedMethod getter = propDef.getGetter(); [EOL] Class<?> rawPropertyType = getter.getRawType(); [EOL] if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL] prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL] } [EOL] } [EOL] if (prop != null) { [EOL] Class<?>[] views = propDef.findViews(); [EOL] if (views == null) { [EOL] if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL] views = NO_VIEWS; [EOL] } [EOL] } [EOL] prop.setViews(views); [EOL] builder.addProperty(prop); [EOL] } [EOL] } [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL] ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL] HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL] for (BeanPropertyDefinition property : propDefsIn) { [EOL] String name = property.getName(); [EOL] if (ignored.contains(name)) { [EOL] continue; [EOL] } [EOL] if (!property.hasConstructorParameter()) { [EOL] Class<?> rawPropertyType = null; [EOL] if (property.hasSetter()) { [EOL] rawPropertyType = property.getSetter().getRawParameterType(0); [EOL] } else if (property.hasField()) { [EOL] rawPropertyType = property.getField().getRawType(); [EOL] } [EOL] if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL] builder.addIgnorable(name); [EOL] continue; [EOL] } [EOL] } [EOL] result.add(property); [EOL] } [EOL] return result; [EOL] }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL] AnnotatedMember mutator = propDef.getMutator(); [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] mutator.fixAccess(); [EOL] } [EOL] JavaType t0 = beanDesc.resolveType(jdkType); [EOL] BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL] JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL] if (type != t0) { [EOL] property = property.withType(type); [EOL] } [EOL] JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL] type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL] TypeDeserializer typeDeser = type.getTypeHandler(); [EOL] SettableBeanProperty prop; [EOL] if (mutator instanceof AnnotatedMethod) { [EOL] prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL] } else { [EOL] prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL] } [EOL] if (propDeser != null) { [EOL] prop = prop.withValueDeserializer(propDeser); [EOL] } [EOL] AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL] if (ref != null && ref.isManagedReference()) { [EOL] prop.setManagedReferenceName(ref.getName()); [EOL] } [EOL] return prop; [EOL] }
protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException { [EOL] final AnnotatedMethod getter = propDef.getGetter(); [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] getter.fixAccess(); [EOL] } [EOL] JavaType type = getter.getType(beanDesc.bindingsForBeanType()); [EOL] JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter); [EOL] type = modifyTypeByAnnotation(ctxt, getter, type); [EOL] TypeDeserializer typeDeser = type.getTypeHandler(); [EOL] SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), getter); [EOL] if (propDeser != null) { [EOL] prop = prop.withValueDeserializer(propDeser); [EOL] } [EOL] return prop; [EOL] }
public void testSimpleFilterProviderConstructor() { [EOL] SimpleFilterProvider filterProvider = new SimpleFilterProvider(); [EOL] assertNotNull(filterProvider); [EOL] assertTrue(filterProvider.getFilterIds().isEmpty()); [EOL] }
public void testSimpleFilterProviderWithNullMap() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(null); [EOL] assertNull(provider.getFilter("anyFilterId")); [EOL] }
public void testSimpleFilterProviderWithEmptyMap() { [EOL] Map<String, BeanPropertyFilter> emptyMap = new HashMap<>(); [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(emptyMap); [EOL] assertNull(provider.getFilter("anyFilterId")); [EOL] }
public void testSimpleFilterProviderWithNonEmptyMap() { [EOL] Map<String, BeanPropertyFilter> map = new HashMap<>(); [EOL] BeanPropertyFilter filter = new BeanPropertyFilter() { [EOL] @Override [EOL] public void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov, PropertyWriter writer) throws Exception { [EOL] } [EOL] }; [EOL] map.put("testFilterId", filter); [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(map); [EOL] assertEquals(filter, provider.getFilter("testFilterId")); [EOL] }
public void testAddFilterWithNonNullIdAndFilter() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] String id = "testFilterId"; [EOL] SimpleFilterProvider result = provider.addFilter(id, filter); [EOL] assertEquals(provider, result); [EOL] assertTrue(provider.hasFilter(id)); [EOL] assertEquals(filter, provider.findFilter(id)); [EOL] }
public void testAddFilterWithNullId() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] String id = null; [EOL] try { [EOL] provider.addFilter(id, filter); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAddFilterWithNullFilter() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = null; [EOL] String id = "testFilterId"; [EOL] SimpleFilterProvider result = provider.addFilter(id, filter); [EOL] assertEquals(provider, result); [EOL] assertNull(provider.findFilter(id)); [EOL] }
public void testFindFilterWithExistingId() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] provider.addFilter("existingFilterId", filter); [EOL] BeanPropertyFilter result = provider.findFilter("existingFilterId"); [EOL] assertNotNull(result); [EOL] assertEquals(filter, result); [EOL] }
public void testFindFilterWithDefaultFilter() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter defaultFilter = mock(BeanPropertyFilter.class); [EOL] provider.setDefaultFilter(defaultFilter); [EOL] BeanPropertyFilter result = provider.findFilter("nonExistingFilterId"); [EOL] assertNotNull(result); [EOL] assertEquals(defaultFilter, result); [EOL] }
public void testFindFilterWithUnknownIdAndFailOnUnknownIdTrue() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] provider.setFailOnUnknownId(true); [EOL] try { [EOL] provider.findFilter("unknownFilterId"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithType_NewType() { [EOL] String name = "testName"; [EOL] JavaType originalType = new SimpleType(String.class); [EOL] JavaType newType = new SimpleType(Integer.class); [EOL] PropertyName wrapperName = new PropertyName("wrapper"); [EOL] AnnotationIntrospector ai = new JacksonAnnotationIntrospector(); [EOL] AnnotatedMember member = null; [EOL] boolean isRequired = false; [EOL] Std originalStd = new Std(name, originalType, wrapperName, ai, member, isRequired); [EOL] Std resultStd = originalStd.withType(newType); [EOL] assertNotNull(resultStd); [EOL] assertEquals(newType, resultStd.getType()); [EOL] assertEquals(name, resultStd.getName()); [EOL] assertEquals(wrapperName, resultStd.getWrapperName()); [EOL] assertEquals(ai, resultStd.getContextAnnotations()); [EOL] assertEquals(member, resultStd.getMember()); [EOL] assertEquals(isRequired, resultStd.isRequired()); [EOL] }
public void testSerializeWithType_NullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] new TestSerializer().serializeWithType(null, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(null, mockJsonGenerator); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(null, mockJsonGenerator); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] Object value = new Object(); [EOL] new TestSerializer().serializeWithType(value, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeObject(value); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(value, mockJsonGenerator); [EOL] }
public void testWithAlwaysAsIdWhenNewStateIsSame() { [EOL] ObjectIdWriter original = new ObjectIdWriter(null, null, null, null, true); [EOL] ObjectIdWriter result = original.withAlwaysAsId(true); [EOL] assertSame(original, result); [EOL] }
public void testWithAlwaysAsIdWhenNewStateIsDifferent() { [EOL] ObjectIdWriter original = new ObjectIdWriter(null, null, null, null, false); [EOL] ObjectIdWriter result = original.withAlwaysAsId(true); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertTrue(result.alwaysAsId); [EOL] }
public void testMapConstructorWithNullNext() { [EOL] Object value = new Object(); [EOL] Object key = new Object(); [EOL] Map result = new Map(null, value, key); [EOL] assertNull(result.next); [EOL] assertEquals(value, result.value); [EOL] assertEquals(key, result._key); [EOL] }
public void testMapConstructorWithNonNullNext() { [EOL] PropertyValue next = new PropertyValue(null, new Object(), new Object()); [EOL] Object value = new Object(); [EOL] Object key = new Object(); [EOL] Map result = new Map(next, value, key); [EOL] assertEquals(next, result.next); [EOL] assertEquals(value, result.value); [EOL] assertEquals(key, result._key); [EOL] }
public void testAssignWithValidMap() throws IOException, JsonProcessingException { [EOL] Map<Object, Object> bean = new HashMap<>(); [EOL] Object _key = "testKey"; [EOL] Object value = "testValue"; [EOL] YourClass instance = new YourClass(_key, value); [EOL] instance.assign(bean); [EOL] assertEquals("The value should be put in the map", value, bean.get(_key)); [EOL] }
public void testAssignWithInvalidType() { [EOL] Object bean = new Object(); // Not a map [EOL] Object _key = "testKey"; [EOL] Object value = "testValue"; [EOL] YourClass instance = new YourClass(_key, value); [EOL] try { [EOL] instance.assign(bean); [EOL] fail("Expected IOException or JsonProcessingException"); [EOL] } catch (IOException | JsonProcessingException e) { [EOL] } [EOL] }
public void testBasicSerializerFactoryWithNullConfig() { [EOL] BasicSerializerFactory factory = new BasicSerializerFactory(null); [EOL] assertNotNull(factory); [EOL] assertNotNull(factory.getFactoryConfig()); [EOL] assertTrue(factory.getFactoryConfig() instanceof SerializerFactoryConfig); [EOL] }
public void testBasicSerializerFactoryWithNonNullConfig() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] BasicSerializerFactory factory = new BasicSerializerFactory(config); [EOL] assertNotNull(factory); [EOL] assertSame(config, factory.getFactoryConfig()); [EOL] }
public void testWithSerializerModifier_NullModifier() { [EOL] SerializerFactory factory = new CustomSerializerFactory(); [EOL] SerializerFactory result = factory.withSerializerModifier(null); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testWithSerializerModifier_NonNullModifier() { [EOL] SerializerFactory factory = new CustomSerializerFactory(); [EOL] BeanSerializerModifier modifier = new BeanSerializerModifier() { [EOL] }; [EOL] SerializerFactory result = factory.withSerializerModifier(modifier); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testFindSerializerByAnnotationsWithJsonSerializable() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class)JsonSerializable.class); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SerializableSerializer); [EOL] }
public void testFindSerializerByAnnotationsWithJsonValueMethod() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedMethod valueMethod = mock(AnnotatedMethod.class); [EOL] Method m = mock(Method.class); [EOL] when(type.getRawClass()).thenReturn((Class)Object.class); [EOL] when(beanDesc.findJsonValueMethod()).thenReturn(valueMethod); [EOL] when(valueMethod.getAnnotated()).thenReturn(m); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(true); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(findSerializerFromAnnotation(prov, valueMethod)).thenReturn(ser); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonValueSerializer); [EOL] }
public void testFindSerializerByAnnotationsWithNoRelevantAnnotations() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class)Object.class); [EOL] when(beanDesc.findJsonValueMethod()).thenReturn(null); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithInetAddress() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(InetAddress.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof InetAddressSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithTimeZone() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(TimeZone.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithCharset() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.nio.charset.Charset.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof ToStringSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithOptionalStdSerializer() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(SomeClassNotCoveredByAbove.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithNumber() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Number.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof NumberSerializers.NumberSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithEnum() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Enum.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithCalendar() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof CalendarSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithDate() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.util.Date.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof DateSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithNull() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNull(result); [EOL] }
public void testBuildCollectionSerializerWithCustomSerializer() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<Object>() { [EOL] }; [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndEnumSet() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(EnumSet.class, new JavaType(Enum.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, null); [EOL] assertTrue(result instanceof StdContainerSerializers.EnumSetSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndIndexedList() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(ArrayList.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, null); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndStringCollection() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, null); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndOtherCollection() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(Collection.class, new JavaType(Object.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, null); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithModifiers() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new JsonSerializer<Object>() { [EOL] }; [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] _factoryConfig.addSerializerModifier(new BeanSerializerModifier() { [EOL] }); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, true, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL] JsonSerializer<?> ser = null; [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL] JavaType keyType = type.getKeyType(); [EOL] EnumValues enums = null; [EOL] if (keyType.isEnumType()) { [EOL] Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL] enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL] } [EOL] ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL] } else { [EOL] ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL] } [EOL] } [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testBuildArraySerializerWithCustomSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] ArrayType type = new ArrayType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] JsonSerializer<?> result = buildArraySerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CustomSerializer); [EOL] }
public void testBuildArraySerializerWithNullElementValueSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] ArrayType type = new ArrayType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = null; [EOL] JsonSerializer<?> result = buildArraySerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ObjectArraySerializer); [EOL] }
public void testBuildArraySerializerWithStringArray() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] ArrayType type = ArrayType.construct(String[].class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] JsonSerializer<?> result = buildArraySerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringArraySerializer); [EOL] }
public void testBuildArraySerializerWithModifier() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] ArrayType type = new ArrayType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] addSerializerModifier(new CustomModifier()); [EOL] JsonSerializer<?> result = buildArraySerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CustomModifiedSerializer); [EOL] }
public void testBuildIteratorSerializerWithNullContainedType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(List.class, null); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, false); [EOL] assertNotNull(serializer); [EOL] }
public void testBuildIteratorSerializerWithNonNullContainedType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(List.class, String.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, true); [EOL] assertNotNull(serializer); [EOL] }
public void testBuildIteratorSerializerWithStaticTyping() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(List.class, String.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, true); [EOL] assertTrue(serializer instanceof SomeSerializerClass); // Replace with actual expected serializer class [EOL] }
public void testBuildIteratorSerializerWithoutStaticTyping() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = TypeFactory.defaultInstance().constructCollectionType(List.class, String.class); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] JsonSerializer<?> serializer = buildIteratorSerializer(config, type, beanDesc, false); [EOL] assertTrue(serializer instanceof SomeSerializerClass); // Replace with actual expected serializer class [EOL] }
public void testSettableAnyPropertyWithValidArguments() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMethod setter = mock(AnnotatedMethod.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] when(setter.getAnnotated()).thenReturn(mock(Method.class)); [EOL] SettableAnyProperty settableAnyProperty = new SettableAnyProperty(property, setter, type, valueDeser); [EOL] assertNotNull(settableAnyProperty); [EOL] }
public void testSettableAnyPropertyWithNonNullValues() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Method rawSetter = SomeClass.class.getMethod("someMethod", SomeParameter.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] SettableAnyProperty settableAnyProperty = new SettableAnyProperty(property, rawSetter, type, valueDeser); [EOL] assertNotNull(settableAnyProperty); [EOL] assertEquals(property, settableAnyProperty.getProperty()); [EOL] assertEquals(type, settableAnyProperty.getType()); [EOL] assertEquals(rawSetter, settableAnyProperty.getSetter()); [EOL] assertEquals(valueDeser, settableAnyProperty.getValueDeserializer()); [EOL] }
public void testWithValueDeserializer_NewDeserializer() { [EOL] BeanProperty.Std property = new BeanProperty.Std( [EOL] new PropertyName("test"), [EOL] TypeFactory.defaultInstance().constructType(String.class), [EOL] null, [EOL] null [EOL] ); [EOL] AnnotatedMethod setter = null; // Assuming we have a setter method [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<Object> originalDeserializer = new StdDeserializer.StringDeserializer(); [EOL] SettableAnyProperty original = new SettableAnyProperty(property, setter, type, originalDeserializer); [EOL] JsonDeserializer<Object> newDeserializer = new StdDeserializer.IntegerDeserializer(); [EOL] SettableAnyProperty result = original.withValueDeserializer(newDeserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(newDeserializer, result.getValueDeserializer()); [EOL] }
public void testWithValueDeserializer_SameDeserializer() { [EOL] BeanProperty.Std property = new BeanProperty.Std( [EOL] new PropertyName("test"), [EOL] TypeFactory.defaultInstance().constructType(String.class), [EOL] null, [EOL] null [EOL] ); [EOL] AnnotatedMethod setter = null; // Assuming we have a setter method [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<Object> deserializer = new StdDeserializer.StringDeserializer(); [EOL] SettableAnyProperty original = new SettableAnyProperty(property, setter, type, deserializer); [EOL] SettableAnyProperty result = original.withValueDeserializer(deserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(deserializer, result.getValueDeserializer()); [EOL] }
public void testGetProperty() { [EOL] BeanProperty expectedProperty = new BeanProperty(); [EOL] BeanPropertyContainer container = new BeanPropertyContainer(expectedProperty); [EOL] BeanProperty actualProperty = container.getProperty(); [EOL] assertSame("The returned property should be the same as the one set in constructor", expectedProperty, actualProperty); [EOL] }
public void testHasValueDeserializerWhenDeserializerIsNull() { [EOL] instance._valueDeserializer = null; // Set the value deserializer to null [EOL] boolean result = instance.hasValueDeserializer(); [EOL] assert !result; // Assert that the result should be false when deserializer is null [EOL] }
public void testHasValueDeserializerWhenDeserializerIsNotNull() { [EOL] instance._valueDeserializer = new SomeValueDeserializer(); // Set the value deserializer to a non-null value [EOL] boolean result = instance.hasValueDeserializer(); [EOL] assert result; // Assert that the result should be true when deserializer is not null [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType expectedType = // initialize with an expected JavaType [EOL] instance._type = expectedType; // assuming _type can be accessed or use a constructor/setter if available [EOL] JavaType result = instance.getType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testDeserializeAndSetWithValidInput() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] String propName = "propertyName"; [EOL] Object value = new Object(); [EOL] PropertyBasedCreatorTest target = new PropertyBasedCreatorTest(); [EOL] when(target.deserialize(jp, ctxt)).thenReturn(value); [EOL] target.deserializeAndSet(jp, ctxt, instance, propName); [EOL] verify(target).set(instance, propName, value); [EOL] }
public void testDeserializeAndSetWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] String propName = "propertyName"; [EOL] PropertyBasedCreatorTest target = new PropertyBasedCreatorTest(); [EOL] when(target.deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] try { [EOL] target.deserializeAndSet(jp, ctxt, instance, propName); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeAndSetWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] String propName = "propertyName"; [EOL] PropertyBasedCreatorTest target = new PropertyBasedCreatorTest(); [EOL] when(target.deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("") {}); [EOL] try { [EOL] target.deserializeAndSet(jp, ctxt, instance, propName); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDeserializer = mock(JsonDeserializer.class); [EOL] Object expected = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(valueDeserializer.deserialize(jp, ctxt)).thenReturn(expected); [EOL] _valueDeserializer = valueDeserializer; // Assuming _valueDeserializer is accessible [EOL] Object result = deserialize(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testSetWithValidArguments() throws IOException { [EOL] MyClass instance = new MyClass(); [EOL] String propName = "propertyName"; [EOL] Object value = "propertyValue"; [EOL] set(instance, propName, value); [EOL] assertEquals("propertyValue", instance.getPropertyName()); [EOL] }
public void testSetWithInvalidArguments() { [EOL] MyClass instance = new MyClass(); [EOL] String propName = "invalidPropertyName"; [EOL] Object value = "propertyValue"; [EOL] try { [EOL] set(instance, propName, value); [EOL] fail("IOException expected for invalid property name"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSetWithNullInstance() { [EOL] MyClass instance = null; [EOL] String propName = "propertyName"; [EOL] Object value = "propertyValue"; [EOL] try { [EOL] set(instance, propName, value); [EOL] fail("IOException expected for null instance"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testConstructWithoutSuperTypesWithNonNullParams() { [EOL] Class<?> cls = Object.class; [EOL] AnnotationIntrospector aintr = mock(AnnotationIntrospector.class); [EOL] MixInResolver mir = mock(MixInResolver.class); [EOL] AnnotatedClass annotatedClass = AnnotatedClass.constructWithoutSuperTypes(cls, aintr, mir); [EOL] assertNotNull(annotatedClass); [EOL] assertEquals(cls, annotatedClass.getRawType()); [EOL] assertEquals(aintr, annotatedClass.getAnnotationIntrospector()); [EOL] assertEquals(mir, annotatedClass.getMixInResolver()); [EOL] }
public void testConstructWithoutSuperTypesWithNullParams() { [EOL] Class<?> cls = Object.class; [EOL] AnnotatedClass annotatedClass = AnnotatedClass.constructWithoutSuperTypes(cls, null, null); [EOL] assertNotNull(annotatedClass); [EOL] assertEquals(cls, annotatedClass.getRawType()); [EOL] assertNull(annotatedClass.getAnnotationIntrospector()); [EOL] assertNull(annotatedClass.getMixInResolver()); [EOL] }
public void testResolveCreatorsWithNoDeclaredConstructorsAndNoDeclaredMethods() { [EOL] _class = SomeClassWithNoDeclaredConstructorsOrMethods.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospector(); [EOL] resolveCreators(); [EOL] assertNull(_defaultConstructor, "Default constructor should be null"); [EOL] assertTrue(_constructors.isEmpty(), "Constructors list should be empty"); [EOL] assertTrue(_creatorMethods.isEmpty(), "Creator methods list should be empty"); [EOL] assertTrue(_creatorsResolved, "Creators should be marked as resolved"); [EOL] }
public void testResolveCreatorsWithDefaultConstructorOnly() { [EOL] _class = SomeClassWithDefaultConstructorOnly.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospector(); [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor, "Default constructor should not be null"); [EOL] assertTrue(_constructors.isEmpty(), "Constructors list should be empty"); [EOL] assertTrue(_creatorMethods.isEmpty(), "Creator methods list should be empty"); [EOL] assertTrue(_creatorsResolved, "Creators should be marked as resolved"); [EOL] }
public void testResolveCreatorsWithMultipleConstructorsIncludingDefault() { [EOL] _class = SomeClassWithMultipleConstructorsIncludingDefault.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospector(); [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor, "Default constructor should not be null"); [EOL] assertFalse(_constructors.isEmpty(), "Constructors list should not be empty"); [EOL] assertTrue(_creatorMethods.isEmpty(), "Creator methods list should be empty"); [EOL] assertTrue(_creatorsResolved, "Creators should be marked as resolved"); [EOL] }
public void testResolveCreatorsWithStaticMethodsOnly() { [EOL] _class = SomeClassWithStaticMethodsOnly.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospector(); [EOL] resolveCreators(); [EOL] assertNull(_defaultConstructor, "Default constructor should be null"); [EOL] assertTrue(_constructors.isEmpty(), "Constructors list should be empty"); [EOL] assertFalse(_creatorMethods.isEmpty(), "Creator methods list should not be empty"); [EOL] assertTrue(_creatorsResolved, "Creators should be marked as resolved"); [EOL] }
public void testResolveCreatorsWithAnnotatedConstructorsAndMethods() { [EOL] _class = SomeClassWithAnnotatedConstructorsAndMethods.class; [EOL] _constructConstructor = mockConstructorCreationMethod(); [EOL] _constructCreatorMethod = mockCreatorMethodCreationMethod(); [EOL] _annotationIntrospector = mockAnnotationIntrospector(); [EOL] when(_annotationIntrospector.hasIgnoreMarker(any(AnnotatedConstructor.class))).thenReturn(true); [EOL] when(_annotationIntrospector.hasIgnoreMarker(any(AnnotatedMethod.class))).thenReturn(true); [EOL] resolveCreators(); [EOL] assertNull(_defaultConstructor, "Default constructor should be null after being ignored"); [EOL] assertTrue(_constructors.isEmpty(), "Constructors list should be empty after ignoring annotated ones"); [EOL] assertTrue(_creatorMethods.isEmpty(), "Creator methods list should be empty after ignoring annotated ones"); [EOL] assertTrue(_creatorsResolved, "Creators should be marked as resolved"); [EOL] }
public void testBaseTypeNameWithNonNullBaseType() { [EOL] BaseType baseType = mock(BaseType.class); [EOL] when(baseType.getRawClass()).thenReturn(String.class); [EOL] TargetClass target = new TargetClass(baseType); [EOL] String result = target.baseTypeName(); [EOL] assertEquals("java.lang.String", result); [EOL] }
public void testBaseTypeNameWithNullBaseType() { [EOL] TargetClass target = new TargetClass(null); [EOL] try { [EOL] target.baseTypeName(); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testResolveAbstractTypeReturnsNull() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] JavaType type = new JavaType(); [EOL] assertNull(resolveAbstractType(config, type)); [EOL] }
public void testSqlDateSerializerConstructor() { [EOL] SqlDateSerializer serializer = new SqlDateSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(java.sql.Date.class, serializer.handledType()); [EOL] }
public void testSerializeSqlDate() throws IOException { [EOL] java.sql.Date value = new java.sql.Date(System.currentTimeMillis()); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new StdSerializer<java.sql.Date>(java.sql.Date.class) { [EOL] @Override [EOL] public void serialize(java.sql.Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException { [EOL] jgen.writeString(value.toString()); [EOL] } [EOL] }.serialize(value, jgen, provider); [EOL] verify(jgen).writeString(anyString()); [EOL] }
public String idFromValueAndTypeTestWithValueAndType() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Object value = new Object(); [EOL] Class<?> type = value.getClass(); [EOL] String result = resolver.idFromValueAndType(value, type); [EOL] assertNotNull(result); [EOL] assertEquals(result, resolver._idFrom(value, type)); [EOL] }
public String idFromValueAndTypeTestWithNullValue() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Class<?> type = Object.class; [EOL] String result = resolver.idFromValueAndType(null, type); [EOL] assertNotNull(result); [EOL] assertEquals(result, resolver._idFrom(null, type)); [EOL] }
public String idFromValueAndTypeTestWithNullType() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Object value = new Object(); [EOL] String result = resolver.idFromValueAndType(value, null); [EOL] assertNotNull(result); [EOL] assertEquals(result, resolver._idFrom(value, null)); [EOL] }
public void testBuildWriterWithContentTypeSerializerNull() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(declaredType.getContentType()).thenReturn(null); [EOL] when(propDef.getName()).thenReturn("testProperty"); [EOL] try { [EOL] buildWriter(propDef, declaredType, ser, typeSer, mock(TypeSerializer.class), am, true); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testBuildWriterWithSerializationInclusionNonNull() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getName()).thenReturn("testProperty"); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, true); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithSerializationInclusionNonDefault() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getName()).thenReturn("testProperty"); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, false); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithSerializationInclusionNonEmpty() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getName()).thenReturn("testProperty"); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, true); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithUnwrappingNameTransformer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getName()).thenReturn("testProperty"); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] when(_annotationIntrospector.findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, null, am, true); [EOL] assertNotNull(writer); [EOL] assertTrue(writer.isUnwrapping()); [EOL] }
public void testInnerClassPropertyWithNonNullValues() { [EOL] SettableBeanProperty delegate = mock(SettableBeanProperty.class); [EOL] Constructor<?> ctor = mock(Constructor.class); [EOL] InnerClassProperty innerClassProperty = new InnerClassProperty(delegate, ctor); [EOL] assertNotNull(innerClassProperty); [EOL] assertSame(delegate, innerClassProperty._delegate); [EOL] assertSame(ctor, innerClassProperty._creator); [EOL] }
public void testDeserializeAndSetWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] new TestSetter().deserializeAndSet(jp, ctxt, bean); [EOL] }
public void testDeserializeAndSetWithValueTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Assuming NOT_AVAILABLE is not VALUE_NULL [EOL] ValueTypeDeserializer vtd = mock(ValueTypeDeserializer.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] TestSetter setter = new TestSetter(vd, vtd, null); [EOL] setter.deserializeAndSet(jp, ctxt, bean); [EOL] }
public void testDeserializeAndSetWithExceptionInCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Assuming NOT_AVAILABLE is not VALUE_NULL [EOL] Creator creator = mock(Creator.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] when(creator.newInstance(bean)).thenThrow(new Exception("Test exception")); [EOL] TestSetter setter = new TestSetter(vd, null, creator); [EOL] try { [EOL] setter.deserializeAndSet(jp, ctxt, bean); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeAndSetWithSuccessfulCreation() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Object createdValue = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Assuming NOT_AVAILABLE is not VALUE_NULL [EOL] Creator creator = mock(Creator.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] when(creator.newInstance(bean)).thenReturn(createdValue); [EOL] TestSetter setter = new TestSetter(vd, null, creator); [EOL] setter.deserializeAndSet(jp, ctxt, bean); [EOL] }
public void testSetWithValidInstanceAndValue() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Delegate delegate = mock(Delegate.class); [EOL] ConcreteClass concreteClass = new ConcreteClass(delegate); [EOL] concreteClass.set(instance, value); [EOL] verify(delegate).set(instance, value); [EOL] }
public void testSetWithIOException() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Delegate delegate = mock(Delegate.class); [EOL] ConcreteClass concreteClass = new ConcreteClass(delegate); [EOL] doThrow(new IOException()).when(delegate).set(any(), any()); [EOL] assertThrows(IOException.class, () -> concreteClass.set(instance, value)); [EOL] }
public void testJsonSchemaWithNullSchema() { [EOL] JsonSchema jsonSchema = new JsonSchema(null); [EOL] assertNull(jsonSchema.getSchema()); [EOL] }
public void testJsonSchemaWithNonNullSchema() { [EOL] ObjectNode schemaNode = JsonNodeFactory.instance.objectNode(); [EOL] schemaNode.put("type", "object"); [EOL] JsonSchema jsonSchema = new JsonSchema(schemaNode); [EOL] assertNotNull(jsonSchema.getSchema()); [EOL] assertEquals(schemaNode, jsonSchema.getSchema()); [EOL] }
public void testGetSchemaNode() { [EOL] YourClass instance = new YourClass(); [EOL] ObjectNode expected = //... initialize expected ObjectNode [EOL] instance.schema = expected; [EOL] ObjectNode result = instance.getSchemaNode(); [EOL] assertEquals(expected, result); [EOL] }
public void testEquals_Reflexive() { [EOL] JsonSchema schema = new JsonSchema(null); [EOL] assertTrue(schema.equals(schema)); [EOL] }
public void testEquals_Null() { [EOL] JsonSchema schema = new JsonSchema(null); [EOL] assertFalse(schema.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] JsonSchema schema = new JsonSchema(null); [EOL] assertFalse(schema.equals(new Object())); [EOL] }
public void testEquals_EqualSchemas() { [EOL] JsonSchema schema1 = new JsonSchema(null); [EOL] JsonSchema schema2 = new JsonSchema(null); [EOL] assertTrue(schema1.equals(schema2)); [EOL] }
public void testEquals_NotEqualSchemas() { [EOL] JsonSchema schema1 = new JsonSchema(new Object()); [EOL] JsonSchema schema2 = new JsonSchema(null); [EOL] assertFalse(schema1.equals(schema2)); [EOL] }
public void testEquals_EqualNonEmptySchemas() { [EOL] Object schemaObject = new Object(); [EOL] JsonSchema schema1 = new JsonSchema(schemaObject); [EOL] JsonSchema schema2 = new JsonSchema(schemaObject); [EOL] assertTrue(schema1.equals(schema2)); [EOL] }
public void testGetDefaultSchemaNode() { [EOL] JsonNode defaultSchemaNode = YourClass.getDefaultSchemaNode(); [EOL] assertTrue(defaultSchemaNode.isObject()); [EOL] assertEquals("any", defaultSchemaNode.get("type").asText()); [EOL] }
public void testWithClassIntrospector_SameInstance() { [EOL] ClassIntrospector ci = new WhateverClassIntrospectorImplementation(); [EOL] BaseSettings baseSettings = new BaseSettings(ci, ...); // other parameters initialized accordingly [EOL] BaseSettings result = baseSettings.withClassIntrospector(ci); [EOL] assertSame(baseSettings, result); [EOL] }
public void testWithClassIntrospector_DifferentInstance() { [EOL] ClassIntrospector originalCi = new WhateverClassIntrospectorImplementation(); [EOL] ClassIntrospector newCi = new DifferentClassIntrospectorImplementation(); [EOL] BaseSettings baseSettings = new BaseSettings(originalCi, ...); // other parameters initialized accordingly [EOL] BaseSettings result = baseSettings.withClassIntrospector(newCi); [EOL] assertNotSame(baseSettings, result); [EOL] assertNotNull(result); [EOL] assertSame(newCi, result.getClassIntrospector()); [EOL] }
public void testWithNullTimeZone() { [EOL] try { [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] settings.with(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithStdDateFormatAndNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, stdDateFormat, null, null, null, null); [EOL] BaseSettings newSettings = settings.with(tz); [EOL] assertNotNull(newSettings); [EOL] DateFormat df = newSettings.getDateFormat(); [EOL] assertTrue(df instanceof StdDateFormat); [EOL] assertEquals(tz, ((StdDateFormat) df).getTimeZone()); [EOL] }
public void testWithNonStdDateFormatAndNonNullTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL] DateFormat nonStdDateFormat = new SimpleDateFormat(); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, nonStdDateFormat, null, null, null, null); [EOL] BaseSettings newSettings = settings.with(tz); [EOL] assertNotNull(newSettings); [EOL] DateFormat df = newSettings.getDateFormat(); [EOL] assertFalse(df instanceof StdDateFormat); [EOL] assertEquals(tz, df.getTimeZone()); [EOL] }
public void testGetLocale() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Locale expectedLocale = Locale.getDefault(); [EOL] mapper.setLocale(expectedLocale); [EOL] Locale actualLocale = mapper.getLocale(); [EOL] assertEquals(expectedLocale, actualLocale); [EOL] }
public void testGetShortBuilder_WhenShortBuilderIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] ShortBuilder result = instance.getShortBuilder(); [EOL] assertNotNull(result); [EOL] ShortBuilder secondCallResult = instance.getShortBuilder(); [EOL] assertSame(result, secondCallResult); [EOL] }
public void testGetShortBuilder_WhenShortBuilderIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] ShortBuilder preCreated = new ShortBuilder(); [EOL] instance.setShortBuilder(preCreated); // Assuming there is a method to set the _shortBuilder field [EOL] ShortBuilder result = instance.getShortBuilder(); [EOL] assertSame(preCreated, result); [EOL] }
public void testGetLongBuilderFirstCall() { [EOL] YourClass instance = new YourClass(); [EOL] LongBuilder result = instance.getLongBuilder(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof LongBuilder); [EOL] }
public void testGetLongBuilderSubsequentCall() { [EOL] YourClass instance = new YourClass(); [EOL] LongBuilder firstCallResult = instance.getLongBuilder(); [EOL] LongBuilder secondCallResult = instance.getLongBuilder(); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public void testGetDoubleBuilder_WhenDoubleBuilderIsNull() { [EOL] YourClass instance = new YourClass(); [EOL] DoubleBuilder result = instance.getDoubleBuilder(); [EOL] assertNotNull(result); [EOL] }
public void testGetDoubleBuilder_WhenDoubleBuilderIsNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] DoubleBuilder initialBuilder = instance.getDoubleBuilder(); // This will create the _doubleBuilder [EOL] DoubleBuilder result = instance.getDoubleBuilder(); // This should return the existing _doubleBuilder [EOL] assertNotNull(result); [EOL] assertSame(initialBuilder, result); // Verify that the same instance is returned [EOL] }
public void testShortBuilderConstructor() { [EOL] ShortBuilder shortBuilder = new ShortBuilder(); [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] final int len = 0; [EOL] short[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testConstructArrayWithPositiveLength() { [EOL] final int len = 10; [EOL] short[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.length); [EOL] }
public void testLongBuilderConstructor() { [EOL] LongBuilder builder = new LongBuilder(); [EOL] assertNotNull(builder); [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] long[] result = _constructArray(0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testConstructArrayWithPositiveLength() { [EOL] int len = 5; [EOL] long[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(len, result.length); [EOL] }
public void testDoubleBuilderConstructor() { [EOL] try { [EOL] DoubleBuilder doubleBuilder = new DoubleBuilder(); [EOL] assertNotNull(doubleBuilder); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] final int len = 0; [EOL] double[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testConstructArrayWithPositiveLength() { [EOL] final int len = 10; [EOL] double[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.length); [EOL] }
public void testGetArrayComparatorWithNonNullArray() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new Integer[] {1, 2, 3}); [EOL] assertTrue(result); [EOL] }
public void testGetArrayComparatorWithDifferentLengthArray() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new Integer[] {1, 2}); [EOL] assertFalse(result); [EOL] }
public void testGetArrayComparatorWithDifferentContentArray() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new Integer[] {1, 2, 4}); [EOL] assertFalse(result); [EOL] }
public void testGetArrayComparatorWithNull() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(null); [EOL] assertFalse(result); [EOL] }
public void testGetArrayComparatorWithDifferentType() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new String[] {"1", "2", "3"}); [EOL] assertFalse(result); [EOL] }
public void testGetArrayComparatorWithSameInstance() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(array); [EOL] assertTrue(result); [EOL] }
public void testGetArrayComparatorWithNullElement() { [EOL] Integer[] array = new Integer[] {1, null, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new Integer[] {1, null, 3}); [EOL] assertTrue(result); [EOL] }
public void testGetArrayComparatorWithNullAndNonNullElement() { [EOL] Integer[] array = new Integer[] {1, null, 3}; [EOL] Object comparator = JacksonDatabindUtils.getArrayComparator(array); [EOL] boolean result = comparator.equals(new Integer[] {1, 2, 3}); [EOL] assertFalse(result); [EOL] }
public void testWithAbstractTypeResolver_ThrowsIllegalArgumentException() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] try { [EOL] config.withAbstractTypeResolver(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null resolver", e.getMessage()); [EOL] } [EOL] }
public void testWithAbstractTypeResolver_Success() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] AbstractTypeResolver resolver = new MyAbstractTypeResolver(); // Assuming MyAbstractTypeResolver implements AbstractTypeResolver [EOL] DeserializerFactoryConfig newConfig = config.withAbstractTypeResolver(resolver); [EOL] assertNotNull(newConfig); [EOL] assertTrue(newConfig.hasAbstractTypeResolvers()); [EOL] }
public void testUnwrappingBeanPropertyWriterWithNonNullUnwrapper() { [EOL] BeanPropertyWriter base = mock(BeanPropertyWriter.class); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(base, unwrapper); [EOL] assertNotNull(writer); [EOL] assertSame(unwrapper, writer._nameTransformer); [EOL] }
public void testUnwrappingBeanPropertyWriterWithNullUnwrapper() { [EOL] BeanPropertyWriter base = mock(BeanPropertyWriter.class); [EOL] UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(base, null); [EOL] assertNotNull(writer); [EOL] assertNull(writer._nameTransformer); [EOL] }
public void testSerializeAsFieldWithNonNullValueAndNoSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter(); [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); // Assuming the value serialized is a String [EOL] }
public void testSerializeAsFieldWithNullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter() { [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return null; [EOL] } [EOL] }; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testSerializeAsFieldWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter() { [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return "suppressibleValue"; [EOL] } [EOL] }; [EOL] writer.setSuppressableValue("suppressibleValue"); [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testSerializeAsFieldWithDynamicSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter() { [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); [EOL] }
public void testSerializeAsFieldWithSelfReference() throws Exception { [EOL] final Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter() { [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return bean; // Self-reference [EOL] } [EOL] }; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); // Assuming the value serialized is a String [EOL] }
public void testSerializeAsFieldWithTypeSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] MyPropertyWriter writer = new MyPropertyWriter() { [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] writer.setTypeSerializer(typeSer); [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); [EOL] }
public void testAssignSerializerWithNonUnwrappingSerializer() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor or a factory method [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] }; [EOL] bpw.assignSerializer(serializer); [EOL] }
public void testAssignSerializerWithUnwrappingSerializer() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor or a factory method [EOL] JsonSerializer<Object> serializer = new UnwrappingBeanSerializer() { [EOL] @Override [EOL] public boolean isUnwrappingSerializer() { [EOL] return true; [EOL] } [EOL] }; [EOL] NameTransformer nameTransformer = new NameTransformer() { [EOL] }; [EOL] bpw.assignSerializer(serializer); [EOL] }
public JsonSerializer<?> createContextual_nullPropertyAndIntr() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextual_withPropertyAndIntr_findPropertiesToIgnore() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextual_withPropertyAndIntr_findObjectIdInfo() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(intr.findObjectReferenceInfo(accessor, objectIdInfo)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextual_withPropertyAndIntr_findObjectIdInfo_PropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(intr.findObjectReferenceInfo(accessor, objectIdInfo)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[]{mock(BeanPropertyWriter.class)}; [EOL] when(props[0].getName()).thenReturn("id"); [EOL] setField(serializer, "_props", props); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextual_withPropertyAndIntr_findObjectIdInfo_OtherGenerator() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(intr.findObjectReferenceInfo(accessor, objectIdInfo)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public JsonSerializer<?> createContextual_withPropertyAndIntr_findFormat() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] JsonSerializer<?> result = serializer.createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testSerializeWithTypeWithObjectId() throws IOException { [EOL] MyBeanSerializer serializer = new MyBeanSerializer(); [EOL] serializer._objectIdWriter = new ObjectIdWriter(); [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] assertTrue(wasSerializeWithObjectIdCalled()); [EOL] }
public void testSerializeWithTypeWithoutObjectIdAndWithoutCustomTypeId() throws IOException { [EOL] MyBeanSerializer serializer = new MyBeanSerializer(); [EOL] serializer._objectIdWriter = null; [EOL] serializer._typeId = null; [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] assertTrue(wasWriteTypePrefixForObjectCalled()); [EOL] assertTrue(wasWriteTypeSuffixForObjectCalled()); [EOL] }
public void testSerializeWithTypeWithoutObjectIdWithCustomTypeId() throws IOException { [EOL] MyBeanSerializer serializer = new MyBeanSerializer(); [EOL] serializer._objectIdWriter = null; [EOL] serializer._typeId = new Object(); // Assuming this will result in a non-null custom type id [EOL] serializer._customTypeId = (bean) -> "customTypeId"; [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] assertTrue(wasWriteCustomTypePrefixForObjectCalled()); [EOL] assertTrue(wasWriteCustomTypeSuffixForObjectCalled()); [EOL] }
public void testSerializeWithTypeWithPropertyFilterId() throws IOException { [EOL] MyBeanSerializer serializer = new MyBeanSerializer(); [EOL] serializer._propertyFilterId = new Object(); // Assuming this will result in filtered serialization [EOL] serializer.serializeWithType(bean, jgen, provider, typeSer); [EOL] assertTrue(wasSerializeFieldsFilteredCalled()); [EOL] }
public void testSerializeWithObjectIdWhenObjectIdWritesAsId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(writableObjectId).writeAsId(jgen, provider, objectIdWriter); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithObjectIdWhenAlwaysAsId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] Object id = new Object(); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(writableObjectId.generateId(bean)).thenReturn(id); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(true); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(objectIdWriter.serializer).serialize(id, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeWithObjectIdWithStartEndObject() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] _serializeWithObjectId(bean, jgen, provider, true); [EOL] verify(jgen).writeStartObject(); [EOL] verify(writableObjectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeWithObjectIdWithoutStartEndObject() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(writableObjectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeWithObjectIdWithPropertyFilterId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_propertyFilterId).thenReturn(new Object()); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(writableObjectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(this).serializeFieldsFiltered(bean, jgen, provider); [EOL] }
public void testSerializeWithObjectIdWithoutPropertyFilterId() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); [EOL] WritableObjectId writableObjectId = mock(WritableObjectId.class); [EOL] when(_objectIdWriter).thenReturn(objectIdWriter); [EOL] when(provider.findObjectId(bean, objectIdWriter.generator)).thenReturn(writableObjectId); [EOL] when(writableObjectId.writeAsId(jgen, provider, objectIdWriter)).thenReturn(false); [EOL] when(objectIdWriter.alwaysAsId).thenReturn(false); [EOL] when(_propertyFilterId).thenReturn(null); [EOL] _serializeWithObjectId(bean, jgen, provider, false); [EOL] verify(writableObjectId).writeAsField(jgen, provider, objectIdWriter); [EOL] verify(this).serializeFields(bean, jgen, provider); [EOL] }
public void testSerializeFieldsFilteredWithActiveViewAndFilter() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] filteredProps[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(filteredProps, null); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] }
public void testSerializeFieldsFilteredWithNoActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(null, props); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(prop).serializeAsField(eq(bean), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsFilteredWithNullFilter() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(null, null); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(serializer).serializeFields(eq(bean), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsFilteredWithException() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] doThrow(new IOException()).when(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(null, props); [EOL] try { [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSerializeFieldsFilteredWithStackOverflowError() { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] doThrow(new StackOverflowError()).when(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(null, props); [EOL] try { [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testFindFilterWithNullFilterProvider() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getFilterProvider()).thenReturn(null); [EOL] try { [EOL] findFilter(provider); [EOL] fail("Should have thrown JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not resolve BeanPropertyFilter with id 'null'; no FilterProvider configured", e.getMessage()); [EOL] } [EOL] }
public void testFindFilterWithNonNullFilterProvider() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] FilterProvider filterProvider = mock(FilterProvider.class); [EOL] BeanPropertyFilter expectedFilter = mock(BeanPropertyFilter.class); [EOL] Object filterId = "filterId"; [EOL] when(provider.getFilterProvider()).thenReturn(filterProvider); [EOL] when(filterProvider.findFilter(filterId)).thenReturn(expectedFilter); [EOL] setPropertyFilterId(filterId); // Assuming there is a method to set _propertyFilterId [EOL] BeanPropertyFilter actualFilter = findFilter(provider); [EOL] assertSame(expectedFilter, actualFilter); [EOL] }
public void testGetSchemaWithAnnotationAndId() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[0]; [EOL] ObjectIdInfo objectIdInfo = null; [EOL] JsonSerializableSchema schemaAnnotation = mock(JsonSerializableSchema.class); [EOL] when(schemaAnnotation.id()).thenReturn("customId"); [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] BeanSerializerBase.class, null, props, null) { [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL] return super.getSchema(provider, typeHint); [EOL] } [EOL] @Override [EOL] protected Class<?> handledType() { [EOL] return BeanSerializerBase.class; [EOL] } [EOL] }; [EOL] BeanSerializerBase.class.getAnnotation(JsonSerializableSchema.class); [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.has("id")); [EOL] assertEquals("customId", schemaNode.get("id").asText()); [EOL] }
public void testGetSchemaWithoutAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[0]; [EOL] ObjectIdInfo objectIdInfo = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] BeanSerializerBase.class, null, props, null) { [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL] return super.getSchema(provider, typeHint); [EOL] } [EOL] @Override [EOL] protected Class<?> handledType() { [EOL] return BeanSerializerBase.class; [EOL] } [EOL] }; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertFalse(schemaNode.has("id")); [EOL] }
public void testGetSchemaWithPropertyFilter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] BeanPropertyWriter propWriter = mock(BeanPropertyWriter.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[]{propWriter}; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] ObjectIdInfo objectIdInfo = null; [EOL] BeanSerializerBase serializer = new BeanSerializerBase( [EOL] BeanSerializerBase.class, null, props, filter) { [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL] return super.getSchema(provider, typeHint); [EOL] } [EOL] @Override [EOL] protected Class<?> handledType() { [EOL] return BeanSerializerBase.class; [EOL] } [EOL] @Override [EOL] protected BeanPropertyFilter findFilter(SerializerProvider provider) { [EOL] return filter; [EOL] } [EOL] }; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] verify(filter).depositSchemaProperty(eq(propWriter), any(ObjectNode.class), eq(provider)); [EOL] }
public void testChangePropertiesReturnsSameList() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyWriter> beanProperties = new ArrayList<>(); [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] beanProperties.add(writer); [EOL] List<BeanPropertyWriter> result = changeProperties(config, beanDesc, beanProperties); [EOL] assertSame("The returned list should be the same as the one passed in", beanProperties, result); [EOL] }
public void testOrderPropertiesWithEmptyList() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyWriter> beanProperties = new ArrayList<>(); [EOL] List<BeanPropertyWriter> result = orderProperties(config, beanDesc, beanProperties); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testOrderPropertiesWithNonEmptyList() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyWriter> beanProperties = new ArrayList<>(); [EOL] beanProperties.add(mock(BeanPropertyWriter.class)); [EOL] List<BeanPropertyWriter> result = orderProperties(config, beanDesc, beanProperties); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(beanProperties.size(), result.size()); [EOL] assertSame(beanProperties.get(0), result.get(0)); [EOL] }
public void testPOJOPropertiesCollectorWithNullMutatorPrefix() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultVisibilityChecker()).thenReturn(mock(VisibilityChecker.class)); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, type, classDef, null); [EOL] assertNotNull(collector); [EOL] assertEquals("set", collector.getMutatorPrefix()); [EOL] assertNotNull(collector.getAnnotationIntrospector()); [EOL] assertNotNull(collector.getVisibilityChecker()); [EOL] }
public void testPOJOPropertiesCollectorWithNonNullMutatorPrefix() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultVisibilityChecker()).thenReturn(mock(VisibilityChecker.class)); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, type, classDef, "add"); [EOL] assertNotNull(collector); [EOL] assertEquals("add", collector.getMutatorPrefix()); [EOL] assertNotNull(collector.getAnnotationIntrospector()); [EOL] assertNotNull(collector.getVisibilityChecker()); [EOL] }
public void testPOJOPropertiesCollectorWithDisabledAnnotationProcessing() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(config.getDefaultVisibilityChecker()).thenReturn(mock(VisibilityChecker.class)); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, type, classDef, "set"); [EOL] assertNotNull(collector); [EOL] assertEquals("set", collector.getMutatorPrefix()); [EOL] assertNull(collector.getAnnotationIntrospector()); [EOL] assertNotNull(collector.getVisibilityChecker()); [EOL] }
public void testGetJsonValueMethodWithNullGetters() { [EOL] assertNull(objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithEmptyGetters() { [EOL] objectUnderTest.setJsonValueGetters(new ArrayList<>()); [EOL] assertNull(objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithOneGetter() { [EOL] List<AnnotatedMethod> getters = new ArrayList<>(); [EOL] AnnotatedMethod getter = mock(AnnotatedMethod.class); [EOL] getters.add(getter); [EOL] objectUnderTest.setJsonValueGetters(getters); [EOL] assertSame(getter, objectUnderTest.getJsonValueMethod()); [EOL] }
public void testGetJsonValueMethodWithMultipleGetters() { [EOL] List<AnnotatedMethod> getters = new ArrayList<>(); [EOL] AnnotatedMethod getter1 = mock(AnnotatedMethod.class); [EOL] AnnotatedMethod getter2 = mock(AnnotatedMethod.class); [EOL] getters.add(getter1); [EOL] getters.add(getter2); [EOL] objectUnderTest.setJsonValueGetters(getters); [EOL] Exception exception = assertThrows(RuntimeException.class, () -> { [EOL] objectUnderTest.getJsonValueMethod(); [EOL] }); [EOL] String expectedMessage = "Multiple value properties defined (" + getter1 + " vs " + getter2 + ")"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
protected Map<String, POJOPropertyBuilder> getPropertyMap() { [EOL] return _properties; [EOL] }
public void testCollectWithNonNullNamingStrategy() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] PropertyNamingStrategy namingStrategy = mock(PropertyNamingStrategy.class); [EOL] when(collector._findNamingStrategy()).thenReturn(namingStrategy); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] verify(collector)._addFields(); [EOL] verify(collector)._addMethods(); [EOL] verify(collector)._addCreators(); [EOL] verify(collector)._addInjectables(); [EOL] verify(collector)._removeUnwantedProperties(); [EOL] verify(collector)._renameProperties(); [EOL] verify(collector)._renameUsing(namingStrategy); [EOL] verify(collector)._sortProperties(); [EOL] assertNotNull(result); [EOL] }
public void testCollectWithNullNamingStrategy() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] when(collector._findNamingStrategy()).thenReturn(null); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] verify(collector)._addFields(); [EOL] verify(collector)._addMethods(); [EOL] verify(collector)._addCreators(); [EOL] verify(collector)._addInjectables(); [EOL] verify(collector)._removeUnwantedProperties(); [EOL] verify(collector)._renameProperties(); [EOL] verify(collector, never())._renameUsing(any(PropertyNamingStrategy.class)); [EOL] verify(collector)._sortProperties(); [EOL] assertNotNull(result); [EOL] }
public void testCollectWithWrapperNameAsPropertyNameEnabled() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] when(collector._config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] verify(collector)._renameWithWrappers(); [EOL] assertNotNull(result); [EOL] }
public void testCollectWithWrapperNameAsPropertyNameDisabled() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] when(collector._config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(false); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] verify(collector, never())._renameWithWrappers(); [EOL] assertNotNull(result); [EOL] }
public void testSortPropertiesWithNullIntrospectorAndConfigSort() { [EOL] _annotationIntrospector = null; [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] Mockito.when(_config.shouldSortPropertiesAlphabetically()).thenReturn(true); [EOL] _classDef = Mockito.mock(AnnotatedClass.class); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] } [EOL] public void testSortPropertiesWithIntrospectorSortAlphaTrue() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.TRUE); [EOL] _classDef = Mockito.mock(AnnotatedClass.class); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] } [EOL] public void testSortPropertiesWithIntrospectorSortAlphaFalseAndNoPropertyOrder() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.FALSE); [EOL] Mockito.when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(null); [EOL] _classDef = Mockito.mock(AnnotatedClass.class); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] } [EOL] public void testSortPropertiesWithPropertyOrder() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] String[] propertyOrder = {"prop1", "prop2"}; [EOL] Mockito.when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(propertyOrder); [EOL] _classDef = Mockito.mock(AnnotatedClass.class); [EOL] _properties = new LinkedHashMap<>(); [EOL] _properties.put("prop2", new POJOPropertyBuilder()); [EOL] _properties.put("prop1", new POJOPropertyBuilder()); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] } [EOL] public void testSortPropertiesWithCreatorProperties() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.FALSE); [EOL] Mockito.when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(null); [EOL] _classDef = Mockito.mock(AnnotatedClass.class); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = new ArrayList<>(); [EOL] POJOPropertyBuilder creatorProp = new POJOPropertyBuilder(); [EOL] _creatorProperties.add(creatorProp); [EOL] _sortProperties(); [EOL] }
public void testAddFieldsWithNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = null; [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] PropertyName propertyName = new PropertyName("test"); [EOL] when(_annotationIntrospector.findNameForSerialization(any(AnnotatedField.class))).thenReturn(propertyName); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndDeserialization() { [EOL] _forSerialization = false; [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] PropertyName propertyName = new PropertyName("test"); [EOL] when(_annotationIntrospector.findNameForDeserialization(any(AnnotatedField.class))).thenReturn(propertyName); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithPruneFinalFields() { [EOL] _forSerialization = false; [EOL] _config = mock(SerializationConfig.class); [EOL] when(_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)).thenReturn(false); [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] AnnotatedField finalField = mock(AnnotatedField.class); [EOL] when(finalField.getModifiers()).thenReturn(Modifier.FINAL); [EOL] when(_classDef.fields()).thenReturn(Collections.singletonList(finalField)); [EOL] when(_annotationIntrospector.hasIgnoreMarker(finalField)).thenReturn(false); [EOL] _addFields(); [EOL] }
public void testAddCreatorsWithNullAnnotationIntrospector() { [EOL] _addCreators(); [EOL] }
public void testAddCreatorsWithConstructors() { [EOL] _addCreators(); [EOL] }
public void testAddCreatorsWithStaticMethods() { [EOL] _addCreators(); [EOL] }
public void testAddCreatorsWithNoNamedParameters() { [EOL] _addCreators(); [EOL] }
public void testAddMethodsWithZeroParameters() { [EOL] initializeTestEnvironment(); // This method should set up _classDef with a method with 0 parameters [EOL] _addMethods(); [EOL] assertTrue("Expected getter method not added", getterMethodsContainsExpectedMethod()); [EOL] } [EOL] public void testAddMethodsWithOneParameter() { [EOL] initializeTestEnvironment(); // This method should set up _classDef with a method with 1 parameter [EOL] _addMethods(); [EOL] assertTrue("Expected setter method not added", setterMethodsContainsExpectedMethod()); [EOL] }
public void testAddMethodsWithTwoParametersWithoutAnnotation() { [EOL] initializeTestEnvironment(); // This method should set up _classDef with a method with 2 parameters without any setter annotation [EOL] _addMethods(); [EOL] assertFalse("Method with 2 parameters without any setter annotation should not be added to any setters", anySettersContainsMethod()); [EOL] } [EOL] public void testAddMethodsWithTwoParametersWithAnnotation() { [EOL] initializeTestEnvironment(); // This method should set up _classDef with a method with 2 parameters with any setter annotation [EOL] _addMethods(); [EOL] assertTrue("Method with 2 parameters and any setter annotation should be added to any setters", anySettersContainsMethod()); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndAnyGetterAnnotation() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] assertNotNull(_anyGetters); [EOL] assertTrue(_anyGetters.contains(m)); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndJsonValueAnnotation() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.hasAsValueAnnotation(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] assertNotNull(_jsonValueGetters); [EOL] assertTrue(_jsonValueGetters.contains(m)); [EOL] }
public void testAddGetterMethodWithNullAnnotationIntrospector() { [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] _addGetterMethod(m, null); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndNameForSerialization() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] PropertyName pn = new PropertyName("testName"); [EOL] Mockito.when(ai.findNameForSerialization(m)).thenReturn(pn); [EOL] _addGetterMethod(m, ai); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndIgnoreMarker() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasIgnoreMarker(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL] String implName; [EOL] boolean visible; [EOL] PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL] String explName = (pn == null) ? null : pn.getSimpleName(); [EOL] if (explName == null) { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] return; [EOL] } [EOL] visible = _visibilityChecker.isSetterVisible(m); [EOL] } else { [EOL] implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL] if (implName == null) { [EOL] implName = m.getName(); [EOL] } [EOL] if (explName.length() == 0) { [EOL] explName = implName; [EOL] } [EOL] visible = true; [EOL] } [EOL] boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL] _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
public void testAddInjectablesWithNullAnnotationIntrospector() { [EOL] _annotationIntrospector = null; [EOL] _addInjectables(); [EOL] }
public void testAddInjectablesWithNoInjectableFieldsOrMethods() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] _classDef = createClassDefWithNoInjectableMembers(); [EOL] _addInjectables(); [EOL] }
public void testAddInjectablesWithInjectableFields() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] _classDef = createClassDefWithInjectableFields(); [EOL] _addInjectables(); [EOL] }
public void testAddInjectablesWithInjectableMethods() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] _classDef = createClassDefWithInjectableMethods(); [EOL] _addInjectables(); [EOL] }
public void testAddInjectablesWithNonSingleParameterMethods() { [EOL] _annotationIntrospector = createMockAnnotationIntrospector(); [EOL] _classDef = createClassDefWithNonSingleParameterMethods(); [EOL] _addInjectables(); [EOL] }
public void testDoAddInjectableWithNullId() { [EOL] Object id = null; [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] _doAddInjectable(id, m); [EOL] }
public void testDoAddInjectableWithNonNullIdAndNoPreviousInjectables() { [EOL] Object id = new Object(); [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] _doAddInjectable(id, m); [EOL] assertNotNull(_injectables); [EOL] assertTrue(_injectables.containsKey(id)); [EOL] assertEquals(m, _injectables.get(id)); [EOL] }
public void testDoAddInjectableWithNonNullIdAndExistingInjectables() { [EOL] Object id = new Object(); [EOL] AnnotatedMember m1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember m2 = mock(AnnotatedMember.class); [EOL] _injectables = new LinkedHashMap<>(); [EOL] _injectables.put(id, m1); [EOL] try { [EOL] _doAddInjectable(id, m2); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] String expectedMessage = "Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + id.getClass().getName() + ")"; [EOL] assertEquals(expectedMessage, e.getMessage()); [EOL] } [EOL] assertEquals(m1, _injectables.get(id)); [EOL] }
public void testRemoveUnwantedProperties_AllInvisible() { [EOL] _initProperties(Collections.emptyMap()); [EOL] _properties.put("invisibleProp", new POJOPropertyBuilder("invisibleProp", _config, _forSerialization)); [EOL] when(_properties.get("invisibleProp").anyVisible()).thenReturn(false); [EOL] _removeUnwantedProperties(); [EOL] assertFalse(_properties.containsKey("invisibleProp")); [EOL] }
public void testRemoveUnwantedProperties_WithIgnorals() { [EOL] _initProperties(Collections.emptyMap()); [EOL] POJOPropertyBuilder propWithIgnorals = new POJOPropertyBuilder("propWithIgnorals", _config, _forSerialization); [EOL] propWithIgnorals.addIgnored("ignoredForSomeReason"); [EOL] _properties.put("propWithIgnorals", propWithIgnorals); [EOL] when(propWithIgnorals.anyIgnorals()).thenReturn(true); [EOL] when(propWithIgnorals.isExplicitlyIncluded()).thenReturn(false); [EOL] _removeUnwantedProperties(); [EOL] assertFalse(_properties.containsKey("propWithIgnorals")); [EOL] assertTrue(_ignoredProperties.contains("propWithIgnorals")); [EOL] }
public void testRemoveUnwantedProperties_WithIgnoralsExplicitlyIncluded() { [EOL] _initProperties(Collections.emptyMap()); [EOL] POJOPropertyBuilder propWithIgnoralsIncluded = new POJOPropertyBuilder("propWithIgnoralsIncluded", _config, _forSerialization); [EOL] propWithIgnoralsIncluded.addIgnored("ignoredForSomeReason"); [EOL] _properties.put("propWithIgnoralsIncluded", propWithIgnoralsIncluded); [EOL] when(propWithIgnoralsIncluded.anyIgnorals()).thenReturn(true); [EOL] when(propWithIgnoralsIncluded.isExplicitlyIncluded()).thenReturn(true); [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_properties.containsKey("propWithIgnoralsIncluded")); [EOL] assertFalse(propWithIgnoralsIncluded.hasIgnorals()); [EOL] }
public void testRemoveUnwantedProperties_NonVisibleRemoval() { [EOL] _initProperties(Collections.emptyMap()); [EOL] POJOPropertyBuilder nonVisibleProp = new POJOPropertyBuilder("nonVisibleProp", _config, _forSerialization); [EOL] _properties.put("nonVisibleProp", nonVisibleProp); [EOL] when(nonVisibleProp.anyVisible()).thenReturn(false); [EOL] when(_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS)).thenReturn(false); [EOL] _removeUnwantedProperties(); [EOL] assertFalse(_properties.containsKey("nonVisibleProp")); [EOL] }
public void testRemoveUnwantedProperties_VisibleWithNonVisibleRemoval() { [EOL] _initProperties(Collections.emptyMap()); [EOL] POJOPropertyBuilder visibleProp = new POJOPropertyBuilder("visibleProp", _config, _forSerialization); [EOL] _properties.put("visibleProp", visibleProp); [EOL] when(visibleProp.anyVisible()).thenReturn(true); [EOL] when(_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS)).thenReturn(false); [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_properties.containsKey("visibleProp")); [EOL] verify(visibleProp).removeNonVisible(true); [EOL] }
public void testRenamePropertiesWithNewName() { [EOL] POJOPropertyBuilder prop = createPOJOPropertyBuilderWithNewName("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName", prop); [EOL] YourObject obj = new YourObject(properties, null); [EOL] obj._renameProperties(); [EOL] assertNull(properties.get("oldName")); [EOL] assertNotNull(properties.get("newName")); [EOL] } [EOL] public void testRenamePropertiesWithoutNewName() { [EOL] POJOPropertyBuilder prop = createPOJOPropertyBuilderWithoutNewName(); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("name", prop); [EOL] YourObject obj = new YourObject(properties, null); [EOL] obj._renameProperties(); [EOL] assertNotNull(properties.get("name")); [EOL] } [EOL] public void testRenamePropertiesWithCreatorProperties() { [EOL] POJOPropertyBuilder prop = createPOJOPropertyBuilderWithNewName("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName", prop); [EOL] List<POJOPropertyBuilder> creatorProperties = new ArrayList<>(); [EOL] creatorProperties.add(prop); [EOL] YourObject obj = new YourObject(properties, creatorProperties); [EOL] obj._renameProperties(); [EOL] assertEquals("newName", creatorProperties.get(0).getName()); [EOL] }
public void testRenamePropertiesWithExistingProperty() { [EOL] POJOPropertyBuilder prop1 = createPOJOPropertyBuilderWithNewName("newName"); [EOL] POJOPropertyBuilder prop2 = createPOJOPropertyBuilderWithNewName("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName1", prop1); [EOL] properties.put("oldName2", prop2); [EOL] YourObject obj = new YourObject(properties, null); [EOL] obj._renameProperties(); [EOL] assertNull(properties.get("oldName1")); [EOL] assertNull(properties.get("oldName2")); [EOL] assertNotNull(properties.get("newName")); [EOL] assertEquals(2, properties.get("newName").size()); [EOL] }
public void testRenameUsingSerializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("renamedGetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedGetter"); [EOL] }
public void testRenameUsingSerializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("renamedField"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedField"); [EOL] }
public void testRenameUsingDeserializationWithSetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForSetterMethod(any(), any(), anyString())).thenReturn("renamedSetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasSetter()).thenReturn(true); [EOL] when(prop.getSetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedSetter"); [EOL] }
public void testRenameUsingDeserializationWithConstructorParameter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForConstructorParameter(any(), any(), anyString())).thenReturn("renamedCtorParam"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasConstructorParameter()).thenReturn(true); [EOL] when(prop.getConstructorParameter()).thenReturn(mock(AnnotatedParameter.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedCtorParam"); [EOL] }
public void testRenameUsingDeserializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("renamedField"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedField"); [EOL] }
public void testRenameUsingDeserializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("renamedGetter"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] _renameUsing(naming); [EOL] verify(prop).withName("renamedGetter"); [EOL] }
public void testRenameUsingNoChanges() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("original"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("original"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _renameUsing(naming); [EOL] verify(prop, never()).withName(anyString()); [EOL] }
public void testRenameUsingMergeProperties() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("merged"); [EOL] POJOPropertyBuilder prop1 = mock(POJOPropertyBuilder.class); [EOL] when(prop1.getName()).thenReturn("original1"); [EOL] when(prop1.hasField()).thenReturn(true); [EOL] when(prop1.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] POJOPropertyBuilder prop2 = mock(POJOPropertyBuilder.class); [EOL] when(prop2.getName()).thenReturn("original2"); [EOL] when(prop2.hasField()).thenReturn(true); [EOL] when(prop2.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] _properties.put("merged", prop1); [EOL] _renameUsing(naming); [EOL] verify(prop1).addAll(prop2); [EOL] }
public void testPropertyWhenNotPresent() { [EOL] String implName = "testProperty"; [EOL] POJOPropertyBuilder result = _property(implName); [EOL] assertNotNull(result); [EOL] assertEquals(implName, result.getName()); [EOL] }
public void testPropertyWhenPresent() { [EOL] String implName = "testProperty"; [EOL] POJOPropertyBuilder prop = new POJOPropertyBuilder(implName, _annotationIntrospector, _forSerialization); [EOL] _properties.put(implName, prop); [EOL] POJOPropertyBuilder result = _property(implName); [EOL] assertNotNull(result); [EOL] assertSame(prop, result); [EOL] }
public void testFindNamingStrategyWithNullIntrospectorAndConfigStrategy() { [EOL] _annotationIntrospector = null; [EOL] PropertyNamingStrategy expectedStrategy = new PropertyNamingStrategy.LowerCaseStrategy(); [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] Mockito.when(_config.getPropertyNamingStrategy()).thenReturn(expectedStrategy); [EOL] PropertyNamingStrategy actualStrategy = _findNamingStrategy(); [EOL] assertSame(expectedStrategy, actualStrategy); [EOL] }
public void testFindNamingStrategyWithDirectNamingStrategy() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] PropertyNamingStrategy expectedStrategy = new PropertyNamingStrategy.LowerCaseStrategy(); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(expectedStrategy); [EOL] PropertyNamingStrategy actualStrategy = _findNamingStrategy(); [EOL] assertSame(expectedStrategy, actualStrategy); [EOL] }
public void testFindNamingStrategyWithInvalidType() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(new Object()); [EOL] try { [EOL] _findNamingStrategy(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindNamingStrategyWithNonAssignableClass() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(String.class); [EOL] try { [EOL] _findNamingStrategy(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindNamingStrategyWithHandlerInstantiator() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] HandlerInstantiator hi = Mockito.mock(HandlerInstantiator.class); [EOL] PropertyNamingStrategy expectedStrategy = new PropertyNamingStrategy.LowerCaseStrategy(); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(PropertyNamingStrategy.LowerCaseStrategy.class); [EOL] Mockito.when(_config.getHandlerInstantiator()).thenReturn(hi); [EOL] Mockito.when(hi.namingStrategyInstance(_config, _classDef, PropertyNamingStrategy.LowerCaseStrategy.class)).thenReturn(expectedStrategy); [EOL] PropertyNamingStrategy actualStrategy = _findNamingStrategy(); [EOL] assertSame(expectedStrategy, actualStrategy); [EOL] }
public void testFindNamingStrategyWithClassUtilInstantiation() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _config = Mockito.mock(SerializationConfig.class); [EOL] Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(PropertyNamingStrategy.LowerCaseStrategy.class); [EOL] Mockito.when(_config.getHandlerInstantiator()).thenReturn(null); [EOL] Mockito.when(_config.canOverrideAccessModifiers()).thenReturn(true); [EOL] PropertyNamingStrategy actualStrategy = _findNamingStrategy(); [EOL] assertTrue(actualStrategy instanceof PropertyNamingStrategy.LowerCaseStrategy); [EOL] }
public void testDeserializeIfNaturalWithStringTokenAndAcceptStringTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("testString"); [EOL] _acceptString = true; [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeIfNaturalWithIntTokenAndAcceptIntTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] _acceptInt = true; [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeIfNaturalWithFloatTokenAndAcceptDoubleTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(45.67); [EOL] _acceptDouble = true; [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Double.valueOf(45.67), result); [EOL] }
public void testDeserializeIfNaturalWithTrueTokenAndAcceptBooleanTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] _acceptBoolean = true; [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeIfNaturalWithFalseTokenAndAcceptBooleanTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] _acceptBoolean = true; [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeIfNaturalWithUnsupportedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = _deserializeIfNatural(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testObjectReaderCopyConstructor() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] ObjectReader base = new ObjectReader(...); // Provide actual initialization [EOL] ObjectReader copy = new ObjectReader(base, config); [EOL] assertEquals(base._context, copy._context); [EOL] assertEquals(base._rootDeserializers, copy._rootDeserializers); [EOL] assertEquals(base._jsonFactory, copy._jsonFactory); [EOL] assertEquals(base._rootNames, copy._rootNames); [EOL] assertEquals(base._valueType, copy._valueType); [EOL] assertEquals(base._rootDeserializer, copy._rootDeserializer); [EOL] assertEquals(base._valueToUpdate, copy._valueToUpdate); [EOL] assertEquals(base._schema, copy._schema); [EOL] assertEquals(base._injectableValues, copy._injectableValues); [EOL] assertEquals(config.useRootWrapping(), copy._unwrapRoot); [EOL] assertEquals(base._dataFormatReaders, copy._dataFormatReaders); [EOL] }
public void testWithHandlerNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.withHandler(null); [EOL] assertNotNull(newReader); [EOL] assertNotSame(reader, newReader); [EOL] }
public void testWithHandlerNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] DeserializationProblemHandler handler = new DeserializationProblemHandler() {}; [EOL] ObjectReader newReader = reader.withHandler(handler); [EOL] assertNotNull(newReader); [EOL] assertNotSame(reader, newReader); [EOL] }
public void testReadValueWithNullDataFormatReaders() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] StringReader reader = new StringReader(json); [EOL] Map<String, String> result = mapper.readValue(reader); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadValueWithDataFormatReaders() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._dataFormatReaders = new DataFormatReaders(); // Assuming this is a valid way to set _dataFormatReaders [EOL] String json = "{\"key\":\"value\"}"; [EOL] StringReader reader = new StringReader(json); [EOL] try { [EOL] mapper.readValue(reader); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenEndObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNullAndTokenNotEndNorNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for non-null, non-end token [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndValueToUpdateNotNullAndTokenNotEndNorNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for non-null, non-end token [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = new Object(); [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertSame(valueToUpdate, result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withSchemaAndUnwrapRoot() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(mock(FormatSchema.class)); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for non-null, non-end token [EOL] when(_unwrapRoot).thenReturn(true); [EOL] jp.setSchema(_schema); [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void test_bindAndClose_withoutSchema() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); // Assuming START_OBJECT for non-null, non-end token [EOL] Object valueToUpdate = null; [EOL] Object result = _bindAndClose(jp, valueToUpdate); [EOL] assertNotNull(result); [EOL] verify(jp).close(); [EOL] }
public void testWithSameConfig() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] ObjectReader reader = new ObjectReader(..., config); // Provide necessary initialization [EOL] ObjectReader result = reader._with(config); [EOL] assertSame("Should return the same ObjectReader when config is the same", reader, result); [EOL] }
public void testWithDifferentConfigAndDataFormatReadersNotNull() { [EOL] DeserializationConfig oldConfig = new DeserializationConfig(...); // Provide necessary initialization [EOL] DeserializationConfig newConfig = new DeserializationConfig(...); // Provide necessary initialization with different settings [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(...); // Provide necessary initialization [EOL] ObjectReader reader = new ObjectReader(..., oldConfig, dataFormatReaders); // Provide necessary initialization [EOL] ObjectReader result = reader._with(newConfig); [EOL] assertNotNull("Should return a new ObjectReader when config is different", result); [EOL] assertNotSame("Should not return the same ObjectReader when config is different", reader, result); [EOL] assertNotNull("DataFormatReaders should be initialized", result.getDataFormatReaders()); [EOL] }
public void testWithDifferentConfigAndDataFormatReadersNull() { [EOL] DeserializationConfig oldConfig = new DeserializationConfig(...); // Provide necessary initialization [EOL] DeserializationConfig newConfig = new DeserializationConfig(...); // Provide necessary initialization with different settings [EOL] ObjectReader reader = new ObjectReader(..., oldConfig); // Provide necessary initialization without DataFormatReaders [EOL] ObjectReader result = reader._with(newConfig); [EOL] assertNotNull("Should return a new ObjectReader when config is different", result); [EOL] assertNotSame("Should not return the same ObjectReader when config is different", reader, result); [EOL] assertNull("DataFormatReaders should be null", result.getDataFormatReaders()); [EOL] }
public void testContainedTypeCount() { [EOL] ExampleClass instance = new ExampleClass(); [EOL] int result = instance.containedTypeCount(); [EOL] assertEquals(1, result); [EOL] }
public void testBuildCanonicalNameWithoutElementType() { [EOL] TypeReference<?> typeRef = new TypeReference<Object>(Object.class) {}; [EOL] String result = typeRef.buildCanonicalName(); [EOL] assertEquals("java.lang.Object", result); [EOL] }
public void testBuildCanonicalNameWithElementType() { [EOL] TypeReference<?> typeRef = new TypeReference<List<String>>(List.class, String.class) {}; [EOL] String result = typeRef.buildCanonicalName(); [EOL] assertEquals("java.util.List<java.lang.String>", result); [EOL] }
public void testSerialize() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] MyCustomClass instance = new MyCustomClass(); // Replace with actual class name that contains the serialize method [EOL] instance.serialize(mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] }
public void testWithSameTimeZone() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] TimeZone defaultTimeZone = writer.getConfig().getTimeZone(); [EOL] ObjectWriter resultWriter = writer.with(defaultTimeZone); [EOL] assertSame("Expected same ObjectWriter instance when same TimeZone is set", writer, resultWriter); [EOL] }
public void testWithDifferentTimeZone() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] TimeZone differentTimeZone = TimeZone.getTimeZone("GMT"); [EOL] ObjectWriter resultWriter = writer.with(differentTimeZone); [EOL] assertNotSame("Expected different ObjectWriter instance when different TimeZone is set", writer, resultWriter); [EOL] assertEquals("Expected the new ObjectWriter to have the updated TimeZone", differentTimeZone, resultWriter.getConfig().getTimeZone()); [EOL] }
public void testWriteValueAsBytesWithValidInput() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String testValue = "Jackson"; [EOL] byte[] result = mapper.writeValueAsBytes(testValue); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] } [EOL] public void testWriteValueAsBytesWithNullInput() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsBytes(null); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testWriteValueAsBytesWithJsonProcessingException() { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL] throw new JsonProcessingException("") {}; [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsBytes(new Object()); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testWriteValueAsBytesWithIOException() { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] protected void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { [EOL] throw new IOException("Simulated IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsBytes(new Object()); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testConfigAndWriteValueWithCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] config = config.with(SerializationFeature.CLOSE_CLOSEABLE); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doNothing().when(spyMapper)._writeCloseable(any(JsonGenerator.class), any(), any(SerializationConfig.class)); [EOL] spyMapper._configAndWriteValue(jgen, value); [EOL] verify(spyMapper). _writeCloseable(jgen, value, config); [EOL] verify(value).close(); [EOL] }
public void testConfigAndWriteValueWithoutCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doNothing().when(spyMapper)._serializerProvider(any(SerializationConfig.class)).serializeValue(any(JsonGenerator.class), any()); [EOL] spyMapper._configAndWriteValue(jgen, value); [EOL] verify(spyMapper)._serializerProvider(config).serializeValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueWithRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> rootSerializer = mock(JsonSerializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] spyMapper._rootType = rootType; [EOL] spyMapper._rootSerializer = rootSerializer; [EOL] doNothing().when(spyMapper)._serializerProvider(any(SerializationConfig.class)).serializeValue(any(JsonGenerator.class), any(), any(JavaType.class), any(JsonSerializer.class)); [EOL] spyMapper._configAndWriteValue(jgen, value); [EOL] verify(spyMapper)._serializerProvider(config).serializeValue(jgen, value, rootType, rootSerializer); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueExceptionHandling() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] spyMapper._configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testFindValueWhenChildrenAreEmpty() { [EOL] JsonNode rootNode = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode result = rootNode.findValue("someField"); [EOL] assertNull(result); [EOL] }
public void testFindValueWhenChildrenDoNotContainField() { [EOL] ObjectNode rootNode = new ObjectNode(JsonNodeFactory.instance); [EOL] rootNode.set("child1", new ObjectNode(JsonNodeFactory.instance)); [EOL] rootNode.set("child2", new ObjectNode(JsonNodeFactory.instance)); [EOL] JsonNode result = rootNode.findValue("nonexistentField"); [EOL] assertNull(result); [EOL] }
public void testFindValueWhenAChildContainsField() { [EOL] ObjectNode rootNode = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode child1 = new ObjectNode(JsonNodeFactory.instance); [EOL] child1.put("someField", "someValue"); [EOL] rootNode.set("child1", child1); [EOL] rootNode.set("child2", new ObjectNode(JsonNodeFactory.instance)); [EOL] JsonNode result = rootNode.findValue("someField"); [EOL] assertNotNull(result); [EOL] assertEquals("someValue", result.asText()); [EOL] }
public void testFindParentWithExistingFieldName() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child1 = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child2 = JsonNodeFactory.instance.objectNode(); [EOL] root.set("child1", child1); [EOL] child1.put("fieldName", "value1"); [EOL] root.set("child2", child2); [EOL] ObjectNode result = root.findParent("fieldName"); [EOL] assertNotNull(result); [EOL] assertEquals(child1, result); [EOL] }
public void testFindParentWithNonExistingFieldName() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child1 = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child2 = JsonNodeFactory.instance.objectNode(); [EOL] root.set("child1", child1); [EOL] root.set("child2", child2); [EOL] ObjectNode result = root.findParent("nonExistingField"); [EOL] assertNull(result); [EOL] }
public void testCreateDeserializerWithAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType abstractType = mock(JavaType.class); [EOL] when(abstractType.isAbstract()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, abstractType)).thenReturn(abstractType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(abstractType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] assertNull(_createDeserializer(ctxt, factory, abstractType)); [EOL] }
public void testCreateDeserializerWithDeserializerFromAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(findDeserializerFromAnnotation(ctxt, ac)).thenReturn(expectedDeserializer); [EOL] assertSame(expectedDeserializer, _createDeserializer(ctxt, factory, type)); [EOL] }
public void testCreateDeserializerWithBuilderBasedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findPOJOBuilder()).thenReturn(Object.class); [EOL] assertNotNull(_createDeserializer(ctxt, factory, type)); [EOL] }
public void testCreateDeserializerWithConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] when(beanDesc.findDeserializationConverter()).thenReturn(converter); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(converter.getInputType(typeFactory)).thenReturn(delegateType); [EOL] assertNotNull(_createDeserializer(ctxt, factory, type)); [EOL] }
public void testCreateDeserializer2WithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] when(factory.createEnumDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithArrayType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] when(factory.createArrayDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithMapType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapType type = mock(MapType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(((MapLikeType) type).isTrueMapType()).thenReturn(true); [EOL] when(factory.createMapDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(type.isTrueMapType()).thenReturn(false); [EOL] when(factory.createMapLikeDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithCollectionType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(true); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(null); [EOL] when(factory.createCollectionDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(type.isTrueCollectionType()).thenReturn(false); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] when(factory.createCollectionLikeDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithJsonNode() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(JsonNode.class); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(true); [EOL] when(factory.createTreeDeserializer(eq(config), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithBeanType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(false); [EOL] when(factory.createBeanDeserializer(eq(ctxt), eq(type), eq(beanDesc))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] Class<?> subclass = intr.findDeserializationType(a, type); [EOL] if (subclass != null) { [EOL] try { [EOL] type = type.narrowBy(subclass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] if (type.isContainerType()) { [EOL] Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL] if (keyClass != null) { [EOL] if (!(type instanceof MapLikeType)) { [EOL] throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL] } [EOL] try { [EOL] type = ((MapLikeType) type).narrowKey(keyClass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType keyType = type.getKeyType(); [EOL] if (keyType != null && keyType.getValueHandler() == null) { [EOL] Object kdDef = intr.findKeyDeserializer(a); [EOL] if (kdDef != null) { [EOL] KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL] if (kd != null) { [EOL] type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL] keyType = type.getKeyType(); [EOL] } [EOL] } [EOL] } [EOL] Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL] if (cc != null) { [EOL] try { [EOL] type = type.narrowContentsBy(cc); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType contentType = type.getContentType(); [EOL] if (contentType.getValueHandler() == null) { [EOL] Object cdDef = intr.findContentDeserializer(a); [EOL] if (cdDef != null) { [EOL] JsonDeserializer<?> cd = null; [EOL] if (cdDef instanceof JsonDeserializer<?>) { [EOL] cdDef = (JsonDeserializer<?>) cdDef; [EOL] } else { [EOL] Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL] if (cdClass != null) { [EOL] cd = ctxt.deserializerInstance(a, cdClass); [EOL] } [EOL] } [EOL] if (cd != null) { [EOL] type = type.withContentValueHandler(cd); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return type; [EOL] }
public void testVerifyAsClassWithNullSrc() { [EOL] Class<?> result = _verifyAsClass(null, "testMethod", Void.class); [EOL] assertNull(result); [EOL] }
public void testVerifyAsClassWithNonClassSrc() { [EOL] Object src = new Object(); [EOL] try { [EOL] _verifyAsClass(src, "testMethod", Void.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector.testMethod() returned value of type java.lang.Object: expected type JsonSerializer or Class<JsonSerializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testVerifyAsClassWithNoneClass() { [EOL] Class<?> result = _verifyAsClass(Void.class, "testMethod", Void.class); [EOL] assertNull(result); [EOL] }
public void testVerifyAsClassWithNoClass() { [EOL] Class<?> result = _verifyAsClass(NoClass.class, "testMethod", Void.class); [EOL] assertNull(result); [EOL] }
public void testVerifyAsClassWithValidClass() { [EOL] Class<?> result = _verifyAsClass(String.class, "testMethod", Void.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testMappingIteratorWithNullValueToUpdate() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, null); [EOL] assertNull(iterator._updatedValue); [EOL] assertEquals(type, iterator._type); [EOL] assertEquals(jp, iterator._parser); [EOL] assertEquals(ctxt, iterator._context); [EOL] assertEquals(deser, iterator._deserializer); [EOL] assertTrue(iterator._closeParser); [EOL] }
public void testMappingIteratorWithValueToUpdate() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] assertEquals(valueToUpdate, iterator._updatedValue); [EOL] assertEquals(type, iterator._type); [EOL] assertEquals(jp, iterator._parser); [EOL] assertEquals(ctxt, iterator._context); [EOL] assertEquals(deser, iterator._deserializer); [EOL] assertTrue(iterator._closeParser); [EOL] }
public void testMappingIteratorWithManagedParserAndStartArrayToken() throws IOException { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] verify(jp).clearCurrentToken(); [EOL] assertEquals(valueToUpdate, iterator._updatedValue); [EOL] assertEquals(type, iterator._type); [EOL] assertEquals(jp, iterator._parser); [EOL] assertEquals(ctxt, iterator._context); [EOL] assertEquals(deser, iterator._deserializer); [EOL] assertTrue(iterator._closeParser); [EOL] }
public void testMappingIteratorWithManagedParserAndNonStartArrayToken() throws IOException { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] verify(jp, never()).clearCurrentToken(); [EOL] assertEquals(valueToUpdate, iterator._updatedValue); [EOL] assertEquals(type, iterator._type); [EOL] assertEquals(jp, iterator._parser); [EOL] assertEquals(ctxt, iterator._context); [EOL] assertEquals(deser, iterator._deserializer); [EOL] assertTrue(iterator._closeParser); [EOL] }
public void testHasNextWithHasNextValueTrue() throws Exception { [EOL] YourClass instance = Mockito.mock(YourClass.class); [EOL] Mockito.when(instance.hasNextValue()).thenReturn(true); [EOL] boolean result = instance.hasNext(); [EOL] assertTrue(result); [EOL] }
public void testHasNextWithJsonMappingException() throws Exception { [EOL] YourClass instance = Mockito.mock(YourClass.class); [EOL] Mockito.when(instance.hasNextValue()).thenThrow(new JsonMappingException("JsonMappingException occurred")); [EOL] try { [EOL] instance.hasNext(); [EOL] fail("Expected RuntimeJsonMappingException to be thrown"); [EOL] } catch (RuntimeJsonMappingException e) { [EOL] assertEquals("JsonMappingException occurred", e.getMessage()); [EOL] } [EOL] }
public void testHasNextWithIOException() throws Exception { [EOL] YourClass instance = Mockito.mock(YourClass.class); [EOL] Mockito.when(instance.hasNextValue()).thenThrow(new IOException("IOException occurred")); [EOL] try { [EOL] instance.hasNext(); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("IOException occurred", e.getMessage()); [EOL] } [EOL] }
public void testNextWithJsonMappingException() { [EOL] IteratorUnderTest iterator = new IteratorUnderTest(); // Replace with actual iterator class name [EOL] try { [EOL] iterator.next(); [EOL] fail("Expected RuntimeJsonMappingException to be thrown"); [EOL] } catch (RuntimeJsonMappingException e) { [EOL] assertTrue(e.getCause() instanceof JsonMappingException); [EOL] } [EOL] }
public void testNextWithIOException() { [EOL] IteratorUnderTest iterator = new IteratorUnderTest(); // Replace with actual iterator class name [EOL] try { [EOL] iterator.next(); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] } [EOL] }
public void testNextWithNoException() { [EOL] IteratorUnderTest iterator = new IteratorUnderTest(); // Replace with actual iterator class name [EOL] try { [EOL] T result = iterator.next(); [EOL] assertNotNull(result); // Replace with actual expected result [EOL] } catch (Exception e) { [EOL] fail("No exception should be thrown"); [EOL] } [EOL] }
public void testHasNextValueWithNullParser() throws IOException { [EOL] YourClass instance = new YourClass(null, false); [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when parser is null", result); [EOL] }
public void testHasNextValueWithNoNextCheckedAndParserAtEndArray() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] YourClass instance = new YourClass(mockParser, false); [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when no next checked and parser is at END_ARRAY", result); [EOL] }
public void testHasNextValueWithNoNextCheckedAndParserAtStartArray() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(mockParser.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] YourClass instance = new YourClass(mockParser, false); [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when no next checked and next token is END_ARRAY", result); [EOL] }
public void testHasNextValueWithNoNextCheckedAndNextTokenNotNull() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(null); [EOL] when(mockParser.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] YourClass instance = new YourClass(mockParser, false); [EOL] boolean result = instance.hasNextValue(); [EOL] assertTrue("Expected true when no next checked and next token is not null", result); [EOL] }
public void testHasNextValueWithHasNextChecked() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] YourClass instance = new YourClass(mockParser, true); [EOL] boolean result = instance.hasNextValue(); [EOL] assertTrue("Expected true when has next checked", result); [EOL] }
public void testNextValueWithNoNext() throws IOException { [EOL] setupForNextValueTest(); [EOL] _hasNextChecked = false; [EOL] when(_iterator.hasNextValue()).thenReturn(false); [EOL] try { [EOL] _iterator.nextValue(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextValueWithNullParser() throws IOException { [EOL] setupForNextValueTest(); [EOL] _hasNextChecked = true; [EOL] _parser = null; [EOL] try { [EOL] _iterator.nextValue(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextValueWithNonNullUpdatedValue() throws IOException { [EOL] setupForNextValueTest(); [EOL] _hasNextChecked = true; [EOL] _updatedValue = mock(Object.class); [EOL] when(_iterator.hasNextValue()).thenReturn(true); [EOL] when(_deserializer.deserialize(_parser, _context, _updatedValue)).thenReturn(_updatedValue); [EOL] Object result = _iterator.nextValue(); [EOL] assertNotNull(result); [EOL] assertEquals(_updatedValue, result); [EOL] }
public void testNextValueWithNullUpdatedValue() throws IOException { [EOL] setupForNextValueTest(); [EOL] _hasNextChecked = true; [EOL] _updatedValue = null; [EOL] when(_iterator.hasNextValue()).thenReturn(true); [EOL] Object expectedValue = new Object(); [EOL] when(_deserializer.deserialize(_parser, _context)).thenReturn(expectedValue); [EOL] Object result = _iterator.nextValue(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testSerializeWithValidData() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] Base64Variant mockBase64Variant = mock(Base64Variant.class); [EOL] when(mockProvider.getConfig()).thenReturn(mockConfig); [EOL] when(mockConfig.getBase64Variant()).thenReturn(mockBase64Variant); [EOL] byte[] testData = new byte[]{1, 2, 3, 4}; [EOL] CustomSerializer serializer = new CustomSerializer(testData); [EOL] serializer.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBinary(mockBase64Variant, testData, 0, testData.length); [EOL] }
public void testSerializeWithEmptyData() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] Base64Variant mockBase64Variant = mock(Base64Variant.class); [EOL] when(mockProvider.getConfig()).thenReturn(mockConfig); [EOL] when(mockConfig.getBase64Variant()).thenReturn(mockBase64Variant); [EOL] byte[] emptyData = new byte[0]; [EOL] CustomSerializer serializer = new CustomSerializer(emptyData); [EOL] serializer.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBinary(mockBase64Variant, emptyData, 0, emptyData.length); [EOL] }
public void testInitialCapacityWhenFreeBufferIsNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertEquals(0, factory.initialCapacity()); [EOL] }
public void testInitialCapacityWhenFreeBufferIsNotNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._freeBuffer = new byte[10]; [EOL] assertEquals(10, factory.initialCapacity()); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithValueEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserialize(jp, null); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithValueStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String text = "test"; [EOL] when(jp.getText()).thenReturn(text); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(text, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] BigInteger bigInteger = new BigInteger("12345"); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInteger); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigInteger, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number number = 12345; [EOL] when(jp.getNumberValue()).thenReturn(number); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(number, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] BigDecimal bigDecimal = new BigDecimal("123.45"); [EOL] when(jp.getDecimalValue()).thenReturn(bigDecimal); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigDecimal, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] double value = 123.45; [EOL] when(jp.getDoubleValue()).thenReturn(value); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(value), result); [EOL] }
public void testDeserializeWithValueTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithValueFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testMapArrayWithJavaArrayFeatureEnabled() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(true); [EOL] Object expected = new Object(); [EOL] when(this.mapArrayToArray(jp, ctxt)).thenReturn(expected); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testMapArrayWithEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList<?>); [EOL] assertTrue(((ArrayList<?>) result).isEmpty()); [EOL] }
public void testMapArrayWithNonEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(this.deserialize(jp, ctxt)).thenReturn("value"); [EOL] ObjectBuffer buffer = new ObjectBuffer(); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList<?>); [EOL] assertFalse(((ArrayList<?>) result).isEmpty()); [EOL] assertEquals("value", ((ArrayList<?>) result).get(0)); [EOL] }
public void testMapObjectWithEmptyObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertTrue(((LinkedHashMap) result).isEmpty()); [EOL] }
public void testMapObjectWithOneField() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(1, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] }
public void testMapObjectWithTwoFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(2, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] assertEquals("value2", ((LinkedHashMap) result).get("field2")); [EOL] }
public void testMapObjectWithManyFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2").thenReturn("field3"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2").thenReturn("value3"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] LinkedHashMap resultMap = (LinkedHashMap) result; [EOL] assertEquals(3, resultMap.size()); [EOL] assertEquals("value1", resultMap.get("field1")); [EOL] assertEquals("value2", resultMap.get("field2")); [EOL] assertEquals("value3", resultMap.get("field3")); [EOL] }
public void testMapArrayToArrayWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] when(buffer.resetAndStart()).thenReturn(new Object[0]); [EOL] Object[] result = mapArrayToArray(jp, ctxt); [EOL] assertArrayEquals(NO_OBJECTS, result); [EOL] }
public void testMapArrayToArrayWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] Object[] initialArray = new Object[1]; [EOL] when(buffer.resetAndStart()).thenReturn(initialArray); [EOL] when(buffer.completeAndClearBuffer(any(Object[].class), anyInt())).thenAnswer(invocation -> invocation.getArguments()[0]); [EOL] when(deserialize(jp, ctxt)).thenReturn("value"); [EOL] Object[] result = mapArrayToArray(jp, ctxt); [EOL] assertEquals("value", result[0]); [EOL] }
public void testMapArrayToArrayWithExpansion() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] Object[] initialArray = new Object[1]; [EOL] Object[] expandedArray = new Object[2]; [EOL] when(buffer.resetAndStart()).thenReturn(initialArray); [EOL] when(buffer.appendCompletedChunk(any(Object[].class))).thenReturn(expandedArray); [EOL] when(buffer.completeAndClearBuffer(any(Object[].class), anyInt())).thenAnswer(invocation -> invocation.getArguments()[0]); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1", "value2"); [EOL] Object[] result = mapArrayToArray(jp, ctxt); [EOL] assertEquals("value1", result[0]); [EOL] assertEquals("value2", result[1]); [EOL] }
public void testFindWithUnlistedClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "UnlistedClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "java.util.Calendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithUtilDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.util.Date.class, "java.util.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DateDeserializer); [EOL] }
public void testFindWithSqlDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.sql.Date.class, "java.sql.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof SqlDateDeserializer); [EOL] }
public void testFindWithTimestampClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Timestamp.class, "java.sql.Timestamp"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimestampDeserializer); [EOL] }
public void testFindWithTimeZoneClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(TimeZone.class, "java.util.TimeZone"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimeZoneDeserializer); [EOL] }
public void testFindWithGregorianCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(GregorianCalendar.class, "java.util.GregorianCalendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected DateBasedDeserializer<T> baseDeserializer; [EOL] protected DateFormat customFormat; [EOL] protected String customFormatString; [EOL] public void setUp() { [EOL] baseDeserializer = new DateBasedDeserializer<>(Date.class); [EOL] customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] customFormatString = "yyyy-MM-dd"; [EOL] } [EOL] public void testDateBasedDeserializerWithCustomFormat() { [EOL] DateBasedDeserializer<?> deserializer = new DateBasedDeserializer<>(baseDeserializer, customFormat, customFormatString); [EOL] assertNotNull(deserializer); [EOL] assertEquals(customFormat, deserializer._customFormat); [EOL] assertEquals(customFormatString, deserializer._formatString); [EOL] }
public void testCreateContextualWithPropertyAndFormatWithPattern() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn("yyyy-MM-dd"); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] when(format.getLocale()).thenReturn(Locale.ENGLISH); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithPropertyAndFormatWithoutPattern() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn(""); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithPropertyAndFormatWithTimeZone() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn(""); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] DateFormat df = mock(DateFormat.class); [EOL] when(ctxt.getConfig().getDateFormat()).thenReturn(df); [EOL] when(df.getClass()).thenReturn(StdDateFormat.class); [EOL] StdDateFormat stdDateFormat = mock(StdDateFormat.class); [EOL] when(((StdDateFormat) df).withTimeZone(any(TimeZone.class))).thenReturn(stdDateFormat); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = null; [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertSame(this, result); [EOL] }
public void testParseDateWithCustomFormatAndValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String validDateString = "2021-03-15"; [EOL] Date expectedDate = customFormat.parse(validDateString); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(validDateString); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] assertEquals(expectedDate, result); [EOL] }
public void testParseDateWithCustomFormatAndEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(" "); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDateWithCustomFormatAndInvalidString() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String invalidDateString = "invalid-date"; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(invalidDateString); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] deserializer._parseDate(jp, ctxt); [EOL] }); [EOL] }
public void testParseDateWithoutCustomFormat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(null, null); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] assertNotNull(result); // Assuming the super implementation returns a non-null date for this case [EOL] }
public void testDateDeserializerWithNonNullValues() { [EOL] DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String formatString = "yyyy-MM-dd"; [EOL] DateDeserializer base = new DateDeserializer(); [EOL] DateDeserializer deserializer = new DateDeserializer(base, dateFormat, formatString); [EOL] }
public void testDateDeserializerWithNullBase() { [EOL] DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String formatString = "yyyy-MM-dd"; [EOL] DateDeserializer deserializer = new DateDeserializer(null, dateFormat, formatString); [EOL] }
public void testDateDeserializerWithNullDateFormat() { [EOL] String formatString = "yyyy-MM-dd"; [EOL] DateDeserializer base = new DateDeserializer(); [EOL] DateDeserializer deserializer = new DateDeserializer(base, null, formatString); [EOL] }
public void testDateDeserializerWithNullFormatString() { [EOL] DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DateDeserializer base = new DateDeserializer(); [EOL] DateDeserializer deserializer = new DateDeserializer(base, dateFormat, null); [EOL] }
protected DateDeserializer withDateFormat(DateFormat df, String formatString) { [EOL] return new DateDeserializer(this, df, formatString); [EOL] }
public void testTimestampDeserializerConstructor() { [EOL] TimestampDeserializer deserializer = new TimestampDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithValidTimestamp() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("2023-01-01T12:00:00.000Z"); [EOL] TimestampDeserializer deserializer = new TimestampDeserializer(); [EOL] Timestamp result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(Timestamp.valueOf("2023-01-01 12:00:00").getTime(), result.getTime()); [EOL] }
public void testDeserializeWithInvalidTimestamp() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("not a valid timestamp"); [EOL] TimestampDeserializer deserializer = new TimestampDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testTimeZoneDeserializerConstructor() { [EOL] TimeZoneDeserializer deserializer = new TimeZoneDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithValidTimeZone() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "GMT"; [EOL] TimeZoneDeserializer deserializer = new TimeZoneDeserializer(); [EOL] TimeZone result = deserializer._deserialize(value, ctxt); [EOL] assertEquals(TimeZone.getTimeZone(value), result); [EOL] }
public void testDeserializeWithInvalidTimeZone() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "InvalidTimeZone"; [EOL] TimeZoneDeserializer deserializer = new TimeZoneDeserializer(); [EOL] TimeZone result = deserializer._deserialize(value, ctxt); [EOL] assertEquals(TimeZone.getTimeZone("GMT"), result); [EOL] }
protected String idFromValueAndType(Object value, Class<?> type) { [EOL] return _idResolver.idFromValueAndType(value, type); [EOL] }
public void testTreeTraversingParserWithArrayNode() { [EOL] JsonNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(arrayNode, codec); [EOL] assertEquals(JsonToken.START_ARRAY, parser.nextToken()); [EOL] }
public void testTreeTraversingParserWithObjectNode() { [EOL] JsonNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(objectNode, codec); [EOL] assertEquals(JsonToken.START_OBJECT, parser.nextToken()); [EOL] }
public void testTreeTraversingParserWithOtherNode() { [EOL] JsonNode valueNode = JsonNodeFactory.instance.textNode("value"); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] TreeTraversingParser parser = new TreeTraversingParser(valueNode, codec); [EOL] assertNull(parser.nextToken()); [EOL] }
public void testNextTokenWithNextTokenNotNull() throws IOException, JsonParseException { [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; [EOL] TestParser parser = new TestParser(); [EOL] parser._nextToken = expectedToken; [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(expectedToken, actualToken); [EOL] assertNull(parser._nextToken); [EOL] }
public void testNextTokenWithStartContainerAndNoChildren() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._startContainer = true; [EOL] parser._currToken = JsonToken.START_OBJECT; [EOL] parser._nodeCursor = new TestNodeCursor(false); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, actualToken); [EOL] assertFalse(parser._startContainer); [EOL] }
public void testNextTokenWithStartContainerAndHasChildren() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._startContainer = true; [EOL] parser._nodeCursor = new TestNodeCursor(true); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertTrue(parser._startContainer || !parser._nodeCursor.currentHasChildren()); [EOL] }
public void testNextTokenWithNodeCursorNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = null; [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNull(actualToken); [EOL] assertTrue(parser._closed); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNotNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = new TestNodeCursor(true); [EOL] parser._nodeCursor.setNextToken(JsonToken.VALUE_STRING); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, actualToken); [EOL] assertTrue(parser._startContainer || actualToken != JsonToken.START_OBJECT && actualToken != JsonToken.START_ARRAY); [EOL] }
public void testNextTokenWithNodeCursorNotNullAndNextTokenNull() throws IOException, JsonParseException { [EOL] TestParser parser = new TestParser(); [EOL] parser._nodeCursor = new TestNodeCursor(true); [EOL] parser._nodeCursor.setNextToken(null); [EOL] JsonToken actualToken = parser.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertNull(parser._nodeCursor.nextToken()); [EOL] assertNotNull(parser._nodeCursor.getParent()); [EOL] }
public void testGetTextWhenClosed() { [EOL] JsonParser parser = createParserWithClosedState(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithFieldNameToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME, "fieldName"); [EOL] String result = parser.getText(); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetTextWithValueStringToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING, "stringValue"); [EOL] String result = parser.getText(); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetTextWithValueNumberIntToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_INT, 123); [EOL] String result = parser.getText(); [EOL] assertEquals("123", result); [EOL] }
public void testGetTextWithValueNumberFloatToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT, 123.45); [EOL] String result = parser.getText(); [EOL] assertEquals("123.45", result); [EOL] }
public void testGetTextWithValueEmbeddedObjectTokenBinary() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_EMBEDDED_OBJECT, new byte[]{1, 2, 3}); [EOL] String result = parser.getText(); [EOL] assertNotNull(result); [EOL] assertEquals("AQID", result); [EOL] }
public void testGetTextWithValueEmbeddedObjectTokenNonBinary() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_EMBEDDED_OBJECT, "nonBinaryData"); [EOL] String result = parser.getText(); [EOL] assertEquals("nonBinaryData", result); [EOL] }
public void testGetTextWithNullToken() { [EOL] JsonParser parser = createParserWithNullToken(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithUnrecognizedToken() { [EOL] JsonParser parser = createParserWithUnrecognizedToken(); [EOL] String result = parser.getText(); [EOL] assertNotNull(result); [EOL] assertEquals("unrecognizedToken", result); [EOL] }
public void testGetTextCharacters() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithContent("some content"); [EOL] parser.nextToken(); // Assuming this method exists and it advances the parser to a token where getText() is meaningful [EOL] char[] textCharacters = parser.getTextCharacters(); [EOL] assertNotNull(textCharacters); [EOL] assertEquals("some content", new String(textCharacters)); [EOL] }
public void testGetTextLengthWithNonNullText() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithText("Some text"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("Some text".length(), length); [EOL] } [EOL] public void testGetTextLengthWithEmptyText() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithText(""); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(0, length); [EOL] } [EOL] public void testGetTextLengthWithNullText() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithText(null); [EOL] try { [EOL] parser.getTextLength(); [EOL] fail("Expected an exception due to null text"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetTextOffset() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] int offset = parser.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testTimeZoneSerializerConstructor() { [EOL] TimeZoneSerializer serializer = new TimeZoneSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithType_NullValue() throws IOException { [EOL] TimeZoneSerializer serializer = new TimeZoneSerializer(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] serializer.serializeWithType(null, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(null, mockJsonGenerator, TimeZone.class); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(null, mockJsonGenerator); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException { [EOL] TimeZoneSerializer serializer = new TimeZoneSerializer(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] serializer.serializeWithType(timeZone, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(timeZone, mockJsonGenerator, TimeZone.class); [EOL] verify(mockJsonGenerator).writeString(timeZone.getID()); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(timeZone, mockJsonGenerator); [EOL] }
public void testBeanSerializerBuilderCopyConstructor() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyWriter> properties = new ArrayList<>(); [EOL] properties.add(mock(BeanPropertyWriter.class)); [EOL] List<BeanPropertyWriter> filteredProperties = new ArrayList<>(); [EOL] filteredProperties.add(mock(BeanPropertyWriter.class)); [EOL] AnyGetterWriter anyGetter = mock(AnyGetterWriter.class); [EOL] Object filterId = new Object(); [EOL] BeanSerializerBuilder original = new BeanSerializerBuilder(beanDesc); [EOL] original.setProperties(properties); [EOL] original.setFilteredProperties(filteredProperties); [EOL] original.setAnyGetter(anyGetter); [EOL] original.setFilterId(filterId); [EOL] BeanSerializerBuilder copy = new BeanSerializerBuilder(original); [EOL] assertSame(beanDesc, copy.getBeanDescription()); [EOL] assertSame(properties, copy.getProperties()); [EOL] assertSame(filteredProperties, copy.getFilteredProperties()); [EOL] assertSame(anyGetter, copy.getAnyGetter()); [EOL] assertSame(filterId, copy.getFilterId()); [EOL] }
public void testSetTypeIdWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMember idProp = null; // Assuming AnnotatedMember is the correct type [EOL] instance.setTypeId(idProp); [EOL] assertEquals(idProp, instance.getTypeId()); [EOL] }
public void testSetTypeIdWithNonNull() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMember idProp = new MockAnnotatedMember(); // Assuming MockAnnotatedMember is a mock implementation of AnnotatedMember [EOL] instance.setTypeId(idProp); [EOL] assertEquals(idProp, instance.getTypeId()); [EOL] }
public void testSetTypeIdWhenAlreadySet() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMember firstIdProp = new MockAnnotatedMember(); [EOL] instance.setTypeId(firstIdProp); [EOL] AnnotatedMember secondIdProp = new MockAnnotatedMember(); [EOL] try { [EOL] instance.setTypeId(secondIdProp); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public String translate(String input) { [EOL] if (input == null) { [EOL] return null; [EOL] } [EOL] return input.toUpperCase(); [EOL] } [EOL] public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName) { [EOL] return translate(defaultName); [EOL] }
public void testConstructFromToStringWithValidEnum() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] AnnotationIntrospector intr = null; // Assuming a default or mock implementation [EOL] EnumValues result = EnumValues.constructFromToString(enumClass, intr); [EOL] assertNotNull(result); [EOL] for (MyEnum constant : MyEnum.values()) { [EOL] SerializedString serialized = result.serializedValueFor(constant); [EOL] assertEquals(constant.toString(), serialized.getValue()); [EOL] } [EOL] }
public void testConstructFromToStringWithInvalidEnum() { [EOL] Class<Enum<?>> enumClass = InvalidEnum.class; // Assuming InvalidEnum is an enum with no constants [EOL] AnnotationIntrospector intr = null; // Assuming a default or mock implementation [EOL] try { [EOL] EnumValues.constructFromToString(enumClass, intr); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBigIntegerNodeWithNull() { [EOL] BigIntegerNode node = new BigIntegerNode(null); [EOL] assertNull(node.getBigIntegerValue()); [EOL] }
public void testBigIntegerNodeWithZero() { [EOL] BigIntegerNode node = new BigIntegerNode(BigInteger.ZERO); [EOL] assertEquals(BigInteger.ZERO, node.getBigIntegerValue()); [EOL] }
public void testBigIntegerNodeWithPositiveValue() { [EOL] BigInteger value = new BigInteger("123456789"); [EOL] BigIntegerNode node = new BigIntegerNode(value); [EOL] assertEquals(value, node.getBigIntegerValue()); [EOL] }
public void testBigIntegerNodeWithNegativeValue() { [EOL] BigInteger value = new BigInteger("-123456789"); [EOL] BigIntegerNode node = new BigIntegerNode(value); [EOL] assertEquals(value, node.getBigIntegerValue()); [EOL] }
public void testBigIntegerNodeValueOfWithNull() { [EOL] BigInteger v = null; [EOL] BigIntegerNode result = BigIntegerNode.valueOf(v); [EOL] assertNull(result); [EOL] }
public void testBigIntegerNodeValueOfWithNonNull() { [EOL] BigInteger v = new BigInteger("12345"); [EOL] BigIntegerNode result = BigIntegerNode.valueOf(v); [EOL] assertNotNull(result); [EOL] assertEquals(new BigInteger("12345"), result.bigIntegerValue()); [EOL] }
public void testAsToken() { [EOL] MyJsonNode node = new MyJsonNode(); [EOL] JsonToken token = node.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, token); [EOL] }
public void testNumberType() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] NumericNode numericNode = nodeFactory.numberNode(new BigInteger("12345678901234567890")); [EOL] assertEquals(JsonParser.NumberType.BIG_INTEGER, numericNode.numberType()); [EOL] }
public void testIsIntegralNumberReturnsTrue() { [EOL] YourClassWithMethod instance = new YourClassWithMethod(); [EOL] boolean result = instance.isIntegralNumber(); [EOL] assert result : "The method should return true"; [EOL] }
public void testIsBigInteger_ShouldReturnTrue() { [EOL] JsonNumber jsonNumber = new JsonNumber(); [EOL] boolean result = jsonNumber.isBigInteger(); [EOL] assert result : "The method should return true for isBigInteger"; [EOL] }
public void testCanConvertToInt_MinValue() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MIN_INTEGER); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_MaxValue() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MAX_INTEGER); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_TooSmall() { [EOL] BigDecimal oneLessThanMin = BigDecimalValue.MIN_INTEGER.subtract(BigDecimal.ONE); [EOL] BigDecimalValue value = new BigDecimalValue(oneLessThanMin); [EOL] assertFalse(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_TooLarge() { [EOL] BigDecimal oneMoreThanMax = BigDecimalValue.MAX_INTEGER.add(BigDecimal.ONE); [EOL] BigDecimalValue value = new BigDecimalValue(oneMoreThanMax); [EOL] assertFalse(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_InRange() { [EOL] BigDecimal inRangeValue = BigDecimalValue.MIN_INTEGER.add(BigDecimal.ONE); [EOL] BigDecimalValue value = new BigDecimalValue(inRangeValue); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToLong_MinValue() { [EOL] BigDecimal value = new BigDecimal(Long.MIN_VALUE); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertTrue(node.canConvertToLong()); [EOL] }
public void testCanConvertToLong_MaxValue() { [EOL] BigDecimal value = new BigDecimal(Long.MAX_VALUE); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertTrue(node.canConvertToLong()); [EOL] }
public void testCanConvertToLong_TooSmall() { [EOL] BigDecimal value = new BigDecimal(Long.MIN_VALUE).subtract(BigDecimal.ONE); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertFalse(node.canConvertToLong()); [EOL] }
public void testCanConvertToLong_TooLarge() { [EOL] BigDecimal value = new BigDecimal(Long.MAX_VALUE).add(BigDecimal.ONE); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertFalse(node.canConvertToLong()); [EOL] }
public void testNumberValueWithNonNullValue() { [EOL] Number expectedValue = 42; [EOL] JsonNumber jsonNumber = new JsonNumber(expectedValue); [EOL] Number result = jsonNumber.numberValue(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testNumberValueWithNullValue() { [EOL] JsonNumber jsonNumber = new JsonNumber(null); [EOL] Number result = jsonNumber.numberValue(); [EOL] assertNull(result); [EOL] }
public void testIntValue_Positive() { [EOL] JsonInteger jsonInteger = new JsonInteger(10); [EOL] int result = jsonInteger.intValue(); [EOL] assert result == 10 : "The intValue method should return the correct int value."; [EOL] }
public void testIntValue_Negative() { [EOL] JsonInteger jsonInteger = new JsonInteger(-10); [EOL] int result = jsonInteger.intValue(); [EOL] assert result == -10 : "The intValue method should return the correct int value for negative numbers."; [EOL] }
public void testIntValue_Zero() { [EOL] JsonInteger jsonInteger = new JsonInteger(0); [EOL] int result = jsonInteger.intValue(); [EOL] assert result == 0 : "The intValue method should return zero when the value is zero."; [EOL] }
public void testLongValue_Positive() { [EOL] JsonLong jsonLong = new JsonLong(123L); [EOL] long expected = 123L; [EOL] long actual = jsonLong.longValue(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testLongValue_Negative() { [EOL] JsonLong jsonLong = new JsonLong(-123L); [EOL] long expected = -123L; [EOL] long actual = jsonLong.longValue(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testLongValue_Zero() { [EOL] JsonLong jsonLong = new JsonLong(0L); [EOL] long expected = 0L; [EOL] long actual = jsonLong.longValue(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testLongValue_MaxLong() { [EOL] JsonLong jsonLong = new JsonLong(Long.MAX_VALUE); [EOL] long expected = Long.MAX_VALUE; [EOL] long actual = jsonLong.longValue(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testLongValue_MinLong() { [EOL] JsonLong jsonLong = new JsonLong(Long.MIN_VALUE); [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = jsonLong.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBigIntegerValueNonNull() { [EOL] BigInteger expected = new BigInteger("1234567890"); [EOL] JsonBigInteger valueWrapper = new JsonBigInteger(expected); [EOL] BigInteger result = valueWrapper.bigIntegerValue(); [EOL] assertNotNull(result); [EOL] assertEquals(expected, result); [EOL] }
public void testBigIntegerValueNull() { [EOL] JsonBigInteger valueWrapper = new JsonBigInteger(null); [EOL] BigInteger result = valueWrapper.bigIntegerValue(); [EOL] assertNull(result); [EOL] }
public void testDoubleValue_Positive() { [EOL] YourClass instance = new YourClass(10.5); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(10.5, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] YourClass instance = new YourClass(-10.5); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(-10.5, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] YourClass instance = new YourClass(0.0); [EOL] double result = instance.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testAsTextWithNonNullValue() { [EOL] JsonNode node = new JsonNode("TestValue"); [EOL] String result = node.asText(); [EOL] assertEquals("TestValue", result); [EOL] }
public void testAsTextWithNullValue() { [EOL] JsonNode node = new JsonNode(null); [EOL] String result = node.asText(); [EOL] assertEquals("null", result); [EOL] }
public void testEqualsWithSameObject() { [EOL] BigIntegerNode node = new BigIntegerNode(new BigInteger("123")); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEqualsWithNull() { [EOL] BigIntegerNode node = new BigIntegerNode(new BigInteger("123")); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] BigIntegerNode node = new BigIntegerNode(new BigInteger("123")); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEqualsWithDifferentValue() { [EOL] BigIntegerNode node1 = new BigIntegerNode(new BigInteger("123")); [EOL] BigIntegerNode node2 = new BigIntegerNode(new BigInteger("456")); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testEqualsWithSameValue() { [EOL] BigIntegerNode node1 = new BigIntegerNode(new BigInteger("123")); [EOL] BigIntegerNode node2 = new BigIntegerNode(new BigInteger("123")); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testHashCodeWithNonNullValue() { [EOL] SomeClass instance = new SomeClass("testValue"); [EOL] int expectedHashCode = "testValue".hashCode(); [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testBooleanNodeTrue() { [EOL] BooleanNode result = booleanNode(true); [EOL] assertTrue(result == BooleanNode.getTrue()); [EOL] }
public void testBooleanNodeFalse() { [EOL] BooleanNode result = booleanNode(false); [EOL] assertTrue(result == BooleanNode.getFalse()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int testValue = 5; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result instanceof IntNode); [EOL] assertEquals(testValue, result.intValue()); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int testValue = -5; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result instanceof IntNode); [EOL] assertEquals(testValue, result.intValue()); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int testValue = 0; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result instanceof IntNode); [EOL] assertEquals(testValue, result.intValue()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] long positiveValue = 123L; [EOL] NumericNode result = numberNode(positiveValue); [EOL] assertTrue(result instanceof LongNode); [EOL] assertEquals(positiveValue, result.longValue()); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] long negativeValue = -123L; [EOL] NumericNode result = numberNode(negativeValue); [EOL] assertTrue(result instanceof LongNode); [EOL] assertEquals(negativeValue, result.longValue()); [EOL] }
public void testNumberNodeWithZero() { [EOL] long zeroValue = 0L; [EOL] NumericNode result = numberNode(zeroValue); [EOL] assertTrue(result instanceof LongNode); [EOL] assertEquals(zeroValue, result.longValue()); [EOL] }
public void testNumberNodeWithNull() { [EOL] BigInteger bigIntegerValue = null; [EOL] NumericNode result = numberNode(bigIntegerValue); [EOL] assertNull(result); [EOL] }
public void testNumberNodeWithZero() { [EOL] BigInteger bigIntegerValue = BigInteger.ZERO; [EOL] NumericNode result = numberNode(bigIntegerValue); [EOL] assertNotNull(result); [EOL] assertEquals(BigInteger.ZERO, result.bigIntegerValue()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] BigInteger bigIntegerValue = BigInteger.valueOf(123); [EOL] NumericNode result = numberNode(bigIntegerValue); [EOL] assertNotNull(result); [EOL] assertEquals(BigInteger.valueOf(123), result.bigIntegerValue()); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] BigInteger bigIntegerValue = BigInteger.valueOf(-123); [EOL] NumericNode result = numberNode(bigIntegerValue); [EOL] assertNotNull(result); [EOL] assertEquals(BigInteger.valueOf(-123), result.bigIntegerValue()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NumericNode node = mapper.numberNode(5.0); [EOL] assertTrue(node.isNumber()); [EOL] assertEquals(5.0, node.doubleValue(), 0.0); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NumericNode node = mapper.numberNode(-5.0); [EOL] assertTrue(node.isNumber()); [EOL] assertEquals(-5.0, node.doubleValue(), 0.0); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NumericNode node = mapper.numberNode(0.0); [EOL] assertTrue(node.isNumber()); [EOL] assertEquals(0.0, node.doubleValue(), 0.0); [EOL] }
public void testTextNodeWithNull() { [EOL] TextNode result = textNode(null); [EOL] assertNull(result.asText()); [EOL] }
public void testTextNodeWithEmptyString() { [EOL] TextNode result = textNode(""); [EOL] assertEquals("", result.asText()); [EOL] }
public void testTextNodeWithRegularString() { [EOL] String regularString = "Jackson"; [EOL] TextNode result = textNode(regularString); [EOL] assertEquals("Jackson", result.asText()); [EOL] }
public void testArrayNodeCreation() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ArrayNode arrayNode = mapper.arrayNode(); [EOL] assertNotNull(arrayNode); [EOL] assertTrue(arrayNode instanceof ArrayNode); [EOL] }
public void testObjectNodeCreation() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectNode objectNode = mapper.objectNode(); [EOL] assertNotNull(objectNode); [EOL] assertTrue(objectNode instanceof ObjectNode); [EOL] }
public void testWithAbstractTypeResolver_NullResolver() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); // Replace with actual factory implementation [EOL] AbstractTypeResolver resolver = null; [EOL] DeserializerFactory resultFactory = factory.withAbstractTypeResolver(resolver); [EOL] assertNotNull(resultFactory); [EOL] assertNotSame(factory, resultFactory); [EOL] }
public void testWithAbstractTypeResolver_NonNullResolver() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); // Replace with actual factory implementation [EOL] AbstractTypeResolver resolver = new MyAbstractTypeResolver(); // Replace with actual AbstractTypeResolver implementation [EOL] DeserializerFactory resultFactory = factory.withAbstractTypeResolver(resolver); [EOL] assertNotNull(resultFactory); [EOL] assertNotSame(factory, resultFactory); [EOL] }
public void testMapAbstractTypeWithNullNextType() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(Object.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) { [EOL] return null; // Simulate _mapAbstractType2 returning null [EOL] } [EOL] }; [EOL] mapper.setAbstractTypeResolver(resolver); [EOL] JavaType result = mapper.mapAbstractType(config, type); [EOL] assertEquals(type, result); // Assert that the original type is returned [EOL] }
public void testMapAbstractTypeWithInvalidResolution() { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(Object.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) { [EOL] return new SimpleType(String.class); // Simulate _mapAbstractType2 returning a non-assignable type [EOL] } [EOL] }; [EOL] mapper.setAbstractTypeResolver(resolver); [EOL] try { [EOL] mapper.mapAbstractType(config, type); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMapAbstractTypeWithValidResolution() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(Collection.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) { [EOL] if (type.getRawClass() == Collection.class) { [EOL] return typeFactory.constructCollectionType(ArrayList.class, Object.class); [EOL] } [EOL] return null; [EOL] } [EOL] }; [EOL] mapper.setAbstractTypeResolver(resolver); [EOL] JavaType result = mapper.mapAbstractType(config, type); [EOL] assertNotEquals(type, result); // Assert that a new type is returned [EOL] assertTrue(result.getRawClass().isAssignableFrom(ArrayList.class)); // Assert that the new type is assignable from the original [EOL] }
public void testMapAbstractType2WithNoAbstractTypeResolvers() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = new JavaType(...); // Provide actual initialization [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.emptyList()); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNull(result); [EOL] }
public void testMapAbstractType2WithUnresolvedAbstractType() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = new JavaType(...); // Provide actual initialization [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL] return null; // Simulate unresolved type [EOL] } [EOL] }; [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.singletonList(resolver)); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNull(result); [EOL] }
public void testMapAbstractType2WithResolvedAbstractType() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JavaType type = new JavaType(...); // Provide actual initialization [EOL] final Class<?> resolvedClass = SomeConcreteClass.class; // Replace with actual concrete class [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL] if (type.getRawClass().equals(SomeAbstractClass.class)) { // Replace with actual abstract class [EOL] return new JavaType(resolvedClass, ...); // Provide actual initialization [EOL] } [EOL] return null; [EOL] } [EOL] }; [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.singletonList(resolver)); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNotNull(result); [EOL] assertEquals(resolvedClass, result.getRawClass()); [EOL] }
public void testFindValueInstantiatorWithAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(new Object()); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAnnotationAndStdInstantiator() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(new StdValueInstantiator(ctxt.getConfig(), beanDesc.getType())); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAnnotationAndConstructDefault() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(null); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithCustomValueInstantiators() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] when(_factoryConfig.hasValueInstantiators()).thenReturn(true); [EOL] when(_factoryConfig.valueInstantiators()).thenReturn(Collections.singletonList(createCustomValueInstantiators())); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullCustomValueInstantiators() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] when(_factoryConfig.hasValueInstantiators()).thenReturn(true); [EOL] when(_factoryConfig.valueInstantiators()).thenReturn(Collections.singletonList(createNullReturningValueInstantiators())); [EOL] assertThrows(JsonMappingException.class, () -> findValueInstantiator(ctxt, beanDesc)); [EOL] }
public void testFindValueInstantiatorWithIncompleteParameter() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiator instantiator = createValueInstantiatorWithIncompleteParameter(); [EOL] when(_constructDefaultValueInstantiator(ctxt, beanDesc)).thenReturn(instantiator); [EOL] assertThrows(IllegalArgumentException.class, () -> findValueInstantiator(ctxt, beanDesc)); [EOL] }
public void testValueInstantiatorInstanceWithNull() { [EOL] DeserializationConfig config = null; // Assuming DeserializationConfig can be null or a mock [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Object instDef = null; [EOL] ValueInstantiator result = _valueInstantiatorInstance(config, annotated, instDef); [EOL] assertNull(result); [EOL] }
public void testValueInstantiatorInstanceWithInstance() { [EOL] DeserializationConfig config = null; // Assuming DeserializationConfig can be null or a mock [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] ValueInstantiator instDef = new ValueInstantiatorBase(); // Assuming ValueInstantiatorBase is a valid subclass [EOL] ValueInstantiator result = _valueInstantiatorInstance(config, annotated, instDef); [EOL] assertSame(instDef, result); [EOL] }
public void testValueInstantiatorInstanceWithInvalidType() { [EOL] DeserializationConfig config = null; // Assuming DeserializationConfig can be null or a mock [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Object instDef = new Object(); // Invalid type for instDef [EOL] try { [EOL] _valueInstantiatorInstance(config, annotated, instDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned key deserializer definition of type java.lang.Object; expected type KeyDeserializer or Class<KeyDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testValueInstantiatorInstanceWithNoClass() { [EOL] DeserializationConfig config = null; // Assuming DeserializationConfig can be null or a mock [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Object instDef = NoClass.class; // Assuming NoClass is a valid class constant [EOL] ValueInstantiator result = _valueInstantiatorInstance(config, annotated, instDef); [EOL] assertNull(result); [EOL] }
public void testValueInstantiatorInstanceWithNonAssignableClass() { [EOL] DeserializationConfig config = null; // Assuming DeserializationConfig can be null or a mock [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Object instDef = String.class; // Non-assignable class [EOL] try { [EOL] _valueInstantiatorInstance(config, annotated, instDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<ValueInstantiator>", e.getMessage()); [EOL] } [EOL] }
public void testValueInstantiatorInstanceWithHandlerInstantiator() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); // Assuming we can mock DeserializationConfig [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Class<?> instDef = ValueInstantiatorBase.class; // Assuming ValueInstantiatorBase is a valid subclass [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); // Assuming we can mock HandlerInstantiator [EOL] ValueInstantiator expectedInst = new ValueInstantiatorBase(); // Assuming ValueInstantiatorBase is a valid subclass [EOL] when(config.getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.valueInstantiatorInstance(any(DeserializationConfig.class), any(Annotated.class), any(Class.class))).thenReturn(expectedInst); [EOL] ValueInstantiator result = _valueInstantiatorInstance(config, annotated, instDef); [EOL] assertSame(expectedInst, result); [EOL] }
public void testValueInstantiatorInstanceWithHandlerInstantiatorReturningNull() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); // Assuming we can mock DeserializationConfig [EOL] Annotated annotated = null; // Assuming Annotated can be null or a mock [EOL] Class<?> instDef = ValueInstantiatorBase.class; // Assuming ValueInstantiatorBase is a valid subclass [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); // Assuming we can mock HandlerInstantiator [EOL] when(config.getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.valueInstantiatorInstance(any(DeserializationConfig.class), any(Annotated.class), any(Class.class))).thenReturn(null); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] ValueInstantiator result = _valueInstantiatorInstance(config, annotated, instDef); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ValueInstantiator); [EOL] }
public void testConstructCreatorPropertyWithNonNullIntrospectorAndRequiredMarker() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.hasRequiredMarker(param)).thenReturn(Boolean.TRUE); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertTrue(result.isRequired()); [EOL] }
public void testConstructCreatorPropertyWithNullIntrospector() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertFalse(result.isRequired()); [EOL] }
public void testConstructCreatorPropertyWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] when(type.getTypeHandler()).thenReturn(typeDeser); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertEquals(typeDeser, result.getTypeDeserializer()); [EOL] }
public void testConstructCreatorPropertyWithValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] when(findDeserializerFromAnnotation(ctxt, param)).thenReturn(valueDeser); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertEquals(valueDeser, result.getValueDeserializer()); [EOL] }
public void testCreateArrayDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayType(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JsonDeserializer<?> customDeser = createCustomArrayDeserializer(); [EOL] when(_findCustomArrayDeserializer(type, ctxt.getConfig(), beanDesc, null, null)).thenReturn(customDeser); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(customDeser, result); [EOL] }
public void testCreateArrayDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithPrimitiveContentType(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof PrimitiveArrayDeserializers); [EOL] }
public void testCreateArrayDeserializerWithStringType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithStringContentType(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(StringArrayDeserializer.instance, result); [EOL] }
public void testCreateArrayDeserializerWithObjectArray() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayTypeWithObjectContentType(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof ObjectArrayDeserializer); [EOL] }
public void testCreateArrayDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ArrayType type = createArrayType(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JsonDeserializer<?> baseDeser = createBaseDeserializer(); [EOL] when(_findCustomArrayDeserializer(type, ctxt.getConfig(), beanDesc, null, null)).thenReturn(baseDeser); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] BeanDeserializerModifier modifier = createBeanDeserializerModifier(); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonDeserializer<?> modifiedDeser = createModifiedDeserializer(); [EOL] when(modifier.modifyArrayDeserializer(ctxt.getConfig(), type, beanDesc, baseDeser)).thenReturn(modifiedDeser); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame(modifiedDeser, result); [EOL] }
public void testFindCustomArrayDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] ArrayType type = mock(ArrayType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer)).thenReturn(expectedDeserializer); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = factoryConfig.withAdditionalDeserializers(deserializers); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomArrayDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] ArrayType type = mock(ArrayType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer)).thenReturn(null); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = factoryConfig.withAdditionalDeserializers(deserializers); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindCustomEnumDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findEnumDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))) [EOL] .thenReturn(expectedDeserializer); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers), null, null); [EOL] JsonDeserializer<?> result = factory._findCustomEnumDeserializer(Enum.class, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomEnumDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findEnumDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))) [EOL] .thenReturn(null); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers), null, null); [EOL] JsonDeserializer<?> result = factory._findCustomEnumDeserializer(Enum.class, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testCreateTreeDeserializerWithCustomDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType nodeType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<? extends JsonNode> nodeClass = JsonNode.class; [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(nodeType.getRawClass()).thenReturn((Class) nodeClass); [EOL] when(_findCustomTreeNodeDeserializer(nodeClass, config, beanDesc)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = createTreeDeserializer(config, nodeType, beanDesc); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateTreeDeserializerWithDefaultDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType nodeType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<? extends JsonNode> nodeClass = JsonNode.class; [EOL] when(nodeType.getRawClass()).thenReturn((Class) nodeClass); [EOL] when(_findCustomTreeNodeDeserializer(nodeClass, config, beanDesc)).thenReturn(null); [EOL] JsonDeserializer<?> result = createTreeDeserializer(config, nodeType, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNodeDeserializer); [EOL] }
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL] for (Deserializers d : _factoryConfig.deserializers()) { [EOL] JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testFindTypeDeserializerWithNoTypeResolverAndNoDefaultTyper() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(mock(BeanDescription.class)); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.getDefaultTyper(any(JavaType.class))).thenReturn(null); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testFindTypeDeserializerWithTypeResolverAndSubtypes() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] BeanDescription bean = mock(BeanDescription.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] SubtypeResolver subtypeResolver = mock(SubtypeResolver.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); [EOL] when(bean.getClassInfo()).thenReturn(ac); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findTypeResolver(config, ac, baseType)).thenReturn(builder); [EOL] when(config.getSubtypeResolver()).thenReturn(subtypeResolver); [EOL] when(subtypeResolver.collectAndResolveSubtypes(ac, config, ai)).thenReturn(subtypes); [EOL] when(builder.buildTypeDeserializer(config, baseType, subtypes)).thenReturn(mock(TypeDeserializer.class)); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindTypeDeserializerWithDefaultImplAndAbstractBaseType() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JavaType defaultType = mock(JavaType.class); [EOL] BeanDescription bean = mock(BeanDescription.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] when(baseType.isAbstract()).thenReturn(true); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); [EOL] when(bean.getClassInfo()).thenReturn(ac); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findTypeResolver(config, ac, baseType)).thenReturn(builder); [EOL] when(builder.getDefaultImpl()).thenReturn(null); [EOL] when(config.getDefaultTyper(baseType)).thenReturn(builder); [EOL] when(builder.defaultImpl(any(Class.class))).thenReturn(builder); [EOL] when(builder.buildTypeDeserializer(config, baseType, null)).thenReturn(mock(TypeDeserializer.class)); [EOL] when(this.mapAbstractType(config, baseType)).thenReturn(defaultType); [EOL] when(defaultType.getRawClass()).thenReturn(String.class); [EOL] TypeDeserializer result = findTypeDeserializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateKeyDeserializerWithKeyDeserializers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializers keyDeserializers = mock(KeyDeserializers.class); [EOL] KeyDeserializer expectedDeserializer = mock(KeyDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspectClassAnnotations(any(Class.class))).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(keyDeserializers.findKeyDeserializer(eq(type), eq(config), eq(beanDesc))).thenReturn(expectedDeserializer); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] factory._factoryConfig = factory._factoryConfig.withAdditionalKeyDeserializers(keyDeserializers); [EOL] KeyDeserializer result = factory.createKeyDeserializer(ctxt, type); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateKeyDeserializerWithoutKeyDeserializersEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] KeyDeserializer result = factory.createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] }
public void testCreateKeyDeserializerWithoutKeyDeserializersNonEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(StdKeyDeserializers.findStringBasedKeyDeserializer(config, type)).thenReturn(mock(KeyDeserializer.class)); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] KeyDeserializer result = factory.createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] }
public void testCreateKeyDeserializerWithDeserializerModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] KeyDeserializer baseDeserializer = mock(KeyDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(StdKeyDeserializers.findStringBasedKeyDeserializer(config, type)).thenReturn(baseDeserializer); [EOL] when(modifier.modifyKeyDeserializer(eq(config), eq(type), any(KeyDeserializer.class))).thenReturn(baseDeserializer); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] factory._factoryConfig = factory._factoryConfig.withDeserializerModifier(modifier); [EOL] KeyDeserializer result = factory.createKeyDeserializer(ctxt, type); [EOL] assertSame(baseDeserializer, result); [EOL] }
public void testCreateEnumKeyDeserializerWithAnnotatedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] AnnotatedClass classInfo = mock(AnnotatedClass.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(classInfo); [EOL] when(findDeserializerFromAnnotation(ctxt, classInfo)).thenReturn(deserializer); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.DelegatingKD); [EOL] }
public void testCreateEnumKeyDeserializerWithCustomEnumDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> enumClass = Enum.class; [EOL] JsonDeserializer<?> customDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(_findCustomEnumDeserializer(enumClass, config, beanDesc)).thenReturn(customDeserializer); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.DelegatingKD); [EOL] }
public void testCreateEnumKeyDeserializerWithFactoryMethod() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> enumClass = Enum.class; [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factory); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.hasCreatorAnnotation(factory)).thenReturn(true); [EOL] when(factory.getParameterCount()).thenReturn(1); [EOL] when(factory.getRawReturnType()).thenReturn(enumClass); [EOL] when(factory.getGenericParameterType(0)).thenReturn(String.class); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.EnumKD); [EOL] }
public void testCreateEnumKeyDeserializerWithInvalidFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> enumClass = Enum.class; [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factory); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.hasCreatorAnnotation(factory)).thenReturn(true); [EOL] when(factory.getParameterCount()).thenReturn(1); [EOL] when(factory.getRawReturnType()).thenReturn(enumClass); [EOL] when(factory.getGenericParameterType(0)).thenReturn(Object.class); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _createEnumKeyDeserializer(ctxt, type); [EOL] }); [EOL] assertEquals("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String", exception.getMessage()); [EOL] }
public void testCreateEnumKeyDeserializerWithUnsuitableFactoryMethod() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> enumClass = Enum.class; [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> factoryMethods = Collections.singletonList(factory); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.hasCreatorAnnotation(factory)).thenReturn(true); [EOL] when(factory.getParameterCount()).thenReturn(2); // argCount is not 1 [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] _createEnumKeyDeserializer(ctxt, type); [EOL] }); [EOL] assertEquals("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")", exception.getMessage()); [EOL] }
public void testCreateEnumKeyDeserializerWithNoCustomDeserializerOrFactoryMethod() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> enumClass = Enum.class; [EOL] List<AnnotatedMethod> factoryMethods = Collections.emptyList(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(type.getRawClass()).thenReturn(enumClass); [EOL] when(beanDesc.getFactoryMethods()).thenReturn(factoryMethods); [EOL] KeyDeserializer result = _createEnumKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdKeyDeserializers.EnumKD); [EOL] }
public void testFindPropertyTypeDeserializerWithNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] AnnotatedMember annotated = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyTypeResolver(config, annotated, baseType)).thenReturn(null); [EOL] TypeDeserializer typeDeserializer = findPropertyTypeDeserializer(config, baseType, annotated); [EOL] assertNotNull(typeDeserializer); [EOL] }
public void testFindPropertyTypeDeserializerWithNonNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] AnnotatedMember annotated = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] TypeDeserializer expectedTypeDeserializer = mock(TypeDeserializer.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyTypeResolver(config, annotated, baseType)).thenReturn(builder); [EOL] when(config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType)).thenReturn(subtypes); [EOL] when(builder.buildTypeDeserializer(config, baseType, subtypes)).thenReturn(expectedTypeDeserializer); [EOL] TypeDeserializer typeDeserializer = findPropertyTypeDeserializer(config, baseType, annotated); [EOL] assertSame(expectedTypeDeserializer, typeDeserializer); [EOL] }
public void testModifyTypeByAnnotationWithSubclass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithDeserializationType(type.getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidSubclass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithKeyClass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(type.getKeyType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidKeyClass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); // Not a MapLikeType [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(Object.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithContentType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentDeserializationType(type.getContentType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidContentType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidContentDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testResolveTypeWithContainerTypeAndKeyDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithKeyDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getKeyType()); [EOL] assertNotNull(resultType.getKeyValueHandler()); [EOL] } [EOL] public void testResolveTypeWithContainerTypeAndContentDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentValueHandler()); [EOL] } [EOL] public void testResolveTypeWithContainerTypeAndContentTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentTypeHandler()); [EOL] } [EOL] public void testResolveTypeWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithValueTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNotNull(resultType.getTypeHandler()); [EOL] } [EOL] public void testResolveTypeWithoutTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithoutTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNull(resultType.getTypeHandler()); [EOL] }
public void testSerializeValueWithNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] JavaType rootType = null; [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(ser).when(spyMapper).getDefaultNullValueSerializer(); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(ser).serialize(eq(value), eq(jgen), any(ObjectMapper.class)); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(any(String.class)); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithTypeAndSerializer() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = "testValue"; [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(rootType.getRawClass()).thenReturn(String.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(false).when(spyMapper).isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(ser).serialize(eq(value), eq(jgen), any(ObjectMapper.class)); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(any(String.class)); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithWrapRootValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = "testValue"; [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] PropertyName rootName = new PropertyName("root"); [EOL] when(rootType.getRawClass()).thenReturn(String.class); [EOL] when(rootType.hasRawClass(String.class)).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] doReturn(true).when(spyMapper).isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL] doReturn(rootName).when(spyMapper).findRootName(any(JavaType.class), any(SerializationConfig.class)); [EOL] spyMapper.serializeValue(jgen, value, rootType, ser); [EOL] verify(ser).serialize(eq(value), eq(jgen), any(ObjectMapper.class)); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(eq(rootName.getSimpleName())); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithIncompatibleRootType() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = null; [EOL] when(rootType.getRawClass()).thenReturn(String.class); [EOL] when(rootType.hasRawClass(String.class)).thenReturn(false); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper spyMapper = spy(mapper); [EOL] assertThrows(JsonMappingException.class, () -> spyMapper.serializeValue(jgen, value, rootType, ser)); [EOL] }
public void testDeserializeWithStartObjectAndVanillaProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming vanillaDeserialize method handles END_OBJECT [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectAndObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeWithObjectId method handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeFromObject method handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOther() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Assuming _deserializeOther method handles VALUE_STRING [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] try { [EOL] _deserializeOther(jp, ctxt, null); [EOL] fail("Expected an exception due to missing token"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testDeserializeOtherWithValueString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string"); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_STRING); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] }
public void testDeserializeOtherWithValueNumberInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_INT); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Integer); [EOL] }
public void testDeserializeOtherWithValueNumberFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_FLOAT); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Double); [EOL] }
public void testDeserializeOtherWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeOtherWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_TRUE); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Boolean); [EOL] assertTrue((Boolean) result); [EOL] }
public void testDeserializeOtherWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_FALSE); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Boolean); [EOL] assertFalse((Boolean) result); [EOL] }
public void testDeserializeOtherWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.START_ARRAY); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] _vanillaProcessing = true; // Assuming this is a field that can be set for the test [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.FIELD_NAME); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithEndObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] _vanillaProcessing = false; // Assuming this is a field that can be set for the test [EOL] _objectIdReader = null; // Assuming this is a field that can be set for the test [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.END_OBJECT); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithInvalidToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _deserializeOther(jp, ctxt, JsonToken.NOT_AVAILABLE); [EOL] fail("Expected an exception due to invalid token"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithUnwrapped(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithExternalTypeId(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationUsingNonDefault(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyDeserializeFromObjectUsingNonDefault(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndInjectables() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithInjectables(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyInjectValues(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndViewProcessing() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithViewProcessing(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithView(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndKnownProperties() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithKnownProperties(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyKnownPropertiesDeserialization(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndIgnorableProperties() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithIgnorableProperties(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyIgnorablePropertiesSkipped(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndAnySetter() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithAnySetter(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyAnySetterDeserialization(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndUnknownProperties() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithUnknownProperties(); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] verifyHandleUnknownProperty(result); [EOL] }
protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer unknown = null; [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] bean = null; [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(jp, ctxt, bean, unknown); [EOL] } [EOL] if (unknown != null) { [EOL] bean = handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return deserialize(jp, ctxt, bean); [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (unknown == null) { [EOL] unknown = new TokenBuffer(jp.getCodec()); [EOL] } [EOL] unknown.writeFieldName(propName); [EOL] unknown.copyCurrentStructure(jp); [EOL] } [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] bean = null; [EOL] } [EOL] if (unknown != null) { [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(null, ctxt, bean, unknown); [EOL] } [EOL] return handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return bean; [EOL] }
protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] tokens.writeStartObject(); [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) { [EOL] ; [EOL] } else { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] t = jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] continue; [EOL] } [EOL] while (t == JsonToken.FIELD_NAME) { [EOL] jp.nextToken(); [EOL] tokens.copyCurrentStructure(jp); [EOL] t = jp.nextToken(); [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL] } [EOL] return ext.complete(jp, ctxt, bean); [EOL] } [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (ext.handlePropertyValue(jp, ctxt, propName, null)) { [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] } [EOL] } [EOL] try { [EOL] return ext.complete(jp, ctxt, buffer, creator); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] return null; [EOL] } [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatAndDifferentSerializeAsIndex() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(prov.getAnnotationIntrospector().findFormat(any(Annotated.class))).thenReturn(format); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(property.getType()).thenReturn(mock(JavaType.class)); [EOL] when(property.getType().getRawClass()).thenReturn(Enum.class); [EOL] EnumSerializer serializer = new EnumSerializer(null, true); [EOL] EnumSerializer spySerializer = spy(serializer); [EOL] doReturn(true).when(spySerializer)._isShapeWrittenUsingIndex(any(Class.class), any(JsonFormat.Value.class), anyBoolean()); [EOL] doReturn(false).when(spySerializer)._serializeAsIndex; [EOL] JsonSerializer<?> result = spySerializer.createContextual(prov, property); [EOL] assertNotSame(spySerializer, result); [EOL] assertTrue(result instanceof EnumSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatAndSameSerializeAsIndex() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(prov.getAnnotationIntrospector().findFormat(any(Annotated.class))).thenReturn(format); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(property.getType()).thenReturn(mock(JavaType.class)); [EOL] when(property.getType().getRawClass()).thenReturn(Enum.class); [EOL] EnumSerializer serializer = new EnumSerializer(null, false); [EOL] EnumSerializer spySerializer = spy(serializer); [EOL] doReturn(false).when(spySerializer)._isShapeWrittenUsingIndex(any(Class.class), any(JsonFormat.Value.class), anyBoolean()); [EOL] doReturn(false).when(spySerializer)._serializeAsIndex; [EOL] JsonSerializer<?> result = spySerializer.createContextual(prov, property); [EOL] assertSame(spySerializer, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] EnumSerializer serializer = new EnumSerializer(null, false); [EOL] JsonSerializer<?> result = serializer.createContextual(prov, property); [EOL] assertSame(serializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullFormat() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(prov.getAnnotationIntrospector().findFormat(any(Annotated.class))).thenReturn(null); [EOL] when(property.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] EnumSerializer serializer = new EnumSerializer(null, false); [EOL] JsonSerializer<?> result = serializer.createContextual(prov, property); [EOL] assertSame(serializer, result); [EOL] }
public void testGetSchemaWithSerializeAsIndex() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(_serializeAsIndex(provider)).thenReturn(true); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("integer", result.get("type").asText()); [EOL] assertTrue(result.get("type").booleanValue()); [EOL] }
public void testGetSchemaWithEnumTypeHint() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = MyEnum.class; // Assuming MyEnum is an enum type [EOL] when(provider.constructType(typeHint)).thenReturn(TypeFactory.defaultInstance().constructType(typeHint)); [EOL] when(_serializeAsIndex(provider)).thenReturn(false); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("string", result.get("type").asText()); [EOL] assertTrue(result.get("type").booleanValue()); [EOL] assertTrue(result.has("enum")); [EOL] ArrayNode enumNode = (ArrayNode) result.get("enum"); [EOL] assertEquals(_values.size(), enumNode.size()); [EOL] for (SerializedString value : _values.values()) { [EOL] assertTrue(enumNode.has(value.getValue())); [EOL] } [EOL] }
public void testGetSchemaWithoutTypeHint() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(_serializeAsIndex(provider)).thenReturn(false); [EOL] when(provider.constructType(null)).thenReturn(null); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("string", result.get("type").asText()); [EOL] assertTrue(result.get("type").booleanValue()); [EOL] assertFalse(result.has("enum")); [EOL] }
public void testSerializeAsIndexWhenConfigured() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(true); [EOL] MyEnumSerializer serializer = new MyEnumSerializer(null, true); [EOL] assertTrue(serializer._serializeAsIndex(provider)); [EOL] }
public void testSerializeAsIndexWhenNotConfigured() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(false); [EOL] MyEnumSerializer serializer = new MyEnumSerializer(null, null); [EOL] assertFalse(serializer._serializeAsIndex(provider)); [EOL] }
public void testIsShapeWrittenUsingIndexWithNullFormat() { [EOL] Boolean result = _isShapeWrittenUsingIndex(MyEnum.class, null, true); [EOL] assertNull(result); [EOL] } [EOL] public void testIsShapeWrittenUsingIndexWithShapeAny() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ANY); [EOL] Boolean result = _isShapeWrittenUsingIndex(MyEnum.class, format, true); [EOL] assertNull(result); [EOL] } [EOL] public void testIsShapeWrittenUsingIndexWithShapeScalar() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.SCALAR); [EOL] Boolean result = _isShapeWrittenUsingIndex(MyEnum.class, format, true); [EOL] assertNull(result); [EOL] } [EOL] public void testIsShapeWrittenUsingIndexWithShapeString() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.STRING); [EOL] Boolean result = _isShapeWrittenUsingIndex(MyEnum.class, format, true); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testIsShapeWrittenUsingIndexWithNumericShape() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.NUMBER); [EOL] Boolean result = _isShapeWrittenUsingIndex(MyEnum.class, format, true); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testIsShapeWrittenUsingIndexWithUnsupportedShape() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ARRAY); [EOL] try { [EOL] _isShapeWrittenUsingIndex(MyEnum.class, format, true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResetTypedWithNonNullClass() { [EOL] TypeReference ref = new TypeReference(SomeClass.class); [EOL] ref.resetTyped(OtherClass.class); [EOL] assertNull(ref.getType()); [EOL] assertEquals(OtherClass.class, ref.getRawClass()); [EOL] assertTrue(ref.isTyped()); [EOL] assertEquals(ref.hashCode(), ref.hash(OtherClass.class, true)); [EOL] }
public void testResetTypedWithNonNullType() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] TypeReference<?> typeRef = new TypeReference<Object>() {}; [EOL] JavaType type = objectMapper.getTypeFactory().constructType(typeRef); [EOL] YourClass instance = new YourClass(type, false); [EOL] instance.resetTyped(mockType); [EOL] assertEquals(mockType, instance._type); [EOL] assertNull(instance._class); [EOL] assertTrue(instance._isTyped); [EOL] assertEquals(instance.hash(mockType, true), instance._hashCode); [EOL] }
public void testResetTypedWithNullType() { [EOL] JavaType nullType = null; [EOL] YourClass instance = new YourClass(nullType, false); [EOL] instance.resetTyped(nullType); [EOL] assertNull(instance._type); [EOL] assertNull(instance._class); [EOL] assertTrue(instance._isTyped); [EOL] assertEquals(instance.hash(nullType, true), instance._hashCode); [EOL] }
public void testRenameAllWithNullTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] BeanPropertyMap result = originalMap.renameAll(null); [EOL] assertSame("Expected the same BeanPropertyMap instance when transformer is null", originalMap, result); [EOL] } [EOL] public void testRenameAllWithNoOpTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] BeanPropertyMap result = originalMap.renameAll(NameTransformer.NOP); [EOL] assertSame("Expected the same BeanPropertyMap instance when transformer is NOP", originalMap, result); [EOL] }
public void testRenameAllWithActualTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] }; [EOL] BeanPropertyMap result = originalMap.renameAll(transformer); [EOL] assertNotNull("Expected a new BeanPropertyMap instance when transformer is applied", result); [EOL] assertNotSame("Expected a different BeanPropertyMap instance when transformer is applied", originalMap, result); [EOL] for (SettableBeanProperty prop : result) { [EOL] assertTrue("Expected property name to be transformed", prop.getName().startsWith("prefix_")); [EOL] } [EOL] }
public void testRenameAllWithUnwrappingDeserializer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] }; [EOL] SettableBeanProperty propWithDeserializer = findPropertyWithDeserializer(originalMap); [EOL] assertNotNull("Expected at least one property with deserializer", propWithDeserializer); [EOL] BeanPropertyMap result = originalMap.renameAll(transformer); [EOL] SettableBeanProperty resultProp = result.find(propWithDeserializer.getName()); [EOL] assertNotNull("Expected transformed property to exist in the result map", resultProp); [EOL] assertNotSame("Expected a different deserializer instance after unwrapping", propWithDeserializer.getValueDeserializer(), resultProp.getValueDeserializer()); [EOL] }
public void testRemove_ExistingProperty() { [EOL] SettableBeanProperty property = createMockProperty("existingProperty"); [EOL] _addProperty(property); [EOL] assertTrue(_hasProperty("existingProperty")); [EOL] remove(property); [EOL] assertFalse(_hasProperty("existingProperty")); [EOL] } [EOL] public void testRemove_NonExistingProperty() { [EOL] SettableBeanProperty property = createMockProperty("nonExistingProperty"); [EOL] try { [EOL] remove(property); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testForTypeWithIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Integer.TYPE); [EOL] assertTrue(deserializer instanceof IntDeser); [EOL] }
public void testForTypeWithLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Long.TYPE); [EOL] assertTrue(deserializer instanceof LongDeser); [EOL] }
public void testForTypeWithByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Byte.TYPE); [EOL] assertTrue(deserializer instanceof ByteDeser); [EOL] }
public void testForTypeWithShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Short.TYPE); [EOL] assertTrue(deserializer instanceof ShortDeser); [EOL] }
public void testForTypeWithFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Float.TYPE); [EOL] assertTrue(deserializer instanceof FloatDeser); [EOL] }
public void testForTypeWithDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Double.TYPE); [EOL] assertTrue(deserializer instanceof DoubleDeser); [EOL] }
public void testForTypeWithBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Boolean.TYPE); [EOL] assertTrue(deserializer instanceof BooleanDeser); [EOL] }
public void testForTypeWithCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Character.TYPE); [EOL] assertTrue(deserializer instanceof CharDeser); [EOL] }
public void testForTypeWithInvalidType() { [EOL] try { [EOL] YourClass.forType(String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testDeserializeWithType_NullTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = null; [EOL] try { [EOL] new TestClass().deserializeWithType(jp, ctxt, typeDeserializer); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithType_ValidTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = new TestClass().deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testIntDeserConstructor() { [EOL] IntDeser deser = new IntDeser(); [EOL] assertNotNull(deser); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] IntArrayDeserializer deserializer = new IntArrayDeserializer(); [EOL] deserializer.deserialize(jp, ctxt); [EOL] verify(ctxt).handleNonArray(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] IntArrayDeserializer deserializer = new IntArrayDeserializer(); [EOL] int[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getIntValue()).thenReturn(1, 2); [EOL] IntArrayDeserializer deserializer = new IntArrayDeserializer(); [EOL] int[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(2, result[1]); [EOL] }
public void testDeserializeWithArrayExpansion() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getIntValue()).thenReturn(1, 2, 3); [EOL] IntArrayDeserializer deserializer = new IntArrayDeserializer(); [EOL] int[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(2, result[1]); [EOL] assertEquals(3, result[2]); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] assertArrayEquals(new long[0], result); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getLongValue()).thenReturn(10L); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] assertArrayEquals(new long[]{10L}, result); [EOL] }
public void testDeserializeWithLargeArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getLongValue()).thenReturn(10L, 20L); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] assertArrayEquals(new long[]{10L, 20L}, result); [EOL] }
public void testPropertyValueBufferConstructor() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] int paramCount = 5; [EOL] ObjectIdReader oir = mock(ObjectIdReader.class); [EOL] PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, paramCount, oir); [EOL] assertNotNull(buffer); [EOL] assertEquals(jp, buffer.getParser()); [EOL] assertEquals(ctxt, buffer.getContext()); [EOL] assertEquals(paramCount, buffer.getParamCount()); [EOL] assertEquals(oir, buffer.getObjectIdReader()); [EOL] assertNotNull(buffer.getCreatorParameters()); [EOL] assertEquals(paramCount, buffer.getCreatorParameters().length); [EOL] }
public void testGetParametersWithNonNullDefaults() { [EOL] Object[] defaults = new Object[] {"default1", "default2", "default3"}; [EOL] Object[] creatorParameters = new Object[3]; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] {"default1", "default2", "default3"}, result); [EOL] } [EOL] public void testGetParametersWithNullDefaults() { [EOL] Object[] defaults = null; [EOL] Object[] creatorParameters = new Object[] {"param1", "param2", "param3"}; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] {"param1", "param2", "param3"}, result); [EOL] } [EOL] public void testGetParametersWithPartialNullValues() { [EOL] Object[] defaults = new Object[] {"default1", null, "default3"}; [EOL] Object[] creatorParameters = new Object[] {null, "param2", null}; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] {"default1", "param2", "default3"}, result); [EOL] }

public void testReadIdPropertyWithNonNullObjectIdReaderAndMatchingPropName() throws IOException { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("matchingPropName"); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] when(deserializer.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn(new Object()); [EOL] objectIdReader.deserializer = deserializer; [EOL] JsonParser parser = mock(JsonParser.class); [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] YourClass instance = new YourClass(); [EOL] instance._objectIdReader = objectIdReader; [EOL] instance._parser = parser; [EOL] instance._context = context; [EOL] boolean result = instance.readIdProperty("matchingPropName"); [EOL] assertTrue(result); [EOL] assertNotNull(instance._idValue); [EOL] }
public void testReadIdPropertyWithNonNullObjectIdReaderAndNonMatchingPropName() throws IOException { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("nonMatchingPropName"); [EOL] JsonParser parser = mock(JsonParser.class); [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] YourClass instance = new YourClass(); [EOL] instance._objectIdReader = objectIdReader; [EOL] instance._parser = parser; [EOL] instance._context = context; [EOL] boolean result = instance.readIdProperty("somePropName"); [EOL] assertFalse(result); [EOL] }
public void testReadIdPropertyWithNullObjectIdReader() throws IOException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] YourClass instance = new YourClass(); [EOL] instance._parser = parser; [EOL] instance._context = context; [EOL] boolean result = instance.readIdProperty("anyPropName"); [EOL] assertFalse(result); [EOL] }
public void testHandleIdValueWithObjectIdReaderAndIdValue() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] Object idValue = new Object(); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(_idValue).thenReturn(idValue); [EOL] when(ctxt.findObjectId(idValue, objectIdReader.generator)).thenReturn(roid); [EOL] when(objectIdReader.idProperty).thenReturn(idProp); [EOL] when(idProp.setAndReturn(bean, idValue)).thenReturn(new Object()); [EOL] Object result = handleIdValue(ctxt, bean); [EOL] verify(roid).bindItem(bean); [EOL] verify(idProp).setAndReturn(bean, idValue); [EOL] assertNotNull(result); [EOL] }
public void testHandleIdValueWithObjectIdReaderAndNullIdValue() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(_idValue).thenReturn(null); [EOL] Object result = handleIdValue(ctxt, bean); [EOL] assertSame(bean, result); [EOL] }
public void testHandleIdValueWithoutObjectIdReader() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object result = handleIdValue(ctxt, bean); [EOL] assertSame(bean, result); [EOL] }
protected PropertyValue buffered() { [EOL] return _buffered; [EOL] }
public void testAssignParameterWithNegativeIndex() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] try { [EOL] underTest.assignParameter(-1, new Object()); [EOL] fail("Should throw ArrayIndexOutOfBoundsException for negative index"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAssignParameterWithIndexOutOfBounds() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] try { [EOL] underTest.assignParameter(100, new Object()); // Assuming the _creatorParameters array has less than 100 elements [EOL] fail("Should throw ArrayIndexOutOfBoundsException for index out of bounds"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAssignParameterDecrementsParamsNeeded() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] int initialParamsNeeded = underTest.getParamsNeeded(); // Assuming getParamsNeeded() method exists to get _paramsNeeded value [EOL] underTest.assignParameter(0, new Object()); [EOL] assertEquals(initialParamsNeeded - 1, underTest.getParamsNeeded()); [EOL] }
public void testAssignParameterReturnsTrueWhenNoParamsNeeded() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] underTest.setParamsNeeded(1); [EOL] boolean result = underTest.assignParameter(0, new Object()); [EOL] assertTrue(result); [EOL] }
public void testAssignParameterReturnsFalseWhenParamsStillNeeded() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] underTest.setParamsNeeded(2); [EOL] boolean result = underTest.assignParameter(0, new Object()); [EOL] assertFalse(result); [EOL] }
public void testBufferMapPropertyWithNonNullKeyAndValue() { [EOL] JsonMappingException ex = new JsonMappingException(null, ""); [EOL] ex.bufferMapProperty("key", "value"); [EOL] assertNotNull(ex._buffered); [EOL] assertEquals("value", ex._buffered.getValue()); [EOL] assertEquals("key", ex._buffered.getKey()); [EOL] }
public void testBufferMapPropertyWithNullKeyAndNonNullValue() { [EOL] JsonMappingException ex = new JsonMappingException(null, ""); [EOL] ex.bufferMapProperty(null, "value"); [EOL] assertNotNull(ex._buffered); [EOL] assertEquals("value", ex._buffered.getValue()); [EOL] assertNull(ex._buffered.getKey()); [EOL] }
public void testBufferMapPropertyWithNonNullKeyAndNullValue() { [EOL] JsonMappingException ex = new JsonMappingException(null, ""); [EOL] ex.bufferMapProperty("key", null); [EOL] assertNotNull(ex._buffered); [EOL] assertNull(ex._buffered.getValue()); [EOL] assertEquals("key", ex._buffered.getKey()); [EOL] }
public void testBufferMapPropertyWithNullKeyAndValue() { [EOL] JsonMappingException ex = new JsonMappingException(null, ""); [EOL] ex.bufferMapProperty(null, null); [EOL] assertNotNull(ex._buffered); [EOL] assertNull(ex._buffered.getValue()); [EOL] assertNull(ex._buffered.getKey()); [EOL] }
public void testSerializeContentsUsingEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(ser); [EOL] }
public void testSerializeContentsUsingNonNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(ser, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithNullElements() throws IOException { [EOL] List<Object> value = Arrays.asList(null, "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(ser).serialize(eq("elem2"), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsUsingWithTypeSerializer() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializeContentsUsing(value, jgen, provider, ser, typeSer); [EOL] verify(ser, times(2)).serializeWithType(any(), eq(jgen), eq(provider), eq(typeSer)); [EOL] }
public void testSerializeContentsUsingWithException() throws IOException { [EOL] List<Object> value = Arrays.asList("elem1", "elem2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] doThrow(new IOException()).when(ser).serialize(eq("elem1"), eq(jgen), eq(provider)); [EOL] try { [EOL] serializeContentsUsing(value, jgen, provider, ser); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(ser).serialize(eq("elem1"), eq(jgen), eq(provider)); [EOL] }
public void testObjectIdReaderConstruction() { [EOL] JavaType idType = SimpleType.constructUnsafe(String.class); [EOL] String propertyName = "id"; [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] JsonDeserializer<?> deserializer = new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException { [EOL] return p.getText(); [EOL] } [EOL] }; [EOL] SettableBeanProperty idProperty = null; [EOL] ObjectIdReader objectIdReader = new ObjectIdReader(idType, propertyName, generator, deserializer, idProperty); [EOL] assertNotNull(objectIdReader); [EOL] assertEquals(idType, objectIdReader.idType); [EOL] assertEquals(propertyName, objectIdReader.propertyName); [EOL] assertEquals(generator, objectIdReader.generator); [EOL] assertTrue(objectIdReader.deserializer instanceof JsonDeserializer); [EOL] assertNull(objectIdReader.idProperty); [EOL] }
public void testConstructWithNonNullValues() { [EOL] JavaType idType = mock(JavaType.class); [EOL] String propName = "testProperty"; [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] ObjectIdReader result = ObjectIdReader.construct(idType, propName, generator, deser, idProp); [EOL] assertNotNull(result); [EOL] assertEquals(idType, result.idType); [EOL] assertEquals(propName, result.propertyName); [EOL] assertEquals(generator, result.generator); [EOL] assertEquals(deser, result.deserializer); [EOL] assertEquals(idProp, result.idProperty); [EOL] }
public void testConstructWithNullValues() { [EOL] JavaType idType = null; [EOL] String propName = null; [EOL] ObjectIdGenerator<?> generator = null; [EOL] JsonDeserializer<?> deser = null; [EOL] SettableBeanProperty idProp = null; [EOL] ObjectIdReader result = ObjectIdReader.construct(idType, propName, generator, deser, idProp); [EOL] assertNotNull(result); [EOL] assertNull(result.idType); [EOL] assertNull(result.propertyName); [EOL] assertNull(result.generator); [EOL] assertNull(result.deserializer); [EOL] assertNull(result.idProperty); [EOL] }
public void testForPropertySameProperty() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] AsArrayTypeSerializer instance = new AsArrayTypeSerializer(mock(TypeIdResolver.class), prop); [EOL] AsArrayTypeSerializer result = instance.forProperty(prop); [EOL] assertSame(instance, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] BeanProperty prop1 = mock(BeanProperty.class); [EOL] BeanProperty prop2 = mock(BeanProperty.class); [EOL] AsArrayTypeSerializer instance = new AsArrayTypeSerializer(mock(TypeIdResolver.class), prop1); [EOL] AsArrayTypeSerializer result = instance.forProperty(prop2); [EOL] assertNotSame(instance, result); [EOL] assertNotNull(result); [EOL] }
public void testWriteTypePrefixForScalarWithNonNullValueAndType() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Object value = new Object(); [EOL] Class<?> type = value.getClass(); [EOL] resolver.writeTypePrefixForScalar(value, mockJsonGenerator, type); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] }
public void testWriteTypePrefixForScalarWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Class<?> type = Object.class; [EOL] resolver.writeTypePrefixForScalar(null, mockJsonGenerator, type); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] }
public void testWriteTypePrefixForScalarWithNullType() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null); [EOL] Object value = new Object(); [EOL] resolver.writeTypePrefixForScalar(value, mockJsonGenerator, null); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] }
protected ContainerNode(JsonNodeFactory nc) { [EOL] _nodeFactory = nc; [EOL] }
public void testArrayNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ArrayNode arrayNode = mapper.createArrayNode(); [EOL] assertNotNull(arrayNode); [EOL] assertTrue(arrayNode instanceof ArrayNode); [EOL] }
public void testObjectNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectNode objectNode = mapper.createObjectNode(); [EOL] assertNotNull(objectNode); [EOL] assertTrue(objectNode instanceof ObjectNode); [EOL] }
public void testGetSchemaWithNonNullProviderAndTypeHint() { [EOL] JsonSerializer<Object> serializer = new CustomSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = String.class; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertEquals("string", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("type").isTextual()); [EOL] }
public void testGetSchemaWithNullProviderAndTypeHint() { [EOL] JsonSerializer<Object> serializer = new CustomSerializer(); [EOL] SerializerProvider provider = null; [EOL] Type typeHint = String.class; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertEquals("string", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("type").isTextual()); [EOL] }
public void testGetSchemaWithNonNullProviderAndNullTypeHint() { [EOL] JsonSerializer<Object> serializer = new CustomSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = null; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertEquals("string", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("type").isTextual()); [EOL] }
public void testGetSchemaWithNullProviderAndNullTypeHint() { [EOL] JsonSerializer<Object> serializer = new CustomSerializer(); [EOL] SerializerProvider provider = null; [EOL] Type typeHint = null; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertEquals("string", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("type").isTextual()); [EOL] }
public void testObjectIdValuePropertyWithRequiredTrue() { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("testProperty"); [EOL] when(objectIdReader.idType).thenReturn(String.class); [EOL] when(objectIdReader.deserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] ObjectIdValueProperty property = new ObjectIdValueProperty(objectIdReader, true); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(String.class, property.getType()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] assertTrue(property.isRequired()); [EOL] }
public void testObjectIdValuePropertyWithRequiredFalse() { [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("testProperty"); [EOL] when(objectIdReader.idType).thenReturn(String.class); [EOL] when(objectIdReader.deserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] ObjectIdValueProperty property = new ObjectIdValueProperty(objectIdReader, false); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(String.class, property.getType()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] assertFalse(property.isRequired()); [EOL] }
public void testGetMemberReturnsNull() { [EOL] TargetClass target = new TargetClass(); [EOL] AnnotatedMember result = target.getMember(); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullIntoValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object intoValue = new Object(); [EOL] StdDelegatingDeserializer<Object> delegatingDeserializer = mock(StdDelegatingDeserializer.class); [EOL] when(delegatingDeserializer.deserialize(jp, ctxt, intoValue)).thenReturn(intoValue); [EOL] Object result = delegatingDeserializer.deserialize(jp, ctxt, intoValue); [EOL] assertSame(intoValue, result); [EOL] }
public void testDeserializeWithNullIntoValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] StdDelegatingDeserializer<Object> delegatingDeserializer = mock(StdDelegatingDeserializer.class); [EOL] when(delegatingDeserializer.deserialize(jp, ctxt, null)).thenReturn(null); [EOL] Object result = delegatingDeserializer.deserialize(jp, ctxt, null); [EOL] assertNull(result); [EOL] }
public void testCreatorPropertyWithNonNullValues() { [EOL] String name = "testName"; [EOL] JavaType type = new SimpleType(String.class); [EOL] PropertyName wrapperName = new PropertyName("wrapper"); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] int index = 1; [EOL] Object injectableValueId = "injectable"; [EOL] boolean isRequired = true; [EOL] CreatorProperty creatorProperty = new CreatorProperty(name, type, wrapperName, typeDeser, contextAnnotations, param, index, injectableValueId, isRequired); [EOL] assertNotNull(creatorProperty); [EOL] assertEquals(name, creatorProperty.getName()); [EOL] assertEquals(type, creatorProperty.getType()); [EOL] assertEquals(wrapperName, creatorProperty.getWrapperName()); [EOL] assertEquals(typeDeser, creatorProperty.getTypeDeserializer()); [EOL] assertEquals(contextAnnotations, creatorProperty.getContextAnnotations()); [EOL] assertEquals(param, creatorProperty.getAnnotated()); [EOL] assertEquals(index, creatorProperty.getCreatorIndex()); [EOL] assertEquals(injectableValueId, creatorProperty.getInjectableValueId()); [EOL] assertEquals(isRequired, creatorProperty.isRequired()); [EOL] }
public void testCreatorPropertyWithNullValues() { [EOL] String name = null; [EOL] JavaType type = null; [EOL] PropertyName wrapperName = null; [EOL] TypeDeserializer typeDeser = null; [EOL] Annotations contextAnnotations = null; [EOL] AnnotatedParameter param = null; [EOL] int index = 0; [EOL] Object injectableValueId = null; [EOL] boolean isRequired = false; [EOL] CreatorProperty creatorProperty = new CreatorProperty(name, type, wrapperName, typeDeser, contextAnnotations, param, index, injectableValueId, isRequired); [EOL] assertNotNull(creatorProperty); [EOL] assertNull(creatorProperty.getName()); [EOL] assertNull(creatorProperty.getType()); [EOL] assertNull(creatorProperty.getWrapperName()); [EOL] assertNull(creatorProperty.getTypeDeserializer()); [EOL] assertNull(creatorProperty.getContextAnnotations()); [EOL] assertNull(creatorProperty.getAnnotated()); [EOL] assertEquals(index, creatorProperty.getCreatorIndex()); [EOL] assertNull(creatorProperty.getInjectableValueId()); [EOL] assertEquals(isRequired, creatorProperty.isRequired()); [EOL] }
public void testCreatorPropertyCopyConstructor() { [EOL] CreatorProperty original = createOriginalCreatorProperty(); [EOL] JsonDeserializer<?> deserializer = createJsonDeserializer(); [EOL] CreatorProperty copy = new CreatorProperty(original, deserializer); [EOL] assertNotNull(copy); [EOL] assertEquals(original.getAnnotated(), copy.getAnnotated()); [EOL] assertEquals(original.getCreatorIndex(), copy.getCreatorIndex()); [EOL] assertEquals(original.getInjectableValueId(), copy.getInjectableValueId()); [EOL] assertSame(deserializer, copy.getDeserializer()); [EOL] }

public void testWithValueDeserializer_NullDeserializer() { [EOL] CreatorProperty original = new CreatorProperty(/* parameters to create a valid CreatorProperty */); [EOL] CreatorProperty result = original.withValueDeserializer(null); [EOL] assertNotNull(result); [EOL] assertNull(result.getValueDeserializer()); [EOL] }
public void testWithValueDeserializer_NonNullDeserializer() { [EOL] CreatorProperty original = new CreatorProperty(/* parameters to create a valid CreatorProperty */); [EOL] JsonDeserializer<?> deserializer = new SomeJsonDeserializerImplementation(); [EOL] CreatorProperty result = original.withValueDeserializer(deserializer); [EOL] assertNotNull(result); [EOL] assertSame(deserializer, result.getValueDeserializer()); [EOL] }
public void testGetAnnotationWithNullAnnotated() { [EOL] AnnotatedElement annotatedElement = createMockAnnotatedElement(null); [EOL] assertNull(annotatedElement.getAnnotation(Deprecated.class)); [EOL] }
public void testGetAnnotationWithNonNullAnnotated() { [EOL] AnnotatedElement annotatedElement = createMockAnnotatedElement(Deprecated.class); [EOL] assertNotNull(annotatedElement.getAnnotation(Deprecated.class)); [EOL] }
public void testGetCreatorIndex() { [EOL] CreatorProperty creatorProperty = new CreatorProperty(/* parameters to construct a valid CreatorProperty with _creatorIndex set to a specific value */); [EOL] int expectedIndex = /* the specific value of _creatorIndex you set */; [EOL] assertEquals(expectedIndex, creatorProperty.getCreatorIndex()); [EOL] }
public void testGetInjectableValueIdWithNonNullId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] Object expectedId = new Object(); [EOL] injectableValues.addValue(expectedId); [EOL] assertEquals(expectedId, injectableValues.getInjectableValueId()); [EOL] }
public void testGetInjectableValueIdWithNullId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] assertNull(injectableValues.getInjectableValueId()); [EOL] }
public void testNamedTypeWithNullName() { [EOL] Class<?> clazz = Object.class; [EOL] NamedType namedType = new NamedType(clazz); [EOL] assertNull(namedType.getName()); [EOL] assertEquals(clazz, namedType.getType()); [EOL] }
public void testNamedTypeWithNonNullClass() { [EOL] Class<?> clazz = String.class; [EOL] NamedType namedType = new NamedType(clazz); [EOL] assertNull(namedType.getName()); [EOL] assertEquals(clazz, namedType.getType()); [EOL] }
public void testGetSchemaWithNullTypeHint() { [EOL] SerializerProvider provider = new MockSerializerProvider(); [EOL] JsonNode result = getSchema(provider, null); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertFalse(result.has("items")); [EOL] }
public void testGetSchemaWithArrayTypeHint() { [EOL] SerializerProvider provider = new MockSerializerProvider(); [EOL] Type typeHint = ArrayType.class; [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertTrue(result.has("items")); [EOL] }
public void testGetSchemaWithNonArrayTypeHint() { [EOL] SerializerProvider provider = new MockSerializerProvider(); [EOL] Type typeHint = NonArrayType.class; [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertFalse(result.has("items")); [EOL] }
public void testGetSchemaWithObjectComponentType() { [EOL] SerializerProvider provider = new MockSerializerProvider(); [EOL] Type typeHint = ObjectArrayType.class; [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertTrue(result.has("items")); [EOL] JsonNode itemsNode = result.get("items"); [EOL] assertEquals(JsonSchema.getDefaultSchemaNode(), itemsNode); [EOL] }
public void testGetSchemaWithCustomComponentType() { [EOL] SerializerProvider provider = new MockSerializerProvider(); [EOL] Type typeHint = CustomArrayType.class; [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertTrue(result.has("items")); [EOL] JsonNode itemsNode = result.get("items"); [EOL] assertNotEquals(JsonSchema.getDefaultSchemaNode(), itemsNode); [EOL] }
public void testGetSchemaWithNullTypeHint() throws JsonMappingException { [EOL] YourClass instance = new YourClass(); [EOL] JsonNode result = instance.getSchema(null, null); [EOL] assertNotNull(result); [EOL] assertEquals("any", result.get("type").asText()); [EOL] }
public void testGetSchemaWithAnnotatedTypeHint() throws JsonMappingException { [EOL] @JsonSerializableSchema(schemaType = "object", schemaObjectPropertiesDefinition = "{\"property\":\"value\"}", schemaItemDefinition = "[\"item\"]") [EOL] class AnnotatedClass {} [EOL] YourClass instance = new YourClass(); [EOL] JsonNode result = instance.getSchema(null, AnnotatedClass.class); [EOL] assertNotNull(result); [EOL] assertEquals("object", result.get("type").asText()); [EOL] assertEquals("{\"property\":\"value\"}", result.get("properties").toString()); [EOL] assertEquals("[\"item\"]", result.get("items").toString()); [EOL] }
public void testGetSchemaWithAnnotatedTypeHintAndIOExceptionOnProperties() { [EOL] @JsonSerializableSchema(schemaType = "object", schemaObjectPropertiesDefinition = "invalid", schemaItemDefinition = "valid") [EOL] class AnnotatedClass {} [EOL] YourClass instance = new YourClass(); [EOL] ObjectMapper objectMapper = mock(ObjectMapper.class); [EOL] when(instance._getObjectMapper()).thenReturn(objectMapper); [EOL] when(objectMapper.readTree("invalid")).thenThrow(new IOException()); [EOL] try { [EOL] instance.getSchema(null, AnnotatedClass.class); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value", e.getMessage()); [EOL] } [EOL] }
public void testGetSchemaWithAnnotatedTypeHintAndIOExceptionOnItems() { [EOL] @JsonSerializableSchema(schemaType = "object", schemaObjectPropertiesDefinition = "valid", schemaItemDefinition = "invalid") [EOL] class AnnotatedClass {} [EOL] YourClass instance = new YourClass(); [EOL] ObjectMapper objectMapper = mock(ObjectMapper.class); [EOL] when(instance._getObjectMapper()).thenReturn(objectMapper); [EOL] when(objectMapper.readTree("invalid")).thenThrow(new IOException()); [EOL] try { [EOL] instance.getSchema(null, AnnotatedClass.class); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Failed to parse @JsonSerializableSchema.schemaItemDefinition value", e.getMessage()); [EOL] } [EOL] }
public void testShortNodeConstructor() { [EOL] short testValue = 10; [EOL] ShortNode node = new ShortNode(testValue); [EOL] assertEquals(testValue, node.shortValue()); [EOL] }
public void testValueOfShortNode() { [EOL] short testValue = 123; [EOL] ShortNode result = ShortNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.shortValue()); [EOL] }
public void testNumberType() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] JsonParser.NumberType expected = JsonParser.NumberType.INT; [EOL] JsonParser.NumberType actual = instance.numberType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCanConvertToInt() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean canConvertToInt() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.canConvertToInt()); [EOL] }
public void testCanConvertToLong() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] boolean result = instance.canConvertToLong(); [EOL] assertTrue(result); [EOL] }
public void testIntValue_Positive() { [EOL] IntNode node = new IntNode(5); [EOL] assertEquals(5, node.intValue()); [EOL] }
public void testIntValue_Negative() { [EOL] IntNode node = new IntNode(-5); [EOL] assertEquals(-5, node.intValue()); [EOL] }
public void testIntValue_Zero() { [EOL] IntNode node = new IntNode(0); [EOL] assertEquals(0, node.intValue()); [EOL] }
public void testLongValue_Positive() { [EOL] LongNode node = new LongNode(5L); [EOL] assertEquals(5L, node.longValue()); [EOL] }
public void testLongValue_Negative() { [EOL] LongNode node = new LongNode(-5L); [EOL] assertEquals(-5L, node.longValue()); [EOL] }
public void testLongValue_Zero() { [EOL] LongNode node = new LongNode(0L); [EOL] assertEquals(0L, node.longValue()); [EOL] }
public void testDoubleValue_Positive() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(123.456, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(-123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(-123.456, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ZERO); [EOL] double result = node.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testDecimalValue_Positive() { [EOL] JsonNode node = new LongNode(12345L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(new BigDecimal("12345"), result); [EOL] }
public void testDecimalValue_Negative() { [EOL] JsonNode node = new LongNode(-12345L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(new BigDecimal("-12345"), result); [EOL] }
public void testDecimalValue_Zero() { [EOL] JsonNode node = new LongNode(0L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(BigDecimal.ZERO, result); [EOL] }
public void testBigIntegerValue_Positive() { [EOL] long input = 123L; [EOL] JsonLong value = new JsonLong(input); [EOL] BigInteger expected = BigInteger.valueOf(input); [EOL] BigInteger result = value.bigIntegerValue(); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testBigIntegerValue_Negative() { [EOL] long input = -123L; [EOL] JsonLong value = new JsonLong(input); [EOL] BigInteger expected = BigInteger.valueOf(input); [EOL] BigInteger result = value.bigIntegerValue(); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testBigIntegerValue_Zero() { [EOL] long input = 0L; [EOL] JsonLong value = new JsonLong(input); [EOL] BigInteger expected = BigInteger.valueOf(input); [EOL] BigInteger result = value.bigIntegerValue(); [EOL] assertEquals(expected, result); [EOL] }
public void testAsTextWithPositiveValue() { [EOL] DoubleNode node = new DoubleNode(10.5); [EOL] String result = node.asText(); [EOL] assertEquals("10.5", result); [EOL] }
public void testAsTextWithNegativeValue() { [EOL] DoubleNode node = new DoubleNode(-10.5); [EOL] String result = node.asText(); [EOL] assertEquals("-10.5", result); [EOL] }
public void testAsTextWithZeroValue() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] String result = node.asText(); [EOL] assertEquals("0.0", result); [EOL] }
public void testEquals_sameObject() { [EOL] ShortNode node = new ShortNode((short) 123); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] ShortNode node = new ShortNode((short) 123); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] ShortNode node = new ShortNode((short) 123); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_differentValue() { [EOL] ShortNode node1 = new ShortNode((short) 123); [EOL] ShortNode node2 = new ShortNode((short) 456); [EOL] assertFalse(node1.equals(node2)); [EOL] } [EOL] public void testEquals_sameValue() { [EOL] ShortNode node1 = new ShortNode((short) 123); [EOL] ShortNode node2 = new ShortNode((short) 123); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testHashCode() { [EOL] SomeClass instance = new SomeClass(123); [EOL] int expectedHashCode = 123; [EOL] assertEquals(expectedHashCode, instance.hashCode()); [EOL] }
public void testIteratorSerializerWithNonNullValues() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] IteratorSerializer src = new IteratorSerializer(null, null, null, null); [EOL] IteratorSerializer iteratorSerializer = new IteratorSerializer(src, property, typeSerializer, valueSerializer); [EOL] assertNotNull(iteratorSerializer); [EOL] }
public void testIteratorSerializerWithNullValues() { [EOL] IteratorSerializer src = new IteratorSerializer(null, null, null, null); [EOL] IteratorSerializer iteratorSerializer = new IteratorSerializer(src, null, null, null); [EOL] assertNotNull(iteratorSerializer); [EOL] }
public void testWithResolved() { [EOL] IteratorSerializer original = new IteratorSerializer(null, null, null, null); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] IteratorSerializer result = original.withResolved(property, vts, elementSerializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(property, result.getProperty()); [EOL] assertSame(vts, result.getTypeSerializer()); [EOL] assertSame(elementSerializer, result.getElementSerializer()); [EOL] }
public void testTypedValueSerializerWithNullCacheKey() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonSerializer<Object> serializer = cache.typedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testTypedValueSerializerWithNonNullCacheKey() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] cache.typedValueSerializer(type); // This will create a _cacheKey [EOL] JsonSerializer<Object> serializer = cache.typedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testTypedValueSerializerWithNullCacheKey() { [EOL] TypeKey mockTypeKey = mock(TypeKey.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] SimpleSerializers serializers = new SimpleSerializers(); [EOL] serializers.addSerializer(String.class, expectedSerializer); [EOL] JsonSerializer<Object> result = serializers.typedValueSerializer(String.class); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testTypedValueSerializerWithNonNullCacheKey() { [EOL] TypeKey mockTypeKey = new TypeKey(String.class, true); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] SimpleSerializers serializers = new SimpleSerializers(); [EOL] serializers.addSerializer(String.class, expectedSerializer); [EOL] serializers.typedValueSerializer(String.class); // This will set the _cacheKey [EOL] JsonSerializer<Object> result = serializers.typedValueSerializer(String.class); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
protected BeanSerializerFactory(SerializerFactoryConfig config) { [EOL] super(config); [EOL] }
public void testWithConfigSameConfig() { [EOL] SerializerFactory factory = new BeanSerializerFactory(null); [EOL] SerializerFactoryConfig config = factory.getFactoryConfig(); [EOL] SerializerFactory result = factory.withConfig(config); [EOL] assertSame("Factory returned should be the same as the original factory", factory, result); [EOL] }
public void testWithConfigDifferentConfig() { [EOL] SerializerFactory factory = new BeanSerializerFactory(null); [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] SerializerFactory result = factory.withConfig(config); [EOL] assertNotSame("Factory returned should not be the same as the original factory", factory, result); [EOL] assertTrue("Factory returned should be a new instance of BeanSerializerFactory", result instanceof BeanSerializerFactory); [EOL] }
public void testWithConfigSubtypeNotOverridden() { [EOL] SerializerFactory factory = new SerializerFactorySubtype(); [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] try { [EOL] factory.withConfig(config); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Subtype of BeanSerializerFactory (SerializerFactorySubtype) has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with additional serializer definitions", e.getMessage()); [EOL] } [EOL] } [EOL] static class SerializerFactorySubtype extends BeanSerializerFactory { [EOL] SerializerFactorySubtype() { [EOL] super(null); [EOL] } [EOL] }
public void testCreateSerializerWithAnnotationSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<?> annotationSerializer = mock(JsonSerializer.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(annotationSerializer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertSame(annotationSerializer, result); [EOL] }
public void testCreateSerializerWithoutAnnotationAndWithoutConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType)).thenReturn(origType); [EOL] when(beanDesc.findSerializationConverter()).thenReturn(null); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertNotNull(result); [EOL] }
public void testCreateSerializerWithModifiedTypeAndConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] JavaType modifiedType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(config.introspect(modifiedType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(findSerializerFromAnnotation(prov, beanDesc.getClassInfo())).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType)).thenReturn(modifiedType); [EOL] when(modifiedType.getRawClass()).thenReturn(String.class); [EOL] when(origType.getRawClass()).thenReturn(Object.class); [EOL] when(beanDesc.findSerializationConverter()).thenReturn(converter); [EOL] when(converter.getOutputType(prov.getTypeFactory())).thenReturn(delegateType); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL] JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL] if (ser != null) { [EOL] return ser; [EOL] } [EOL] final SerializationConfig config = prov.getConfig(); [EOL] if (type.isContainerType()) { [EOL] if (!staticTyping) { [EOL] staticTyping = usesStaticTyping(config, beanDesc, null); [EOL] } [EOL] ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL] if (ser != null) { [EOL] return ser; [EOL] } [EOL] } else { [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findSerializer(config, type, beanDesc); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL] if (ser == null) { [EOL] ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] if (ser == null) { [EOL] ser = findBeanSerializer(prov, type, beanDesc); [EOL] if (ser == null) { [EOL] ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (ser != null) { [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifySerializer(config, beanDesc, ser); [EOL] } [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testFindPropertyTypeSerializerWithNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] TypeSerializer result = findPropertyTypeSerializer(baseType, config, accessor); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyTypeSerializerWithNonNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL] TypeResolverBuilder<?> b = Mockito.mock(TypeResolverBuilder.class); [EOL] Mockito.when(ai.findPropertyTypeResolver(config, accessor, baseType)).thenReturn(b); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] Mockito.when(config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, baseType)).thenReturn(subtypes); [EOL] TypeSerializer builtSerializer = Mockito.mock(TypeSerializer.class); [EOL] Mockito.when(b.buildTypeSerializer(config, baseType, subtypes)).thenReturn(builtSerializer); [EOL] TypeSerializer result = findPropertyTypeSerializer(baseType, config, accessor); [EOL] assertSame(builtSerializer, result); [EOL] }
public void testConstructBeanSerializerWithObjectClass() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] when(prov.getUnknownTypeSerializer(Object.class)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(mock(BeanSerializerModifier.class))); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithAnyGetter() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] AnnotatedMember anyGetter = mock(AnnotatedMember.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(beanDesc.findAnyGetter()).thenReturn(anyGetter); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithNullSerializer() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(constructBeanSerializerBuilder(beanDesc)).thenReturn(builder); [EOL] when(builder.build()).thenReturn(null); [EOL] when(beanDesc.hasKnownClassAnnotations()).thenReturn(true); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructObjectIdHandlerWithNullObjectIdInfo() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(null); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, new ArrayList<>()); [EOL] assertNull(result); [EOL] }
public void testConstructObjectIdHandlerWithPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] List<BeanPropertyWriter> props = new ArrayList<>(); [EOL] BeanPropertyWriter idProp = mock(BeanPropertyWriter.class); [EOL] when(idProp.getName()).thenReturn("id"); [EOL] props.add(idProp); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, props); [EOL] assertNotNull(result); [EOL] assertEquals(idProp, props.get(0)); // The id property should be moved to the first position [EOL] }
public void testConstructObjectIdHandlerWithPropertyGeneratorAndMissingProperty() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] List<BeanPropertyWriter> props = new ArrayList<>(); [EOL] BeanPropertyWriter otherProp = mock(BeanPropertyWriter.class); [EOL] when(otherProp.getName()).thenReturn("other"); [EOL] props.add(otherProp); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] constructObjectIdHandler(prov, beanDesc, props); [EOL] }); [EOL] String expectedMessage = "Invalid Object Id definition for "; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testConstructObjectIdHandlerWithCustomGenerator() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("customId"); [EOL] List<BeanPropertyWriter> props = new ArrayList<>(); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, props); [EOL] assertNotNull(result); [EOL] assertEquals("customId", result.propertyName); [EOL] }
public void testRemoveIgnorableTypesWithNoProperties() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithIgnorableProperty() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition ignorableProperty = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] properties.add(ignorableProperty); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.isIgnorableType(any(AnnotatedClass.class))).thenReturn(Boolean.TRUE); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithNonIgnorableProperty() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition nonIgnorableProperty = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] properties.add(nonIgnorableProperty); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.isIgnorableType(any(AnnotatedClass.class))).thenReturn(Boolean.FALSE); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertFalse(properties.isEmpty()); [EOL] assertEquals(1, properties.size()); [EOL] }
public void testRemoveIgnorableTypesWithNullAccessor() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary initialization [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition propertyWithNullAccessor = new BeanPropertyDefinition(...); // Provide necessary initialization [EOL] when(propertyWithNullAccessor.getAccessor()).thenReturn(null); [EOL] properties.add(propertyWithNullAccessor); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue(properties.isEmpty()); [EOL] }
public void testObjectIdGeneratorInstanceWithNullHandlerInstantiator() throws JsonMappingException { [EOL] Annotated annotated = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(Name.class, null, null); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(Name.class); [EOL] when(getConfig()).thenReturn(mock(MapperConfig.class)); [EOL] when(getConfig().getHandlerInstantiator()).thenReturn(null); [EOL] ObjectIdGenerator<?> result = objectIdGeneratorInstance(annotated, objectIdInfo); [EOL] assertNotNull(result); [EOL] assertEquals(Name.class, result.getScope()); [EOL] }
public void testObjectIdGeneratorInstanceWithNonNullHandlerInstantiator() throws JsonMappingException { [EOL] Annotated annotated = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(Name.class, null, null); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] ObjectIdGenerator<?> expectedGen = mock(ObjectIdGenerator.class); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(Name.class); [EOL] when(getConfig()).thenReturn(mock(MapperConfig.class)); [EOL] when(getConfig().getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.objectIdGeneratorInstance(any(MapperConfig.class), eq(annotated), eq(Name.class))).thenReturn(expectedGen); [EOL] when(expectedGen.forScope(any(Class.class))).thenReturn(expectedGen); [EOL] ObjectIdGenerator<?> result = objectIdGeneratorInstance(annotated, objectIdInfo); [EOL] assertSame(expectedGen, result); [EOL] }
public void testObjectIdGeneratorInstanceWithHandlerInstantiatorReturningNull() throws JsonMappingException { [EOL] Annotated annotated = mock(Annotated.class); [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(Name.class, null, null); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(Name.class); [EOL] when(getConfig()).thenReturn(mock(MapperConfig.class)); [EOL] when(getConfig().getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.objectIdGeneratorInstance(any(MapperConfig.class), eq(annotated), eq(Name.class))).thenReturn(null); [EOL] ObjectIdGenerator<?> result = objectIdGeneratorInstance(annotated, objectIdInfo); [EOL] assertNotNull(result); [EOL] assertEquals(Name.class, result.getScope()); [EOL] }
public void testCallSuccess() throws Exception { [EOL] Constructor<?> constructorMock = mock(Constructor.class); [EOL] Object expectedInstance = new Object(); [EOL] when(constructorMock.newInstance()).thenReturn(expectedInstance); [EOL] ConstructorBasedCreator creator = new ConstructorBasedCreator(constructorMock); [EOL] Object actualInstance = creator.call(); [EOL] assertEquals(expectedInstance, actualInstance); [EOL] }
public void testCallException() throws Exception { [EOL] Constructor<?> constructorMock = mock(Constructor.class); [EOL] when(constructorMock.newInstance()).thenThrow(new InstantiationException()); [EOL] ConstructorBasedCreator creator = new ConstructorBasedCreator(constructorMock); [EOL] try { [EOL] creator.call(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (InstantiationException e) { [EOL] } [EOL] }
public void testCollectionSerializerWithStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] boolean staticTyping = true; [EOL] TypeSerializer vts = new StdTypeSerializer(); [EOL] JsonSerializer<Object> valueSerializer = new StdValueSerializer(); [EOL] ContainerSerializer<?> result = JacksonDatabind.collectionSerializer(elemType, staticTyping, vts, valueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionSerializer); [EOL] assertEquals(elemType, ((CollectionSerializer) result).getContentType()); [EOL] assertTrue(((CollectionSerializer) result).usesStaticTyping()); [EOL] assertEquals(vts, ((CollectionSerializer) result).getTypeSerializer()); [EOL] assertEquals(valueSerializer, ((CollectionSerializer) result).getContentSerializer()); [EOL] }
public void testCollectionSerializerWithoutStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] boolean staticTyping = false; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> valueSerializer = new StdValueSerializer(); [EOL] ContainerSerializer<?> result = JacksonDatabind.collectionSerializer(elemType, staticTyping, vts, valueSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionSerializer); [EOL] assertEquals(elemType, ((CollectionSerializer) result).getContentType()); [EOL] assertFalse(((CollectionSerializer) result).usesStaticTyping()); [EOL] assertNull(((CollectionSerializer) result).getTypeSerializer()); [EOL] assertEquals(valueSerializer, ((CollectionSerializer) result).getContentSerializer()); [EOL] }
public void testIteratorSerializerWithStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] boolean staticTyping = true; [EOL] TypeSerializer vts = new StdTypeSerializer(); // Assuming StdTypeSerializer is a placeholder for an actual TypeSerializer implementation [EOL] ContainerSerializer<?> result = JacksonDatabindUtils.iteratorSerializer(elemType, staticTyping, vts); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IteratorSerializer); [EOL] IteratorSerializer serializer = (IteratorSerializer) result; [EOL] assertEquals(elemType, serializer.handledType()); [EOL] assertTrue(serializer.usesStaticTyping()); [EOL] assertEquals(vts, serializer.getTypeSerializer()); [EOL] }
public void testIteratorSerializerWithoutStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] boolean staticTyping = false; [EOL] TypeSerializer vts = null; [EOL] ContainerSerializer<?> result = JacksonDatabindUtils.iteratorSerializer(elemType, staticTyping, vts); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IteratorSerializer); [EOL] IteratorSerializer serializer = (IteratorSerializer) result; [EOL] assertEquals(elemType, serializer.handledType()); [EOL] assertFalse(serializer.usesStaticTyping()); [EOL] assertNull(serializer.getTypeSerializer()); [EOL] }
public void testIterableSerializerWithStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] boolean staticTyping = true; [EOL] TypeSerializer vts = new StdTypeSerializer(); [EOL] ContainerSerializer<?> result = ClassName.iterableSerializer(elemType, staticTyping, vts); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IterableSerializer); [EOL] IterableSerializer iterableSerializer = (IterableSerializer) result; [EOL] assertEquals(elemType, iterableSerializer.contentType); [EOL] assertTrue(iterableSerializer._staticTyping); [EOL] assertEquals(vts, iterableSerializer._valueTypeSerializer); [EOL] }
public void testIterableSerializerWithoutStaticTypingAndTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] boolean staticTyping = false; [EOL] TypeSerializer vts = null; [EOL] ContainerSerializer<?> result = ClassName.iterableSerializer(elemType, staticTyping, vts); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IterableSerializer); [EOL] IterableSerializer iterableSerializer = (IterableSerializer) result; [EOL] assertEquals(elemType, iterableSerializer.contentType); [EOL] assertFalse(iterableSerializer._staticTyping); [EOL] assertNull(iterableSerializer._valueTypeSerializer); [EOL] }
public void testEnumSetSerializerWithNonNullType() { [EOL] JavaType enumType = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, MyEnum.class); [EOL] JsonSerializer<?> serializer = EnumSetSerializer.enumSetSerializer(enumType); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof EnumSetSerializer); [EOL] } [EOL] public void testEnumSetSerializerWithNullType() { [EOL] try { [EOL] JsonSerializer<?> serializer = EnumSetSerializer.enumSetSerializer(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRawSerializerWithNonNullClass() { [EOL] Class<?> cls = String.class; [EOL] RawSerializer rawSerializer = new RawSerializer(cls); [EOL] assertNotNull(rawSerializer); [EOL] }
public void testRawSerializerWithNullClass() { [EOL] Class<?> cls = null; [EOL] try { [EOL] RawSerializer rawSerializer = new RawSerializer(cls); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFindWithPrimitiveIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Integer.TYPE, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] }
public void testFindWithPrimitiveBooleanType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Boolean.TYPE, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] }
public void testFindWithPrimitiveLongType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Long.TYPE, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] }
public void testFindWithPrimitiveDoubleType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Double.TYPE, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] }
public void testFindWithPrimitiveCharacterType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Character.TYPE, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] }
public void testFindWithPrimitiveByteType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Byte.TYPE, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] }
public void testFindWithPrimitiveShortType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Short.TYPE, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] }
public void testFindWithPrimitiveFloatType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Float.TYPE, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] }
public void testFindWithWrapperIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Integer.class, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] }
public void testFindWithWrapperBooleanType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Boolean.class, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] }
public void testFindWithWrapperLongType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Long.class, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] }
public void testFindWithWrapperDoubleType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Double.class, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] }
public void testFindWithWrapperCharacterType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Character.class, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] }
public void testFindWithWrapperByteType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Byte.class, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] }
public void testFindWithWrapperShortType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Short.class, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] }
public void testFindWithWrapperFloatType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Float.class, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] }
public void testFindWithNumberType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Number.class, "java.lang.Number"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof NumberDeserializer); [EOL] }
public void testFindWithBigDecimalType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(BigDecimal.class, "java.math.BigDecimal"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigDecimalDeserializer); [EOL] }
public void testFindWithBigIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(BigInteger.class, "java.math.BigInteger"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigIntegerDeserializer); [EOL] }
public void testFindWithUnrecognizedType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Object.class, "java.lang.Object"); [EOL] assertNull(deserializer); [EOL] }
public void testDeserializeWithIntTokenAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithIntTokenAndUseBigIntegerForIntsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(12345); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(12345, result); [EOL] }
public void testDeserializeWithFloatTokenAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithFloatTokenAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeWithStringTokenWithDotAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithStringTokenWithDotAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(new Double("123.45"), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndValueInIntegerRange() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Integer.valueOf(12345), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndValueOutsideIntegerRange() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf(Long.MAX_VALUE)); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(Long.MAX_VALUE), result); [EOL] }
public void testDeserializeWithInvalidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeKeyWithNull() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] Object result = deserializer.deserializeKey(null, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeKeyWithValidKey() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String validKey = "validKey"; [EOL] when(ctxt.weirdKeyException(any(), any(), any())).thenThrow(new JsonMappingException("error")); [EOL] Object result = deserializer.deserializeKey(validKey, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeKeyWithInvalidKeyAndException() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String invalidKey = "invalidKey"; [EOL] when(ctxt.weirdKeyException(any(), any(), any())).thenThrow(new JsonMappingException("error")); [EOL] try { [EOL] deserializer.deserializeKey(invalidKey, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("error", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeKeyWithInvalidKeyAndEnumClass() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] KeyDeserializer deserializer = new MyKeyDeserializer(); [EOL] String invalidKey = "invalidKey"; [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] when(ctxt.weirdKeyException(any(), any(), any())).thenThrow(new JsonMappingException("error")); [EOL] Object result = deserializer.deserializeKey(invalidKey, ctxt); [EOL] assertNull(result); [EOL] }
protected int _parseInt(String key) throws IllegalArgumentException { [EOL] return Integer.parseInt(key); [EOL] }
public void testParseWithValidKey() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String expected = "validKey"; [EOL] String result = _parse(expected, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testIntKDConstructor() { [EOL] IntKD instance = new IntKD(); [EOL] assertNotNull(instance); [EOL] }
public Integer _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL] return _parseInt(key); [EOL] }
public void testParseWithFactory() throws JsonMappingException { [EOL] MyFactory factory = mock(MyFactory.class); [EOL] MyEnum expected = MyEnum.VALUE_ONE; [EOL] when(factory.call1("VALUE_ONE")).thenReturn(expected); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(factory, null, MyEnum.class); [EOL] Object result = deserializer._parse("VALUE_ONE", null); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithResolver() throws JsonMappingException { [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] MyEnum expected = MyEnum.VALUE_TWO; [EOL] when(resolver.findEnum("VALUE_TWO")).thenReturn(expected); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] Object result = deserializer._parse("VALUE_TWO", null); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithFactoryException() { [EOL] MyFactory factory = mock(MyFactory.class); [EOL] when(factory.call1("INVALID")).thenThrow(new IllegalArgumentException()); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(factory, null, MyEnum.class); [EOL] assertThrows(IllegalArgumentException.class, () -> deserializer._parse("INVALID", null)); [EOL] }
public void testParseWithResolverReturningNullAndFeatureDisabled() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] when(resolver.findEnum("UNKNOWN")).thenReturn(null); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] assertThrows(JsonMappingException.class, () -> deserializer._parse("UNKNOWN", ctxt)); [EOL] }
public void testParseWithResolverReturningNullAndFeatureEnabled() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] MyEnumResolver resolver = mock(MyEnumResolver.class); [EOL] when(resolver.findEnum("UNKNOWN")).thenReturn(null); [EOL] MyKeyDeserializer deserializer = new MyKeyDeserializer(null, resolver, MyEnum.class); [EOL] Object result = deserializer._parse("UNKNOWN", ctxt); [EOL] assertNull(result); [EOL] }
protected DateKD() { [EOL] super(java.util.Date.class); [EOL] }
public void testParseValidDate() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validDateStr = "2021-12-03T10:15:30"; [EOL] Date expectedDate = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").parse(validDateStr); [EOL] when(ctxt.parseDate(validDateStr)).thenReturn(expectedDate); [EOL] Object result = _parse(validDateStr, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Date); [EOL] assertEquals(expectedDate, result); [EOL] }
public void testParseInvalidDate() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String invalidDateStr = "not-a-date"; [EOL] when(ctxt.parseDate(invalidDateStr)).thenThrow(new IllegalArgumentException("Invalid date format")); [EOL] try { [EOL] _parse(invalidDateStr, ctxt); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid date format", e.getMessage()); [EOL] } [EOL] }
protected CalendarKD() { [EOL] super(java.util.Calendar.class); [EOL] }
public void testParseWithValidDate() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validDateString = "2021-04-01"; [EOL] java.util.Date expectedDate = new SimpleDateFormat("yyyy-MM-dd").parse(validDateString); [EOL] when(ctxt.parseDate(validDateString)).thenReturn(expectedDate); [EOL] Object result = _parse(validDateString, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Calendar); [EOL] assertEquals(expectedDate.getTime(), ((Calendar) result).getTimeInMillis()); [EOL] }
public void testParseWithNullDate() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String nullDateString = null; [EOL] when(ctxt.parseDate(nullDateString)).thenReturn(null); [EOL] Object result = _parse(nullDateString, ctxt); [EOL] assertNull(result); [EOL] }
protected UuidKD() { [EOL] super(UUID.class); [EOL] }
public void testParseValidUUID() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validUUIDString = "123e4567-e89b-12d3-a456-426614174000"; [EOL] Object result = _parse(validUUIDString, ctxt); [EOL] assertTrue(result instanceof UUID); [EOL] assertEquals(UUID.fromString(validUUIDString), result); [EOL] } [EOL] public void testParseInvalidUUID() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String invalidUUIDString = "invalid-uuid"; [EOL] try { [EOL] _parse(invalidUUIDString, ctxt); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected an IllegalArgumentException, not a JsonMappingException"); [EOL] } [EOL] }
public void testIterateChildrenWithArrayNode() { [EOL] JsonNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] NodeCursor cursor = new NodeCursor(arrayNode); [EOL] NodeCursor result = cursor.iterateChildren(); [EOL] assertTrue(result instanceof NodeCursor.Array); [EOL] }
public void testIterateChildrenWithObjectNode() { [EOL] JsonNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] NodeCursor cursor = new NodeCursor(objectNode); [EOL] NodeCursor result = cursor.iterateChildren(); [EOL] assertTrue(result instanceof NodeCursor.Object); [EOL] }
public void testIterateChildrenWithNullCurrentNode() { [EOL] NodeCursor cursor = new NodeCursor(null); [EOL] try { [EOL] cursor.iterateChildren(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No current node", e.getMessage()); [EOL] } [EOL] }
public void testIterateChildrenWithUnsupportedNodeType() { [EOL] JsonNode unsupportedNode = new TextNode("text"); [EOL] NodeCursor cursor = new NodeCursor(unsupportedNode); [EOL] try { [EOL] cursor.iterateChildren(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Current node of type")); [EOL] } [EOL] }
public void testArrayConstructorWithNonNullNodeAndParent() { [EOL] JsonNode jsonNode = mock(JsonNode.class); [EOL] when(jsonNode.elements()).thenReturn(mock(Iterator.class)); [EOL] NodeCursor parentCursor = mock(NodeCursor.class); [EOL] Array array = new Array(jsonNode, parentCursor); [EOL] assertNotNull(array); [EOL] assertEquals(JsonStreamContext.TYPE_ARRAY, array.type()); [EOL] assertNotNull(array.getParent()); [EOL] assertEquals(parentCursor, array.getParent()); [EOL] assertNotNull(array.getContents()); [EOL] }
public void testArrayConstructorWithNullNode() { [EOL] NodeCursor parentCursor = mock(NodeCursor.class); [EOL] Array array = new Array(null, parentCursor); [EOL] assertNotNull(array); [EOL] assertEquals(JsonStreamContext.TYPE_ARRAY, array.type()); [EOL] assertNotNull(array.getParent()); [EOL] assertEquals(parentCursor, array.getParent()); [EOL] assertNull(array.getContents()); [EOL] }
public void testArrayConstructorWithNullParent() { [EOL] JsonNode jsonNode = mock(JsonNode.class); [EOL] when(jsonNode.elements()).thenReturn(mock(Iterator.class)); [EOL] Array array = new Array(jsonNode, null); [EOL] assertNotNull(array); [EOL] assertEquals(JsonStreamContext.TYPE_ARRAY, array.type()); [EOL] assertNull(array.getParent()); [EOL] assertNotNull(array.getContents()); [EOL] }
public void testNextTokenWhenContentsHasNext() { [EOL] Iterator<JsonNode> contentsMock = mock(Iterator.class); [EOL] when(contentsMock.hasNext()).thenReturn(true); [EOL] JsonNode nodeMock = mock(JsonNode.class); [EOL] when(contentsMock.next()).thenReturn(nodeMock); [EOL] JsonToken expectedToken = JsonToken.VALUE_STRING; [EOL] when(nodeMock.asToken()).thenReturn(expectedToken); [EOL] JsonTokenIterator iterator = new JsonTokenIterator(contentsMock); [EOL] JsonToken actualToken = iterator.nextToken(); [EOL] assertNotNull(actualToken); [EOL] assertEquals(expectedToken, actualToken); [EOL] }
public void testNextTokenWhenContentsHasNoNext() { [EOL] Iterator<JsonNode> contentsMock = mock(Iterator.class); [EOL] when(contentsMock.hasNext()).thenReturn(false); [EOL] JsonTokenIterator iterator = new JsonTokenIterator(contentsMock); [EOL] JsonToken actualToken = iterator.nextToken(); [EOL] assertNull(actualToken); [EOL] }
public void testEndToken() { [EOL] JsonParser parser = createParserWithEndArrayToken(); [EOL] JsonToken token = parser.endToken(); [EOL] assertEquals(JsonToken.END_ARRAY, token); [EOL] }
public void testCurrentNodeReturnsCorrectNode() { [EOL] JsonNode expectedNode = ...; // Initialize with the expected node [EOL] YourClassUnderTest instance = new YourClassUnderTest(expectedNode); [EOL] JsonNode result = instance.currentNode(); [EOL] assertEquals(expectedNode, result); [EOL] }
public void testSerializerForSameType() { [EOL] Class<?> expectedType = String.class; [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializerImplementation(); [EOL] SerializerProvider serializerProvider = new SerializerProvider(expectedType, expectedSerializer); [EOL] JsonSerializer<Object> result = serializerProvider.serializerFor(String.class); [EOL] assertSame("Serializer should be the same for the same type", expectedSerializer, result); [EOL] }
public void testSerializerForDifferentType() { [EOL] Class<?> expectedType = String.class; [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializerImplementation(); [EOL] SerializerProvider serializerProvider = new SerializerProvider(expectedType, expectedSerializer); [EOL] JsonSerializer<Object> result = serializerProvider.serializerFor(Integer.class); [EOL] assertNull("Serializer should be null for a different type", result); [EOL] }
public void testEnumSetDeserializerWithValidEnumTypeAndDeserializer() { [EOL] JavaType enumType = TypeFactory.defaultInstance().constructType(MyEnum.class); [EOL] JsonDeserializer<?> deser = new MyEnumDeserializer(); [EOL] EnumSetDeserializer deserializer = new EnumSetDeserializer(enumType, deser); [EOL] assertEquals(MyEnum.class, deserializer._enumClass); [EOL] assertNotNull(deserializer._enumDeserializer); [EOL] }
public void testEnumSetDeserializerWithNullEnumType() { [EOL] try { [EOL] new EnumSetDeserializer(null, new MyEnumDeserializer()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEnumSetDeserializerWithNullDeserializer() { [EOL] JavaType enumType = TypeFactory.defaultInstance().constructType(MyEnum.class); [EOL] try { [EOL] new EnumSetDeserializer(enumType, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDeserializerSameInstance() { [EOL] JsonDeserializer<?> originalDeserializer = new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] return null; [EOL] } [EOL] }; [EOL] Class<Enum> enumType = Enum.class; [EOL] EnumSetDeserializer enumSetDeserializer = new EnumSetDeserializer(enumType, originalDeserializer); [EOL] EnumSetDeserializer result = enumSetDeserializer.withDeserializer(originalDeserializer); [EOL] assertSame(enumSetDeserializer, result); [EOL] }
public void testWithDeserializerDifferentInstance() { [EOL] JsonDeserializer<?> originalDeserializer = new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] return null; [EOL] } [EOL] }; [EOL] JsonDeserializer<?> newDeserializer = new JsonDeserializer<Object>() { [EOL] @Override [EOL] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] Class<Enum> enumType = Enum.class; [EOL] EnumSetDeserializer enumSetDeserializer = new EnumSetDeserializer(enumType, originalDeserializer); [EOL] EnumSetDeserializer result = enumSetDeserializer.withDeserializer(newDeserializer); [EOL] assertNotSame(enumSetDeserializer, result); [EOL] assertSame(newDeserializer, result.getEnumDeserializer()); [EOL] }
public void testIsCachable() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] boolean result = objectMapper.isCachable(); [EOL] assertTrue(result); [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType enumType = mock(JavaType.class); [EOL] EnumDeserializer enumDeserializer = new EnumDeserializer(enumType, null, null, null, null); [EOL] JsonDeserializer<?> result = enumDeserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] JavaType enumType = mock(JavaType.class); [EOL] EnumDeserializer enumDeserializer = new EnumDeserializer(enumType, initialDeserializer, null, null, null); [EOL] JsonDeserializer<?> result = enumDeserializer.createContextual(ctxt, property); [EOL] assertSame(initialDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> contextualInstance = mock(JsonDeserializer.class); [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(contextualInstance); [EOL] JavaType enumType = mock(JavaType.class); [EOL] EnumDeserializer enumDeserializer = new EnumDeserializer(enumType, contextualDeserializer, null, null, null); [EOL] JsonDeserializer<?> result = enumDeserializer.createContextual(ctxt, property); [EOL] assertSame(contextualInstance, result); [EOL] }
public void testDeserializeWithNonStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] try { [EOL] new EnumSetDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] try { [EOL] new EnumSetDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected mappingException to be thrown for null value"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithValidEnum() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] EnumSetDeserializer deserializer = new EnumSetDeserializer(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(deserializer._enumDeserializer.deserialize(jp, ctxt)).thenReturn(mock(Enum.class)); [EOL] EnumSet<?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] EnumSetDeserializer deserializer = new EnumSetDeserializer(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] EnumSet<?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
private EnumSet constructSet() { [EOL] return EnumSet.noneOf(_enumClass); [EOL] }
public void testConstructEnumKeyDeserializerWithNonNullResolver() { [EOL] EnumResolver<?> enumResolver = EnumResolver.constructFor(EnumType.class, null); [EOL] KeyDeserializer keyDeserializer = StdKeyDeserializer.constructEnumKeyDeserializer(enumResolver); [EOL] assertNotNull(keyDeserializer); [EOL] assertTrue(keyDeserializer instanceof StdKeyDeserializer.EnumKD); [EOL] }
public void testConstructEnumKeyDeserializerWithNullResolver() { [EOL] try { [EOL] KeyDeserializer keyDeserializer = StdKeyDeserializer.constructEnumKeyDeserializer(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindKeyDeserializerWithStringClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithObjectClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Object.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithUUIDClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(UUID.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.UuidKD); [EOL] }
public void testFindKeyDeserializerWithPrimitiveClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(int.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithIntegerClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithLongClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Long.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LongKD); [EOL] }
public void testFindKeyDeserializerWithDateClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Date.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DateKD); [EOL] }
public void testFindKeyDeserializerWithCalendarClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Calendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CalendarKD); [EOL] }
public void testFindKeyDeserializerWithBooleanClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Boolean.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.BoolKD); [EOL] }
public void testFindKeyDeserializerWithByteClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Byte.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ByteKD); [EOL] }
public void testFindKeyDeserializerWithCharacterClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Character.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CharKD); [EOL] }
public void testFindKeyDeserializerWithShortClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Short.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ShortKD); [EOL] }
public void testFindKeyDeserializerWithFloatClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Float.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.FloatKD); [EOL] }
public void testFindKeyDeserializerWithDoubleClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Double.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DoubleKD); [EOL] }
public void testFindKeyDeserializerWithLocaleClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Locale.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LocaleKD); [EOL] }
public void testFindKeyDeserializerWithUnmappedClass() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(SomeUnmappedClass.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; // Mock or create a BeanDescription instance as needed [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testLinkedNodeWithNonNullValues() { [EOL] String value = "testValue"; [EOL] LinkedNode<String> nextNode = new LinkedNode<>("nextValue", null); [EOL] LinkedNode<String> node = new LinkedNode<>(value, nextNode); [EOL] assertEquals(value, node._value); [EOL] assertEquals(nextNode, node._next); [EOL] }
public void testLinkedNodeWithNullValues() { [EOL] LinkedNode<String> node = new LinkedNode<>(null, null); [EOL] assertNull(node._value); [EOL] assertNull(node._next); [EOL] }
public T valueTest() { [EOL] YourType instance = new YourType(expectedValue); [EOL] T result = instance.value(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testContainsWithNullNode() { [EOL] LinkedNode<String> node = null; [EOL] boolean result = JacksonDatabind.contains(node, "testValue"); [EOL] assertFalse(result); [EOL] }
public void testContainsWithValuePresent() { [EOL] LinkedNode<String> firstNode = new LinkedNode<>("testValue", null); [EOL] boolean result = JacksonDatabind.contains(firstNode, "testValue"); [EOL] assertTrue(result); [EOL] }
public void testContainsWithValueNotPresent() { [EOL] LinkedNode<String> firstNode = new LinkedNode<>("testValue", null); [EOL] LinkedNode<String> secondNode = new LinkedNode<>("anotherValue", firstNode); [EOL] boolean result = JacksonDatabind.contains(secondNode, "differentValue"); [EOL] assertFalse(result); [EOL] }
public void testContainsWithMultipleNodesValuePresent() { [EOL] LinkedNode<String> firstNode = new LinkedNode<>("testValue", null); [EOL] LinkedNode<String> secondNode = new LinkedNode<>("anotherValue", firstNode); [EOL] LinkedNode<String> thirdNode = new LinkedNode<>("testValue", secondNode); [EOL] boolean result = JacksonDatabind.contains(thirdNode, "testValue"); [EOL] assertTrue(result); [EOL] }
public void testSerializeContentsWithEmptyList() throws IOException { [EOL] List<String> value = new ArrayList<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider, 0); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(provider); [EOL] }
public void testSerializeContentsWithNonNullValues() throws IOException { [EOL] List<String> value = Arrays.asList("string1", "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider, value.size()); [EOL] verify(jgen, times(2)).writeString(anyString()); [EOL] verifyNoMoreInteractions(provider); [EOL] }
public void testSerializeContentsWithNullValues() throws IOException { [EOL] List<String> value = Arrays.asList(null, null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider, value.size()); [EOL] verify(provider, times(2)).defaultSerializeNull(jgen); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] List<String> value = Arrays.asList("string1", null, "string2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] doThrow(IOException.class).when(jgen).writeString(anyString()); [EOL] try { [EOL] serializeContents(value, jgen, provider, value.size()); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(jgen).writeString("string1"); [EOL] }
public void testAtomicLongSerializerConstructor() { [EOL] AtomicLongSerializer serializer = new AtomicLongSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(AtomicLong.class, serializer.handledType()); [EOL] assertFalse(serializer.usesObjectId()); [EOL] }
public void testSerializeAtomicLong() throws IOException { [EOL] AtomicLong value = new AtomicLong(123L); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new AtomicLongSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeNumber(123L); [EOL] }
public void testGetNodeType() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] assertEquals(JsonNodeType.OBJECT, node.getNodeType()); [EOL] }
public void testPathWithExistingField() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] TextNode expectedNode = new TextNode("value"); [EOL] objectNode.set("fieldName", expectedNode); [EOL] JsonNode resultNode = objectNode.path("fieldName"); [EOL] assertSame(expectedNode, resultNode); [EOL] }
public void testPathWithNonExistingField() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode resultNode = objectNode.path("nonExistingField"); [EOL] assertTrue(resultNode instanceof MissingNode); [EOL] }
public void testFindValuesWithNullFoundSoFar() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<JsonNode> result = root.findValues("key1", null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("value1", result.get(0).asText()); [EOL] }
public void testFindValuesWithNonNullFoundSoFar() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<JsonNode> foundSoFar = new ArrayList<>(); [EOL] foundSoFar.add(new TextNode("existingValue")); [EOL] List<JsonNode> result = root.findValues("key1", foundSoFar); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("existingValue", result.get(0).asText()); [EOL] assertEquals("value1", result.get(1).asText()); [EOL] }
public void testFindValuesWithNoMatch() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("key1", "value1"); [EOL] root.put("key2", "value2"); [EOL] List<JsonNode> result = root.findValues("key3", null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindValuesNested() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child = JsonNodeFactory.instance.objectNode(); [EOL] child.put("key1", "childValue1"); [EOL] root.set("child", child); [EOL] List<JsonNode> result = root.findValues("key1", null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("childValue1", result.get(0).asText()); [EOL] }
public void testFindParentsWhenFieldNameExists() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.set("field1", new TextNode("value1")); [EOL] objectNode.set("field2", new TextNode("value2")); [EOL] List<JsonNode> foundSoFar = objectNode.findParents("field1", null); [EOL] assertNotNull(foundSoFar); [EOL] assertEquals(1, foundSoFar.size()); [EOL] assertTrue(foundSoFar.contains(objectNode)); [EOL] }
public void testFindParentsWhenFieldNameDoesNotExist() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.set("field1", new TextNode("value1")); [EOL] objectNode.set("field2", new TextNode("value2")); [EOL] List<JsonNode> foundSoFar = objectNode.findParents("field3", null); [EOL] assertNull(foundSoFar); [EOL] }
public void testFindParentsWhenFieldNameExistsAndFoundSoFarIsNotNull() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.set("field1", new TextNode("value1")); [EOL] objectNode.set("field2", new TextNode("value2")); [EOL] List<JsonNode> initialList = new ArrayList<>(); [EOL] List<JsonNode> foundSoFar = objectNode.findParents("field1", initialList); [EOL] assertNotNull(foundSoFar); [EOL] assertEquals(1, foundSoFar.size()); [EOL] assertTrue(foundSoFar.contains(objectNode)); [EOL] assertSame(initialList, foundSoFar); [EOL] }
public void testFindParentsWhenFieldNameExistsInNestedNode() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode childNode = new ObjectNode(JsonNodeFactory.instance); [EOL] childNode.set("field1", new TextNode("value1")); [EOL] objectNode.set("child", childNode); [EOL] List<JsonNode> foundSoFar = objectNode.findParents("field1", null); [EOL] assertNotNull(foundSoFar); [EOL] assertEquals(1, foundSoFar.size()); [EOL] assertTrue(foundSoFar.contains(childNode)); [EOL] }
public void testSetAllWithNonNullProperties() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] Map<String, JsonNode> properties = new HashMap<>(); [EOL] properties.put("key1", TextNode.valueOf("value1")); [EOL] properties.put("key2", TextNode.valueOf("value2")); [EOL] JsonNode result = node.setAll(properties); [EOL] assertNotNull(result); [EOL] assertEquals("value1", result.get("key1").asText()); [EOL] assertEquals("value2", result.get("key2").asText()); [EOL] }
public void testSetAllWithNullProperties() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] Map<String, JsonNode> properties = new HashMap<>(); [EOL] properties.put("key1", null); [EOL] JsonNode result = node.setAll(properties); [EOL] assertNotNull(result); [EOL] assertTrue(result.get("key1").isNull()); [EOL] }
public void testSetAllWithEmptyMap() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] Map<String, JsonNode> properties = new HashMap<>(); [EOL] JsonNode result = node.setAll(properties); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.size()); [EOL] }
public void testSetAllWithEmptyObjectNode() { [EOL] ObjectNode targetNode = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode otherNode = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode result = targetNode.setAll(otherNode); [EOL] assertTrue("Result should be the same instance as targetNode", result == targetNode); [EOL] assertTrue("Target node should remain empty", targetNode.size() == 0); [EOL] }
public void testSetAllWithNonEmptyObjectNode() { [EOL] ObjectNode targetNode = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode otherNode = new ObjectNode(JsonNodeFactory.instance); [EOL] otherNode.put("key", "value"); [EOL] JsonNode result = targetNode.setAll(otherNode); [EOL] assertTrue("Result should be the same instance as targetNode", result == targetNode); [EOL] assertTrue("Target node should have one entry", targetNode.size() == 1); [EOL] assertTrue("Target node should contain the entry from otherNode", targetNode.has("key")); [EOL] }
public void testReplaceWithNullValue() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "field"; [EOL] JsonNode nullValue = null; [EOL] JsonNode result = objectNode.replace(fieldName, nullValue); [EOL] assertTrue(result.isNull()); [EOL] }
public void testReplaceWithNonNullValue() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "field"; [EOL] JsonNode nonNullValue = JsonNodeFactory.instance.textNode("value"); [EOL] JsonNode result = objectNode.replace(fieldName, nonNullValue); [EOL] assertEquals(nonNullValue, result); [EOL] }
public void testPutWithNullValue() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] JsonNode nullValue = null; [EOL] JsonNode result = objectNode.put(fieldName, nullValue); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testPutWithNonNullValue() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testField"; [EOL] JsonNode nonNullValue = JsonNodeFactory.instance.textNode("value"); [EOL] JsonNode result = objectNode.put(fieldName, nonNullValue); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.asText()); [EOL] }
public void testPutArrayWithValidFieldName() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "testArray"; [EOL] ArrayNode result = objectNode.putArray(fieldName); [EOL] assertNotNull(result); [EOL] assertTrue(objectNode.has(fieldName)); [EOL] assertTrue(objectNode.get(fieldName).isArray()); [EOL] assertEquals(result, objectNode.get(fieldName)); [EOL] }
public void testPutArrayWithNullFieldName() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = null; [EOL] try { [EOL] objectNode.putArray(fieldName); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPutObjectWithValidFieldName() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(false); [EOL] ObjectNode parent = new ObjectNode(nodeFactory); [EOL] String fieldName = "testField"; [EOL] ObjectNode child = parent.putObject(fieldName); [EOL] assertNotNull(child); [EOL] assertTrue(parent.get(fieldName) instanceof ObjectNode); [EOL] assertEquals(child, parent.get(fieldName)); [EOL] }
public void testPutObjectWithNullFieldName() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(false); [EOL] ObjectNode parent = new ObjectNode(nodeFactory); [EOL] String fieldName = null; [EOL] try { [EOL] parent.putObject(fieldName); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
It appears that the provided input text is for a constructor of an empty protected method named `Annotated`. Since the method body is empty, there is no executable code to cover with unit tests. Therefore, no unit test cases can be generated for this specific input as there are no lines of code to cover or meaningful assertions to be made. If you have a more complex method or a method with logic to test, please provide the relevant code snippet, and I can help generate unit test cases for that.
public void testHasAnnotationWithPresentAnnotation() { [EOL] boolean result = objectUnderTest.hasAnnotation(MyAnnotation.class); [EOL] assertTrue(result); [EOL] }
public void testHasAnnotationWithAbsentAnnotation() { [EOL] boolean result = objectUnderTest.hasAnnotation(OtherAnnotation.class); [EOL] assertFalse(result); [EOL] }
public void testOkNameForRegularGetterWithGetCallbacks() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithCglibCallbacks(); [EOL] String name = "getCallbacks"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithGetMetaClass() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithGroovyMetaClass(); [EOL] String name = "getMetaClass"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithRegularGetMethod() { [EOL] AnnotatedMethod am = createRegularAnnotatedMethod(); [EOL] String name = "getRegularProperty"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertEquals("regularProperty", result); [EOL] } [EOL] public void testOkNameForRegularGetterWithNonGetMethod() { [EOL] AnnotatedMethod am = createRegularAnnotatedMethod(); [EOL] String name = "nonGetMethod"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] }
private AnnotatedMethod createAnnotatedMethodWithCglibCallbacks() { [EOL] } [EOL] private AnnotatedMethod createAnnotatedMethodWithGroovyMetaClass() { [EOL] } [EOL] private AnnotatedMethod createRegularAnnotatedMethod() { [EOL] }
public void testIsCglibGetCallbacks_NullRawType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(am.getRawType()).thenReturn(null); [EOL] boolean result = YourClass.isCglibGetCallbacks(am); [EOL] assertFalse(result); [EOL] }
public void testIsCglibGetCallbacks_NonArrayType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(am.getRawType()).thenReturn(String.class); [EOL] boolean result = YourClass.isCglibGetCallbacks(am); [EOL] assertFalse(result); [EOL] }
public void testIsCglibGetCallbacks_CglibArrayType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Class<?> cglibClass = net.sf.cglib.proxy.Enhancer[].class; [EOL] Mockito.when(am.getRawType()).thenReturn(cglibClass); [EOL] boolean result = YourClass.isCglibGetCallbacks(am); [EOL] assertTrue(result); [EOL] }
public void testIsCglibGetCallbacks_HibernateCglibArrayType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Class<?> hibernateCglibClass = org.hibernate.repackage.cglib.proxy.Enhancer[].class; [EOL] Mockito.when(am.getRawType()).thenReturn(hibernateCglibClass); [EOL] boolean result = YourClass.isCglibGetCallbacks(am); [EOL] assertTrue(result); [EOL] }
public void testIsCglibGetCallbacks_NonCglibArrayType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Class<?> nonCglibClass = java.util.List[].class; [EOL] Mockito.when(am.getRawType()).thenReturn(nonCglibClass); [EOL] boolean result = YourClass.isCglibGetCallbacks(am); [EOL] assertFalse(result); [EOL] }
public void testIsGroovyMetaClassGetterWithNullType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(am.getRawType()).thenReturn(null); [EOL] boolean result = isGroovyMetaClassGetter(am); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGroovyMetaClassGetterWithArrayType() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(am.getRawType()).thenReturn(new Class<?>[0].getClass()); [EOL] boolean result = isGroovyMetaClassGetter(am); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGroovyMetaClassGetterWithGroovyLangPackage() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Class<?> mockClass = Mockito.mock(Class.class); [EOL] Package mockPackage = Mockito.mock(Package.class); [EOL] Mockito.when(am.getRawType()).thenReturn(mockClass); [EOL] Mockito.when(mockClass.getPackage()).thenReturn(mockPackage); [EOL] Mockito.when(mockPackage.getName()).thenReturn("groovy.lang"); [EOL] boolean result = isGroovyMetaClassGetter(am); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGroovyMetaClassGetterWithNonGroovyLangPackage() { [EOL] AnnotatedMethod am = Mockito.mock(AnnotatedMethod.class); [EOL] Class<?> mockClass = Mockito.mock(Class.class); [EOL] Package mockPackage = Mockito.mock(Package.class); [EOL] Mockito.when(am.getRawType()).thenReturn(mockClass); [EOL] Mockito.when(mockClass.getPackage()).thenReturn(mockPackage); [EOL] Mockito.when(mockPackage.getName()).thenReturn("java.lang"); [EOL] boolean result = isGroovyMetaClassGetter(am); [EOL] assertFalse(result); [EOL] }
public void testManglePropertyNameEmpty() { [EOL] String result = manglePropertyName(""); [EOL] assertNull(result); [EOL] } [EOL] public void testManglePropertyNameAlreadyLowercase() { [EOL] String input = "lowercase"; [EOL] String result = manglePropertyName(input); [EOL] assertSame("Should return the same string if no change is made", input, result); [EOL] } [EOL] public void testManglePropertyNameMixedCase() { [EOL] String result = manglePropertyName("MixedCASE"); [EOL] assertEquals("mixedcase", result); [EOL] } [EOL] public void testManglePropertyNameAllUppercase() { [EOL] String result = manglePropertyName("UPPERCASE"); [EOL] assertEquals("uppercase", result); [EOL] }
public void testIntNodeConstructor() { [EOL] int testValue = 5; [EOL] IntNode node = new IntNode(testValue); [EOL] assertEquals(testValue, node.intValue()); [EOL] }
public void testValueOfWithIntGreaterThanMaxCanonical() { [EOL] int testValue = IntNode.MAX_CANONICAL + 1; [EOL] IntNode result = IntNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.intValue()); [EOL] }
public void testValueOfWithIntLessThanMinCanonical() { [EOL] int testValue = IntNode.MIN_CANONICAL - 1; [EOL] IntNode result = IntNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.intValue()); [EOL] }
public void testValueOfWithIntWithinCanonicalRange() { [EOL] for (int i = IntNode.MIN_CANONICAL; i <= IntNode.MAX_CANONICAL; i++) { [EOL] IntNode result = IntNode.valueOf(i); [EOL] assertNotNull(result); [EOL] assertEquals(i, result.intValue()); [EOL] } [EOL] }
public void testUnwrappedPropertyHandlerConstructor() { [EOL] new UnwrappedPropertyHandler(); [EOL] }
public void testAddPropertyWithNonNull() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty property = new MockSettableBeanProperty("testProperty"); [EOL] map.addProperty(property); [EOL] assertTrue(map.hasProperty("testProperty")); [EOL] }
public void testAddPropertyWithNull() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] try { [EOL] map.addProperty(null); [EOL] fail("Should not be able to add null property"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testProcessUnwrappedWithEmptyProperties() throws IOException, JsonProcessingException { [EOL] JsonParser originalParser = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer buffered = new TokenBuffer(originalParser, ctxt); [EOL] UnwrappingBeanDeserializer deserializer = new UnwrappingBeanDeserializer(null, null, Collections.emptyList()); [EOL] Object result = deserializer.processUnwrapped(originalParser, ctxt, bean, buffered); [EOL] assertSame("The bean returned should be the same as the one passed in.", bean, result); [EOL] }
public void testProcessUnwrappedWithNonEmptyProperties() throws IOException, JsonProcessingException { [EOL] JsonParser originalParser = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer buffered = new TokenBuffer(originalParser, ctxt); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] List<SettableBeanProperty> properties = Arrays.asList(prop); [EOL] UnwrappingBeanDeserializer deserializer = new UnwrappingBeanDeserializer(null, null, properties); [EOL] when(buffered.asParser()).thenReturn(originalParser); [EOL] when(originalParser.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] doNothing().when(prop).deserializeAndSet(any(JsonParser.class), any(DeserializationContext.class), any()); [EOL] Object result = deserializer.processUnwrapped(originalParser, ctxt, bean, buffered); [EOL] verify(prop, times(1)).deserializeAndSet(any(JsonParser.class), any(DeserializationContext.class), eq(bean)); [EOL] assertSame("The bean returned should be the same as the one passed in.", bean, result); [EOL] }
public void testSimpleDeserializersConstructor() { [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] }
public void testAddDeserializerWithNewMap() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] module.addDeserializer(String.class, deserializer); [EOL] assertNotNull(module.getDeserializerModifier()); [EOL] }
public void testAddDeserializerWithExistingMap() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonDeserializer<?> deserializer1 = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> deserializer2 = mock(JsonDeserializer.class); [EOL] module.addDeserializer(String.class, deserializer1); [EOL] module.addDeserializer(Integer.class, deserializer2); [EOL] assertNotNull(module.getDeserializerModifier()); [EOL] assertEquals(deserializer1, module.getDeserializer(String.class)); [EOL] assertEquals(deserializer2, module.getDeserializer(Integer.class)); [EOL] }
public void testFindArrayDeserializerWithNullClassMappings() { [EOL] DeserializationConfig config = null; // Mock or create an instance as per your context [EOL] BeanDescription beanDesc = null; // Mock or create an instance as per your context [EOL] TypeDeserializer elementTypeDeserializer = null; // Mock or create an instance as per your context [EOL] JsonDeserializer<?> elementDeserializer = null; // Mock or create an instance as per your context [EOL] ArrayType type = null; // Mock or create an instance as per your context [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] JsonDeserializer<?> result = factory.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindArrayDeserializerWithNonNullClassMappings() { [EOL] DeserializationConfig config = null; // Mock or create an instance as per your context [EOL] BeanDescription beanDesc = null; // Mock or create an instance as per your context [EOL] TypeDeserializer elementTypeDeserializer = null; // Mock or create an instance as per your context [EOL] JsonDeserializer<?> elementDeserializer = null; // Mock or create an instance as per your context [EOL] ArrayType type = null; // Mock or create an instance as per your context [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] factory._classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] ClassKey key = new ClassKey(type.getRawClass()); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] factory._classMappings.put(key, expectedDeserializer); [EOL] JsonDeserializer<?> result = factory.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindBeanDeserializerWithNullClassMappings() { [EOL] _classMappings = null; [EOL] JavaType type = ...; // Initialize with a mock or concrete JavaType [EOL] DeserializationConfig config = ...; // Initialize with a mock or concrete DeserializationConfig [EOL] BeanDescription beanDesc = ...; // Initialize with a mock or concrete BeanDescription [EOL] JsonDeserializer<?> result = findBeanDeserializer(type, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindBeanDeserializerWithNonNullClassMappingsAndTypeNotPresent() { [EOL] _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] JavaType type = ...; // Initialize with a mock or concrete JavaType not present in _classMappings [EOL] DeserializationConfig config = ...; // Initialize with a mock or concrete DeserializationConfig [EOL] BeanDescription beanDesc = ...; // Initialize with a mock or concrete BeanDescription [EOL] JsonDeserializer<?> result = findBeanDeserializer(type, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindBeanDeserializerWithNonNullClassMappingsAndTypePresent() { [EOL] _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] Class<?> rawClass = ...; // Initialize with a concrete class [EOL] JavaType type = ...; // Initialize with a mock or concrete JavaType that corresponds to rawClass [EOL] DeserializationConfig config = ...; // Initialize with a mock or concrete DeserializationConfig [EOL] BeanDescription beanDesc = ...; // Initialize with a mock or concrete BeanDescription [EOL] JsonDeserializer<?> expectedDeserializer = ...; // Initialize with a mock or concrete JsonDeserializer [EOL] _classMappings.put(new ClassKey(rawClass), expectedDeserializer); [EOL] JsonDeserializer<?> result = findBeanDeserializer(type, config, beanDesc); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindEnumDeserializerWithNullClassMappings() { [EOL] _classMappings = null; [EOL] JsonDeserializer<?> result = findEnumDeserializer(MyEnum.class, mock(DeserializationConfig.class), mock(BeanDescription.class)); [EOL] assertNull(result); [EOL] }
public void testFindEnumDeserializerWithNonNullClassMappingsAndKeyNotPresent() { [EOL] _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] JsonDeserializer<?> result = findEnumDeserializer(MyEnum.class, mock(DeserializationConfig.class), mock(BeanDescription.class)); [EOL] assertNull(result); [EOL] }
public void testFindEnumDeserializerWithNonNullClassMappingsAndKeyPresent() { [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL] _classMappings.put(new ClassKey(MyEnum.class), expectedDeserializer); [EOL] JsonDeserializer<?> result = findEnumDeserializer(MyEnum.class, mock(DeserializationConfig.class), mock(BeanDescription.class)); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testReplaceParameterAnnotations_ValidIndex() { [EOL] AnnotatedParameter originalParam = setupAnnotatedParameterWithAnnotations(); [EOL] int index = 0; // valid index [EOL] AnnotationMap newAnnotations = new AnnotationMap(); [EOL] newAnnotations.add(someAnnotation); // Assuming someAnnotation is a valid annotation instance [EOL] AnnotatedParameter result = originalParam.replaceParameterAnnotations(index, newAnnotations); [EOL] assertNotNull(result); [EOL] assertEquals(newAnnotations, originalParam.getParameter(index).getAnnotations()); [EOL] }
public void testReplaceParameterAnnotations_InvalidIndex() { [EOL] AnnotatedParameter originalParam = setupAnnotatedParameterWithAnnotations(); [EOL] int index = -1; // invalid index, should throw an exception or handle it accordingly [EOL] try { [EOL] originalParam.replaceParameterAnnotations(index, new AnnotationMap()); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetIgnoredPropertyNamesWhenNull() { [EOL] YourClass instance = new YourClass(); [EOL] Set<String> result = instance.getIgnoredPropertyNames(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetIgnoredPropertyNamesWhenNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] Set<String> mockSet = new HashSet<>(); [EOL] mockSet.add("property1"); [EOL] instance.setIgnoredPropertyNames(mockSet); [EOL] Set<String> result = instance.getIgnoredPropertyNames(); [EOL] assertEquals(mockSet, result); [EOL] }
public void testFindInjectablesWhenInjectablesIsNull() { [EOL] TargetClass target = new TargetClass(); // You need to replace TargetClass with the actual class name [EOL] target._injectables = null; // You might need to set this via a constructor or a setter method [EOL] Map<Object, AnnotatedMember> result = target.findInjectables(); [EOL] assertNull(result); [EOL] }
public void testFindInjectablesWhenInjectablesIsNotNull() { [EOL] TargetClass target = new TargetClass(); // You need to replace TargetClass with the actual class name [EOL] Map<Object, AnnotatedMember> expectedInjectables = new HashMap<>(); [EOL] expectedInjectables.put(new Object(), new AnnotatedMember() { [EOL] }); [EOL] target._injectables = expectedInjectables; // You might need to set this via a constructor or a setter method [EOL] Map<Object, AnnotatedMember> result = target.findInjectables(); [EOL] assertEquals(expectedInjectables, result); [EOL] }
public void testFindBackReferenceProperties_NoBackReferences() { [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.getMutator()).thenReturn(null); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(any(AnnotatedMember.class))).thenReturn(null); [EOL] Map<String, AnnotatedMember> result = new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceProperties_WithBackReferences() { [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.getMutator()).thenReturn(annotatedMember); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember)).thenReturn(refProperty); [EOL] Map<String, AnnotatedMember> result = new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsKey("backRef")); [EOL] assertEquals(annotatedMember, result.get("backRef")); [EOL] }
public void testFindBackReferenceProperties_MultipleBackReferencesSameName() { [EOL] AnnotatedMember annotatedMember1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember annotatedMember2 = mock(AnnotatedMember.class); [EOL] BeanPropertyDefinition property1 = mock(BeanPropertyDefinition.class); [EOL] BeanPropertyDefinition property2 = mock(BeanPropertyDefinition.class); [EOL] when(property1.getMutator()).thenReturn(annotatedMember1); [EOL] when(property2.getMutator()).thenReturn(annotatedMember2); [EOL] List<BeanPropertyDefinition> properties = Arrays.asList(property1, property2); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember1)).thenReturn(refProperty); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember2)).thenReturn(refProperty); [EOL] try { [EOL] new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Multiple back-reference properties with name 'backRef'", e.getMessage()); [EOL] } [EOL] }
public void testCreateConverterWithNull() { [EOL] Converter<Object, Object> result = _createConverter(null); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithConverterInstance() { [EOL] Converter<Object, Object> converter = new Converter<Object, Object>() { [EOL] @Override [EOL] public Object convert(Object value) { [EOL] return value; [EOL] } [EOL] }; [EOL] Converter<Object, Object> result = _createConverter(converter); [EOL] assertSame(converter, result); [EOL] }
public void testCreateConverterWithInvalidType() { [EOL] Object invalidConverterDef = new Object(); [EOL] try { [EOL] _createConverter(invalidConverterDef); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Converter definition of type " + invalidConverterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead", e.getMessage()); [EOL] } [EOL] }
public void testCreateConverterWithConverterClass() { [EOL] class TestConverter implements Converter<Object, Object> { [EOL] @Override [EOL] public Object convert(Object value) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter<Object, Object> result = _createConverter(TestConverter.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TestConverter); [EOL] }
public void testCreateConverterWithNoneClass() { [EOL] Converter<Object, Object> result = _createConverter(Converter.None.class); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithNoClass() { [EOL] Converter<Object, Object> result = _createConverter(NoClass.class); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithNonConverterClass() { [EOL] class NonConverter {} [EOL] try { [EOL] _createConverter(NonConverter.class); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class " + NonConverter.class.getName() + "; expected Class<Converter>", e.getMessage()); [EOL] } [EOL] }
public void testCreateConverterWithHandlerInstantiator() { [EOL] class TestConverter implements Converter<Object, Object> { [EOL] @Override [EOL] public Object convert(Object value) { [EOL] return value; [EOL] } [EOL] } [EOL] HandlerInstantiator hi = new HandlerInstantiator() { [EOL] @Override [EOL] public Converter<?, ?> converterInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass) { [EOL] return new TestConverter(); [EOL] } [EOL] }; [EOL] _config = new MapperConfig<Object>() { [EOL] @Override [EOL] public HandlerInstantiator getHandlerInstantiator() { [EOL] return hi; [EOL] } [EOL] }; [EOL] Converter<Object, Object> result = _createConverter(TestConverter.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TestConverter); [EOL] }
public void testGetValueTypeDesc_WithNonNullValue() { [EOL] String expected = "ExpectedTypeDescription"; [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(expected); [EOL] String actual = obj.getValueTypeDesc(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetValueTypeDesc_WithNullValue() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(null); [EOL] String actual = obj.getValueTypeDesc(); [EOL] assertNull(actual); [EOL] }
public void testCanCreateFromString_WithFromStringCreator() { [EOL] YourClass instance = new YourClass(); [EOL] instance._fromStringCreator = someFromStringCreatorInstance; // Replace with actual creator instance [EOL] boolean result = instance.canCreateFromString(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateFromString_WithoutFromStringCreator() { [EOL] YourClass instance = new YourClass(); [EOL] instance._fromStringCreator = null; [EOL] boolean result = instance.canCreateFromString(); [EOL] assertFalse(result); [EOL] }
public void testCanCreateFromInt_WithNonNullFromIntCreator() { [EOL] MyClass instance = new MyClass(); [EOL] instance._fromIntCreator = mock(Creator.class); // Mocking the _fromIntCreator field [EOL] boolean result = instance.canCreateFromInt(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateFromInt_WithNullFromIntCreator() { [EOL] MyClass instance = new MyClass(); [EOL] instance._fromIntCreator = null; // Setting the _fromIntCreator field to null [EOL] boolean result = instance.canCreateFromInt(); [EOL] assertFalse(result); [EOL] }
public void testCanCreateFromLong_WithFromLongCreator() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] instance.setFromLongCreator(someLongCreator); // Replace with actual method to set _fromLongCreator [EOL] boolean result = instance.canCreateFromLong(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateFromLong_WithoutFromLongCreator() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] boolean result = instance.canCreateFromLong(); [EOL] assertFalse(result); [EOL] }
public void testCanCreateFromDouble_WithFromDoubleCreator() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setFromDoubleCreator(someDoubleCreator); // Replace 'someDoubleCreator' with actual double creator object [EOL] boolean result = instance.canCreateFromDouble(); [EOL] assert result == true; // Assert that the result should be true when _fromDoubleCreator is set [EOL] }
public void testCanCreateFromDouble_WithoutFromDoubleCreator() { [EOL] MyClass instance = new MyClass(); [EOL] boolean result = instance.canCreateFromDouble(); [EOL] assert result == false; // Assert that the result should be false when _fromDoubleCreator is not set [EOL] }
public void testCanCreateFromBoolean_WithFromBooleanCreator() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] instance.setFromBooleanCreator(someBooleanCreator); // Replace with actual method to set _fromBooleanCreator [EOL] boolean result = instance.canCreateFromBoolean(); [EOL] assertTrue(result); [EOL] }
public void testCanCreateFromBoolean_WithoutFromBooleanCreator() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] boolean result = instance.canCreateFromBoolean(); [EOL] assertFalse(result); [EOL] }
public void testCreateFromStringFallbacksWithTrue() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " true "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertTrue((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithFalse() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " false "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertFalse((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithEmptyString() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = ""; [EOL] _cfgEmptyStringsAsObjects = true; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNull(result); [EOL] }
public void testCreateFromStringFallbacksWithNonEmptyString() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = "nonEmptyString"; [EOL] try { [EOL] _createFromStringFallbacks(ctxt, value); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testGetSchema() { [EOL] JsonSerializer<?> serializer = new MyArraySerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = boolean[].class; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("array", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("items").isObject()); [EOL] assertEquals("boolean", schemaNode.get("items").get("type").asText()); [EOL] }
public void testGetSchema() { [EOL] SerializerProvider provider = null; // Assuming SerializerProvider can be null or a mock if required [EOL] Type typeHint = null; // Assuming Type can be null or a mock if required [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("items")); [EOL] JsonNode itemsNode = result.get("items"); [EOL] assertNotNull(itemsNode); [EOL] assertEquals("string", itemsNode.get("type").asText()); [EOL] }
public void testGetSchema() { [EOL] TestClass testInstance = new TestClass(); [EOL] SerializerProvider provider = null; // Assuming that we can pass null for this test [EOL] Type typeHint = null; // Assuming that we can pass null for this test [EOL] JsonNode result = testInstance.getSchema(provider, typeHint); [EOL] assertTrue(result.isObject()); [EOL] assertTrue(result.has("type")); [EOL] assertEquals("array", result.get("type").asText()); [EOL] assertTrue(result.has("items")); [EOL] JsonNode items = result.get("items"); [EOL] assertTrue(items.isObject()); [EOL] assertTrue(items.has("type")); [EOL] assertEquals("string", items.get("type").asText()); [EOL] }
public void testGetSchema() { [EOL] ArrayNodeSerializer serializer = new ArrayNodeSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] JsonNode schema = serializer.getSchema(provider, null); [EOL] assertTrue(schema.isObject()); [EOL] ObjectNode schemaObj = (ObjectNode) schema; [EOL] assertEquals("array", schemaObj.get("type").asText()); [EOL] assertTrue(schemaObj.get("items").isObject()); [EOL] assertEquals("integer", schemaObj.get("items").get("type").asText()); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] long[] value = new long[]{1L, 2L, 3L}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] StdArraySerializers.LongArraySerializer serializer = new StdArraySerializers.LongArraySerializer(); [EOL] serializer._valueTypeSerializer = typeSerializer; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(typeSerializer, times(value.length)).writeTypePrefixForScalar(null, jgen, Long.TYPE); [EOL] verify(jgen, times(value.length)).writeNumber(anyLong()); [EOL] verify(typeSerializer, times(value.length)).writeTypeSuffixForScalar(null, jgen); [EOL] }
public void testSerializeContentsWithoutValueTypeSerializer() throws IOException { [EOL] long[] value = new long[]{1L, 2L, 3L}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdArraySerializers.LongArraySerializer serializer = new StdArraySerializers.LongArraySerializer(); [EOL] serializer._valueTypeSerializer = null; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(jgen, times(value.length)).writeNumber(anyLong()); [EOL] }
public void testGetSchema() { [EOL] JsonSerializer<?> serializer = new ArraySerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = Double[].class; [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("array", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("items").isObject()); [EOL] assertEquals("number", schemaNode.get("items").get("type").asText()); [EOL] }
public void testGetSchema() { [EOL] ArrayNodeSerializer serializer = new ArrayNodeSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] JsonNode schema = serializer.getSchema(provider, null); [EOL] assertTrue(schema.isObject()); [EOL] ObjectNode schemaObj = (ObjectNode) schema; [EOL] assertEquals("array", schemaObj.get("type").asText()); [EOL] assertTrue(schemaObj.get("items").isObject()); [EOL] assertEquals("number", schemaObj.get("items").get("type").asText()); [EOL] }
public void testWithContentValueHandlerNonNull() { [EOL] MapType original = new MapType(SomeClass.class, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(Integer.class), null, null, false); [EOL] Object contentValueHandler = new Object(); [EOL] MapType result = original.withContentValueHandler(contentValueHandler); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(SomeClass.class, result.getRawClass()); [EOL] assertEquals(String.class, result.getKeyType().getRawClass()); [EOL] assertEquals(Integer.class, result.getContentType().getRawClass()); [EOL] assertSame(contentValueHandler, result.getContentType().getValueHandler()); [EOL] assertNull(result.getValueHandler()); [EOL] assertNull(result.getTypeHandler()); [EOL] assertFalse(result.isStatic()); [EOL] }
public void testWithContentValueHandlerNull() { [EOL] MapType original = new MapType(SomeClass.class, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(Integer.class), null, null, false); [EOL] MapType result = original.withContentValueHandler(null); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(SomeClass.class, result.getRawClass()); [EOL] assertEquals(String.class, result.getKeyType().getRawClass()); [EOL] assertEquals(Integer.class, result.getContentType().getRawClass()); [EOL] assertNull(result.getContentType().getValueHandler()); [EOL] assertNull(result.getValueHandler()); [EOL] assertNull(result.getTypeHandler()); [EOL] assertFalse(result.isStatic()); [EOL] }
public void testWithKeyValueHandler_NewHandler() { [EOL] Class<?> mapClass = Map.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] MapType mapType = (MapType) TypeFactory.defaultInstance().constructMapType(HashMap.class, keyType, valueType); [EOL] Object newKeyValueHandler = new Object(); [EOL] MapType newMapType = mapType.withKeyValueHandler(newKeyValueHandler); [EOL] assertNotNull(newMapType); [EOL] assertEquals(newKeyValueHandler, newMapType.getKeyType().getValueHandler()); [EOL] }
public void testWithKeyValueHandler_SameHandler() { [EOL] Class<?> mapClass = Map.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Object keyValueHandler = new Object(); [EOL] keyType = keyType.withValueHandler(keyValueHandler); [EOL] MapType mapType = (MapType) TypeFactory.defaultInstance().constructMapType(HashMap.class, keyType, valueType); [EOL] MapType newMapType = mapType.withKeyValueHandler(keyValueHandler); [EOL] assertNotNull(newMapType); [EOL] assertSame(keyValueHandler, newMapType.getKeyType().getValueHandler()); [EOL] }
public void testFindBeanDeserializerWithQName() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(QName.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof QNameDeserializer); [EOL] }
public void testFindBeanDeserializerWithXMLGregorianCalendar() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(XMLGregorianCalendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof GregorianCalendarDeserializer); [EOL] }
public void testFindBeanDeserializerWithDuration() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Duration.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DurationDeserializer); [EOL] }
public void testFindBeanDeserializerWithUnrecognizedType() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testDurationDeserializerConstructor() { [EOL] DurationDeserializer deserializer = new DurationDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(Duration.class, deserializer.handledType()); [EOL] }
public void testGregorianCalendarDeserializerConstructor() { [EOL] GregorianCalendarDeserializer deserializer = new GregorianCalendarDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(XMLGregorianCalendar.class, deserializer.handledType()); [EOL] }
public void testQNameDeserializerConstructor() { [EOL] QNameDeserializer deserializer = new QNameDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeValidQName() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] QNameDeserializer deserializer = new QNameDeserializer(); [EOL] String validQNameString = "localPart"; [EOL] QName expected = QName.valueOf(validQNameString); [EOL] QName result = deserializer._deserialize(validQNameString, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeInvalidQName() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] QNameDeserializer deserializer = new QNameDeserializer(); [EOL] String invalidQNameString = "##invalid"; [EOL] try { [EOL] deserializer._deserialize(invalidQNameString, ctxt); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPropertyTypeWithAccessorMethod() { [EOL] Method mockMethod = MyClass.class.getMethod("myMethod"); [EOL] PropertyAccessor accessor = new PropertyAccessor(mockMethod, null); [EOL] Class<?> returnType = accessor.getPropertyType(); [EOL] assertEquals(mockMethod.getReturnType(), returnType); [EOL] }
public void testGetPropertyTypeWithField() { [EOL] Field mockField = MyClass.class.getField("myField"); [EOL] PropertyAccessor accessor = new PropertyAccessor(null, mockField); [EOL] Class<?> fieldType = accessor.getPropertyType(); [EOL] assertEquals(mockField.getType(), fieldType); [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] Object[] expected = new Object[] {}; [EOL] when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(expected); [EOL] Object[] result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertArrayEquals(expected, result); [EOL] }
public PropertyName findWrapperName(Annotated ann) { [EOL] return null; [EOL] }
public String findEnumValue(Enum<?> value) { [EOL] return value.name(); [EOL] }
public void testFromStringDeserializerConstructor() { [EOL] Class<?> vc = String.class; // Example class object [EOL] FromStringDeserializer instance = new FromStringDeserializer(vc); [EOL] assertNotNull(instance); [EOL] }
public void testDeserializeWithNonNullTextAndValidRepresentation() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("validText"); [EOL] T expected = createValidInstanceOfT(); [EOL] when(this._deserialize("validText", ctxt)).thenReturn(expected); [EOL] T result = this.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithNonNullTextAndInvalidRepresentation() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("invalidText"); [EOL] when(this._deserialize(anyString(), any(DeserializationContext.class))) [EOL] .thenThrow(new IllegalArgumentException()); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> this.deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithEmptyText() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(""); [EOL] T result = this.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNullTextAndEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = createEmbeddedObject(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] when(_valueClass.isAssignableFrom(embeddedObject.getClass())).thenReturn(true); [EOL] T result = this.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithNullTextAndNonAssignableEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = createNonAssignableEmbeddedObject(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] when(_valueClass.isAssignableFrom(embeddedObject.getClass())).thenReturn(false); [EOL] T expected = createValidInstanceOfT(); [EOL] when(this._deserializeEmbedded(embeddedObject, ctxt)).thenReturn(expected); [EOL] T result = this.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithNullTextAndNullEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] T result = this.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNullTextAndNoEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> this.deserialize(jp, ctxt)); [EOL] }
public void testMapSerializerConstructor() { [EOL] HashSet<String> ignoredEntries = new HashSet<>(); [EOL] ignoredEntries.add("key1"); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] boolean valueTypeIsStatic = true; [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> keySerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] MapSerializer mapSerializer = new MapSerializer( [EOL] ignoredEntries, keyType, valueType, valueTypeIsStatic, vts, keySerializer, valueSerializer [EOL] ); [EOL] assertNotNull(mapSerializer); [EOL] assertEquals(ignoredEntries, mapSerializer.getIgnoredEntries()); [EOL] assertEquals(keyType, mapSerializer.getKeyType()); [EOL] assertEquals(valueType, mapSerializer.getValueType()); [EOL] assertEquals(valueTypeIsStatic, mapSerializer.isValueTypeStatic()); [EOL] assertEquals(vts, mapSerializer.getValueTypeSerializer()); [EOL] assertEquals(keySerializer, mapSerializer.getKeySerializer()); [EOL] assertEquals(valueSerializer, mapSerializer.getValueSerializer()); [EOL] assertNotNull(mapSerializer.getDynamicValueSerializers()); [EOL] assertNull(mapSerializer.getProperty()); [EOL] }
public void testMapSerializerConstructorWithNullValues() { [EOL] HashSet<String> ignoredEntries = null; [EOL] JavaType keyType = null; [EOL] JavaType valueType = null; [EOL] boolean valueTypeIsStatic = false; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<?> keySerializer = null; [EOL] JsonSerializer<?> valueSerializer = null; [EOL] MapSerializer mapSerializer = new MapSerializer( [EOL] ignoredEntries, keyType, valueType, valueTypeIsStatic, vts, keySerializer, valueSerializer [EOL] ); [EOL] assertNotNull(mapSerializer); [EOL] assertNull(mapSerializer.getIgnoredEntries()); [EOL] assertNull(mapSerializer.getKeyType()); [EOL] assertNull(mapSerializer.getValueType()); [EOL] assertEquals(valueTypeIsStatic, mapSerializer.isValueTypeStatic()); [EOL] assertNull(mapSerializer.getValueTypeSerializer()); [EOL] assertNull(mapSerializer.getKeySerializer()); [EOL] assertNull(mapSerializer.getValueSerializer()); [EOL] assertNotNull(mapSerializer.getDynamicValueSerializers()); [EOL] assertNull(mapSerializer.getProperty()); [EOL] }
public void testConstructWithNullMapType() { [EOL] String[] ignoredList = new String[]{"key1", "key2"}; [EOL] JavaType mapType = null; [EOL] boolean staticValueType = false; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> keySerializer = null; [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] MapSerializer result = MapSerializer.construct(ignoredList, mapType, staticValueType, vts, keySerializer, valueSerializer); [EOL] assertNotNull(result); [EOL] assertEquals(HashSet.class, result.getIgnoredEntries().getClass()); [EOL] assertTrue(result.getIgnoredEntries().contains("key1")); [EOL] assertTrue(result.getIgnoredEntries().contains("key2")); [EOL] assertEquals(MapSerializer.UNSPECIFIED_TYPE, result.getKeyType()); [EOL] assertEquals(MapSerializer.UNSPECIFIED_TYPE, result.getValueType()); [EOL] assertFalse(result.isStaticValueType()); [EOL] }
public void testConstructWithNonNullMapTypeAndFinalValueType() { [EOL] String[] ignoredList = new String[]{"key1", "key2"}; [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(valueType); [EOL] when(valueType.isFinal()).thenReturn(true); [EOL] boolean staticValueType = false; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> keySerializer = null; [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] MapSerializer result = MapSerializer.construct(ignoredList, mapType, staticValueType, vts, keySerializer, valueSerializer); [EOL] assertNotNull(result); [EOL] assertEquals(HashSet.class, result.getIgnoredEntries().getClass()); [EOL] assertTrue(result.getIgnoredEntries().contains("key1")); [EOL] assertTrue(result.getIgnoredEntries().contains("key2")); [EOL] assertSame(keyType, result.getKeyType()); [EOL] assertSame(valueType, result.getValueType()); [EOL] assertTrue(result.isStaticValueType()); [EOL] }
public void testConstructWithNonNullMapTypeAndNonFinalValueType() { [EOL] String[] ignoredList = new String[]{"key1", "key2"}; [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(valueType); [EOL] when(valueType.isFinal()).thenReturn(false); [EOL] boolean staticValueType = false; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> keySerializer = null; [EOL] JsonSerializer<Object> valueSerializer = null; [EOL] MapSerializer result = MapSerializer.construct(ignoredList, mapType, staticValueType, vts, keySerializer, valueSerializer); [EOL] assertNotNull(result); [EOL] assertEquals(HashSet.class, result.getIgnoredEntries().getClass()); [EOL] assertTrue(result.getIgnoredEntries().contains("key1")); [EOL] assertTrue(result.getIgnoredEntries().contains("key2")); [EOL] assertSame(keyType, result.getKeyType()); [EOL] assertSame(valueType, result.getValueType()); [EOL] assertFalse(result.isStaticValueType()); [EOL] }
public void testToSetWithNullInput() { [EOL] HashSet<String> result = toSet(null); [EOL] assertNull(result); [EOL] }
public void testToSetWithEmptyArray() { [EOL] HashSet<String> result = toSet(new String[]{}); [EOL] assertNull(result); [EOL] }
public void testToSetWithNonEmptyArray() { [EOL] String[] ignoredEntries = {"entry1", "entry2", "entry3"}; [EOL] HashSet<String> result = toSet(ignoredEntries); [EOL] assertNotNull(result); [EOL] assertEquals(ignoredEntries.length, result.size()); [EOL] for (String entry : ignoredEntries) { [EOL] assertTrue(result.contains(entry)); [EOL] } [EOL] }
public void testSerializeFieldsWithValueTypeSerializerNotNull() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._valueTypeSerializer = mock(TypeSerializer.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(instance._valueTypeSerializer).serializeTypedFields(value, jgen, provider); [EOL] }
public void testSerializeFieldsWithNullKey() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put(null, "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(provider).findNullKeySerializer(any(), any()); [EOL] verify(jgen).writeFieldName((String) null); [EOL] }
public void testSerializeFieldsWithIgnoredEntry() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("ignoredKey", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._ignoredEntries = new HashSet<>(); [EOL] instance._ignoredEntries.add("ignoredKey"); [EOL] instance.serializeFields(value, jgen, provider); [EOL] }
public void testSerializeFieldsWithNonNullKeyAndValue() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", "value"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(instance._keySerializer).serialize(eq("key"), eq(jgen), eq(provider)); [EOL] verify(provider, never()).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithNonNullKeyAndNullValue() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._keySerializer = mock(JsonSerializer.class); [EOL] instance.serializeFields(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeFieldsWithDynamicValueSerializer() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", new CustomValue()); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] instance._valueType = mock(JavaType.class); [EOL] when(instance._valueType.hasGenericTypes()).thenReturn(false); [EOL] instance.serializeFields(value, jgen, provider); [EOL] }
public void testSerializeFieldsWithExceptionDuringSerialization() throws IOException { [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key", new CustomValue()); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance._dynamicValueSerializers = PropertySerializerMap.emptyForProperties(); [EOL] JsonSerializer<Object> failingSerializer = mock(JsonSerializer.class); [EOL] doThrow(new IOException()).when(failingSerializer).serialize(any(), any(), any()); [EOL] instance._dynamicValueSerializers = instance._dynamicValueSerializers.newWith("CustomValue", failingSerializer); [EOL] assertThrows(IOException.class, () -> instance.serializeFields(value, jgen, provider)); [EOL] }
protected void serializeTypedFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL] final JsonSerializer<Object> keySerializer = _keySerializer; [EOL] JsonSerializer<Object> prevValueSerializer = null; [EOL] Class<?> prevValueClass = null; [EOL] final HashSet<String> ignored = _ignoredEntries; [EOL] final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL] for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL] Object valueElem = entry.getValue(); [EOL] Object keyElem = entry.getKey(); [EOL] if (keyElem == null) { [EOL] provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL] } else { [EOL] if (skipNulls && valueElem == null) [EOL] continue; [EOL] if (ignored != null && ignored.contains(keyElem)) [EOL] continue; [EOL] keySerializer.serialize(keyElem, jgen, provider); [EOL] } [EOL] if (valueElem == null) { [EOL] provider.defaultSerializeNull(jgen); [EOL] } else { [EOL] Class<?> cc = valueElem.getClass(); [EOL] JsonSerializer<Object> currSerializer; [EOL] if (cc == prevValueClass) { [EOL] currSerializer = prevValueSerializer; [EOL] } else { [EOL] currSerializer = provider.findValueSerializer(cc, _property); [EOL] prevValueSerializer = currSerializer; [EOL] prevValueClass = cc; [EOL] } [EOL] try { [EOL] currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer); [EOL] } catch (Exception e) { [EOL] String keyDesc = "" + keyElem; [EOL] wrapAndThrow(provider, e, value, keyDesc); [EOL] } [EOL] } [EOL] } [EOL] }
public void testGetSchemaWithNonNullProviderAndTypeHint() { [EOL] JsonSerializer<Object> serializer = new MyJsonSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] Type typeHint = new TypeReference<Map<String, Object>>() {}.getType(); [EOL] JsonNode schemaNode = serializer.getSchema(provider, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("object", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("required").asBoolean()); [EOL] }
public void testGetSchemaWithNullProviderAndTypeHint() { [EOL] JsonSerializer<Object> serializer = new MyJsonSerializer(); [EOL] Type typeHint = new TypeReference<Map<String, Object>>() {}.getType(); [EOL] JsonNode schemaNode = serializer.getSchema(null, typeHint); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("object", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("required").asBoolean()); [EOL] }
public void testGetSchemaWithNonNullProviderAndNullTypeHint() { [EOL] JsonSerializer<Object> serializer = new MyJsonSerializer(); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] JsonNode schemaNode = serializer.getSchema(provider, null); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("object", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("required").asBoolean()); [EOL] }
public void testGetSchemaWithNullProviderAndNullTypeHint() { [EOL] JsonSerializer<Object> serializer = new MyJsonSerializer(); [EOL] JsonNode schemaNode = serializer.getSchema(null, null); [EOL] assertNotNull(schemaNode); [EOL] assertTrue(schemaNode.isObject()); [EOL] assertEquals("object", schemaNode.get("type").asText()); [EOL] assertTrue(schemaNode.get("required").asBoolean()); [EOL] }
public void testWithResolvedSameObjects() { [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser, valueDeser, valueTypeDeser, ignorable); [EOL] MapDeserializer result = instance.withResolved(keyDeser, valueTypeDeser, valueDeser, ignorable); [EOL] assertSame(instance, result); [EOL] }
public void testWithResolvedDifferentKeyDeserializer() { [EOL] KeyDeserializer originalKeyDeser = mock(KeyDeserializer.class); [EOL] KeyDeserializer newKeyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(); [EOL] MapDeserializer instance = new MapDeserializer(null, originalKeyDeser, valueDeser, valueTypeDeser, ignorable); [EOL] MapDeserializer result = instance.withResolved(newKeyDeser, valueTypeDeser, valueDeser, ignorable); [EOL] assertNotSame(instance, result); [EOL] assertSame(newKeyDeser, result.getKeyDeserializer()); [EOL] }
public void testWithResolvedDifferentValueDeserializer() { [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> originalValueDeser = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newValueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser, originalValueDeser, valueTypeDeser, ignorable); [EOL] MapDeserializer result = instance.withResolved(keyDeser, valueTypeDeser, newValueDeser, ignorable); [EOL] assertNotSame(instance, result); [EOL] assertSame(newValueDeser, result.getValueDeserializer()); [EOL] }
public void testWithResolvedDifferentValueTypeDeserializer() { [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer originalValueTypeDeser = mock(TypeDeserializer.class); [EOL] TypeDeserializer newValueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser, valueDeser, originalValueTypeDeser, ignorable); [EOL] MapDeserializer result = instance.withResolved(keyDeser, newValueTypeDeser, valueDeser, ignorable); [EOL] assertNotSame(instance, result); [EOL] assertSame(newValueTypeDeser, result.getValueTypeDeserializer()); [EOL] }
public void testWithResolvedDifferentIgnorable() { [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> originalIgnorable = new HashSet<>(); [EOL] HashSet<String> newIgnorable = new HashSet<>(); [EOL] newIgnorable.add("test"); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser, valueDeser, valueTypeDeser, originalIgnorable); [EOL] MapDeserializer result = instance.withResolved(keyDeser, valueTypeDeser, valueDeser, newIgnorable); [EOL] assertNotSame(instance, result); [EOL] assertSame(newIgnorable, result.getIgnorableProperties()); [EOL] }
public void testResolveWithDelegateTypeNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(valueInstantiator.getDelegateType(any())).thenReturn(null); [EOL] MapType mapType = mock(MapType.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeserializer, null, null); [EOL] try { [EOL] mapDeserializer.resolve(ctxt); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, got JsonMappingException"); [EOL] } [EOL] }
public void testResolveWithDelegateTypeNotNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(valueInstantiator.getDelegateType(any())).thenReturn(delegateType); [EOL] MapType mapType = mock(MapType.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeserializer, null, null); [EOL] try { [EOL] mapDeserializer.resolve(ctxt); [EOL] assertNotNull(mapDeserializer._delegateDeserializer); [EOL] } catch (JsonMappingException e) { [EOL] fail("Did not expect JsonMappingException"); [EOL] } [EOL] }
public void testResolveCanCreateFromObjectWith() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(valueInstantiator.getFromObjectArguments(any())).thenReturn(creatorProps); [EOL] MapType mapType = mock(MapType.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeserializer, null, null); [EOL] try { [EOL] mapDeserializer.resolve(ctxt); [EOL] assertNotNull(mapDeserializer._propertyBasedCreator); [EOL] } catch (JsonMappingException e) { [EOL] fail("Did not expect JsonMappingException"); [EOL] } [EOL] }
public void testResolveStandardStringKey() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] MapType mapType = mock(MapType.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeserializer, null, null); [EOL] try { [EOL] mapDeserializer.resolve(ctxt); [EOL] assertEquals(mapDeserializer._standardStringKey, mapDeserializer._isStdKeyDeser(mapType, keyDeserializer)); [EOL] } catch (JsonMappingException e) { [EOL] fail("Did not expect JsonMappingException"); [EOL] } [EOL] }
public void testCreateContextualWithNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] MapType mapType = mock(MapType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(contentType); [EOL] KeyDeserializer keyDeserializer = null; [EOL] JsonDeserializer<?> valueDeserializer = null; [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] CustomDeserializer deserializer = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer, ignorableProperties); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] verify(ctxt).findKeyDeserializer(keyType, property); [EOL] verify(ctxt).findContextualValueDeserializer(contentType, property); [EOL] }
public void testCreateContextualWithNonNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] MapType mapType = mock(MapType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(contentType); [EOL] KeyDeserializer keyDeserializer = mock(ContextualKeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(ContextualDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] HashSet<String> ignorableProperties = new HashSet<>(); [EOL] when(((ContextualKeyDeserializer) keyDeserializer).createContextual(ctxt, property)).thenReturn(keyDeserializer); [EOL] when(((ContextualDeserializer) valueDeserializer).createContextual(ctxt, property)).thenReturn(valueDeserializer); [EOL] when(valueTypeDeserializer.forProperty(property)).thenReturn(valueTypeDeserializer); [EOL] CustomDeserializer deserializer = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer, ignorableProperties); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] verify(keyDeserializer).createContextual(ctxt, property); [EOL] verify(valueDeserializer).createContextual(ctxt, property); [EOL] verify(valueTypeDeserializer).forProperty(property); [EOL] }
public void testCreateContextualWithIgnorableProperties() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] String[] moreToIgnore = new String[]{"propToIgnore"}; [EOL] when(intr.findPropertiesToIgnore(member)).thenReturn(moreToIgnore); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] MapType mapType = mock(MapType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(mapType.getContentType()).thenReturn(contentType); [EOL] KeyDeserializer keyDeserializer = null; [EOL] JsonDeserializer<?> valueDeserializer = null; [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] CustomDeserializer deserializer = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer, ignorableProperties); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertTrue(((CustomDeserializer) result).getIgnorableProperties().contains("propToIgnore")); [EOL] }
public void testDeserializeWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithoutDefaultCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] try { [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] fail("Expected an exception due to no default constructor"); [EOL] } catch (InstantiationException e) { [EOL] } [EOL] }
public void testDeserializeFromStringValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("some string"); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithStandardStringKey() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithNonStandardStringKey() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> resultMap = new HashMap<>(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.mappingException(any(Class.class))).thenReturn(new JsonMappingException("Error")); [EOL] MapDeserializer deserializer = new MapDeserializer(Map.class, null, null, null, null); [EOL] Map<Object, Object> result = deserializer.deserialize(jp, ctxt, resultMap); [EOL] assertNotNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt, never()).mappingException(any(Class.class)); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> resultMap = new HashMap<>(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(ctxt.mappingException(any(Class.class))).thenReturn(new JsonMappingException("Error")); [EOL] MapDeserializer deserializer = new MapDeserializer(Map.class, null, null, null, null); [EOL] Map<Object, Object> result = deserializer.deserialize(jp, ctxt, resultMap); [EOL] assertNotNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt, never()).mappingException(any(Class.class)); [EOL] }
public void testDeserializeWithInvalidToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> resultMap = new HashMap<>(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.mappingException(any(Class.class))).thenReturn(new JsonMappingException("Error")); [EOL] MapDeserializer deserializer = new MapDeserializer(Map.class, null, null, null, null); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt, resultMap); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Error", e.getMessage()); [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] verify(ctxt).mappingException(any(Class.class)); [EOL] }
public void testReadAndBindWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
public void testReadAndBindWithIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key1"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1", "key2"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1", "key2"); [EOL] when(valueDes.deserialize(any(JsonParser.class), any(DeserializationContext.class))).thenReturn("value2"); [EOL] _ignorableProperties = ignorableProperties; [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key2")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testReadAndBindWithValueTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] when(valueDes.deserializeWithType(any(JsonParser.class), any(DeserializationContext.class), any(TypeDeserializer.class))).thenReturn("value1"); [EOL] _valueTypeDeserializer = typeDeser; [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertEquals("value1", result.get("key1")); [EOL] }
public void testReadAndBindWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_NULL, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key1"); [EOL] when(keyDes.deserializeKey(anyString(), any(DeserializationContext.class))).thenReturn("key1"); [EOL] _readAndBind(jp, ctxt, result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.containsKey("key1")); [EOL] assertNull(result.get("key1")); [EOL] }
public void testReadAndBindStringMapWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("value"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadAndBindStringMapWithIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] this._ignorableProperties = ignorableProperties; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testReadAndBindStringMapWithValueNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertNull(result.get("key")); [EOL] }
public void testReadAndBindStringMapWithTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("typedValue"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("typedValue", result.get("key")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public Map<Object, Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null); [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.START_OBJECT) { [EOL] t = jp.nextToken(); [EOL] } [EOL] final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL] final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] t = jp.nextToken(); [EOL] if (_ignorableProperties != null && _ignorableProperties.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = creator.findCreatorProperty(propName); [EOL] if (prop != null) { [EOL] Object value = prop.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(prop.getCreatorIndex(), value)) { [EOL] jp.nextToken(); [EOL] Map<Object, Object> result; [EOL] try { [EOL] result = (Map<Object, Object>) creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _mapType.getRawClass()); [EOL] return null; [EOL] } [EOL] _readAndBind(jp, ctxt, result); [EOL] return result; [EOL] } [EOL] continue; [EOL] } [EOL] String fieldName = jp.getCurrentName(); [EOL] Object key = _keyDeserializer.deserializeKey(fieldName, ctxt); [EOL] Object value; [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] value = null; [EOL] } else if (typeDeser == null) { [EOL] value = valueDes.deserialize(jp, ctxt); [EOL] } else { [EOL] value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL] } [EOL] buffer.bufferMapProperty(key, value); [EOL] } [EOL] try { [EOL] return (Map<Object, Object>) creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _mapType.getRawClass()); [EOL] return null; [EOL] } [EOL] }
public JsonDeserializer<T> unwrappingDeserializerTest_withNullUnwrapper() { [EOL] JsonDeserializer<T> originalDeserializer = new JsonDeserializerSubType(); [EOL] JsonDeserializer<T> result = originalDeserializer.unwrappingDeserializer(null); [EOL] assertSame(originalDeserializer, result); [EOL] }
public JsonDeserializer<T> unwrappingDeserializerTest_withNonNullUnwrapper() { [EOL] JsonDeserializer<T> originalDeserializer = new JsonDeserializerSubType(); [EOL] NameTransformer unwrapper = new NameTransformerSubType(); [EOL] JsonDeserializer<T> result = originalDeserializer.unwrappingDeserializer(unwrapper); [EOL] assertSame(originalDeserializer, result); [EOL] }
public void testFormatWithMillis() { [EOL] Date date = new Date(); [EOL] String formattedDate = ClassName.format(date, true); [EOL] assertNotNull(formattedDate); [EOL] assertTrue(formattedDate.endsWith("Z")); [EOL] }
public void testFormatWithoutMillis() { [EOL] Date date = new Date(); [EOL] String formattedDate = ClassName.format(date, false); [EOL] assertNotNull(formattedDate); [EOL] assertFalse(formattedDate.contains(".")); [EOL] }
public void testFormatWithMillisAndZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] String formattedDate = YourClass.format(date, true, tz); [EOL] assertTrue(formattedDate.matches(".*\\.\\d{3}Z$")); [EOL] }
public void testFormatWithoutMillisAndZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] String formattedDate = YourClass.format(date, false, tz); [EOL] assertTrue(formattedDate.matches(".*[^\\.\\d{3}]Z$")); [EOL] }
public void testFormatWithMillisAndNonZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("GMT+2"); [EOL] String formattedDate = YourClass.format(date, true, tz); [EOL] assertTrue(formattedDate.matches(".*\\.\\d{3}\\+\\d{2}:\\d{2}$")); [EOL] }
public void testFormatWithoutMillisAndNonZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("GMT-2"); [EOL] String formattedDate = YourClass.format(date, false, tz); [EOL] assertTrue(formattedDate.matches(".*[^\\.\\d{3}]\\-\\d{2}:\\d{2}$")); [EOL] }
public void testFindWithTokenBufferClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(TokenBuffer.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TokenBufferDeserializer); [EOL] }
public void testFindWithJavaTypeClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(JavaType.class); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof JavaTypeDeserializer); [EOL] }
public void testFindWithUnrelatedClass() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(String.class); [EOL] assertNull(deserializer); [EOL] }
public void testJavaTypeDeserializerConstructor() { [EOL] JavaTypeDeserializer deserializer = new JavaTypeDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(" "); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructFromCanonical(anyString())).thenReturn(null); [EOL] JavaType result = deserialize(jp, ctxt); [EOL] verify(jp).getText(); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType expectedType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("java.lang.String"); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructFromCanonical("java.lang.String")).thenReturn(expectedType); [EOL] JavaType result = deserialize(jp, ctxt); [EOL] verify(jp).getText(); [EOL] verify(typeFactory).constructFromCanonical("java.lang.String"); [EOL] assertSame(expectedType, result); [EOL] }
public void testDeserializeWithEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType embeddedJavaType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedJavaType); [EOL] JavaType result = deserialize(jp, ctxt); [EOL] verify(jp).getEmbeddedObject(); [EOL] assertSame(embeddedJavaType, result); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void setDefaultKeySerializer_NullJsonSerializer_ThrowsIllegalArgumentException() { [EOL] JsonSerializer<Object> nullSerializer = null; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] try { [EOL] provider.setDefaultKeySerializer(nullSerializer); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null JsonSerializer", e.getMessage()); [EOL] } [EOL] }
public void setDefaultKeySerializer_ValidJsonSerializer_SetsKeySerializer() { [EOL] JsonSerializer<Object> validSerializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setDefaultKeySerializer(validSerializer); [EOL] assertEquals(validSerializer, provider.getKeySerializer()); [EOL] }
public void testSetNullValueSerializerWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] mapper.setNullValueSerializer(serializer); [EOL] assertSame(serializer, mapper.getSerializerProvider().getDefaultNullValueSerializer()); [EOL] }
public void testSetNullValueSerializerWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.setNullValueSerializer(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null JsonSerializer", e.getMessage()); [EOL] } [EOL] }
public void testGetTimeZone() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TimeZone timeZone = mapper.getTimeZone(); [EOL] assertNotNull(timeZone); [EOL] assertEquals(TimeZone.getDefault(), timeZone); [EOL] }
public void testFindTypedValueSerializerWithKnownSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = null; [EOL] boolean cache = false; [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithCachedSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = null; [EOL] boolean cache = false; [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithTypeWrappedSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = null; [EOL] boolean cache = false; [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] when(_serializerFactory.createTypeSerializer(_config, _config.constructType(valueType))).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] assertTrue(result instanceof TypeWrappedSerializer); [EOL] }
public void testFindTypedValueSerializerWithCaching() { [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = null; [EOL] boolean cache = true; [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(_serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] when(_serializerFactory.createTypeSerializer(_config, _config.constructType(valueType))).thenReturn(null); [EOL] JsonSerializer<Object> result = findTypedValueSerializer(valueType, cache, property); [EOL] verify(_serializerCache).addTypedSerializer(valueType, result); [EOL] }
public void testDefaultSerializeNullWithNonNullJsonGenerator() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] SerializerProvider serializerProvider = objectMapper.getSerializerProviderInstance(); [EOL] serializerProvider.defaultSerializeNull(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeNull(); [EOL] }
public void testDefaultSerializeNullWithNullJsonGenerator() { [EOL] SerializerProvider serializerProvider = new ObjectMapper().getSerializerProviderInstance(); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] serializerProvider.defaultSerializeNull(null); [EOL] }); [EOL] }
public void testReportIncompatibleRootTypeWithPrimitiveAndCompatibleWrapper() throws IOException { [EOL] Object value = Integer.valueOf(5); [EOL] JavaType rootType = TypeFactory.defaultInstance().constructType(int.class); [EOL] try { [EOL] _reportIncompatibleRootType(value, rootType); [EOL] } catch (JsonProcessingException e) { [EOL] fail("No exception should be thrown for compatible types"); [EOL] } [EOL] }
public void testReportIncompatibleRootTypeWithPrimitiveAndIncompatibleWrapper() { [EOL] Object value = Boolean.TRUE; [EOL] JavaType rootType = TypeFactory.defaultInstance().constructType(int.class); [EOL] try { [EOL] _reportIncompatibleRootType(value, rootType); [EOL] fail("Exception should be thrown for incompatible types"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Incompatible types: declared root type (int) vs java.lang.Boolean", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testReportIncompatibleRootTypeWithNonPrimitive() { [EOL] Object value = new Object(); [EOL] JavaType rootType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] try { [EOL] _reportIncompatibleRootType(value, rootType); [EOL] fail("Exception should be thrown for incompatible types"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Incompatible types: declared root type (java.lang.Object) vs java.lang.Object", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testCreateAndCacheUntypedSerializerWithValidType() throws JsonMappingException { [EOL] Class<?> type = String.class; // Use any class for testing [EOL] JsonSerializer<Object> serializer = _createAndCacheUntypedSerializer(type); [EOL] assertNotNull(serializer); [EOL] assertTrue(_serializerCache.containsSerializerFor(type)); [EOL] } [EOL] public void testCreateAndCacheUntypedSerializerWithInvalidType() { [EOL] Class<?> type = void.class; // Use a type that would cause IllegalArgumentException [EOL] try { [EOL] _createAndCacheUntypedSerializer(type); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertNotNull(e.getCause()); [EOL] assertTrue(e.getCause() instanceof IllegalArgumentException); [EOL] } [EOL] }
