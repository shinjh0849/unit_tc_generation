public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomNoEmpty() throws Exception { [EOL]     assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123))); [EOL]     assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0))); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testIssue92() throws Exception { [EOL]     assertEquals("{\"_id\":\"abc\"}", MAPPER.writeValueAsString(new Bean92())); [EOL] }
public void testIssue92() throws Exception { [EOL]     assertEquals("{\"_id\":\"abc\"}", MAPPER.writeValueAsString(new Bean92())); [EOL] }
public void testIssue92() throws Exception { [EOL]     assertEquals("{\"_id\":\"abc\"}", MAPPER.writeValueAsString(new Bean92())); [EOL] }
public void testIssue92() throws Exception { [EOL]     assertEquals("{\"_id\":\"abc\"}", MAPPER.writeValueAsString(new Bean92())); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testCloneObject() throws Exception { [EOL]     DateFormat clone = (DateFormat) df.clone(); [EOL]     assertSame(df, clone); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testFailureDueToDups() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDups() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDups() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDups() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDups() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testFailureDueToDupField() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean2()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDupField() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean2()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDupField() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean2()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testFailureDueToDupField() throws Exception { [EOL]     try { [EOL]         writeAndMap(MAPPER, new DupFieldBean2()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Multiple fields representing"); [EOL]     } [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testNullSerializer() throws Exception { [EOL]     String json = MAPPER.writeValueAsString(new NullBean()); [EOL]     assertEquals("{\"value\":null}", json); [EOL] }
public void testNullSerializer() throws Exception { [EOL]     String json = MAPPER.writeValueAsString(new NullBean()); [EOL]     assertEquals("{\"value\":null}", json); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
public void testExceptionHelpers() { [EOL]     RuntimeException e = new RuntimeException("test"); [EOL]     RuntimeException wrapper = new RuntimeException(e); [EOL]     assertSame(e, ClassUtil.getRootCause(wrapper)); [EOL]     try { [EOL]         ClassUtil.throwAsIAE(e); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL]     try { [EOL]         ClassUtil.unwrapAndThrowAsIAE(wrapper); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL] }
public void testExceptionHelpers() { [EOL]     RuntimeException e = new RuntimeException("test"); [EOL]     RuntimeException wrapper = new RuntimeException(e); [EOL]     assertSame(e, ClassUtil.getRootCause(wrapper)); [EOL]     try { [EOL]         ClassUtil.throwAsIAE(e); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL]     try { [EOL]         ClassUtil.unwrapAndThrowAsIAE(wrapper); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL] }
public void testExceptionHelpers() { [EOL]     RuntimeException e = new RuntimeException("test"); [EOL]     RuntimeException wrapper = new RuntimeException(e); [EOL]     assertSame(e, ClassUtil.getRootCause(wrapper)); [EOL]     try { [EOL]         ClassUtil.throwAsIAE(e); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL]     try { [EOL]         ClassUtil.unwrapAndThrowAsIAE(wrapper); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL] }
public void testExceptionHelpers() { [EOL]     RuntimeException e = new RuntimeException("test"); [EOL]     RuntimeException wrapper = new RuntimeException(e); [EOL]     assertSame(e, ClassUtil.getRootCause(wrapper)); [EOL]     try { [EOL]         ClassUtil.throwAsIAE(e); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL]     try { [EOL]         ClassUtil.unwrapAndThrowAsIAE(wrapper); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL] }
public void testExceptionHelpers() { [EOL]     RuntimeException e = new RuntimeException("test"); [EOL]     RuntimeException wrapper = new RuntimeException(e); [EOL]     assertSame(e, ClassUtil.getRootCause(wrapper)); [EOL]     try { [EOL]         ClassUtil.throwAsIAE(e); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL]     try { [EOL]         ClassUtil.unwrapAndThrowAsIAE(wrapper); [EOL]         fail("Shouldn't get this far"); [EOL]     } catch (RuntimeException e2) { [EOL]         assertSame(e, e2); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, "maybe"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals("maybe", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
public void testSubclassedEnums() throws Exception { [EOL]     assertEquals("\"B\"", mapper.writeValueAsString(EnumWithSubClass.B)); [EOL] }
public void testSubclassedEnums() throws Exception { [EOL]     assertEquals("\"B\"", mapper.writeValueAsString(EnumWithSubClass.B)); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, "maybe"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals("maybe", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, "maybe"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals("maybe", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testOverrideIntrospectors() { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     DeserializationConfig cfg = m.getDeserializationConfig(); [EOL]     cfg = cfg.with((ClassIntrospector) null); [EOL]     cfg = cfg.with((AnnotationIntrospector) null); [EOL]     assertNull(cfg.getAnnotationIntrospector()); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testProps() { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertNotNull(m.getNodeFactory()); [EOL]     JsonNodeFactory nf = JsonNodeFactory.instance; [EOL]     m.setNodeFactory(nf); [EOL]     assertSame(nf, m.getNodeFactory()); [EOL] }
public void testProps() { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertNotNull(m.getNodeFactory()); [EOL]     JsonNodeFactory nf = JsonNodeFactory.instance; [EOL]     m.setNodeFactory(nf); [EOL]     assertSame(nf, m.getNodeFactory()); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testDateUtilISO8601() throws Exception { [EOL]     String inputStr = "1972-12-28T00:00:00.000+0000"; [EOL]     Date inputDate = MAPPER.readValue("\"" + inputStr + "\"", java.util.Date.class); [EOL]     Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT")); [EOL]     c.setTime(inputDate); [EOL]     assertEquals(1972, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH)); [EOL]     assertEquals(28, c.get(Calendar.DAY_OF_MONTH)); [EOL]     inputStr = "1972-12-28T00:00:00.000Z"; [EOL]     inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class); [EOL]     c.setTime(inputDate); [EOL]     assertEquals(1972, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH)); [EOL]     assertEquals(28, c.get(Calendar.DAY_OF_MONTH)); [EOL]     inputStr = "1972-12-28T00:00:00.000+00:00"; [EOL]     inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class); [EOL]     c.setTime(inputDate); [EOL]     assertEquals(1972, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH)); [EOL]     assertEquals(28, c.get(Calendar.DAY_OF_MONTH)); [EOL]     inputStr = "1972-12-28T00:00:00.000+00"; [EOL]     inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class); [EOL]     c.setTime(inputDate); [EOL]     assertEquals(1972, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH)); [EOL]     assertEquals(28, c.get(Calendar.DAY_OF_MONTH)); [EOL]     inputStr = "1984-11-30T00:00:00.000Z"; [EOL]     inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class); [EOL]     c.setTime(inputDate); [EOL]     assertEquals(1984, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH)); [EOL]     assertEquals(30, c.get(Calendar.DAY_OF_MONTH)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testFactories() { [EOL]     assertNotNull(StdDateFormat.getBlueprintISO8601Format()); [EOL]     assertNotNull(StdDateFormat.getBlueprintRFC1123Format()); [EOL]     TimeZone tz = TimeZone.getTimeZone("GMT"); [EOL]     assertNotNull(StdDateFormat.getISO8601Format(tz)); [EOL]     assertNotNull(StdDateFormat.getRFC1123Format(tz)); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testNull() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, NullNode.instance); [EOL]     assertEquals("null", sw.toString()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testTypeIdResolver() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator("foobar")); [EOL]     String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123))); [EOL]     assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json); [EOL]     TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class); [EOL]     TypeIdBean bean = result.bean; [EOL]     assertEquals(123, bean.x); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testOverrideArrayContents() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayContentHolder result = m.readValue("{ \"data\" : [ 1, 2, 3 ] }", ArrayContentHolder.class); [EOL]     Object[] data = result._data; [EOL]     assertEquals(3, data.length); [EOL]     assertEquals(Long[].class, data.getClass()); [EOL]     assertEquals(1L, data[0]); [EOL]     assertEquals(2L, data[1]); [EOL]     assertEquals(3L, data[2]); [EOL] }
public void testOverrideArrayContents() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayContentHolder result = m.readValue("{ \"data\" : [ 1, 2, 3 ] }", ArrayContentHolder.class); [EOL]     Object[] data = result._data; [EOL]     assertEquals(3, data.length); [EOL]     assertEquals(Long[].class, data.getClass()); [EOL]     assertEquals(1L, data[0]); [EOL]     assertEquals(2L, data[1]); [EOL]     assertEquals(3L, data[2]); [EOL] }
public void testNoArgsException() throws IOException { [EOL]     MyNoArgException exc = MAPPER.readValue("{}", MyNoArgException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testNoArgsException() throws IOException { [EOL]     MyNoArgException exc = MAPPER.readValue("{}", MyNoArgException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testMiscScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     assertEquals("[\"abc\"]", m.writeValueAsString(new Object[] { "abc" })); [EOL]     assertEquals("[true,null,false]", m.writeValueAsString(new Boolean[] { true, null, false })); [EOL] }
public void testNoArgsException() throws IOException { [EOL]     MyNoArgException exc = MAPPER.readValue("{}", MyNoArgException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, "maybe"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals("maybe", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, "maybe"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals("maybe", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testMapDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(Map.class, TreeMap.class); [EOL]     mapper.registerModule(mod); [EOL]     Map<?, ?> result = mapper.readValue("{}", Map.class); [EOL]     assertEquals(TreeMap.class, result.getClass()); [EOL] }
public void testMapDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(Map.class, TreeMap.class); [EOL]     mapper.registerModule(mod); [EOL]     Map<?, ?> result = mapper.readValue("{}", Map.class); [EOL]     assertEquals(TreeMap.class, result.getClass()); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testWithJSONSampleDoc() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), false); [EOL]     verifyJsonSpecSampleDoc(tb.asParser(), true); [EOL]     tb.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testAppend() throws IOException { [EOL]     TokenBuffer buf1 = new TokenBuffer(null); [EOL]     buf1.writeStartObject(); [EOL]     buf1.writeFieldName("a"); [EOL]     buf1.writeBoolean(true); [EOL]     TokenBuffer buf2 = new TokenBuffer(null); [EOL]     buf2.writeFieldName("b"); [EOL]     buf2.writeNumber(13); [EOL]     buf2.writeEndObject(); [EOL]     buf1.append(buf2); [EOL]     JsonParser jp = buf1.asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("a", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("b", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(13, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL]     buf1.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals("{\"0\":1}", mapper.writeValueAsString(map)); [EOL] }
public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals("{\"0\":1}", mapper.writeValueAsString(map)); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testProps() { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertNotNull(m.getNodeFactory()); [EOL]     JsonNodeFactory nf = JsonNodeFactory.instance; [EOL]     m.setNodeFactory(nf); [EOL]     assertSame(nf, m.getNodeFactory()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testNoAccessOverrides() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL]     assertEquals("{\"x\":1}", m.writeValueAsString(new SimpleBean())); [EOL] }
public void testNoAccessOverrides() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL]     assertEquals("{\"x\":1}", m.writeValueAsString(new SimpleBean())); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testNodeConvert() throws Exception { [EOL]     ObjectNode src = (ObjectNode) MAPPER.readTree("{}"); [EOL]     TreeNode node = src; [EOL]     ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class); [EOL]     assertSame(src, result); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testFormatForGenerators() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema()); [EOL]     MySchema s = new MySchema(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     try { [EOL]         mapper.writer(s).writeValue(sw, "Foobar"); [EOL]         fail("Excpected exception"); [EOL]     } catch (SchemaException e) { [EOL]         assertSame(s, e._schema); [EOL]     } [EOL] }
public void testFormatForGenerators() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema()); [EOL]     MySchema s = new MySchema(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     try { [EOL]         mapper.writer(s).writeValue(sw, "Foobar"); [EOL]         fail("Excpected exception"); [EOL]     } catch (SchemaException e) { [EOL]         assertSame(s, e._schema); [EOL]     } [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testFile() throws Exception { [EOL]     File src = new File("/test").getAbsoluteFile(); [EOL]     String abs = src.getAbsolutePath(); [EOL]     String json = mapper.writeValueAsString(abs); [EOL]     File result = mapper.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE); [EOL]     result = mapper2.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL] }
public void testFile() throws Exception { [EOL]     File src = new File("/test").getAbsoluteFile(); [EOL]     String abs = src.getAbsolutePath(); [EOL]     String json = mapper.writeValueAsString(abs); [EOL]     File result = mapper.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE); [EOL]     result = mapper2.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testURI() throws Exception { [EOL]     URI value = new URI("http://foo.com"); [EOL]     assertEquals(value, MAPPER.readValue("\"" + value.toString() + "\"", URI.class)); [EOL] }
public void testCurrency() throws IOException { [EOL]     Currency usd = Currency.getInstance("USD"); [EOL]     assertEquals(usd, new ObjectMapper().readValue(quote("USD"), Currency.class)); [EOL] }
public void testCurrency() throws IOException { [EOL]     Currency usd = Currency.getInstance("USD"); [EOL]     assertEquals(usd, new ObjectMapper().readValue(quote("USD"), Currency.class)); [EOL] }
public void testCurrency() throws IOException { [EOL]     Currency usd = Currency.getInstance("USD"); [EOL]     assertEquals(usd, new ObjectMapper().readValue(quote("USD"), Currency.class)); [EOL] }
public void testRegexps() throws IOException { [EOL]     final String PATTERN_STR = "abc:\\s?(\\d+)"; [EOL]     Pattern exp = Pattern.compile(PATTERN_STR); [EOL]     String json = mapper.writeValueAsString(exp); [EOL]     Pattern result = mapper.readValue(json, Pattern.class); [EOL]     assertEquals(exp.pattern(), result.pattern()); [EOL] }
public void testRegexps() throws IOException { [EOL]     final String PATTERN_STR = "abc:\\s?(\\d+)"; [EOL]     Pattern exp = Pattern.compile(PATTERN_STR); [EOL]     String json = mapper.writeValueAsString(exp); [EOL]     Pattern result = mapper.readValue(json, Pattern.class); [EOL]     assertEquals(exp.pattern(), result.pattern()); [EOL] }
public void testRegexps() throws IOException { [EOL]     final String PATTERN_STR = "abc:\\s?(\\d+)"; [EOL]     Pattern exp = Pattern.compile(PATTERN_STR); [EOL]     String json = mapper.writeValueAsString(exp); [EOL]     Pattern result = mapper.readValue(json, Pattern.class); [EOL]     assertEquals(exp.pattern(), result.pattern()); [EOL] }
public void testFile() throws Exception { [EOL]     File src = new File("/test").getAbsoluteFile(); [EOL]     String abs = src.getAbsolutePath(); [EOL]     String json = mapper.writeValueAsString(abs); [EOL]     File result = mapper.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE); [EOL]     result = mapper2.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL] }
public void testFile() throws Exception { [EOL]     File src = new File("/test").getAbsoluteFile(); [EOL]     String abs = src.getAbsolutePath(); [EOL]     String json = mapper.writeValueAsString(abs); [EOL]     File result = mapper.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE); [EOL]     result = mapper2.readValue(json, File.class); [EOL]     assertEquals(abs, result.getAbsolutePath()); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testSharedTypeInfoWithCtor() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new TypeWrapper(13L)); [EOL]     TypeWrapper result = mapper.readValue(json, TypeWrapper.class); [EOL]     assertEquals(Long.class, result.value.getClass()); [EOL] }
public void testSharedTypeInfoWithCtor() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new TypeWrapper(13L)); [EOL]     TypeWrapper result = mapper.readValue(json, TypeWrapper.class); [EOL]     assertEquals(Long.class, result.value.getClass()); [EOL] }
public void testSharedTypeInfoWithCtor() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new TypeWrapper(13L)); [EOL]     TypeWrapper result = mapper.readValue(json, TypeWrapper.class); [EOL]     assertEquals(Long.class, result.value.getClass()); [EOL] }
public void testSharedTypeInfoWithCtor() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new TypeWrapper(13L)); [EOL]     TypeWrapper result = mapper.readValue(json, TypeWrapper.class); [EOL]     assertEquals(Long.class, result.value.getClass()); [EOL] }
public void testSharedTypeInfoWithCtor() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new TypeWrapper(13L)); [EOL]     TypeWrapper result = mapper.readValue(json, TypeWrapper.class); [EOL]     assertEquals(Long.class, result.value.getClass()); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testJackson431() throws Exception { [EOL]     final Test431Container foo = MAPPER.readValue("{\"items\":\n" + "[{\"bar\": 0,\n" + "\"id\": \"id123\",\n" + "\"foo\": 1\n" + "}]}", Test431Container.class); [EOL]     assertNotNull(foo); [EOL] }
public void testJackson431() throws Exception { [EOL]     final Test431Container foo = MAPPER.readValue("{\"items\":\n" + "[{\"bar\": 0,\n" + "\"id\": \"id123\",\n" + "\"foo\": 1\n" + "}]}", Test431Container.class); [EOL]     assertNotNull(foo); [EOL] }
public void testJackson431() throws Exception { [EOL]     final Test431Container foo = MAPPER.readValue("{\"items\":\n" + "[{\"bar\": 0,\n" + "\"id\": \"id123\",\n" + "\"foo\": 1\n" + "}]}", Test431Container.class); [EOL]     assertNotNull(foo); [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testExceptionFromConstructor() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{}", BustedCtor.class); [EOL]         fail("Expected exception"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, ": foobar"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         assertEquals("foobar", t.getMessage()); [EOL]     } [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testMethodDeserializer() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MethodBean result = m.readValue(" { \"ints\" : 3 } ", MethodBean.class); [EOL]     assertNotNull(result); [EOL]     int[] ints = result._ints; [EOL]     assertNotNull(ints); [EOL]     assertEquals(1, ints.length); [EOL]     assertEquals(3, ints[0]); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testByteArraysWith763() throws Exception { [EOL]     String[] input = new String[] { "YQ==", "Yg==", "Yw==" }; [EOL]     byte[][] data = MAPPER.convertValue(input, byte[][].class); [EOL]     assertEquals("a", new String(data[0], "US-ASCII")); [EOL]     assertEquals("b", new String(data[1], "US-ASCII")); [EOL]     assertEquals("c", new String(data[2], "US-ASCII")); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testSerializeAsInClass() throws IOException { [EOL]     assertEquals("{\"foo\":42}", WRITER.writeValueAsString(new FooImpl())); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testMixIns() throws Exception { [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.setMixInAnnotation(MixableBean.class, MixInForOrder.class); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> props = this.writeAndMap(mapper, new MixableBean()); [EOL]     assertEquals(3, props.size()); [EOL]     assertEquals(Integer.valueOf(3), props.get("c")); [EOL]     assertEquals(Integer.valueOf(1), props.get("a")); [EOL]     assertEquals(Integer.valueOf(2), props.get("b")); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testFieldIntrospection() { [EOL]     AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null); [EOL]     assertEquals(2, ac.getFieldCount()); [EOL]     for (AnnotatedField f : ac.fields()) { [EOL]         String fname = f.getName(); [EOL]         if (!"bar".equals(fname) && !"props".equals(fname)) { [EOL]             fail("Unexpected field name '" + fname + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDefaultImpl() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SuperTypeWithDefault bean = mapper.readValue("{\"a\":13}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(13, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"a\":14,\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(14, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\",\"a\":15}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(15, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(0, ((DefaultImpl) bean).a); [EOL] }
public void testDefaultImpl() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SuperTypeWithDefault bean = mapper.readValue("{\"a\":13}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(13, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"a\":14,\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(14, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\",\"a\":15}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(15, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(0, ((DefaultImpl) bean).a); [EOL] }
public void testDefaultImpl() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SuperTypeWithDefault bean = mapper.readValue("{\"a\":13}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(13, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"a\":14,\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(14, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\",\"a\":15}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(15, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(0, ((DefaultImpl) bean).a); [EOL] }
public void testDefaultImpl() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SuperTypeWithDefault bean = mapper.readValue("{\"a\":13}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(13, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"a\":14,\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(14, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\",\"a\":15}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(15, ((DefaultImpl) bean).a); [EOL]     bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithDefault.class); [EOL]     assertEquals(DefaultImpl.class, bean.getClass()); [EOL]     assertEquals(0, ((DefaultImpl) bean).a); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah); [EOL] }
public void testModifyEnumDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setDeserializerModifier(new EnumDeserializerModifier())); [EOL]     Object result = mapper.readValue(quote("B"), EnumABC.class); [EOL]     assertEquals("foo", result); [EOL] }
public void testModifyEnumDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setDeserializerModifier(new EnumDeserializerModifier())); [EOL]     Object result = mapper.readValue(quote("B"), EnumABC.class); [EOL]     assertEquals("foo", result); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testSimpleEnumBean() throws Exception { [EOL]     TimeUnitBean bean = new TimeUnitBean(); [EOL]     bean.timeUnit = TimeUnit.SECONDS; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json = m.writeValueAsString(bean); [EOL]     TimeUnitBean result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL]     m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     json = m.writeValueAsString(bean); [EOL]     result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL] }
public void testSimpleEnumBean() throws Exception { [EOL]     TimeUnitBean bean = new TimeUnitBean(); [EOL]     bean.timeUnit = TimeUnit.SECONDS; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json = m.writeValueAsString(bean); [EOL]     TimeUnitBean result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL]     m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     json = m.writeValueAsString(bean); [EOL]     result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL] }
public void testSimpleEnumBean() throws Exception { [EOL]     TimeUnitBean bean = new TimeUnitBean(); [EOL]     bean.timeUnit = TimeUnit.SECONDS; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json = m.writeValueAsString(bean); [EOL]     TimeUnitBean result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL]     m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     json = m.writeValueAsString(bean); [EOL]     result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL] }
public void testSimpleEnumBean() throws Exception { [EOL]     TimeUnitBean bean = new TimeUnitBean(); [EOL]     bean.timeUnit = TimeUnit.SECONDS; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json = m.writeValueAsString(bean); [EOL]     TimeUnitBean result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL]     m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     json = m.writeValueAsString(bean); [EOL]     result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL] }
public void testSimpleEnumBean() throws Exception { [EOL]     TimeUnitBean bean = new TimeUnitBean(); [EOL]     bean.timeUnit = TimeUnit.SECONDS; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json = m.writeValueAsString(bean); [EOL]     TimeUnitBean result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL]     m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     json = m.writeValueAsString(bean); [EOL]     result = m.readValue(json, TimeUnitBean.class); [EOL]     assertEquals(TimeUnit.SECONDS, result.timeUnit); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testWithTimeZoneOverride() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z")); [EOL]     mapper.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     String json = mapper.writeValueAsString(new Date(0)); [EOL]     assertEquals(quote("1969-12-31/16:00 PST"), json); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testNonRootArraysUsingParser() throws Exception { [EOL]     final String JSON = "[[1],[3]]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.readValues(jp, int[].class); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL]     jp.close(); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testFloatPrimitiveNonNumeric() throws Exception { [EOL]     float value = Float.POSITIVE_INFINITY; [EOL]     FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), FloatBean.class); [EOL]     assertEquals(value, result._v); [EOL]     float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Float.POSITIVE_INFINITY, array[0]); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testPropertyIgnoralWithClass() throws Exception { [EOL]     XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class); [EOL]     assertEquals(1, result.value.x); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testModifyKeySerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new KeySerializerModifier())); [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("x", 3); [EOL]     assertEquals("{\"foo\":3}", mapper.writeValueAsString(map)); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testDataBindingUsage() throws Exception { [EOL]     ObjectMapper objectMapper = createObjectMapper(null); [EOL]     String result = serializeWithObjectMapper(new ComplexTestData(), Views.View.class, objectMapper); [EOL]     assertEquals(-1, result.indexOf("nameHidden")); [EOL] }
public void testDataBindingUsage() throws Exception { [EOL]     ObjectMapper objectMapper = createObjectMapper(null); [EOL]     String result = serializeWithObjectMapper(new ComplexTestData(), Views.View.class, objectMapper); [EOL]     assertEquals(-1, result.indexOf("nameHidden")); [EOL] }
public void testDataBindingUsage() throws Exception { [EOL]     ObjectMapper objectMapper = createObjectMapper(null); [EOL]     String result = serializeWithObjectMapper(new ComplexTestData(), Views.View.class, objectMapper); [EOL]     assertEquals(-1, result.indexOf("nameHidden")); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("x"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testSimpleGetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean())); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testPerClassAnnotation() throws Exception { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new LcStrategy()); [EOL]     BeanWithPrefixNames input = new BeanWithPrefixNames(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     assertEquals("{\"Get-a\":3}", json); [EOL]     BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}", BeanWithPrefixNames.class); [EOL]     assertEquals(7, output.a); [EOL] }
public void testToStringEnums() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true); [EOL]     LowerCaseEnum value = m.readValue("\"c\"", LowerCaseEnum.class); [EOL]     assertEquals(LowerCaseEnum.C, value); [EOL] }
public void testToStringEnums() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true); [EOL]     LowerCaseEnum value = m.readValue("\"c\"", LowerCaseEnum.class); [EOL]     assertEquals(LowerCaseEnum.C, value); [EOL] }
public void testToStringEnums() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true); [EOL]     LowerCaseEnum value = m.readValue("\"c\"", LowerCaseEnum.class); [EOL]     assertEquals(LowerCaseEnum.C, value); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testAllowUnknownEnumValuesReadAsNull() throws Exception { [EOL]     ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL); [EOL]     assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\"")); [EOL]     assertNull(reader.withType(TestEnum.class).readValue(" 4343 ")); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testFormatForGenerators() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema()); [EOL]     MySchema s = new MySchema(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     try { [EOL]         mapper.writer(s).writeValue(sw, "Foobar"); [EOL]         fail("Excpected exception"); [EOL]     } catch (SchemaException e) { [EOL]         assertSame(s, e._schema); [EOL]     } [EOL] }
public void testFormatForGenerators() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema()); [EOL]     MySchema s = new MySchema(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     try { [EOL]         mapper.writer(s).writeValue(sw, "Foobar"); [EOL]         fail("Excpected exception"); [EOL]     } catch (SchemaException e) { [EOL]         assertSame(s, e._schema); [EOL]     } [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testIndentation() throws Exception { [EOL]     Map<String, Integer> map = new HashMap<String, Integer>(); [EOL]     map.put("a", Integer.valueOf(2)); [EOL]     String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(map); [EOL]     String lf = getLF(); [EOL]     assertEquals("{" + lf + "  \"a\" : 2" + lf + "}", result); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String TEST = "test exception"; [EOL]     Map<String, Object> result = writeAndMap(mapper, new Exception(TEST)); [EOL]     Object ob = result.get("suppressed"); [EOL]     if (ob != null) { [EOL]         assertEquals(5, result.size()); [EOL]     } else { [EOL]         assertEquals(4, result.size()); [EOL]     } [EOL]     assertEquals(TEST, result.get("message")); [EOL]     assertNull(result.get("cause")); [EOL]     assertEquals(TEST, result.get("localizedMessage")); [EOL]     Object traces = result.get("stackTrace"); [EOL]     if (!(traces instanceof List<?>)) { [EOL]         fail("Expected a List for exception member 'stackTrace', got: " + traces); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put("number", 15); [EOL]     n.put("string", "abc"); [EOL]     ObjectNode n2 = n.putObject("ob"); [EOL]     n2.putArray("arr"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("abc", result.get("string")); [EOL]     assertEquals(Integer.valueOf(15), result.get("number")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get("ob"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get("arr"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testSchemaSerialization() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, jsonSchema); [EOL]     assertNotNull(result); [EOL]     assertEquals("object", result.get("type")); [EOL]     assertNull(result.get("required")); [EOL]     assertNotNull(result.get("properties")); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testAsInt() throws Exception { [EOL]     assertEquals(9, IntNode.valueOf(9).asInt()); [EOL]     assertEquals(7, LongNode.valueOf(7L).asInt()); [EOL]     assertEquals(13, new TextNode("13").asInt()); [EOL]     assertEquals(0, new TextNode("foobar").asInt()); [EOL]     assertEquals(27, new TextNode("foobar").asInt(27)); [EOL]     assertEquals(1, BooleanNode.TRUE.asInt()); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testLong() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long value = 12345678L << 32; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isLong()); [EOL]     assertType(result, LongNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().longValue()); [EOL]     assertEquals(value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals(result, LongNode.valueOf(value)); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testEmbeddedObjectInObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeStartObject(); [EOL]     buf.writeFieldName("pojo"); [EOL]     buf.writeObject(MARKER); [EOL]     buf.writeEndObject(); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, node.size()); [EOL]     JsonNode n = node.get("pojo"); [EOL]     assertTrue(n.isPojo()); [EOL]     assertSame(MARKER, ((POJONode) n).getPojo()); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testDeferredConstructorAndProps() throws Exception { [EOL]     DeferredConstructorAndPropsBean bean = MAPPER.readValue("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }", DeferredConstructorAndPropsBean.class); [EOL]     assertEquals("...", bean.propB); [EOL]     assertNull(bean.propA); [EOL]     assertNotNull(bean.createA); [EOL]     assertEquals(1, bean.createA.length); [EOL]     assertEquals(1, bean.createA[0]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testSimpleAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }", SimpleFieldBean2.class); [EOL]     String[] values = bean.values; [EOL]     assertNotNull(values); [EOL]     assertEquals(2, values.length); [EOL]     assertEquals("x", values[0]); [EOL]     assertEquals("y", values[1]); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testCreatorEnums() throws Exception { [EOL]     EnumWithCreator value = MAPPER.readValue("\"enumA\"", EnumWithCreator.class); [EOL]     assertEquals(EnumWithCreator.A, value); [EOL] }
public void testCreatorEnums() throws Exception { [EOL]     EnumWithCreator value = MAPPER.readValue("\"enumA\"", EnumWithCreator.class); [EOL]     assertEquals(EnumWithCreator.A, value); [EOL] }
public void testCreatorEnums() throws Exception { [EOL]     EnumWithCreator value = MAPPER.readValue("\"enumA\"", EnumWithCreator.class); [EOL]     assertEquals(EnumWithCreator.A, value); [EOL] }
public void testCreatorEnums() throws Exception { [EOL]     EnumWithCreator value = MAPPER.readValue("\"enumA\"", EnumWithCreator.class); [EOL]     assertEquals(EnumWithCreator.A, value); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testIterableWithStrings() throws Exception { [EOL]     String JSON = "{ \"values\":[\"a\",\"b\"]}"; [EOL]     ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class); [EOL]     assertNotNull(w); [EOL]     assertNotNull(w.values); [EOL]     Iterator<String> it = w.values.iterator(); [EOL]     assertTrue(it.hasNext()); [EOL]     assertEquals("a", it.next()); [EOL]     assertEquals("b", it.next()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testIterableWithStrings() throws Exception { [EOL]     String JSON = "{ \"values\":[\"a\",\"b\"]}"; [EOL]     ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class); [EOL]     assertNotNull(w); [EOL]     assertNotNull(w.values); [EOL]     Iterator<String> it = w.values.iterator(); [EOL]     assertTrue(it.hasNext()); [EOL]     assertEquals("a", it.next()); [EOL]     assertEquals("b", it.next()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testIterableWithStrings() throws Exception { [EOL]     String JSON = "{ \"values\":[\"a\",\"b\"]}"; [EOL]     ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class); [EOL]     assertNotNull(w); [EOL]     assertNotNull(w.values); [EOL]     Iterator<String> it = w.values.iterator(); [EOL]     assertTrue(it.hasNext()); [EOL]     assertEquals("a", it.next()); [EOL]     assertEquals("b", it.next()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testIterableWithStrings() throws Exception { [EOL]     String JSON = "{ \"values\":[\"a\",\"b\"]}"; [EOL]     ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class); [EOL]     assertNotNull(w); [EOL]     assertNotNull(w.values); [EOL]     Iterator<String> it = w.values.iterator(); [EOL]     assertTrue(it.hasNext()); [EOL]     assertEquals("a", it.next()); [EOL]     assertEquals("b", it.next()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testIterableWithStrings() throws Exception { [EOL]     String JSON = "{ \"values\":[\"a\",\"b\"]}"; [EOL]     ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class); [EOL]     assertNotNull(w); [EOL]     assertNotNull(w.values); [EOL]     Iterator<String> it = w.values.iterator(); [EOL]     assertTrue(it.hasNext()); [EOL]     assertEquals("a", it.next()); [EOL]     assertEquals("b", it.next()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testMethodDeserializer() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MethodBean result = m.readValue(" { \"ints\" : 3 } ", MethodBean.class); [EOL]     assertNotNull(result); [EOL]     int[] ints = result._ints; [EOL]     assertNotNull(ints); [EOL]     assertEquals(1, ints.length); [EOL]     assertEquals(3, ints[0]); [EOL] }
public void testMethodDeserializer() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MethodBean result = m.readValue(" { \"ints\" : 3 } ", MethodBean.class); [EOL]     assertNotNull(result); [EOL]     int[] ints = result._ints; [EOL]     assertNotNull(ints); [EOL]     assertEquals(1, ints.length); [EOL]     assertEquals(3, ints[0]); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = "test"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue("{\"num\": 10, \"str\":\"foobar\"}"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals("foobar", bean.str); [EOL] }
public void testEnumMap() throws IOException { [EOL]     EnumMap<Key, String> map = new EnumMap<Key, String>(Key.class); [EOL]     map.put(Key.B, "xyz"); [EOL]     map.put(Key.C, "abc"); [EOL]     String json = MAPPER.writeValueAsString(map); [EOL]     assertEquals("{\"B\":\"xyz\",\"C\":\"abc\"}", json.trim()); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testMultipleFieldMixIns() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     HashMap<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     mixins.put(SubClass.class, MixIn.class); [EOL]     mixins.put(BaseClass.class, MixIn2.class); [EOL]     mapper.setMixInAnnotations(mixins); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new SubClass("1", "2")); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals("2", result.get("banana")); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testReadSimplePropertyValue() throws Exception { [EOL]     String json = "{\"value\":[true,\"Foobar\",42,13]}"; [EOL]     Pojo p = MAPPER.readValue(json, Pojo.class); [EOL]     assertNotNull(p.value); [EOL]     assertTrue(p.value.complete); [EOL]     assertEquals("Foobar", p.value.name); [EOL]     assertEquals(42, p.value.x); [EOL]     assertEquals(13, p.value.y); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testDoubleArray() throws Exception { [EOL]     final int LEN = 7000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(i).append('.').append(i % 10); [EOL]     } [EOL]     sb.append(']'); [EOL]     double[] result = MAPPER.readValue(sb.toString(), double[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         String expStr = String.valueOf(i) + "." + String.valueOf(i % 10); [EOL]         String actStr = String.valueOf(result[i]); [EOL]         if (!expStr.equals(actStr)) { [EOL]             fail("Entry #" + i + "/" + LEN + "; exp '" + expStr + "', got '" + actStr + "'"); [EOL]         } [EOL]     } [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testJackson628() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     ArrayList<Foo> data = new ArrayList<Foo>(); [EOL]     String json = mapper.writeValueAsString(data); [EOL]     List<?> output = mapper.readValue(json, List.class); [EOL]     assertTrue(output.isEmpty()); [EOL] }
public void testJackson628() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     ArrayList<Foo> data = new ArrayList<Foo>(); [EOL]     String json = mapper.writeValueAsString(data); [EOL]     List<?> output = mapper.readValue(json, List.class); [EOL]     assertTrue(output.isEmpty()); [EOL] }
public void testJackson628() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     ArrayList<Foo> data = new ArrayList<Foo>(); [EOL]     String json = mapper.writeValueAsString(data); [EOL]     List<?> output = mapper.readValue(json, List.class); [EOL]     assertTrue(output.isEmpty()); [EOL] }
public void testJackson628() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     ArrayList<Foo> data = new ArrayList<Foo>(); [EOL]     String json = mapper.writeValueAsString(data); [EOL]     List<?> output = mapper.readValue(json, List.class); [EOL]     assertTrue(output.isEmpty()); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue("123", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testVisibleWithWrapperArray() throws Exception { [EOL]     String json = mapper.writeValueAsString(new WrapperArrayBean()); [EOL]     assertEquals("[\"ArrayType\",{\"a\":1}]", json); [EOL]     WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class); [EOL]     assertEquals("ArrayType", result.type); [EOL]     assertEquals(1, result.a); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testInArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     SubType[] ob = new SubType[] { new SubType() }; [EOL]     String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob); [EOL]     assertEquals("[{\"b\":3}]", json); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = "[false,\"Bubba\",1,2]"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals("Bubba", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testListBean() throws Exception { [EOL]     final int COUNT = 13; [EOL]     ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>(); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         beans.add(new CtorValueBean(i)); [EOL]     } [EOL]     BeanWithList bean = new BeanWithList(beans); [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, bean); [EOL]     BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testIssue506WithDate() throws Exception { [EOL]     Issue506DateBean input = new Issue506DateBean(); [EOL]     input.date = new Date(1234L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506DateBean output = mapper.readValue(json, Issue506DateBean.class); [EOL]     assertEquals(input.date, output.date); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testSerializeAsInClass() throws IOException { [EOL]     assertEquals("{\"foo\":42}", WRITER.writeValueAsString(new FooImpl())); [EOL] }
public void testSerializeAsInClass() throws IOException { [EOL]     assertEquals("{\"foo\":42}", WRITER.writeValueAsString(new FooImpl())); [EOL] }
public void testSerializeAsInClass() throws IOException { [EOL]     assertEquals("{\"foo\":42}", WRITER.writeValueAsString(new FooImpl())); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testIssue11() throws Exception { [EOL]     ObjectNode root = MAPPER.createObjectNode(); [EOL]     JsonNode n = root; [EOL]     ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class); [EOL]     assertSame(root, ob2); [EOL]     JsonNode n2 = MAPPER.convertValue(n, JsonNode.class); [EOL]     assertSame(root, n2); [EOL]     String STR = "test"; [EOL]     CharSequence seq = MAPPER.convertValue(STR, CharSequence.class); [EOL]     assertSame(STR, seq); [EOL]     Leaf l = new Leaf(13); [EOL]     Map<?, ?> m = MAPPER.convertValue(l, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(1, m.size()); [EOL]     assertEquals(Integer.valueOf(13), m.get("value")); [EOL]     Leaf l2 = MAPPER.convertValue(m, Leaf.class); [EOL]     assertEquals(13, l2.value); [EOL]     Object ob = MAPPER.convertValue(l, Object.class); [EOL]     assertNotNull(ob); [EOL]     assertEquals(LinkedHashMap.class, ob.getClass()); [EOL]     final Object plaino = new Object(); [EOL]     try { [EOL]         m = MAPPER.convertValue(plaino, Map.class); [EOL]         fail("Conversion should have failed"); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "no properties discovered"); [EOL]     } [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); [EOL]     try { [EOL]         assertEquals("{}", mapper.writeValueAsString(plaino)); [EOL]     } catch (Exception e) { [EOL]         throw (Exception) e.getCause(); [EOL]     } [EOL]     m = mapper.convertValue(plaino, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(0, m.size()); [EOL] }
public void testIssue11() throws Exception { [EOL]     ObjectNode root = MAPPER.createObjectNode(); [EOL]     JsonNode n = root; [EOL]     ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class); [EOL]     assertSame(root, ob2); [EOL]     JsonNode n2 = MAPPER.convertValue(n, JsonNode.class); [EOL]     assertSame(root, n2); [EOL]     String STR = "test"; [EOL]     CharSequence seq = MAPPER.convertValue(STR, CharSequence.class); [EOL]     assertSame(STR, seq); [EOL]     Leaf l = new Leaf(13); [EOL]     Map<?, ?> m = MAPPER.convertValue(l, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(1, m.size()); [EOL]     assertEquals(Integer.valueOf(13), m.get("value")); [EOL]     Leaf l2 = MAPPER.convertValue(m, Leaf.class); [EOL]     assertEquals(13, l2.value); [EOL]     Object ob = MAPPER.convertValue(l, Object.class); [EOL]     assertNotNull(ob); [EOL]     assertEquals(LinkedHashMap.class, ob.getClass()); [EOL]     final Object plaino = new Object(); [EOL]     try { [EOL]         m = MAPPER.convertValue(plaino, Map.class); [EOL]         fail("Conversion should have failed"); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "no properties discovered"); [EOL]     } [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); [EOL]     try { [EOL]         assertEquals("{}", mapper.writeValueAsString(plaino)); [EOL]     } catch (Exception e) { [EOL]         throw (Exception) e.getCause(); [EOL]     } [EOL]     m = mapper.convertValue(plaino, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(0, m.size()); [EOL] }
public void testIssue11() throws Exception { [EOL]     ObjectNode root = MAPPER.createObjectNode(); [EOL]     JsonNode n = root; [EOL]     ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class); [EOL]     assertSame(root, ob2); [EOL]     JsonNode n2 = MAPPER.convertValue(n, JsonNode.class); [EOL]     assertSame(root, n2); [EOL]     String STR = "test"; [EOL]     CharSequence seq = MAPPER.convertValue(STR, CharSequence.class); [EOL]     assertSame(STR, seq); [EOL]     Leaf l = new Leaf(13); [EOL]     Map<?, ?> m = MAPPER.convertValue(l, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(1, m.size()); [EOL]     assertEquals(Integer.valueOf(13), m.get("value")); [EOL]     Leaf l2 = MAPPER.convertValue(m, Leaf.class); [EOL]     assertEquals(13, l2.value); [EOL]     Object ob = MAPPER.convertValue(l, Object.class); [EOL]     assertNotNull(ob); [EOL]     assertEquals(LinkedHashMap.class, ob.getClass()); [EOL]     final Object plaino = new Object(); [EOL]     try { [EOL]         m = MAPPER.convertValue(plaino, Map.class); [EOL]         fail("Conversion should have failed"); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "no properties discovered"); [EOL]     } [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); [EOL]     try { [EOL]         assertEquals("{}", mapper.writeValueAsString(plaino)); [EOL]     } catch (Exception e) { [EOL]         throw (Exception) e.getCause(); [EOL]     } [EOL]     m = mapper.convertValue(plaino, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(0, m.size()); [EOL] }
public void testIssue11() throws Exception { [EOL]     ObjectNode root = MAPPER.createObjectNode(); [EOL]     JsonNode n = root; [EOL]     ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class); [EOL]     assertSame(root, ob2); [EOL]     JsonNode n2 = MAPPER.convertValue(n, JsonNode.class); [EOL]     assertSame(root, n2); [EOL]     String STR = "test"; [EOL]     CharSequence seq = MAPPER.convertValue(STR, CharSequence.class); [EOL]     assertSame(STR, seq); [EOL]     Leaf l = new Leaf(13); [EOL]     Map<?, ?> m = MAPPER.convertValue(l, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(1, m.size()); [EOL]     assertEquals(Integer.valueOf(13), m.get("value")); [EOL]     Leaf l2 = MAPPER.convertValue(m, Leaf.class); [EOL]     assertEquals(13, l2.value); [EOL]     Object ob = MAPPER.convertValue(l, Object.class); [EOL]     assertNotNull(ob); [EOL]     assertEquals(LinkedHashMap.class, ob.getClass()); [EOL]     final Object plaino = new Object(); [EOL]     try { [EOL]         m = MAPPER.convertValue(plaino, Map.class); [EOL]         fail("Conversion should have failed"); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "no properties discovered"); [EOL]     } [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); [EOL]     try { [EOL]         assertEquals("{}", mapper.writeValueAsString(plaino)); [EOL]     } catch (Exception e) { [EOL]         throw (Exception) e.getCause(); [EOL]     } [EOL]     m = mapper.convertValue(plaino, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(0, m.size()); [EOL] }
public void testIssue11() throws Exception { [EOL]     ObjectNode root = MAPPER.createObjectNode(); [EOL]     JsonNode n = root; [EOL]     ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class); [EOL]     assertSame(root, ob2); [EOL]     JsonNode n2 = MAPPER.convertValue(n, JsonNode.class); [EOL]     assertSame(root, n2); [EOL]     String STR = "test"; [EOL]     CharSequence seq = MAPPER.convertValue(STR, CharSequence.class); [EOL]     assertSame(STR, seq); [EOL]     Leaf l = new Leaf(13); [EOL]     Map<?, ?> m = MAPPER.convertValue(l, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(1, m.size()); [EOL]     assertEquals(Integer.valueOf(13), m.get("value")); [EOL]     Leaf l2 = MAPPER.convertValue(m, Leaf.class); [EOL]     assertEquals(13, l2.value); [EOL]     Object ob = MAPPER.convertValue(l, Object.class); [EOL]     assertNotNull(ob); [EOL]     assertEquals(LinkedHashMap.class, ob.getClass()); [EOL]     final Object plaino = new Object(); [EOL]     try { [EOL]         m = MAPPER.convertValue(plaino, Map.class); [EOL]         fail("Conversion should have failed"); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "no properties discovered"); [EOL]     } [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); [EOL]     try { [EOL]         assertEquals("{}", mapper.writeValueAsString(plaino)); [EOL]     } catch (Exception e) { [EOL]         throw (Exception) e.getCause(); [EOL]     } [EOL]     m = mapper.convertValue(plaino, Map.class); [EOL]     assertNotNull(m); [EOL]     assertEquals(0, m.size()); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testIgnoreViaPropsAndClass() throws Exception { [EOL]     assertEquals("{\"value\":{\"y\":2}}", MAPPER.writeValueAsString(new WrapperWithPropIgnore2())); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "stuffValue").addValue("myId", "xyz").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals("stuffValue", bean.stuff); [EOL]     assertEquals("xyz", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals("{\"values\":[[7,8],[8,7]]}", json); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = "{\"x\":1,\"y\":2}"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSerializedAsListWithClassSerializer() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     SimpleValueListWithSerializer list = new SimpleValueListWithSerializer(); [EOL]     list.add(new ActualValue("foo")); [EOL]     assertEquals("[\"value foo\"]", m.writeValueAsString(list)); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testCharacterWrapper() throws Exception { [EOL]     Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class); [EOL]     assertEquals(Character.valueOf('a'), result); [EOL]     result = MAPPER.readValue(new StringReader(" " + ((int) 'X')), Character.class); [EOL]     assertEquals(Character.valueOf('X'), result); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testSimpleFactory() throws Exception { [EOL]     FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class); [EOL]     assertEquals(0.25, bean.d); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testFpTypeOverrideSimple() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL]     BigDecimal dec = new BigDecimal("0.1"); [EOL]     Number result = m.readValue(dec.toString(), Number.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, result); [EOL]     Object value = m.readValue(dec.toString(), Object.class); [EOL]     assertEquals(BigDecimal.class, result.getClass()); [EOL]     assertEquals(dec, value); [EOL] }
public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("{\"nums\":[\"java.util.ArrayList\",[[\"java.lang.Long\",1],2,3.0]]}", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }
public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("{\"nums\":[\"java.util.ArrayList\",[[\"java.lang.Long\",1],2,3.0]]}", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }
public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("{\"nums\":[\"java.util.ArrayList\",[[\"java.lang.Long\",1],2,3.0]]}", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }
public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("{\"nums\":[\"java.util.ArrayList\",[[\"java.lang.Long\",1],2,3.0]]}", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode("   APs=\n"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode("?!??"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "Illegal character"); [EOL]     } [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = "TestTypedArraySerialization$TypedListAsWrapper"; [EOL]     assertEquals("{\"" + expName + "\":[true,null,false]}", serializeAsString(input)); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals("foo")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "Unrecognized field \"foo\""); [EOL]     } [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list)); [EOL]     assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals("{}", m.writeValueAsString(list)); [EOL]     assertEquals("{}", m.writeValueAsString(array)); [EOL] }
public void testLocation() throws IOException { [EOL]     File f = new File("/tmp/test.json"); [EOL]     JsonLocation loc = new JsonLocation(f, -1, 100, 13); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(mapper, loc); [EOL]     assertEquals(5, result.size()); [EOL]     assertEquals(f.getAbsolutePath(), result.get("sourceRef")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("charOffset")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("byteOffset")); [EOL]     assertEquals(Integer.valueOf(100), result.get("lineNr")); [EOL]     assertEquals(Integer.valueOf(13), result.get("columnNr")); [EOL] }
public void testLocation() throws IOException { [EOL]     File f = new File("/tmp/test.json"); [EOL]     JsonLocation loc = new JsonLocation(f, -1, 100, 13); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(mapper, loc); [EOL]     assertEquals(5, result.size()); [EOL]     assertEquals(f.getAbsolutePath(), result.get("sourceRef")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("charOffset")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("byteOffset")); [EOL]     assertEquals(Integer.valueOf(100), result.get("lineNr")); [EOL]     assertEquals(Integer.valueOf(13), result.get("columnNr")); [EOL] }
public void testLocation() throws IOException { [EOL]     File f = new File("/tmp/test.json"); [EOL]     JsonLocation loc = new JsonLocation(f, -1, 100, 13); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(mapper, loc); [EOL]     assertEquals(5, result.size()); [EOL]     assertEquals(f.getAbsolutePath(), result.get("sourceRef")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("charOffset")); [EOL]     assertEquals(Integer.valueOf(-1), result.get("byteOffset")); [EOL]     assertEquals(Integer.valueOf(100), result.get("lineNr")); [EOL]     assertEquals(Integer.valueOf(13), result.get("columnNr")); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
@SuppressWarnings("unused") [EOL] public void testMissingNode() throws Exception { [EOL]     String JSON = "[ { }, [ ] ]"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode result = mapper.readTree(new StringReader(JSON)); [EOL]     assertTrue(result.isContainerNode()); [EOL]     assertTrue(result.isArray()); [EOL]     assertEquals(2, result.size()); [EOL]     int count = 0; [EOL]     for (JsonNode node : result) { [EOL]         ++count; [EOL]     } [EOL]     assertEquals(2, count); [EOL]     Iterator<JsonNode> it = result.iterator(); [EOL]     JsonNode onode = it.next(); [EOL]     assertTrue(onode.isContainerNode()); [EOL]     assertTrue(onode.isObject()); [EOL]     assertEquals(0, onode.size()); [EOL]     assertFalse(onode.isMissingNode()); [EOL]     assertNull(onode.textValue()); [EOL]     assertNull(onode.get(0)); [EOL]     JsonNode dummyNode = onode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(3)); [EOL]     assertNull(dummyNode.get("whatever")); [EOL]     JsonNode dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     JsonNode dummyNode3 = dummyNode.path("field"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL]     JsonNode anode = it.next(); [EOL]     assertTrue(anode.isContainerNode()); [EOL]     assertTrue(anode.isArray()); [EOL]     assertFalse(anode.isMissingNode()); [EOL]     assertEquals(0, anode.size()); [EOL]     assertNull(anode.get(0)); [EOL]     dummyNode = anode.path(0); [EOL]     assertNotNull(dummyNode); [EOL]     assertTrue(dummyNode.isMissingNode()); [EOL]     assertNull(dummyNode.get(0)); [EOL]     assertNull(dummyNode.get("myfield")); [EOL]     dummyNode2 = dummyNode.path(98); [EOL]     assertNotNull(dummyNode2); [EOL]     assertTrue(dummyNode2.isMissingNode()); [EOL]     dummyNode3 = dummyNode.path("f"); [EOL]     assertNotNull(dummyNode3); [EOL]     assertTrue(dummyNode3.isMissingNode()); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set("x", TextNode.valueOf("Test")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set("x", TextNode.valueOf("Test")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testCustomWith() throws Exception { [EOL]     final String json = "{\"value\":1}"; [EOL]     ValueFoo value = mapper.readValue(json, ValueFoo.class); [EOL]     assertEquals(1, value.value); [EOL] }
public void testCustomWith() throws Exception { [EOL]     final String json = "{\"value\":1}"; [EOL]     ValueFoo value = mapper.readValue(json, ValueFoo.class); [EOL]     assertEquals(1, value.value); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testInt() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     int value = -90184; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertTrue(result.isIntegralNumber()); [EOL]     assertTrue(result.isInt()); [EOL]     assertType(result, IntNode.class); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isFloatingPointNumber()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue().intValue()); [EOL]     assertEquals(value, result.intValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals((double) value, result.doubleValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(result, IntNode.valueOf(value)); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testTypeIdFromObject() throws Exception { [EOL]     assertEquals("{\"SomeType\":{\"a\":3}}", mapper.writeValueAsString(new TypeIdFromMethodObject())); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>")); [EOL]         fail("Should have failed"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, "Can not detect format from input"); [EOL]     } [EOL] }
public void testFactoryCreatorWithRenamingMixin() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class); [EOL]     FactoryBean bean = m.readValue("{ \"mixed\" :  20.5 }", FactoryBean.class); [EOL]     assertEquals(20.5, bean.d); [EOL] }
public void testFactoryCreatorWithRenamingMixin() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class); [EOL]     FactoryBean bean = m.readValue("{ \"mixed\" :  20.5 }", FactoryBean.class); [EOL]     assertEquals(20.5, bean.d); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testEnumAsObjectValid() throws Exception { [EOL]     assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A)); [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testIssue329() throws Exception { [EOL]     ArrayList<Animal> animals = new ArrayList<Animal>(); [EOL]     animals.add(new Dog("Spot")); [EOL]     JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class); [EOL]     String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator()); [EOL]     if (json.indexOf("\"object-type\":\"doggy\"") < 0) { [EOL]         fail("No polymorphic type retained, should be; JSON = '" + json + "'"); [EOL]     } [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testKeyViaFactory() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<KeyTypeCtor, Integer> map = mapper.readValue("{\"a\":123}", TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class)); [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     assertEquals(Integer.valueOf(123), entry.getValue()); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(KeyTypeFactory.class, key.getClass()); [EOL]     assertEquals("a", ((KeyTypeFactory) key).value); [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException("TEST"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testJackson438() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class); [EOL]         fail("Should have failed"); [EOL]     } catch (Exception e) { [EOL]         if (!(e instanceof JsonMappingException)) { [EOL]             fail("Should have received JsonMappingException, caught " + e.getClass().getName()); [EOL]         } [EOL]         verifyException(e, "don't like that name"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         verifyException(e, "don't like that name"); [EOL]     } [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testBytesToBase64AndBack() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     String encoded = MAPPER.convertValue(input, String.class); [EOL]     assertNotNull(encoded); [EOL]     byte[] result = MAPPER.convertValue(encoded, byte[].class); [EOL]     assertArrayEquals(input, result); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testFloatArray() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY }); [EOL]     assertEquals("[1.01,2.0,-7.0,\"NaN\",\"-Infinity\",\"Infinity\"]", sw.toString().trim()); [EOL] }
public void testFloatArray() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     MAPPER.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY }); [EOL]     assertEquals("[1.01,2.0,-7.0,\"NaN\",\"-Infinity\",\"Infinity\"]", sw.toString().trim()); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]", m.writeValueAsString(new Animal[] { new Dog("Spot", 3) })); [EOL]     assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]", m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true) })); [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testMapType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType keyT = tf.constructType(String.class); [EOL]     JavaType baseT = tf.constructType(BaseType.class); [EOL]     MapType mapT = MapType.construct(Map.class, keyT, baseT); [EOL]     assertNotNull(mapT); [EOL]     assertTrue(mapT.isContainerType()); [EOL]     assertSame(mapT, mapT.narrowContentsBy(BaseType.class)); [EOL]     assertSame(mapT, mapT.narrowKey(String.class)); [EOL]     assertTrue(mapT.equals(mapT)); [EOL]     assertFalse(mapT.equals(null)); [EOL]     assertFalse(mapT.equals("xyz")); [EOL]     MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT); [EOL]     assertFalse(mapT.equals(mapT2)); [EOL]     try { [EOL]         SimpleType.construct(HashMap.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "for a Map"); [EOL]     } [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25)); [EOL]     assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testClassAnnotations() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addSerializer(String.class, new AnnotatedContextualSerializer()); [EOL]     mapper.registerModule(module); [EOL]     assertEquals("{\"value\":\"Voila->xyz\"}", mapper.writeValueAsString(new BeanWithClassConfig("xyz"))); [EOL] }
public void testClassAnnotations() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addSerializer(String.class, new AnnotatedContextualSerializer()); [EOL]     mapper.registerModule(module); [EOL]     assertEquals("{\"value\":\"Voila->xyz\"}", mapper.writeValueAsString(new BeanWithClassConfig("xyz"))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals("[1,null,3]", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue("[1,2,3]"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean("abc")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class); [EOL]     assertNotNull(result); [EOL]     Object[] obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.length); [EOL]     assertEquals(ValueClass.class, obs[0].getClass()); [EOL]     assertEquals(1, ((ValueClass) obs[0])._a); [EOL]     assertEquals(ValueClass.class, obs[1].getClass()); [EOL]     assertEquals(2, ((ValueClass) obs[1])._a); [EOL]     assertEquals(ValueClass.class, obs[2].getClass()); [EOL]     assertEquals(3, ((ValueClass) obs[2])._a); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testArrayOfRefs() throws Exception { [EOL]     NodeArray root = new NodeArray(); [EOL]     ArrayNode node1 = new ArrayNode("a"); [EOL]     ArrayNode node2 = new ArrayNode("b"); [EOL]     root.nodes = new ArrayNode[] { node1, node2 }; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(root); [EOL]     NodeArray result = mapper.readValue(json, NodeArray.class); [EOL]     ArrayNode[] kids = result.nodes; [EOL]     assertNotNull(kids); [EOL]     assertEquals(2, kids.length); [EOL]     assertEquals("a", kids[0].name); [EOL]     assertEquals("b", kids[1].name); [EOL]     assertSame(result, kids[0].parent); [EOL]     assertSame(result, kids[1].parent); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode("root"); [EOL]     FullTreeNode child1 = new FullTreeNode("kid1"); [EOL]     FullTreeNode child2 = new FullTreeNode("kid2"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals("root", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals("kid1", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals("kid2", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testAnnotationsDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     AnnoBean bean = m.readValue("{ \"y\" : 0 }", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     bean = m.readValue("{ \"x\" : 0 }", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL] }
public void testAnnotationsDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     AnnoBean bean = m.readValue("{ \"y\" : 0 }", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     bean = m.readValue("{ \"x\" : 0 }", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO("foobar"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals("foobar", result.value); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testEnumsWithJsonValueUsingMixin() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class); [EOL]     assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testExplicitIgnoralWithMap() throws Exception { [EOL]     MyMap value = new MyMap(); [EOL]     value.put("a", "b"); [EOL]     value.put("@class", MyMap.class.getName()); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, value); [EOL]     assertEquals(1, result.size()); [EOL]     assertFalse(result.containsKey("@class")); [EOL]     assertEquals(value.get("a"), result.get("a")); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations2() throws IOException { [EOL]     MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b"); [EOL]     assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testEmptyInclusion() throws IOException { [EOL]     ObjectMapper defMapper = MAPPER; [EOL]     ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); [EOL]     StringWrapper str = new StringWrapper(""); [EOL]     assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(str)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper())); [EOL]     ListWrapper<String> list = new ListWrapper<String>(); [EOL]     assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(list)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>())); [EOL]     MapWrapper<String, Integer> map = new MapWrapper<String, Integer>(new HashMap<String, Integer>()); [EOL]     assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(map)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String, Integer>(null))); [EOL]     ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]); [EOL]     assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(array)); [EOL]     assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null))); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testDelegateMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator())); [EOL]     MyMap result = mapper.readValue("123", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.values().iterator().next()); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue("{\"enumA\":\"value\"}", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals("value", value.get(EnumWithCreator.A)); [EOL] }
public void testCustomBeanDeserializer() throws Exception { [EOL]     final ObjectMapper map = new ObjectMapper(); [EOL]     String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}"; [EOL]     TestBeans beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     List<TestBean> results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(1, results.size()); [EOL]     TestBean bean = results.get(0); [EOL]     assertEquals("hello, tatu", bean.d); [EOL]     CustomBean c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(10, c.a); [EOL]     assertEquals(20, c.b); [EOL]     json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"}," + "{\"d\":\"abc\", \"c\":{\"b\":15}}]}"; [EOL]     beans = map.readValue(json, TestBeans.class); [EOL]     assertNotNull(beans); [EOL]     results = beans.beans; [EOL]     assertNotNull(results); [EOL]     assertEquals(2, results.size()); [EOL]     bean = results.get(0); [EOL]     assertEquals("", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(-4, c.a); [EOL]     assertEquals(3, c.b); [EOL]     bean = results.get(1); [EOL]     assertEquals("abc", bean.d); [EOL]     c = bean.c; [EOL]     assertNotNull(c); [EOL]     assertEquals(0, c.a); [EOL]     assertEquals(15, c.b); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testBasicSetup() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.with(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testBasicSetup() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.with(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testBasicSetup() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.with(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testBasicSetup() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.with(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testMapperShortcutMethods() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testPrivateUsingGlobals() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     VisibilityChecker<?> vc = m.getVisibilityChecker(); [EOL]     vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     Map<String, Object> result = writeAndMap(m, new FieldBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("public", result.get("p1")); [EOL]     assertEquals("protected", result.get("p2")); [EOL]     assertEquals("private", result.get("p3")); [EOL]     m = new ObjectMapper(); [EOL]     vc = m.getVisibilityChecker(); [EOL]     vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY); [EOL]     m.setVisibilityChecker(vc); [EOL]     result = writeAndMap(m, new MethodBean()); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals("a", result.get("a")); [EOL]     assertEquals("b", result.get("b")); [EOL]     assertEquals("c", result.get("c")); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField("num", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testExceptionFromConstructor() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue("{}", BustedCtor.class); [EOL]         fail("Expected exception"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, ": foobar"); [EOL]         Throwable t = e.getCause(); [EOL]         assertNotNull(t); [EOL]         assertEquals(IllegalArgumentException.class, t.getClass()); [EOL]         assertEquals("foobar", t.getMessage()); [EOL]     } [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, "test string"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail("Wrapped exception not IAE, but " + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue("{\"bar\":3}", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail("Should have failed binding"); [EOL]     } [EOL]     assertEquals("bar", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, "propX"); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testClass() throws IOException { [EOL]     assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class)); [EOL]     assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE)); [EOL]     assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE)); [EOL]     assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE)); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testJackson398() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class); [EOL]     List<TestClass398> typedList = new ArrayList<TestClass398>(); [EOL]     typedList.add(new TestClass398()); [EOL]     final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]"; [EOL]     String json = mapper.writerWithType(collectionType).writeValueAsString(typedList); [EOL]     assertEquals(EXP, json); [EOL]     StringWriter out = new StringWriter(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList); [EOL]     assertEquals(EXP, out.toString()); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals("{\"0\":1}", mapper.writeValueAsString(map)); [EOL] }
public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals("{\"0\":1}", mapper.writeValueAsString(map)); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
public void testXMLGregorianCalendarSerAndDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     long timestamp = cal.toGregorianCalendar().getTimeInMillis(); [EOL]     String numStr = String.valueOf(timestamp); [EOL]     assertEquals(numStr, mapper.writeValueAsString(cal)); [EOL]     XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class); [EOL]     assertNotNull(calOut); [EOL]     assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis()); [EOL]     mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); [EOL]     String exp = cal.toXMLFormat(); [EOL]     String act = mapper.writeValueAsString(cal); [EOL]     act = act.substring(1, act.length() - 1); [EOL]     exp = removeZ(exp); [EOL]     act = removeZ(act); [EOL]     assertEquals(exp, act); [EOL] }
