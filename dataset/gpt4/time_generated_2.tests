public void testAbstractPartialConstructor() { [EOL] AbstractPartial subclassInstance = new AbstractPartialSubclass(); [EOL] }
public void testGetFieldTypes_Empty() { [EOL] DateTime dateTime = new DateTime(0); // Assuming DateTime is the class containing getFieldTypes [EOL] DateTimeFieldType[] fieldTypes = dateTime.getFieldTypes(); [EOL] assertNotNull(fieldTypes); [EOL] assertEquals(0, fieldTypes.length); [EOL] }
public void testGetFieldTypes_NonEmpty() { [EOL] DateTime dateTime = new DateTime(); // Assuming a constructor that initializes with current time [EOL] DateTimeFieldType[] fieldTypes = dateTime.getFieldTypes(); [EOL] assertNotNull(fieldTypes); [EOL] assertTrue(fieldTypes.length > 0); [EOL] for (DateTimeFieldType fieldType : fieldTypes) { [EOL] assertNotNull(fieldType); [EOL] } [EOL] }
public DateTimeField getField(int index) { [EOL] return getField(index, getChronology()); [EOL] }
public void testGetFields_Empty() { [EOL] Time time = new Time(); [EOL] DateTimeField[] fields = time.getFields(); [EOL] assertNotNull(fields); [EOL] assertEquals(0, fields.length); [EOL] } [EOL] public void testGetFields_NonEmpty() { [EOL] Time time = new Time(); [EOL] time.setField(DateTimeFieldType.hourOfDay(), 10); [EOL] time.setField(DateTimeFieldType.minuteOfHour(), 30); [EOL] DateTimeField[] fields = time.getFields(); [EOL] assertNotNull(fields); [EOL] assertEquals(2, fields.length); [EOL] assertEquals(DateTimeFieldType.hourOfDay(), fields[0].getType()); [EOL] assertEquals(DateTimeFieldType.minuteOfHour(), fields[1].getType()); [EOL] }
public int get(DateTimeFieldType type) { [EOL] return getValue(indexOfSupported(type)); [EOL] }
public void testIsSupported_withSupportedType() { [EOL] DateTimeFieldType supportedType = DateTimeFieldType.year(); [EOL] boolean result = isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_withUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = DateTimeFieldType.era(); [EOL] boolean result = isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIndexOf_WithExistingType() { [EOL] DateTimeFieldType existingType = DateTimeFieldType.year(); [EOL] int index = partial.indexOf(existingType); [EOL] assertTrue(index >= 0); [EOL] }
public void testIndexOf_WithNonExistingType() { [EOL] DateTimeFieldType nonExistingType = DateTimeFieldType.era(); [EOL] int index = partial.indexOf(nonExistingType); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfSupported_WithSupportedType() { [EOL] DateTimeFieldType supportedType = DateTimeFieldType.hourOfDay(); [EOL] addSupportedType(supportedType); [EOL] int index = indexOfSupported(supportedType); [EOL] assertTrue(index >= 0); [EOL] }
public void testIndexOfSupported_WithUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = DateTimeFieldType.hourOfHalfday(); [EOL] try { [EOL] indexOfSupported(unsupportedType); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field '" + unsupportedType + "' is not supported", e.getMessage()); [EOL] } [EOL] }
public void testToDateTimeWithNullBaseInstant() { [EOL] Partial partial = new Partial(); // Assuming Partial is the class that contains toDateTime [EOL] DateTime result = partial.toDateTime(null); [EOL] assertNotNull(result); [EOL] assertEquals(result.getChronology(), ISOChronology.getInstance()); [EOL] }
public void testToDateTimeWithNonNullBaseInstant() { [EOL] Partial partial = new Partial(); // Assuming Partial is the class that contains toDateTime [EOL] ReadableInstant baseInstant = new DateTime(2023, 3, 25, 10, 0, ISOChronology.getInstanceUTC()); [EOL] DateTime result = partial.toDateTime(baseInstant); [EOL] assertNotNull(result); [EOL] assertEquals(result.getChronology(), baseInstant.getChronology()); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.getClass(), YearMonthDay.class); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(new YearMonthDay(), ymd); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(new YearMonthDay(), ymd); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayWithDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertNotNull(ymd); [EOL] assertEquals(ISOChronology.getInstance(zone), ymd.getChronology()); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] assertEquals(ISOChronology.getInstance(), ymd.getChronology()); [EOL] }
public void testYearMonthDayChronology() { [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(ISOChronology.getInstance(), ymd.getChronology()); [EOL] }
public void testYearMonthDayLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayObject() { [EOL] Instant instant = new Instant(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(ISOChronology.getInstance(), ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayInts() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntsChronology() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }

public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.toDate().getTime(), instant); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd, new YearMonthDay(DateTimeZone.getDefault())); [EOL] }
public void testYearMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.getChronology().getZone(), zone); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.getChronology(), chronology); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.toDate().getTime(), instant); [EOL] assertEquals(ymd.getChronology(), chronology); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.toDate(), date); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Date date = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.toDate(), date); [EOL] assertEquals(ymd.getChronology(), chronology); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.getYear(), year); [EOL] assertEquals(ymd.getMonthOfYear(), month); [EOL] assertEquals(ymd.getDayOfMonth(), day); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(ymd.getYear(), year); [EOL] assertEquals(ymd.getMonthOfYear(), month); [EOL] assertEquals(ymd.getDayOfMonth(), day); [EOL] assertEquals(ymd.getChronology(), chronology); [EOL] }
public void testYearMonthDayWithPartialAndChronology() { [EOL] YearMonthDay partial = new YearMonthDay(2020, 1, 1); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(partial, chrono); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] assertEquals(partial, ymd); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertEquals(zone, ymd.getChronology().getZone()); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight().getMillis()); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(new YearMonthDay(instant), ymd); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(new YearMonthDay(instant, chrono), ymd); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] assertEquals(2020, ymd.getYear()); [EOL] assertEquals(1, ymd.getMonthOfYear()); [EOL] assertEquals(1, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1, chrono); [EOL] assertEquals(2020, ymd.getYear()); [EOL] assertEquals(1, ymd.getMonthOfYear()); [EOL] assertEquals(1, ymd.getDayOfMonth()); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public int size() { [EOL] return 3; [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }];
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case YEAR: [EOL] return chrono.year(); [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] case DAY_OF_MONTH: [EOL] return chrono.dayOfMonth(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] }
public void testGetFieldType_ValidIndex() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertEquals(DateTimeFieldType.year(), ymd.getFieldType(0)); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), ymd.getFieldType(1)); [EOL] assertEquals(DateTimeFieldType.dayOfMonth(), ymd.getFieldType(2)); [EOL] } [EOL] public void testGetFieldType_InvalidIndex() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] try { [EOL] ymd.getFieldType(3); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] Chronology chrono = ymd.getChronology(); [EOL] YearMonthDay result = ymd.withChronologyRetainFields(chrono); [EOL] assertSame("Should be the same object as no chronology change", ymd, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] Chronology newChrono = ISOChronology.getInstanceUTC(); [EOL] if (!newChrono.equals(ymd.getChronology())) { [EOL] YearMonthDay result = ymd.withChronologyRetainFields(newChrono); [EOL] assertNotSame("Should be a different object as chronology changes", ymd, result); [EOL] assertEquals("Chronology should be changed", newChrono, result.getChronology()); [EOL] } [EOL] }
public void testWithChronologyRetainFields_NullChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay result = ymd.withChronologyRetainFields(null); [EOL] assertNotSame("Should be a different object as chronology changes", ymd, result); [EOL] assertNotNull("Chronology should not be null", result.getChronology()); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay result = ymd.withPeriodAdded(null, 1); [EOL] assertSame("The method should return the same YearMonthDay object for null period", ymd, result); [EOL] }
public void testWithPeriodAdded_ZeroScalar() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay result = ymd.withPeriodAdded(period, 0); [EOL] assertSame("The method should return the same YearMonthDay object for zero scalar", ymd, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodPositiveScalar() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay result = ymd.withPeriodAdded(period, 1); [EOL] assertNotNull("The method should not return null for a non-null period and positive scalar", result); [EOL] assertNotSame("The method should return a new YearMonthDay object for non-null period and positive scalar", ymd, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodNegativeScalar() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay result = ymd.withPeriodAdded(period, -1); [EOL] assertNotNull("The method should not return null for a non-null period and negative scalar", result); [EOL] assertNotSame("The method should return a new YearMonthDay object for non-null period and negative scalar", ymd, result); [EOL] }
public void testPlusYears_Normal() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay newYmd = ymd.plusYears(1); [EOL] assertEquals(new YearMonthDay(2021, 1, 1), newYmd); [EOL] }
public void testPlusYears_Negative() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay newYmd = ymd.plusYears(-1); [EOL] assertEquals(new YearMonthDay(2019, 1, 1), newYmd); [EOL] }
public void testPlusYears_Zero() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay newYmd = ymd.plusYears(0); [EOL] assertEquals(ymd, newYmd); [EOL] }
public void testPlusMonths() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] YearMonthDay result = ymd.plusMonths(1); [EOL] assertEquals(new YearMonthDay(2023, 2, 1), result); [EOL] }
public void testPlusMonthsAcrossYear() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 12, 1); // Assuming default chronology is ISO [EOL] YearMonthDay result = ymd.plusMonths(1); [EOL] assertEquals(new YearMonthDay(2024, 1, 1), result); [EOL] }
public void testPlusMonthsNegative() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] YearMonthDay result = ymd.plusMonths(-1); [EOL] assertEquals(new YearMonthDay(2022, 12, 1), result); [EOL] }
public void testPlusMonthsToZero() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] YearMonthDay result = ymd.plusMonths(-1); [EOL] assertFalse(result.getMonthOfYear() == 0); [EOL] }
public void testPlusMonthsWithZero() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] YearMonthDay result = ymd.plusMonths(0); [EOL] assertEquals(ymd, result); [EOL] }
public void testPlusMonthsWithMaxInt() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] try { [EOL] ymd.plusMonths(Integer.MAX_VALUE); [EOL] fail("Should have thrown an exception due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testPlusMonthsWithMinInt() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 1); // Assuming default chronology is ISO [EOL] try { [EOL] ymd.plusMonths(Integer.MIN_VALUE); [EOL] fail("Should have thrown an exception due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testMinus_withNullPeriod() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay result = ymd.minus(null); [EOL] assertEquals("Minus method should return the same YearMonthDay when period is null", ymd, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay result = ymd.minus(period); [EOL] YearMonthDay expected = ymd.minusYears(1); [EOL] assertEquals("Minus method should subtract the period from the YearMonthDay", expected, result); [EOL] }
public void testMinusDays_CoverNewLines() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] YearMonthDay result = ymd.minusDays(10); [EOL] assertEquals(new YearMonthDay(2023, 4, 5), result); [EOL] result = ymd.minusDays(0); [EOL] assertEquals(ymd, result); [EOL] result = ymd.minusDays(-5); [EOL] assertEquals(new YearMonthDay(2023, 4, 20), result); [EOL] }

public LocalDate toLocalDate() { [EOL] return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology()); [EOL] } [EOL] public YearMonthDay() {} [EOL] public YearMonthDay(DateTimeZone zone) {} [EOL] public YearMonthDay(Chronology chronology) {} [EOL] public YearMonthDay(long instant) {} [EOL] public YearMonthDay(long instant, Chronology chronology) {} [EOL] public YearMonthDay(Object instant) {} [EOL] public YearMonthDay(Object instant, Chronology chronology) {} [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {} [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {} [EOL] YearMonthDay(YearMonthDay partial, int[] values) {} [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono) {} [EOL] Property(YearMonthDay partial, int fieldIndex) {} [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonthDay fromDateFields(Date date) {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonthDay plus(ReadablePeriod period) {} [EOL] public YearMonthDay plusYears(int years) {} [EOL] public YearMonthDay plusMonths(int months) {} [EOL] public YearMonthDay plusDays(int days) {} [EOL] public YearMonthDay minus(ReadablePeriod period) {} [EOL] public YearMonthDay minusYears(int years) {} [EOL] public YearMonthDay minusMonths(int months) {} [EOL] public YearMonthDay minusDays(int days) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public LocalDate toLocalDate() {} [EOL] public DateTime toDateTimeAtMidnight() {} [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) {} [EOL] public DateTime toDateTimeAtCurrentTime() {} [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {} [EOL] public DateMidnight toDateMidnight() {} [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) {} [EOL] public DateTime toDateTime(TimeOfDay time) {} [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public int getDayOfMonth() {} [EOL] public YearMonthDay withYear(int year) {} [EOL] public YearMonthDay withMonthOfYear(int monthOfYear) {} [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public Property dayOfMonth() {} [EOL] public String toString() {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonthDay getYearMonthDay() {} [EOL] public int get() {} [EOL] public YearMonthDay addToCopy(int valueToAdd) {} [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonthDay setCopy(int value) {} [EOL] public YearMonthDay setCopy(String text, Locale locale) {} [EOL] public YearMonthDay setCopy(String text) {} [EOL] public YearMonthDay withMaximumValue() {} [EOL] public YearMonthDay withMinimumValue() {} [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public DateMidnight toDateMidnight(DateTimeZone zone) { [EOL] Chronology chrono = getChronology().withZone(zone); [EOL] return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public DateTime toDateTime(TimeOfDay time) { [EOL] return toDateTime(time, null); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) { [EOL] Chronology chrono = getChronology().withZone(zone); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] instant = chrono.set(this, instant); [EOL] if (time != null) { [EOL] instant = chrono.set(time, instant); [EOL] } [EOL] return new DateTime(instant, chrono); [EOL] } [EOL] public YearMonthDay() { } [EOL] public YearMonthDay(DateTimeZone zone) { } [EOL] public YearMonthDay(Chronology chronology) { } [EOL] public YearMonthDay(long instant) { } [EOL] public YearMonthDay(long instant, Chronology chronology) { } [EOL] public YearMonthDay(Object instant) { } [EOL] public YearMonthDay(Object instant, Chronology chronology) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { } [EOL] YearMonthDay(YearMonthDay partial, int[] values) { } [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono) { } [EOL] Property(YearMonthDay partial, int fieldIndex) { } [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar) { return null; } [EOL] public static YearMonthDay fromDateFields(Date date) { return null; } [EOL] public int size() { return 0; } [EOL] protected DateTimeField getField(int index, Chronology chrono) { return null; } [EOL] public DateTimeFieldType getFieldType(int index) { return null; } [EOL] public DateTimeFieldType[] getFieldTypes() { return null; } [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology) { return null; } [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value) { return null; } [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { return null; } [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { return null; } [EOL] public YearMonthDay plus(ReadablePeriod period) { return null; } [EOL] public YearMonthDay plusYears(int years) { return null; } [EOL] public YearMonthDay plusMonths(int months) { return null; } [EOL] public YearMonthDay plusDays(int days) { return null; } [EOL] public YearMonthDay minus(ReadablePeriod period) { return null; } [EOL] public YearMonthDay minusYears(int years) { return null; } [EOL] public YearMonthDay minusMonths(int months) { return null; } [EOL] public YearMonthDay minusDays(int days) { return null; } [EOL] public Property property(DateTimeFieldType type) { return null; } [EOL] public LocalDate toLocalDate() { return null; } [EOL] public DateTime toDateTimeAtMidnight() { return null; } [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { return null; } [EOL] public DateTime toDateTimeAtCurrentTime() { return null; } [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { return null; } [EOL] public DateMidnight toDateMidnight() { return null; } [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { return null; } [EOL] public DateTime toDateTime(TimeOfDay time) { return null; } [EOL] public Interval toInterval() { return null; } [EOL] public Interval toInterval(DateTimeZone zone) { return null; } [EOL] public int getYear() { return 0; } [EOL] public int getMonthOfYear() { return 0; } [EOL] public int getDayOfMonth() { return 0; } [EOL] public YearMonthDay withYear(int year) { return null; } [EOL] public YearMonthDay withMonthOfYear(int monthOfYear) { return null; } [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth) { return null; } [EOL] public Property year() { return null; } [EOL] public Property monthOfYear() { return null; } [EOL] public Property dayOfMonth() { return null; } [EOL] public String toString() { return null; } [EOL] public DateTimeField getField() { return null; } [EOL] protected ReadablePartial getReadablePartial() { return null; } [EOL] public YearMonthDay getYearMonthDay() { return null; } [EOL] public int get() { return 0; } [EOL] public YearMonthDay addToCopy(int valueToAdd) { return null; } [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd) { return null; } [EOL] public YearMonthDay setCopy(int value) { return null; } [EOL] public YearMonthDay setCopy(String text, Locale locale) { return null; } [EOL] public YearMonthDay setCopy(String text) { return null; } [EOL] public YearMonthDay withMaximumValue() { return null; } [EOL] public YearMonthDay withMinimumValue() { return null; } [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public Interval toInterval() { [EOL] return toInterval(null); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public Interval toInterval(DateTimeZone zone) { [EOL] zone = DateTimeUtils.getZone(zone); [EOL] return toDateMidnight(zone).toInterval(); [EOL] } [EOL] public YearMonthDay() { } [EOL] public YearMonthDay(DateTimeZone zone) { } [EOL] public YearMonthDay(Chronology chronology) { } [EOL] public YearMonthDay(long instant) { } [EOL] public YearMonthDay(long instant, Chronology chronology) { } [EOL] public YearMonthDay(Object instant) { } [EOL] public YearMonthDay(Object instant, Chronology chronology) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { } [EOL] YearMonthDay(YearMonthDay partial, int[] values) { } [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono) { } [EOL] Property(YearMonthDay partial, int fieldIndex) { } [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar) { } [EOL] public static YearMonthDay fromDateFields(Date date) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public YearMonthDay plus(ReadablePeriod period) { } [EOL] public YearMonthDay plusYears(int years) { } [EOL] public YearMonthDay plusMonths(int months) { } [EOL] public YearMonthDay plusDays(int days) { } [EOL] public YearMonthDay minus(ReadablePeriod period) { } [EOL] public YearMonthDay minusYears(int years) { } [EOL] public YearMonthDay minusMonths(int months) { } [EOL] public YearMonthDay minusDays(int days) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalDate toLocalDate() { } [EOL] public DateTime toDateTimeAtMidnight() { } [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTimeAtCurrentTime() { } [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { } [EOL] public DateMidnight toDateMidnight() { } [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTime(TimeOfDay time) { } [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) { } [EOL] public Interval toInterval() { } [EOL] public int getYear() { } [EOL] public int getMonthOfYear() { } [EOL] public int getDayOfMonth() { } [EOL] public YearMonthDay withYear(int year) { } [EOL] public YearMonthDay withMonthOfYear(int monthOfYear) { } [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth) { } [EOL] public Property year() { } [EOL] public Property monthOfYear() { } [EOL] public Property dayOfMonth() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public YearMonthDay getYearMonthDay() { } [EOL] public int get() { } [EOL] public YearMonthDay addToCopy(int valueToAdd) { } [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public YearMonthDay setCopy(int value) { } [EOL] public YearMonthDay setCopy(String text, Locale locale) { } [EOL] public YearMonthDay setCopy(String text) { } [EOL] public YearMonthDay withMaximumValue() { } [EOL] public YearMonthDay withMinimumValue() { } [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public Property year() { [EOL] return new Property(this, YEAR); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public String toString() { [EOL] return ISODateTimeFormat.yearMonthDay().print(this); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testPropertyConstructorWithYearMonthDayAndFieldIndex() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 4, 1); [EOL] int fieldIndex = 0; [EOL] Property property = new Property(ymd, fieldIndex); [EOL] assertNotNull(property); [EOL] assertEquals(ymd, property.getYearMonthDay()); [EOL] assertEquals(fieldIndex, property.getField().getType().getFieldIndex()); [EOL] }
public void testYearMonthDayConstructorWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayConstructorWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayConstructorWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight(chronology.getZone()).getMillis()); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayConstructorWithObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] assertEquals(date.getTime(), ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayConstructorWithObjectAndChronology() { [EOL] Date date = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(date.getTime(), ymd.toDateTimeAtMidnight(chronology.getZone()).getMillis()); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayConstructorWithYearMonthDayAndValues() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 4, 1); [EOL] int[] values = new int[] {2021, 5, 2}; [EOL] YearMonthDay newYmd = new YearMonthDay(ymd, values); [EOL] assertNotNull(newYmd); [EOL] assertArrayEquals(values, newYmd.getValues()); [EOL] }
public void testYearMonthDayConstructorWithYearMonthDayAndChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 4, 1); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay newYmd = new YearMonthDay(ymd, chronology); [EOL] assertNotNull(newYmd); [EOL] assertEquals(chronology, newYmd.getChronology()); [EOL] }
public void testGetField() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTimeField field = ymd.getField(); [EOL] assertNotNull(field); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertNotNull(ymd); [EOL] assertEquals(zone, ymd.getChronology().getZone()); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Instant instant = new Instant(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testGet() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] Property property = ymd.year(); [EOL] int fieldValue = property.get(); [EOL] assertEquals(2023, fieldValue); [EOL] }
public void testYearMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 5); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertEquals(2023, ymd.getYear()); [EOL] assertEquals(4, ymd.getMonthOfYear()); [EOL] assertEquals(5, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayFromDateFields() { [EOL] Date date = new Date(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 5); [EOL] date.setTime(calendar.getTimeInMillis()); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] assertEquals(2023, ymd.getYear()); [EOL] assertEquals(4, ymd.getMonthOfYear()); [EOL] assertEquals(5, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayWithChronologyRetainFields() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymdWithChrono = ymd.withChronologyRetainFields(chrono); [EOL] assertEquals(chrono, ymdWithChrono.getChronology()); [EOL] }
public void testYearMonthDayWithField() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] YearMonthDay updatedYmd = ymd.withField(DateTimeFieldType.year(), 2025); [EOL] assertEquals(2025, updatedYmd.getYear()); [EOL] assertEquals(4, updatedYmd.getMonthOfYear()); [EOL] assertEquals(5, updatedYmd.getDayOfMonth()); [EOL] }
public void testYearMonthDayWithFieldAdded() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] YearMonthDay updatedYmd = ymd.withFieldAdded(DurationFieldType.years(), 2); [EOL] assertEquals(2025, updatedYmd.getYear()); [EOL] }
public void testYearMonthDayWithPeriodAdded() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] Period period = new Period().withYears(2); [EOL] YearMonthDay updatedYmd = ymd.withPeriodAdded(period, 1); [EOL] assertEquals(2025, updatedYmd.getYear()); [EOL] }
public void testYearMonthDayPlusYears() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] YearMonthDay updatedYmd = ymd.plusYears(2); [EOL] assertEquals(2025, updatedYmd.getYear()); [EOL] }
public void testYearMonthDayMinusYears() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] YearMonthDay updatedYmd = ymd.minusYears(2); [EOL] assertEquals(2021, updatedYmd.getYear()); [EOL] }
public void testYearMonthDayProperty() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] Property property = ymd.property(DateTimeFieldType.year()); [EOL] assertNotNull(property); [EOL] assertEquals(2023, property.get()); [EOL] }
public void testYearMonthDaySerialization() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] oos.writeObject(ymd); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] YearMonthDay deserializedYmd = (YearMonthDay) ois.readObject(); [EOL] assertEquals(ymd, deserializedYmd); [EOL] }
public void testWithMaximumValue() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay maxValYMD = ymd.withMaximumValue(); [EOL] assertNotNull(maxValYMD); [EOL] assertEquals(ymd.getChronology().getMaximumValue(ymd.getField(0)), maxValYMD.getYear()); [EOL] assertEquals(ymd.getChronology().getMaximumValue(ymd.getField(1)), maxValYMD.getMonthOfYear()); [EOL] assertEquals(ymd.getChronology().getMaximumValue(ymd.getField(2)), maxValYMD.getDayOfMonth()); [EOL] }
public Class<?> getSupportedType() { [EOL] return ReadablePartial.class; [EOL] }
public void testGetDurationMillisWithValidLongObject() { [EOL] Object object = Long.valueOf(12345L); [EOL] long result = getDurationMillis(object); [EOL] assertEquals(12345L, result); [EOL] }
public void testGetDurationMillisWithNull() { [EOL] try { [EOL] Object object = null; [EOL] getDurationMillis(object); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFieldDifference_WithNullStart() { [EOL] try { [EOL] Period result = Time.fieldDifference(null, new LocalDate()); [EOL] fail("Should have thrown IllegalArgumentException for null start"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithNullEnd() { [EOL] try { [EOL] Period result = Time.fieldDifference(new LocalDate(), null); [EOL] fail("Should have thrown IllegalArgumentException for null end"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithDifferentSizes() { [EOL] try { [EOL] Period result = Time.fieldDifference(new LocalDate(), new LocalTime()); [EOL] fail("Should have thrown IllegalArgumentException for different sizes"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithDifferentFieldTypes() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DurationFieldType getFieldType(int index) { [EOL] if (index == 0) { [EOL] return DurationFieldType.days(); [EOL] } [EOL] return super.getFieldType(index); [EOL] } [EOL] }; [EOL] try { [EOL] Period result = Time.fieldDifference(start, end); [EOL] fail("Should have thrown IllegalArgumentException for different field types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithOverlappingFields() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DurationFieldType getFieldType(int index) { [EOL] return DurationFieldType.days(); [EOL] } [EOL] }; [EOL] try { [EOL] Period result = Time.fieldDifference(start, end); [EOL] fail("Should have thrown IllegalArgumentException for overlapping fields"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not have overlapping fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_ValidInput() { [EOL] ReadablePartial start = new LocalDate(2020, 1, 1); [EOL] ReadablePartial end = new LocalDate(2020, 1, 2); [EOL] Period result = Time.fieldDifference(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getDays()); [EOL] }
public void testPeriodConstructor() { [EOL] Period period = new Period(); [EOL] assertNotNull(period); [EOL] }
public void testPeriodConstructorWithPositiveDuration() { [EOL] long duration = 1000L; // Any positive long value [EOL] Period period = new Period(duration); [EOL] assertEquals(duration, period.getDuration()); [EOL] }
public void testPeriodConstructorWithZeroDuration() { [EOL] long duration = 0L; // Zero value [EOL] Period period = new Period(duration); [EOL] assertEquals(duration, period.getDuration()); [EOL] }
public void testPeriodConstructorWithNegativeDuration() { [EOL] long duration = -1000L; // Any negative long value [EOL] Period period = new Period(duration); [EOL] assertEquals(duration, period.getDuration()); [EOL] }
public void testPeriodConstructorWithValidArguments() { [EOL] long duration = 1000L; [EOL] PeriodType type = PeriodType.days(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] Period period = new Period(duration, type, chronology); [EOL] assertNotNull(period); [EOL] assertEquals(duration, period.getDuration()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(chronology, period.getChronology()); [EOL] }
public void testPeriodConstructorWithNullType() { [EOL] long duration = 1000L; [EOL] PeriodType type = null; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] Period period = new Period(duration, type, chronology); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodConstructorWithNullChronology() { [EOL] long duration = 1000L; [EOL] PeriodType type = PeriodType.days(); [EOL] Chronology chronology = null; [EOL] Period period = new Period(duration, type, chronology); [EOL] assertNotNull(period); [EOL] assertEquals(duration, period.getDuration()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertNull(period.getChronology()); [EOL] }
public void testPeriodWithValidChronology() { [EOL] long startInstant = System.currentTimeMillis(); [EOL] long endInstant = startInstant + 1000; // 1 second later [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Period period = new Period(startInstant, endInstant, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(chrono, period.getChronology()); [EOL] }
public void testPeriodWithNullChronology() { [EOL] long startInstant = System.currentTimeMillis(); [EOL] long endInstant = startInstant + 1000; // 1 second later [EOL] Period period = new Period(startInstant, endInstant, null); [EOL] assertNotNull(period); [EOL] assertEquals(ISOChronology.getInstanceUTC(), period.getChronology()); [EOL] }
public void testPeriodWithStartAndEndInstant() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = PeriodType.standard(); [EOL] Period period = new Period(startInstant, endInstant, type); [EOL] }
public void testPeriodWithNullStartInstant() { [EOL] ReadableInstant startInstant = null; [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = PeriodType.standard(); [EOL] try { [EOL] new Period(startInstant, endInstant, type); [EOL] fail("Should have thrown IllegalArgumentException for null startInstant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithNullEndInstant() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = null; [EOL] PeriodType type = PeriodType.standard(); [EOL] try { [EOL] new Period(startInstant, endInstant, type); [EOL] fail("Should have thrown IllegalArgumentException for null endInstant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithNullType() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = null; [EOL] Period period = new Period(startInstant, endInstant, type); [EOL] }
public void testPeriodWithInstantAndDurationAndType() { [EOL] DateTime startInstant = new DateTime(2023, 4, 1, 12, 0); [EOL] Duration duration = new Duration(1000L); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] Period period = new Period(startInstant, duration, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(0, period.getYears()); [EOL] assertEquals(0, period.getMonths()); [EOL] assertEquals(0, period.getWeeks()); [EOL] assertEquals(0, period.getDays()); [EOL] assertEquals(0, period.getHours()); [EOL] assertEquals(0, period.getMinutes()); [EOL] assertEquals(1, period.getSeconds()); [EOL] assertEquals(0, period.getMillis()); [EOL] }
public void testPeriodConstructorWithValidArguments() { [EOL] ReadableDuration mockDuration = mock(ReadableDuration.class); [EOL] ReadableInstant mockEndInstant = mock(ReadableInstant.class); [EOL] PeriodType mockType = mock(PeriodType.class); [EOL] Period period = new Period(mockDuration, mockEndInstant, mockType); [EOL] assertNotNull(period); [EOL] }
public void testPeriodWithNullChronology() { [EOL] Object period = new Object(); [EOL] Chronology chrono = null; [EOL] Period result = new Period(period, chrono); [EOL] assertNotNull(result); [EOL] }
public void testPeriodWithNonNullChronology() { [EOL] Object period = new Object(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Period result = new Period(period, chrono); [EOL] assertNotNull(result); [EOL] assertEquals(chrono, result.getChronology()); [EOL] }
public void testPeriodConstructor() { [EOL] Object period = // initialize with a valid period object [EOL] PeriodType type = // initialize with a valid PeriodType [EOL] Chronology chrono = // initialize with a valid Chronology [EOL] Period result = new Period(period, type, chrono); [EOL] assertNotNull(result); [EOL] }
public int getYears() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX); [EOL] }
public int getMonths() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX); [EOL] }
public int getWeeks() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX); [EOL] }
public int getDays() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX); [EOL] }
public int getHours() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX); [EOL] }
public void testGetMinutes() { [EOL] PeriodType mockPeriodType = Mockito.mock(PeriodType.class); [EOL] TimePeriod mockTimePeriod = Mockito.mock(TimePeriod.class); [EOL] Mockito.when(mockTimePeriod.getPeriodType()).thenReturn(mockPeriodType); [EOL] Mockito.when(mockPeriodType.getIndexedField(mockTimePeriod, PeriodType.MINUTE_INDEX)).thenReturn(15); [EOL] int minutes = mockTimePeriod.getMinutes(); [EOL] assertEquals(15, minutes); [EOL] }
public int getSeconds() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX); [EOL] }
public int getMillis() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX); [EOL] }
public void testWithFields_NullPeriod() { [EOL] Period testPeriod = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = testPeriod.withFields(null); [EOL] assertSame("Expected the same period", testPeriod, result); [EOL] }
public void testWithFields_NonNullPeriod() { [EOL] Period testPeriod = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period newPeriod = new Period(0, 0, 0, 0, 1, 1, 1, 1); [EOL] Period result = testPeriod.withFields(newPeriod); [EOL] assertNotNull("Expected a new period", result); [EOL] assertNotSame("Expected a different period object", testPeriod, result); [EOL] int[] expectedValues = new int[] {1, 2, 3, 4, 6, 7, 8, 9}; [EOL] assertArrayEquals("Expected merged values", expectedValues, result.getValues()); [EOL] }
public void testWithFieldAdded_NullField() { [EOL] try { [EOL] Period period = new Period(); [EOL] period.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 0); [EOL] assertSame("Period should be the same as it is unchanged", period, result); [EOL] }
public void testWithFieldAdded_NonZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 10); [EOL] assertNotNull("Resulting period must not be null", result); [EOL] assertNotSame("Period should not be the same as it is changed", period, result); [EOL] }
public void testWithWeeks_NewPeriodWithWeeks() { [EOL] Period period = new Period(); [EOL] int weeks = 5; [EOL] Period newPeriod = period.withWeeks(weeks); [EOL] assertEquals(weeks, newPeriod.getWeeks()); [EOL] }
public void testWithWeeks_SamePeriodType() { [EOL] Period period = new Period(); [EOL] int weeks = 5; [EOL] Period newPeriod = period.withWeeks(weeks); [EOL] assertEquals(period.getPeriodType(), newPeriod.getPeriodType()); [EOL] }
public void testWithDays_NewPeriodWithDifferentDays() { [EOL] Period period = new Period(); [EOL] int newDays = 10; [EOL] Period newPeriod = period.withDays(newDays); [EOL] assertEquals(newDays, newPeriod.getDays()); [EOL] }
public void testWithMinutes_NewMinutes() { [EOL] Period period = new Period(); [EOL] int newMinutes = 10; [EOL] Period updatedPeriod = period.withMinutes(newMinutes); [EOL] assertEquals(newMinutes, updatedPeriod.getMinutes()); [EOL] }
public void testWithMinutes_SameMinutes() { [EOL] Period period = new Period(); [EOL] int newMinutes = period.getMinutes(); [EOL] Period updatedPeriod = period.withMinutes(newMinutes); [EOL] assertEquals(newMinutes, updatedPeriod.getMinutes()); [EOL] }
public void testWithSeconds_NewPeriodWithDifferentSeconds() { [EOL] Period period = new Period(); [EOL] int newSeconds = 10; [EOL] Period newPeriod = period.withSeconds(newSeconds); [EOL] int[] values = newPeriod.getValues(); [EOL] assertEquals(newSeconds, values[PeriodType.SECOND_INDEX]); [EOL] }
public void testWithSeconds_SamePeriodIfSecondsUnchanged() { [EOL] Period period = new Period(); [EOL] int originalSeconds = period.getValues()[PeriodType.SECOND_INDEX]; [EOL] Period newPeriod = period.withSeconds(originalSeconds); [EOL] assertEquals(period, newPeriod); [EOL] }
public void testWithMillis_NewValue() { [EOL] Period period = new Period(); [EOL] int newMillis = 500; [EOL] Period updatedPeriod = period.withMillis(newMillis); [EOL] assertEquals(newMillis, updatedPeriod.getMillis()); [EOL] }
public void testWithMillis_SameValue() { [EOL] Period period = new Period(); [EOL] int originalMillis = period.getMillis(); [EOL] Period updatedPeriod = period.withMillis(originalMillis); [EOL] assertEquals(originalMillis, updatedPeriod.getMillis()); [EOL] }
public void testToStandardWeeks_withNoYearsAndMonths() { [EOL] Time time = new Time(0, 0, 0, 0, 0, 0, 0, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] assertEquals("Weeks should be zero", 0, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withSeconds() { [EOL] Time time = new Time(0, 0, 0, 0, 0, 1, 0, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] long expectedWeeks = 1 / DateTimeConstants.SECONDS_PER_WEEK; [EOL] assertEquals("Weeks should account for seconds", expectedWeeks, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withMinutes() { [EOL] Time time = new Time(0, 0, 0, 0, 1, 0, 0, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] long expectedWeeks = 1 / DateTimeConstants.MINUTES_PER_WEEK; [EOL] assertEquals("Weeks should account for minutes", expectedWeeks, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withHours() { [EOL] Time time = new Time(0, 0, 0, 1, 0, 0, 0, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] long expectedWeeks = 1 / DateTimeConstants.HOURS_PER_WEEK; [EOL] assertEquals("Weeks should account for hours", expectedWeeks, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withDays() { [EOL] Time time = new Time(0, 0, 1, 0, 0, 0, 0, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] long expectedWeeks = 1 / DateTimeConstants.DAYS_PER_WEEK; [EOL] assertEquals("Weeks should account for days", expectedWeeks, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withWeeks() { [EOL] Time time = new Time(0, 0, 0, 0, 0, 0, 1, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] assertEquals("Weeks should be the same as input", 1, result.getWeeks()); [EOL] }
public void testToStandardWeeks_withMaxValues() { [EOL] Time time = new Time(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 0); [EOL] Weeks result = time.toStandardWeeks(); [EOL] assertEquals("Weeks should be max int", Integer.MAX_VALUE, result.getWeeks()); [EOL] }
public void testToStandardMinutes() { [EOL] Time time = new Time(); [EOL] time.setMillis(0); [EOL] time.setSeconds(0); [EOL] time.setMinutes(0); [EOL] time.setHours(0); [EOL] time.setDays(0); [EOL] time.setWeeks(0); [EOL] Minutes result = time.toStandardMinutes(); [EOL] assertEquals(0, result.getMinutes());
time.setSeconds(30); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(0, result.getMinutes()); // Assuming 30 seconds is less than a minute and does not round up
time.setSeconds(0); [EOL] time.setMinutes(15); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(15, result.getMinutes());
time.setMinutes(0); [EOL] time.setHours(1); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(60, result.getMinutes()); // Assuming 1 hour equals 60 minutes
time.setHours(0); [EOL] time.setDays(1); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(1440, result.getMinutes()); // Assuming 1 day equals 1440 minutes
time.setDays(0); [EOL] time.setWeeks(1); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(10080, result.getMinutes()); // Assuming 1 week equals 10080 minutes
time.setMillis(1000); [EOL] time.setSeconds(30); [EOL] time.setMinutes(15); [EOL] time.setHours(1); [EOL] time.setDays(1); [EOL] time.setWeeks(1); [EOL] result = time.toStandardMinutes(); [EOL] long expectedMinutes = 1 // from millis [EOL] + 0 // from 30 seconds [EOL] + 15 // from minutes [EOL] + 60 // from 1 hour [EOL] + 1440 // from 1 day [EOL] + 10080; // from 1 week [EOL] assertEquals(expectedMinutes, result.getMinutes());
time.setYears(1); // Assuming setYears method exists [EOL] try { [EOL] result = time.toStandardMinutes(); [EOL] fail("Expected an exception when years are set"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] time.setMonths(1); // Assuming setMonths method exists [EOL] try { [EOL] result = time.toStandardMinutes(); [EOL] fail("Expected an exception when months are set"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testCheckYearsAndMonths_WithMonths() { [EOL] try { [EOL] checkYearsAndMonths("Days"); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Cannot convert to Days as this period contains months and months vary in length", e.getMessage()); [EOL] } [EOL] }
public void testCheckYearsAndMonths_WithYears() { [EOL] try { [EOL] checkYearsAndMonths("Weeks"); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Cannot convert to Weeks as this period contains years and years vary in length", e.getMessage()); [EOL] } [EOL] }
public void testCheckYearsAndMonths_WithNoMonthsOrYears() { [EOL] checkYearsAndMonths("Hours"); // Should pass without exception [EOL] }
public void testGetInstance() { [EOL] IslamicChronology instance = IslamicChronology.getInstance(); [EOL] assertNotNull(instance); [EOL] assertEquals(IslamicChronology.LEAP_YEAR_16_BASED, instance.getLeapYearPatternType()); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] IslamicChronology result = IslamicChronology.getInstance(null, LeapYearPatternType.FIFTEEN_BASED); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone nonNullZone = DateTimeZone.forID("Europe/Paris"); [EOL] IslamicChronology result = IslamicChronology.getInstance(nonNullZone, LeapYearPatternType.FIFTEEN_BASED); [EOL] assertNotNull(result); [EOL] assertEquals(nonNullZone, result.getZone()); [EOL] }
public void testGetInstanceWithUTCZone() { [EOL] IslamicChronology result = IslamicChronology.getInstance(DateTimeZone.UTC, LeapYearPatternType.FIFTEEN_BASED); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result.getZone()); [EOL] }
public void testSetYearOnNonLeapYear() { [EOL] long instant = /* some instant representing a non-leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting the year */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testSetYearOnLeapYear() { [EOL] long instant = /* some instant representing a leap year */; [EOL] int year = /* a leap year */; [EOL] long expected = /* expected instant after setting the year */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testSetYearDecreasingDayOfYear() { [EOL] long instant = /* some instant representing a day beyond 354th in a non-leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting the year and decreasing day of year */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testGetTotalMillisByYearMonth_OddMonth() { [EOL] int year = 2021; [EOL] int month = 3; // March, which is an odd month [EOL] long expected = MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH; [EOL] long result = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expected, result); [EOL] }
public void testGetTotalMillisByYearMonth_EvenMonth() { [EOL] int year = 2021; [EOL] int month = 4; // April, which is an even month [EOL] long expected = MILLIS_PER_MONTH_PAIR; [EOL] long result = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDaysInYearMonth_DecemberLeapYear() { [EOL] int year = 2020; // Example leap year [EOL] int month = 12; [EOL] int expectedDays = LONG_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_DecemberNonLeapYear() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 12; [EOL] int expectedDays = SHORT_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_LongMonth() { [EOL] int year = 2021; [EOL] int month = 7; // Example long month that is not December [EOL] int expectedDays = LONG_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_ShortMonth() { [EOL] int year = 2021; [EOL] int month = 6; // Example short month [EOL] int expectedDays = SHORT_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetMinYear() { [EOL] Time time = new Time(); [EOL] int minYear = time.getMinYear(); [EOL] assertEquals(1, minYear); [EOL] }
public void testGetMaxYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MAX_YEAR; [EOL] int actual = time.getMaxYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testConvertByYearWithSameChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] long convertedInstant = convertByYear(instant, chronology, chronology); [EOL] assertEquals(instant, convertedInstant); [EOL] }
public void testConvertByYearWithDifferentChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology fromChronology = ISOChronology.getInstanceUTC(); [EOL] Chronology toChronology = GregorianChronology.getInstanceUTC(); [EOL] long expectedMillis = toChronology.getDateTimeMillis( [EOL] fromChronology.year().get(instant), [EOL] fromChronology.monthOfYear().get(instant), [EOL] fromChronology.dayOfMonth().get(instant), [EOL] fromChronology.millisOfDay().get(instant) [EOL] ); [EOL] long convertedInstant = convertByYear(instant, fromChronology, toChronology); [EOL] assertEquals(expectedMillis, convertedInstant); [EOL] }
public void testConvertByWeekyear_SameChronology() { [EOL] long instant = System.currentTimeMillis(); // Use current time for testing [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] long convertedInstant = convertByWeekyear(instant, chronology, chronology); [EOL] assertEquals(instant, convertedInstant); [EOL] }
public void testConvertByWeekyear_DifferentChronology() { [EOL] long instant = System.currentTimeMillis(); // Use current time for testing [EOL] Chronology fromChronology = ISOChronology.getInstance(); [EOL] Chronology toChronology = GregorianChronology.getInstance(); [EOL] long convertedInstant = convertByWeekyear(instant, fromChronology, toChronology); [EOL] assertNotEquals(instant, convertedInstant); [EOL] }
public void testGetInstanceUTC() { [EOL] GJChronology gjChronology = GJChronology.getInstanceUTC(); [EOL] assertNotNull(gjChronology); [EOL] assertEquals(DateTimeZone.UTC, gjChronology.getZone()); [EOL] assertEquals(GJChronology.getInstance(DateTimeZone.UTC), gjChronology); [EOL] }
public void testGetInstance() { [EOL] GJChronology instance = GJChronology.getInstance(); [EOL] assertNotNull(instance); [EOL] assertEquals(DateTimeZone.getDefault(), instance.getZone()); [EOL] assertEquals(GJChronology.getInstance(DateTimeZone.getDefault()), instance); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] GJChronology chronology = GJChronology.getInstance(null); [EOL] assertNotNull("Chronology instance should not be null", chronology); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] GJChronology chronology = GJChronology.getInstance(zone); [EOL] assertEquals("Chronology zone should match the specified zone", zone, chronology.getZone()); [EOL] }
public void testGetInstance_NullZoneNullCutover() { [EOL] GJChronology chrono = GJChronology.getInstance(null, null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(GJChronology.DEFAULT_CUTOVER, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstance_NullZoneValidCutover() { [EOL] Instant validCutover = new Instant(/* valid timestamp */); [EOL] GJChronology chrono = GJChronology.getInstance(null, validCutover, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(validCutover, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstance_ValidZoneNullCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] GJChronology chrono = GJChronology.getInstance(zone, null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(GJChronology.DEFAULT_CUTOVER, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstance_ValidZoneValidCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Instant validCutover = new Instant(/* valid timestamp */); [EOL] GJChronology chrono = GJChronology.getInstance(zone, validCutover, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(validCutover, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstance_ValidZoneValidCutoverMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Instant validCutover = new Instant(/* valid timestamp */); [EOL] int minDaysInFirstWeek = 7; [EOL] GJChronology chrono = GJChronology.getInstance(zone, validCutover, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(validCutover, chrono.getGregorianCutover()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstance_ValidZoneValidCutoverCached() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Instant validCutover = new Instant(/* valid timestamp */); [EOL] int minDaysInFirstWeek = 4; [EOL] GJChronology chrono1 = GJChronology.getInstance(zone, validCutover, minDaysInFirstWeek); [EOL] GJChronology chrono2 = GJChronology.getInstance(zone, validCutover, minDaysInFirstWeek); [EOL] assertSame(chrono1, chrono2); [EOL] }
public void testGetInstance_InvalidCutover() { [EOL] try { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Instant invalidCutover = new Instant(/* timestamp representing a date before 0001-01-01 */); [EOL] GJChronology.getInstance(zone, invalidCutover, 4); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstanceWithDefaultCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long gregorianCutover = GJChronology.DEFAULT_CUTOVER.getMillis(); [EOL] int minDaysInFirstWeek = 4; [EOL] GJChronology chronology = GJChronology.getInstance(zone, gregorianCutover, minDaysInFirstWeek); [EOL] assertNotNull(chronology); [EOL] assertEquals("Europe/London", chronology.getZone().getID()); [EOL] assertEquals(4, chronology.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNonDefaultCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long gregorianCutover = new DateTime(1582, 10, 15, 0, 0, zone).getMillis(); [EOL] int minDaysInFirstWeek = 4; [EOL] GJChronology chronology = GJChronology.getInstance(zone, gregorianCutover, minDaysInFirstWeek); [EOL] assertNotNull(chronology); [EOL] assertEquals("Europe/London", chronology.getZone().getID()); [EOL] assertEquals(4, chronology.getMinimumDaysInFirstWeek()); [EOL] assertEquals(new Instant(gregorianCutover), chronology.getGregorianCutover()); [EOL] }
public void testGetInstanceWithInvalidMinDaysInFirstWeek() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long gregorianCutover = GJChronology.DEFAULT_CUTOVER.getMillis(); [EOL] int minDaysInFirstWeek = 0; // Invalid value [EOL] try { [EOL] GJChronology.getInstance(zone, gregorianCutover, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) { [EOL] super(null, new Object[] { julian, gregorian, cutoverInstant }); [EOL] }
private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) { [EOL] super(base, new Object[] { julian, gregorian, cutoverInstant }); [EOL] }
public void testReadResolve() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long cutoverInstant = System.currentTimeMillis(); [EOL] int minimumDaysInFirstWeek = 4; [EOL] MyClass instance = new MyClass(zone, cutoverInstant, minimumDaysInFirstWeek); [EOL] Object resolvedInstance = instance.readResolve(); [EOL] assertNotNull("Resolved instance should not be null", resolvedInstance); [EOL] }
public void testGetZone_BaseChronologyNotNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeZone expectedZone = DateTimeZone.forID("Europe/London"); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(expectedZone); [EOL] DateTime dateTime = new DateTime(mockChronology); [EOL] DateTimeZone actualZone = dateTime.getZone(); [EOL] assertEquals("Expected zone should be returned when base chronology is not null", expectedZone, actualZone); [EOL] }
public void testGetZone_BaseChronologyNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(null); [EOL] DateTime dateTime = new DateTime(mockChronology); [EOL] DateTimeZone actualZone = dateTime.getZone(); [EOL] assertEquals("UTC should be returned when base chronology is null", DateTimeZone.UTC, actualZone); [EOL] }
public void testWithUTC_Coverage() { [EOL] Chronology chronology = /* create an instance of a Chronology implementation here */; [EOL] Chronology utcChronology = chronology.withUTC(); [EOL] assertNotNull(utcChronology); [EOL] assertEquals(DateTimeZone.UTC, utcChronology.getZone()); [EOL] }
public void testWithZoneSameAsCurrent() { [EOL] DateTimeZone initialZone = DateTimeZone.forID("Europe/London"); [EOL] Chronology chronology = ISOChronology.getInstance(initialZone); [EOL] Chronology result = chronology.withZone(initialZone); [EOL] assertSame("Should be the same chronology as the zone is the same", chronology, result); [EOL] }
public void testWithZoneDifferentFromCurrent() { [EOL] DateTimeZone initialZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("America/New_York"); [EOL] Chronology chronology = ISOChronology.getInstance(initialZone); [EOL] Chronology result = chronology.withZone(newZone); [EOL] assertNotSame("Should not be the same chronology as the zone is different", chronology, result); [EOL] assertEquals("The new chronology should have the new zone", newZone, result.getZone()); [EOL] }
public void testWithZoneNull() { [EOL] DateTimeZone initialZone = DateTimeZone.forID("Europe/London"); [EOL] Chronology chronology = ISOChronology.getInstance(initialZone); [EOL] Chronology result = chronology.withZone(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] assertNotSame("Should not be the same chronology as the zone is set to default", chronology, result); [EOL] assertEquals("The new chronology should have the default zone", defaultZone, result.getZone()); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Chronology mockBaseChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBaseChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iChronology.getBase()).thenReturn(mockBaseChronology); [EOL] long result = iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull_GregorianBeforeCutover() { [EOL] Mockito.when(iChronology.getBase()).thenReturn(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L - 1); [EOL] Mockito.when(iChronology.getCutoverMillis()).thenReturn(1234567890L); [EOL] long result = iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L - 1, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull_GregorianEqualsCutover() { [EOL] Mockito.when(iChronology.getBase()).thenReturn(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iChronology.getCutoverMillis()).thenReturn(1234567890L); [EOL] try { [EOL] iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Specified date does not exist", e.getMessage()); [EOL] } [EOL] }
public void testGetDateTimeMillis_BaseChronology() { [EOL] Chronology baseChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(baseChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] setBase(baseChronology); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronology() { [EOL] setBase(null); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(expectedGregorianResult, result); [EOL] }
public void testGetDateTimeMillis_IllegalFieldValueException() { [EOL] setBase(null); // Assuming there is a method to set the base chronology [EOL] Mockito.doThrow(new IllegalFieldValueException("fieldType", "illegalValue")).when(iGregorianChronology).getDateTimeMillis(2021, 2, 29, 0, 0, 0, 0); [EOL] try { [EOL] getDateTimeMillis(2021, 2, 29, 0, 0, 0, 0); [EOL] fail("Expected IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testGetDateTimeMillis_IllegalFieldValueException_NotFebruary29() { [EOL] setBase(null); // Assuming there is a method to set the base chronology [EOL] Mockito.doThrow(new IllegalFieldValueException("fieldType", "illegalValue")).when(iGregorianChronology).getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] try { [EOL] getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] fail("Expected IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testGetDateTimeMillis_JulianChronology() { [EOL] setBase(null); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(expectedJulianResult, result); [EOL] }
public void testGetDateTimeMillis_IllegalArgumentException() { [EOL] setBase(null); // Assuming there is a method to set the base chronology [EOL] try { [EOL] getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetGregorianCutover() { [EOL] Instant expectedCutoverInstant = Instant.now(); [EOL] Time time = new Time(expectedCutoverInstant); [EOL] Instant actualCutoverInstant = time.getGregorianCutover(); [EOL] assertEquals(expectedCutoverInstant, actualCutoverInstant); [EOL] }
public void testGetMinimumDaysInFirstWeek() { [EOL] int expectedMinimumDays = 4; // Assuming that the expected minimum days in the first week is 4 [EOL] GregorianChronology mockGregorianChronology = mock(GregorianChronology.class); [EOL] when(mockGregorianChronology.getMinimumDaysInFirstWeek()).thenReturn(expectedMinimumDays); [EOL] Time time = new Time(mockGregorianChronology); [EOL] int actualMinimumDays = time.getMinimumDaysInFirstWeek(); [EOL] assertEquals(expectedMinimumDays, actualMinimumDays); [EOL] }
protected void assemble(Fields fields) { [EOL] Object[] params = (Object[]) getParam(); [EOL] JulianChronology julian = (JulianChronology) params[0]; [EOL] GregorianChronology gregorian = (GregorianChronology) params[1]; [EOL] Instant cutoverInstant = (Instant) params[2]; [EOL] iCutoverMillis = cutoverInstant.getMillis(); [EOL] iJulianChronology = julian; [EOL] iGregorianChronology = gregorian; [EOL] iCutoverInstant = cutoverInstant; [EOL] if (getBase() != null) { [EOL] return; [EOL] } [EOL] if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis); [EOL] fields.copyFieldsFrom(gregorian); [EOL] if (gregorian.millisOfDay().get(iCutoverMillis) == 0) { [EOL] fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis); [EOL] fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis); [EOL] fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis); [EOL] fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis); [EOL] fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis); [EOL] fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis); [EOL] fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis); [EOL] fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis); [EOL] fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis); [EOL] fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(), fields.clockhourOfHalfday, iCutoverMillis); [EOL] fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis); [EOL] } [EOL] { [EOL] fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis); [EOL] } [EOL] { [EOL] fields.year = new ImpreciseCutoverField(julian.year(), fields.year, iCutoverMillis); [EOL] fields.years = fields.year.getDurationField(); [EOL] fields.yearOfEra = new ImpreciseCutoverField(julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis); [EOL] fields.centuryOfEra = new ImpreciseCutoverField(julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis); [EOL] fields.centuries = fields.centuryOfEra.getDurationField(); [EOL] fields.yearOfCentury = new ImpreciseCutoverField(julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis); [EOL] fields.monthOfYear = new ImpreciseCutoverField(julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis); [EOL] fields.months = fields.monthOfYear.getDurationField(); [EOL] fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, null, iCutoverMillis, true); [EOL] fields.weekyears = fields.weekyear.getDurationField(); [EOL] fields.weekyearOfCentury = new ImpreciseCutoverField(julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis); [EOL] } [EOL] { [EOL] long cutover = gregorian.year().roundCeiling(iCutoverMillis); [EOL] fields.dayOfYear = new CutoverField(julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false); [EOL] } [EOL] { [EOL] long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis); [EOL] fields.weekOfWeekyear = new CutoverField(julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true); [EOL] } [EOL] { [EOL] CutoverField cf = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis); [EOL] cf.iRangeDurationField = fields.months; [EOL] fields.dayOfMonth = cf; [EOL] } [EOL] }
public void testJulianToGregorianByYearWithValidInstant() { [EOL] long instant = SOME_VALID_JULIAN_INSTANT; // Replace with an actual Julian date instant [EOL] long expected = SOME_EXPECTED_GREGORIAN_INSTANT; // Replace with the expected Gregorian date instant [EOL] long actual = julianToGregorianByYear(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testJulianToGregorianByYearWithNegativeInstant() { [EOL] long instant = SOME_NEGATIVE_JULIAN_INSTANT; // Replace with an actual negative Julian date instant [EOL] long expected = SOME_EXPECTED_NEGATIVE_GREGORIAN_INSTANT; // Replace with the expected Gregorian date instant [EOL] long actual = julianToGregorianByYear(instant); [EOL] assertEquals(expected, actual); [EOL] }
long gregorianToJulianByYear(long instant) { [EOL] return convertByYear(instant, iGregorianChronology, iJulianChronology); [EOL] }
public void testGregorianToJulianByWeekyear() { [EOL] long instant = SOME_GREGORIAN_INSTANT; // Replace with an actual gregorian instant [EOL] long expectedJulianInstant = SOME_EXPECTED_JULIAN_INSTANT; // Replace with the expected julian instant [EOL] long actualJulianInstant = gregorianToJulianByWeekyear(instant); [EOL] assertEquals(expectedJulianInstant, actualJulianInstant); [EOL] }
public void testCutoverFieldWithValidFieldsAndCutover() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] long cutoverMillis = 123456789L; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, cutoverMillis); [EOL] assertNotNull(cutoverField); [EOL] assertSame(julianField, cutoverField.getJulianField()); [EOL] assertSame(gregorianField, cutoverField.getGregorianField()); [EOL] assertEquals(cutoverMillis, cutoverField.getCutoverMillis()); [EOL] }
public void testCutoverFieldWithJulianAndGregorianFields() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] long cutoverMillis = 1234567890L; [EOL] boolean convertByWeekyear = false; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(cutoverField); [EOL] }
public void testCutoverFieldWithJulianAndGregorianFieldsAndConvertByWeekyear() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] long cutoverMillis = 1234567890L; [EOL] boolean convertByWeekyear = true; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(cutoverField); [EOL] }
public void testCutoverFieldWithNonNullRangeField() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] DurationField rangeField = mock(DurationField.class); [EOL] long cutoverMillis = 123456789L; [EOL] boolean convertByWeekyear = true; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, rangeField, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(cutoverField); [EOL] assertSame(julianField, cutoverField.iJulianField); [EOL] assertSame(gregorianField, cutoverField.iGregorianField); [EOL] assertEquals(cutoverMillis, cutoverField.iCutover); [EOL] assertEquals(convertByWeekyear, cutoverField.iConvertByWeekyear); [EOL] assertSame(rangeField, cutoverField.iRangeDurationField); [EOL] }
public void testCutoverFieldWithNullRangeFieldAndNonNullGregorianRangeField() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] DurationField gregorianRangeField = mock(DurationField.class); [EOL] when(gregorianField.getRangeDurationField()).thenReturn(gregorianRangeField); [EOL] long cutoverMillis = 123456789L; [EOL] boolean convertByWeekyear = false; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, null, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(cutoverField); [EOL] assertSame(gregorianRangeField, cutoverField.iRangeDurationField); [EOL] }
public void testCutoverFieldWithNullRangeFieldAndNullGregorianRangeField() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] DurationField julianRangeField = mock(DurationField.class); [EOL] when(gregorianField.getRangeDurationField()).thenReturn(null); [EOL] when(julianField.getRangeDurationField()).thenReturn(julianRangeField); [EOL] long cutoverMillis = 123456789L; [EOL] boolean convertByWeekyear = false; [EOL] CutoverField cutoverField = new CutoverField(julianField, gregorianField, null, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(cutoverField); [EOL] assertSame(julianRangeField, cutoverField.iRangeDurationField); [EOL] }
public void testGet_AfterCutover() { [EOL] long instantAfterCutover = iCutover + 1; // Assuming iCutover is a predefined cutover point [EOL] int expectedValue = iGregorianField.get(instantAfterCutover); // Assuming iGregorianField is a mock or a stub with a known return value [EOL] int actualValue = get(instantAfterCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGet_BeforeCutover() { [EOL] long instantBeforeCutover = iCutover - 1; // Assuming iCutover is a predefined cutover point [EOL] int expectedValue = iJulianField.get(instantBeforeCutover); // Assuming iJulianField is a mock or a stub with a known return value [EOL] int actualValue = get(instantBeforeCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public long addTestWithPositiveValue() { [EOL] long instant = 1234567890L; [EOL] int value = 10; [EOL] long result = add(instant, value); [EOL] assertEquals(1234567890L + 10, result); [EOL] } [EOL] public long addTestWithNegativeValue() { [EOL] long instant = 1234567890L; [EOL] int value = -10; [EOL] long result = add(instant, value); [EOL] assertEquals(1234567890L - 10, result); [EOL] } [EOL] public long addTestWithZeroValue() { [EOL] long instant = 1234567890L; [EOL] int value = 0; [EOL] long result = add(instant, value); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testAdd_ValueToAddIsZero() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(values, result); [EOL] }
public void testAdd_WithContiguousPartial() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Mockito.when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(true); [EOL] Mockito.when(mockPartial.size()).thenReturn(3); [EOL] Mockito.when(mockPartial.getFieldType(Mockito.anyInt())).thenReturn(Mockito.mock(DateTimeFieldType.class)); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockPartial.getFieldType(Mockito.anyInt()).getField(Mockito.any(GJChronology.class))).thenReturn(mockField); [EOL] Mockito.when(mockField.set(Mockito.anyLong(), Mockito.anyInt())).thenReturn(1L); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 10; [EOL] int[] expected = new int[] {4, 5, 6}; // Assuming GJChronology.this.get() returns this for the test [EOL] Mockito.when(GJChronology.this.get(mockPartial, Mockito.anyLong())).thenReturn(expected); [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithNonContiguousPartial() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Mockito.when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(false); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 10; [EOL] int[] expected = new int[] {11, 12, 13}; // Assuming super.add() returns this for the test [EOL] Mockito.when(super.add(mockPartial, fieldIndex, values, valueToAdd)).thenReturn(expected); [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testSetWithInstantGreaterThanOrEqualToCutoverAndResultingInstantLessThanCutover() { [EOL] long instant = iCutover; [EOL] int value = 10; [EOL] try { [EOL] long result = set(instant, value); [EOL] assertTrue(result < iCutover); [EOL] assertEquals(value, get(result)); [EOL] } catch (IllegalFieldValueException e) { [EOL] fail("Should not throw IllegalFieldValueException"); [EOL] } [EOL] }
public void testSetWithInstantGreaterThanOrEqualToCutoverAndResultingInstantNotLessThanCutover() { [EOL] long instant = iCutover; [EOL] int value = 10; [EOL] long result = set(instant + iGapDuration, value); [EOL] assertTrue(result >= iCutover); [EOL] assertEquals(value, get(result)); [EOL] }
public void testSetWithInstantLessThanCutoverAndResultingInstantGreaterThanOrEqualToCutover() { [EOL] long instant = iCutover - 1; [EOL] int value = 10; [EOL] try { [EOL] long result = set(instant, value); [EOL] assertTrue(result >= iCutover); [EOL] assertEquals(value, get(result)); [EOL] } catch (IllegalFieldValueException e) { [EOL] fail("Should not throw IllegalFieldValueException"); [EOL] } [EOL] }
public void testSetWithInstantLessThanCutoverAndResultingInstantLessThanCutover() { [EOL] long instant = iCutover - 1; [EOL] int value = 10; [EOL] long result = set(instant - iGapDuration, value); [EOL] assertTrue(result < iCutover); [EOL] assertEquals(value, get(result)); [EOL] }
public void testSetWithInvalidValueCausingIllegalFieldValueExceptionAfterCutover() { [EOL] long instant = iCutover; [EOL] int invalidValue = -1; // Assuming this value is invalid for the field [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testSetWithInvalidValueCausingIllegalFieldValueExceptionBeforeCutover() { [EOL] long instant = iCutover - 1; [EOL] int invalidValue = -1; // Assuming this value is invalid for the field [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testGetDurationField() { [EOL] MyClass testInstance = new MyClass(); [EOL] DurationField result = testInstance.getDurationField(); [EOL] assertNotNull(result); [EOL] }
public void testGetRangeDurationField() { [EOL] MyClass myClassInstance = new MyClass(); // Assuming MyClass is the class containing the getRangeDurationField method [EOL] DurationField expected = myClassInstance.iRangeDurationField; // Direct access to the field, assuming it's accessible [EOL] DurationField actual = myClassInstance.getRangeDurationField(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetLeapDurationField() { [EOL] DurationField result = object.getLeapDurationField(); [EOL] assertNotNull("Leap Duration Field should not be null", result); [EOL] }
public void testGetMaximumValue_AfterCutover() { [EOL] long instantAfterCutover = iCutover + 1; [EOL] int expectedMax = iGregorianField.getMaximumValue(instantAfterCutover); [EOL] int actualMax = getMaximumValue(instantAfterCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_BeforeCutover() { [EOL] long instantBeforeCutover = iCutover - 1; [EOL] int expectedMax = iJulianField.getMaximumValue(instantBeforeCutover); [EOL] int actualMax = getMaximumValue(instantBeforeCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_AtCutoverBoundary() { [EOL] long instantAtCutover = iCutover; [EOL] int expectedMax = iGregorianField.getMaximumValue(instantAtCutover); [EOL] int actualMax = getMaximumValue(instantAtCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_JustBeforeCutoverAdjusted() { [EOL] long instantJustBeforeCutover = iJulianField.add(iCutover, -1); [EOL] int max = iJulianField.getMaximumValue(instantJustBeforeCutover); [EOL] long adjustedInstant = iJulianField.set(instantJustBeforeCutover, max); [EOL] if (adjustedInstant >= iCutover) { [EOL] max = iJulianField.get(instantJustBeforeCutover); [EOL] } [EOL] int expectedMax = max; [EOL] int actualMax = getMaximumValue(instantJustBeforeCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValueWithNullPartial() { [EOL] try { [EOL] getMaximumValue(null); [EOL] fail("Should have thrown IllegalArgumentException for null partial"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetMaximumValueWithValidPartial() { [EOL] ReadablePartial mockPartial = new MockPartial(); [EOL] int maxValue = getMaximumValue(mockPartial); [EOL] int expectedMaxValue = SOME_EXPECTED_VALUE; [EOL] assertEquals("The maximum value should be the expected one", expectedMaxValue, maxValue); [EOL] }
public void testRoundFloor_AfterCutover() { [EOL] long instant = iCutover + 1; // Some value after cutover [EOL] long expected = iGregorianField.roundFloor(instant); [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloor_AtCutover() { [EOL] long instant = iCutover; [EOL] long expected = iGregorianField.roundFloor(instant); [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloor_BeforeCutover() { [EOL] long instant = iCutover - 1; // Some value before cutover [EOL] long expected = iJulianField.roundFloor(instant); [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloor_GapBeforeCutover() { [EOL] long instant = iCutover - 1; // Some value before cutover [EOL] when(iGregorianField.roundFloor(instant)).thenReturn(instant); [EOL] when(iJulianField.roundFloor(instant)).thenReturn(instant); [EOL] long result = roundFloor(instant); [EOL] long expected = gregorianToJulian(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloor_GapAfterCutover() { [EOL] long instant = iCutover + iGapDuration - 1; // Some value in the gap after cutover [EOL] when(iGregorianField.roundFloor(instant)).thenReturn(instant - iGapDuration); [EOL] long result = roundFloor(instant); [EOL] long expected = gregorianToJulian(instant - iGapDuration); [EOL] assertEquals(expected, result); [EOL] }
public void testJulianToGregorianWithConvertByWeekyearTrue() { [EOL] setConvertByWeekyear(true); [EOL] long instant = SOME_JULIAN_INSTANT; [EOL] long expected = EXPECTED_GREGORIAN_INSTANT; [EOL] long actual = julianToGregorian(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testJulianToGregorianWithConvertByWeekyearFalse() { [EOL] setConvertByWeekyear(false); [EOL] long instant = SOME_JULIAN_INSTANT; [EOL] long expected = EXPECTED_GREGORIAN_INSTANT; [EOL] long actual = julianToGregorian(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGregorianToJulianWithConvertByWeekyearTrue() { [EOL] instance.iConvertByWeekyear = true; [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] long expected = instance.gregorianToJulianByWeekyear(instant); [EOL] long actual = instance.gregorianToJulian(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGregorianToJulianWithConvertByWeekyearFalse() { [EOL] instance.iConvertByWeekyear = false; [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] long expected = instance.gregorianToJulianByYear(instant); [EOL] long actual = instance.gregorianToJulian(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testImpreciseCutoverFieldWithNonNullFields() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] long cutoverMillis = 12345678L; [EOL] ImpreciseCutoverField field = new ImpreciseCutoverField(julianField, gregorianField, cutoverMillis); [EOL] assertNotNull(field); [EOL] }
public void testImpreciseCutoverFieldWithNullJulianField() { [EOL] DateTimeField julianField = null; [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] long cutoverMillis = 12345678L; [EOL] try { [EOL] new ImpreciseCutoverField(julianField, gregorianField, cutoverMillis); [EOL] fail("Should have thrown IllegalArgumentException because julianField is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testImpreciseCutoverFieldWithNullGregorianField() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = null; [EOL] long cutoverMillis = 12345678L; [EOL] try { [EOL] new ImpreciseCutoverField(julianField, gregorianField, cutoverMillis); [EOL] fail("Should have thrown IllegalArgumentException because gregorianField is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testImpreciseCutoverField_WithNonNullFields() { [EOL] DateTimeField julianField = new MockDateTimeField(); [EOL] DateTimeField gregorianField = new MockDateTimeField(); [EOL] DurationField durationField = new MockDurationField(); [EOL] long cutoverMillis = 123456789L; [EOL] ImpreciseCutoverField field = new ImpreciseCutoverField(julianField, gregorianField, durationField, cutoverMillis); [EOL] assertNotNull(field); [EOL] }
public void testImpreciseCutoverField_WithNonNullFields() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] DurationField durationField = mock(DurationField.class); [EOL] DurationField rangeDurationField = mock(DurationField.class); [EOL] long cutoverMillis = 123456789L; [EOL] ImpreciseCutoverField field = new ImpreciseCutoverField(julianField, gregorianField, durationField, rangeDurationField, cutoverMillis); [EOL] assertNotNull(field); [EOL] assertSame(julianField, field.getJulianField()); [EOL] assertSame(gregorianField, field.getGregorianField()); [EOL] assertSame(durationField, field.getDurationField()); [EOL] assertSame(rangeDurationField, field.getRangeDurationField()); [EOL] assertEquals(cutoverMillis, field.getCutoverMillis()); [EOL] }
public void testImpreciseCutoverFieldWithNonNullDurationField() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] DurationField durationField = mock(DurationField.class); [EOL] long cutoverMillis = 123456789L; [EOL] boolean convertByWeekyear = true; [EOL] ImpreciseCutoverField field = new ImpreciseCutoverField(julianField, gregorianField, durationField, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(field); [EOL] assertSame(durationField, field.getDurationField()); [EOL] }
public void testImpreciseCutoverFieldWithNullDurationField() { [EOL] DateTimeField julianField = mock(DateTimeField.class); [EOL] DateTimeField gregorianField = mock(DateTimeField.class); [EOL] long cutoverMillis = 123456789L; [EOL] boolean convertByWeekyear = false; [EOL] ImpreciseCutoverField field = new ImpreciseCutoverField(julianField, gregorianField, null, cutoverMillis, convertByWeekyear); [EOL] assertNotNull(field); [EOL] assertNotNull(field.getDurationField()); [EOL] }
public void testGetMaximumValue_AfterCutover() { [EOL] long instantAfterCutover = iCutover + 1; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iGregorianField.getMaximumValue(instantAfterCutover); // Assuming iGregorianField is a mockable field [EOL] int actualValue = getMaximumValue(instantAfterCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue_AtCutover() { [EOL] long instantAtCutover = iCutover; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iGregorianField.getMaximumValue(instantAtCutover); // Assuming iGregorianField is a mockable field [EOL] int actualValue = getMaximumValue(instantAtCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue_BeforeCutover() { [EOL] long instantBeforeCutover = iCutover - 1; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iJulianField.getMaximumValue(instantBeforeCutover); // Assuming iJulianField is a mockable field [EOL] int actualValue = getMaximumValue(instantBeforeCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testLinkedDurationFieldWithNonNullFields() { [EOL] DurationField mockDurationField = new MockDurationField(DurationFieldType.seconds()); [EOL] ImpreciseCutoverField mockDateTimeField = new MockImpreciseCutoverField(); [EOL] LinkedDurationField linkedDurationField = new LinkedDurationField(mockDurationField, mockDateTimeField); [EOL] assertNotNull(linkedDurationField); [EOL] assertEquals(mockDurationField.getType(), linkedDurationField.getType()); [EOL] assertSame(mockDateTimeField, linkedDurationField.getField()); [EOL] }
public long getInstantMillisTest() { [EOL] Object object = new Object(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long millis = getInstantMillis(object, chrono); [EOL] long expectedMillis = DateTimeUtils.currentTimeMillis(); [EOL] assertEquals(expectedMillis, millis); [EOL] }
public void testGetChronologyWithNullZone() { [EOL] Object object = new Object(); [EOL] DateTimeZone zone = null; [EOL] Chronology result = getChronology(object, zone); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetChronologyWithNonNullZone() { [EOL] Object object = new Object(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Chronology result = getChronology(object, zone); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] assertEquals("Europe/Paris", result.getZone().getID()); [EOL] }
public void testGetPeriodTypeWithNull() { [EOL] PeriodType result = getPeriodType(null); [EOL] assertNotNull(result); [EOL] assertEquals(PeriodType.standard(), result); [EOL] }
public void testGetPartialValuesWithNonNullParserZone() { [EOL] ReadablePartial mockFieldSource = mock(ReadablePartial.class); [EOL] Object mockObject = "2023-03-15T12:34:56"; [EOL] Chronology mockChrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeFormatter mockParser = mock(DateTimeFormatter.class); [EOL] DateTimeZone mockZone = DateTimeZone.forID("Europe/London"); [EOL] when(mockParser.getZone()).thenReturn(mockZone); [EOL] when(mockParser.withChronology(any(Chronology.class))).thenReturn(mockParser); [EOL] when(mockParser.parseMillis(anyString())).thenReturn(1234567890L); [EOL] when(mockChrono.withZone(mockZone)).thenReturn(mockChrono); [EOL] when(mockChrono.get(mockFieldSource, 1234567890L)).thenReturn(new int[]{1, 2, 3}); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono, mockParser); [EOL] verify(mockParser).withChronology(mockChrono.withZone(mockZone)); [EOL] verify(mockChrono).get(mockFieldSource, 1234567890L); [EOL] assertArrayEquals(new int[]{1, 2, 3}, result); [EOL] }
public void testGetPartialValuesWithNullParserZone() { [EOL] ReadablePartial mockFieldSource = mock(ReadablePartial.class); [EOL] Object mockObject = "2023-03-15T12:34:56"; [EOL] Chronology mockChrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeFormatter mockParser = mock(DateTimeFormatter.class); [EOL] when(mockParser.getZone()).thenReturn(null); [EOL] when(mockParser.withChronology(any(Chronology.class))).thenReturn(mockParser); [EOL] when(mockParser.parseMillis(anyString())).thenReturn(1234567890L); [EOL] when(mockChrono.get(mockFieldSource, 1234567890L)).thenReturn(new int[]{4, 5, 6}); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono, mockParser); [EOL] verify(mockParser).withChronology(mockChrono); [EOL] verify(mockChrono).get(mockFieldSource, 1234567890L); [EOL] assertArrayEquals(new int[]{4, 5, 6}, result); [EOL] }
public void testSetIntoWithInvalidSeparator() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "invalidFormat"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format requires a '/' separator: invalidFormat", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyLeftPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "/P1Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: /P1Y", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyRightPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: P1Y/", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithTwoDurations() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/P2Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Interval composed of two durations: P1Y/P2Y", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithPeriodAndDateTime() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/2023-01-01T00:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithDateTimeAndPeriod() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2023-01-01T00:00:00Z/P1Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithTwoDateTimes() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2023-01-01T00:00:00Z/2024-01-01T00:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void setInto_withValidPeriodAndChronology() { [EOL] ReadWritablePeriod mockDuration = mock(ReadWritablePeriod.class); [EOL] ReadablePeriod mockReadablePeriod = mock(ReadablePeriod.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] new Time().setInto(mockDuration, mockReadablePeriod, mockChronology); [EOL] verify(mockDuration).setPeriod(mockReadablePeriod); [EOL] }
public void setInto_withNullDuration() { [EOL] Object mockReadablePeriod = mock(ReadablePeriod.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] try { [EOL] new Time().setInto(null, mockReadablePeriod, mockChronology); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void setInto_withNullReadablePeriod() { [EOL] ReadWritablePeriod mockDuration = mock(ReadWritablePeriod.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] try { [EOL] new Time().setInto(mockDuration, null, mockChronology); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testSkipUndoDateTimeFieldWithNullChronologyAndField() { [EOL] SkipUndoDateTimeField result = new SkipUndoDateTimeField(null, null); [EOL] assertNull(result.getChronology()); [EOL] assertNull(result.getField()); [EOL] }
public void testSkipUndoDateTimeFieldWithNonNullChronologyAndField() { [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] SkipUndoDateTimeField result = new SkipUndoDateTimeField(mockChronology, mockField); [EOL] assertNotNull(result.getChronology()); [EOL] assertNotNull(result.getField()); [EOL] }
public void testSkipUndoDateTimeField_MinLessThanSkip() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(3); [EOL] int skip = 5; [EOL] SkipUndoDateTimeField field = new SkipUndoDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(4, field.getMinimumValue()); [EOL] }
public void testSkipUndoDateTimeField_MinEqualToSkipPlusOne() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(6); [EOL] int skip = 5; [EOL] SkipUndoDateTimeField field = new SkipUndoDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(5, field.getMinimumValue()); [EOL] }
public void testSkipUndoDateTimeField_MinGreaterThanSkipPlusOne() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(8); [EOL] int skip = 5; [EOL] SkipUndoDateTimeField field = new SkipUndoDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(8, field.getMinimumValue()); [EOL] }
public void testSet_ValueWithinBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue; // Assuming iMinValue is a valid value within bounds [EOL] long expected = millis; // Assuming this is the expected behavior of super.set() [EOL] long result = set(millis, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSet_ValueBelowBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue - 1; // Value below minimum bound [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSet_ValueAboveBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = getMaximumValue() + 1; // Assuming getMaximumValue() is the maximum valid value [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSet_ValueAtSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip; // Assuming iSkip is a valid value that should be skipped [EOL] long expected = millis; // Assuming this is the expected behavior of super.set() [EOL] long result = set(millis, value - 1); // Value is decremented in the method if equal to iSkip [EOL] assertEquals(expected, result); [EOL] }
public void testSet_ValueJustAboveSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip + 1; // Value just above the skip value [EOL] long expected = millis; // Assuming this is the expected behavior of super.set() [EOL] long result = set(millis, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMinimumValue() { [EOL] Time time = new Time(); // Assuming there is a constructor available [EOL] int expected = 0; // Replace with the actual expected minimum value [EOL] int actual = time.getMinimumValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAppend_ThrowsIllegalArgumentException_WhenBothPrinterAndParserAreNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.append(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppend_ClearsPrefixAndAppends_WhenPrinterIsNotNullAndParserIsNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] builder.append(printer, null); [EOL] }
public void testAppend_ClearsPrefixAndAppends_WhenPrinterIsNullAndParserIsNotNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append(null, parser); [EOL] }
public void testAppend_ClearsPrefixAndAppends_WhenBothPrinterAndParserAreNotNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append(printer, parser); [EOL] }
public void testPrintZeroRarelyLast() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder returnedBuilder = builder.printZeroRarelyLast(); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] assertEquals(PeriodFormatterBuilder.PRINT_ZERO_RARELY_LAST, returnedBuilder.getPrintZeroSetting()); [EOL] }
public void testAppendSeconds() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendSeconds(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendSuffixWithEmptyElementPairs() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSuffix(null); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No field to apply suffix to", e.getMessage()); [EOL] } [EOL] }
public void testAppendSuffixWithNonEmptyElementPairsDifferentPrinterParser() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendDays(); // Adds a FieldFormatter to the element pairs [EOL] builder.appendSuffix(null); // This should fail because the printer and parser are not the same [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No field to apply suffix to", e.getMessage()); [EOL] } [EOL] }
public void testAppendSuffixWithNonEmptyElementPairsSamePrinterParser() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendDays(); // Adds a FieldFormatter to the element pairs [EOL] PeriodFieldAffix mockSuffix = new PeriodFieldAffix() { [EOL] public int calculatePrintedLength(int value) { return 0; } [EOL] public void printTo(StringBuffer buf, int value) {} [EOL] public void printTo(Writer out, int value) {} [EOL] public int parse(String periodStr, ParsePosition pos) { return 0; } [EOL] public int scan(String periodStr, ParsePosition pos) { return 0; } [EOL] }; [EOL] builder.appendSuffix(mockSuffix); [EOL] }
public void testAppendSeparatorIfFieldsAfter() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendSeparatorIfFieldsAfter(","); [EOL] assertNotNull(result); [EOL] }
public void testAppendSeparatorWithNonNullTexts() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSeparator("separator", "finalSeparator"); [EOL] }
public void testAppendSeparatorWithNullText() { [EOL] try { [EOL] appendSeparator(null, "finalText", new String[]{"variant"}, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAppendSeparatorWithNullFinalText() { [EOL] try { [EOL] appendSeparator("text", null, new String[]{"variant"}, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAppendSeparatorWithEmptyPairsAndUseAfterOnly() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder = builder.appendSeparator("text", "finalText", new String[]{"variant"}, false, true); [EOL] } [EOL] public void testAppendSeparatorWithAdjacentSeparators() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSeparator("text", "finalText", new String[]{"variant"}, true, true); [EOL] try { [EOL] builder.appendSeparator("text", "finalText", new String[]{"variant"}, true, true); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] } [EOL] public void testAppendSeparatorWithNonEmptyPairs() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendLiteral("literal"); [EOL] builder = builder.appendSeparator("text", "finalText", new String[]{"variant"}, true, true); [EOL] }
public void testToFormatter_ThrowsIllegalStateException() { [EOL] try { [EOL] toFormatter(new ArrayList<>(), true, true); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Builder has created neither a printer nor a parser", e.getMessage()); [EOL] } [EOL] }
public void testToFormatter_WithSeparatorAndNullAfterParserPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Separator(null, null, null, null, null)); [EOL] elementPairs.add(new Object()); [EOL] PeriodFormatter result = toFormatter(elementPairs, false, false); [EOL] assertNotNull(result); [EOL] }
public void testToFormatter_WithNotPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] PeriodFormatter result = toFormatter(elementPairs, true, false); [EOL] assertNotNull(result.getParser()); [EOL] assertNull(result.getPrinter()); [EOL] }
public void testToFormatter_WithNotParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] PeriodFormatter result = toFormatter(elementPairs, false, true); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNull(result.getParser()); [EOL] }
public void testToFormatter_WithPrinterAndParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] PeriodFormatter result = toFormatter(elementPairs, false, false); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testCreateCompositeWithEmptyList() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertSame("Expected both elements to be Literal.EMPTY", Literal.EMPTY, result[0]); [EOL] assertSame("Expected both elements to be Literal.EMPTY", Literal.EMPTY, result[1]); [EOL] }
public void testCreateCompositeWithOneElementPair() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add("First"); [EOL] elementPairs.add("Second"); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertEquals("Expected first element to match", "First", result[0]); [EOL] assertEquals("Expected second element to match", "Second", result[1]); [EOL] }
public void testCreateCompositeWithMultipleElementPairs() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add("First"); [EOL] elementPairs.add("Second"); [EOL] elementPairs.add("Third"); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertTrue("Expected first element to be instance of Composite", result[0] instanceof Composite); [EOL] assertSame("Expected both elements to be the same Composite instance", result[0], result[1]); [EOL] }
public void testCountFieldsToPrint_StopAtLessThanOrEqualToZero() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 0; [EOL] Locale mockLocale = mock(Locale.class); [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(0, result); [EOL] }
public void testCountFieldsToPrint_PrintZeroAlways() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 1; [EOL] Locale mockLocale = mock(Locale.class); [EOL] iPrintZeroSetting = PRINT_ZERO_ALWAYS; [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(1, result); [EOL] }
public void testCountFieldsToPrint_FieldValueNotMax() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1L); [EOL] int stopAt = 1; [EOL] Locale mockLocale = mock(Locale.class); [EOL] iPrintZeroSetting = PRINT_ZERO_RARELY; // Assuming PRINT_ZERO_RARELY is a valid setting that is not PRINT_ZERO_ALWAYS [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(1, result); [EOL] }
public void testCalculatePrintedLength_MaxValue() { [EOL] ReadablePeriod period = createMockReadablePeriodWithMaxValue(); [EOL] Locale locale = Locale.getDefault(); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCalculatePrintedLength_NegativeValue() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValue(-12345L); [EOL] Locale locale = Locale.getDefault(); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertTrue(result >= 5); [EOL] } [EOL] public void testCalculatePrintedLength_PositiveValue() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValue(12345L); [EOL] Locale locale = Locale.getDefault(); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertTrue(result >= 4); [EOL] } [EOL] public void testCalculatePrintedLength_WithPrefix() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValue(12345L); [EOL] Locale locale = Locale.getDefault(); [EOL] setPrefixMockWithPrintedLength(3); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertTrue(result > 0); // Assuming prefix length is added correctly [EOL] } [EOL] public void testCalculatePrintedLength_WithSuffix() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValue(12345L); [EOL] Locale locale = Locale.getDefault(); [EOL] setSuffixMockWithPrintedLength(3); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertTrue(result > 0); // Assuming suffix length is added correctly [EOL] } [EOL] public void testCalculatePrintedLength_WithSecondsOptionalMillis() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValue(DateTimeConstants.MILLIS_PER_SECOND); [EOL] Locale locale = Locale.getDefault(); [EOL] setFieldTypeToSecondsOptionalMillis(); [EOL] int result = calculatePrintedLength(period, locale); [EOL] assertEquals(1, result); // Assuming the optional millis part is subtracted correctly [EOL] }

public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL] long valueLong = getFieldValue(period); [EOL] if (valueLong == Long.MAX_VALUE) { [EOL] return; [EOL] } [EOL] int value = (int) valueLong; [EOL] if (iFieldType >= SECONDS_MILLIS) { [EOL] value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL] } [EOL] if (iPrefix != null) { [EOL] iPrefix.printTo(buf, value); [EOL] } [EOL] int bufLen = buf.length(); [EOL] int minDigits = iMinPrintedDigits; [EOL] if (minDigits <= 1) { [EOL] FormatUtils.appendUnpaddedInteger(buf, value); [EOL] } else { [EOL] FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL] } [EOL] if (iFieldType >= SECONDS_MILLIS) { [EOL] int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL] if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL] if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL] buf.insert(bufLen, '-'); [EOL] } [EOL] buf.append('.'); [EOL] FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL] } [EOL] } [EOL] if (iSuffix != null) { [EOL] iSuffix.printTo(buf, value); [EOL] } [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL] boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL] if (position >= text.length()) { [EOL] return mustParse ? ~position : position; [EOL] } [EOL] if (iPrefix != null) { [EOL] position = iPrefix.parse(text, position); [EOL] if (position >= 0) { [EOL] mustParse = true; [EOL] } else { [EOL] if (!mustParse) { [EOL] return ~position; [EOL] } [EOL] return position; [EOL] } [EOL] } [EOL] int suffixPos = -1; [EOL] if (iSuffix != null && !mustParse) { [EOL] suffixPos = iSuffix.scan(text, position); [EOL] if (suffixPos >= 0) { [EOL] mustParse = true; [EOL] } else { [EOL] if (!mustParse) { [EOL] return ~suffixPos; [EOL] } [EOL] return suffixPos; [EOL] } [EOL] } [EOL] if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL] return position; [EOL] } [EOL] int limit; [EOL] if (suffixPos > 0) { [EOL] limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL] } else { [EOL] limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL] } [EOL] int length = 0; [EOL] int fractPos = -1; [EOL] boolean hasDigits = false; [EOL] while (length < limit) { [EOL] char c = text.charAt(position + length); [EOL] if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL] boolean negative = c == '-'; [EOL] if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL] break; [EOL] } [EOL] if (negative) { [EOL] length++; [EOL] } else { [EOL] position++; [EOL] } [EOL] limit = Math.min(limit + 1, text.length() - position); [EOL] continue; [EOL] } [EOL] if (c >= '0' && c <= '9') { [EOL] hasDigits = true; [EOL] } else { [EOL] if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL] if (fractPos >= 0) { [EOL] break; [EOL] } [EOL] fractPos = position + length + 1; [EOL] limit = Math.min(limit + 1, text.length() - position); [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] length++; [EOL] } [EOL] if (!hasDigits) { [EOL] return ~position; [EOL] } [EOL] if (suffixPos >= 0 && position + length != suffixPos) { [EOL] return position; [EOL] } [EOL] if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL] setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL] } else if (fractPos < 0) { [EOL] setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL] setFieldValue(period, MILLIS, 0); [EOL] } else { [EOL] int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL] setFieldValue(period, SECONDS, wholeValue); [EOL] int fractLen = position + length - fractPos; [EOL] int fractValue; [EOL] if (fractLen <= 0) { [EOL] fractValue = 0; [EOL] } else { [EOL] if (fractLen >= 3) { [EOL] fractValue = parseInt(text, fractPos, 3); [EOL] } else { [EOL] fractValue = parseInt(text, fractPos, fractLen); [EOL] if (fractLen == 1) { [EOL] fractValue *= 100; [EOL] } else { [EOL] fractValue *= 10; [EOL] } [EOL] } [EOL] if (wholeValue < 0) { [EOL] fractValue = -fractValue; [EOL] } [EOL] } [EOL] setFieldValue(period, MILLIS, fractValue); [EOL] } [EOL] position += length; [EOL] if (position >= 0 && iSuffix != null) { [EOL] position = iSuffix.parse(text, position); [EOL] } [EOL] return position; [EOL] }
public void testParseIntWithLengthGreaterThanNine() { [EOL] int result = parseInt("12345678901", 0, 10); [EOL] assertEquals(1234567890, result); [EOL] }
public void testParseIntWithLengthLessThanOrEqualToZero() { [EOL] int result = parseInt("123", 1, 0); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntWithNegativeNumber() { [EOL] int result = parseInt("-123", 0, 4); [EOL] assertEquals(-123, result); [EOL] }
public void testParseIntWithPositiveNumber() { [EOL] int result = parseInt("123", 0, 3); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithLengthOneAndNegative() { [EOL] int result = parseInt("-1", 0, 2); [EOL] assertEquals(-1, result); [EOL] }
public void testParseIntWithLengthOneAndPositive() { [EOL] int result = parseInt("1", 0, 1); [EOL] assertEquals(1, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeNotSupported() { [EOL] ReadablePeriod period = createPeriodWithUnsupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_TypeNotNullAndFieldTypeSupported() { [EOL] ReadablePeriod period = createPeriodWithTypeAndSupportedField(); [EOL] setPrintZeroSetting(NOT_PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_TypeIsNull() { [EOL] ReadablePeriod period = createPeriodWithNullType(); [EOL] setPrintZeroSetting(NOT_PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroNever() { [EOL] ReadablePeriod period = createPeriodWithZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastWithNonZeroFieldsAfter() { [EOL] ReadablePeriod period = createPeriodWithZeroValueAndNonZeroFieldsAfter(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastWithZeroFieldsAfter() { [EOL] ReadablePeriod period = createPeriodWithZeroValueAndZeroFieldsAfter(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstWithNonZeroFieldsBefore() { [EOL] ReadablePeriod period = createPeriodWithZeroValueAndNonZeroFieldsBefore(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstWithZeroFieldsBefore() { [EOL] ReadablePeriod period = createPeriodWithZeroValueAndZeroFieldsBefore(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseYears() { [EOL] ReadablePeriod period = createPeriodWithYearsField(); [EOL] setFieldType(YEARS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseMonths() { [EOL] ReadablePeriod period = createPeriodWithMonthsField(); [EOL] setFieldType(MONTHS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseWeeks() { [EOL] ReadablePeriod period = createPeriodWithWeeksField(); [EOL] setFieldType(WEEKS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseDays() { [EOL] ReadablePeriod period = createPeriodWithDaysField(); [EOL] setFieldType(DAYS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseHours() { [EOL] ReadablePeriod period = createPeriodWithHoursField(); [EOL] setFieldType(HOURS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseMinutes() { [EOL] ReadablePeriod period = createPeriodWithMinutesField(); [EOL] setFieldType(MINUTES); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseSeconds() { [EOL] ReadablePeriod period = createPeriodWithSecondsField(); [EOL] setFieldType(SECONDS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseMillis() { [EOL] ReadablePeriod period = createPeriodWithMillisField(); [EOL] setFieldType(MILLIS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseSecondsMillis() { [EOL] ReadablePeriod period = createPeriodWithSecondsAndMillisField(); [EOL] setFieldType(SECONDS_MILLIS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_SwitchCaseSecondsOptionalMillis() { [EOL] ReadablePeriod period = createPeriodWithSecondsAndOptionalMillisField(); [EOL] setFieldType(SECONDS_OPTIONAL_MILLIS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] }
public void testIsZeroWithNonZeroPeriod() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(period.size()).thenReturn(3); [EOL] when(period.getValue(0)).thenReturn(1); [EOL] when(period.getValue(1)).thenReturn(0); [EOL] when(period.getValue(2)).thenReturn(0); [EOL] boolean result = isZero(period); [EOL] assertFalse(result); [EOL] }
public void testIsZeroWithZeroPeriod() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(period.size()).thenReturn(3); [EOL] when(period.getValue(0)).thenReturn(0); [EOL] when(period.getValue(1)).thenReturn(0); [EOL] when(period.getValue(2)).thenReturn(0); [EOL] boolean result = isZero(period); [EOL] assertTrue(result); [EOL] }
public void testIsZeroWithEmptyPeriod() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(period.size()).thenReturn(0); [EOL] boolean result = isZero(period); [EOL] assertTrue(result); [EOL] }
public void testSetFieldValueWithYears() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = YEARS; [EOL] int value = 10; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setYears(value); [EOL] }
public void testSetFieldValueWithMonths() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MONTHS; [EOL] int value = 5; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMonths(value); [EOL] }
public void testSetFieldValueWithWeeks() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = WEEKS; [EOL] int value = 3; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setWeeks(value); [EOL] }
public void testSetFieldValueWithDays() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = DAYS; [EOL] int value = 7; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setDays(value); [EOL] }
public void testSetFieldValueWithHours() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = HOURS; [EOL] int value = 24; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setHours(value); [EOL] }
public void testSetFieldValueWithMinutes() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MINUTES; [EOL] int value = 45; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMinutes(value); [EOL] }
public void testSetFieldValueWithSeconds() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = SECONDS; [EOL] int value = 30; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setSeconds(value); [EOL] }
public void testSetFieldValueWithMillis() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MILLIS; [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMillis(value); [EOL] }
public void testSetFieldValueWithInvalidField() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = -1; // Assuming -1 is an invalid field value [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verifyNoInteractions(mockPeriod); [EOL] }
public void testParseInto_MatchAtPosition() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String periodStr = "prefixText"; [EOL] int position = 6; [EOL] Locale mockLocale = mock(Locale.class); [EOL] TimeParser parser = new TimeParser("Text"); [EOL] int result = parser.parseInto(mockPeriod, periodStr, position, mockLocale); [EOL] assertEquals(position + "Text".length(), result); [EOL] }
public void testParseInto_NoMatchAtPosition() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String periodStr = "prefixtext"; [EOL] int position = 0; [EOL] Locale mockLocale = mock(Locale.class); [EOL] TimeParser parser = new TimeParser("Mismatch"); [EOL] int result = parser.parseInto(mockPeriod, periodStr, position, mockLocale); [EOL] assertEquals(~position, result); [EOL] }
public void testSeparatorWithNullFinalTextAndNoVariants() { [EOL] String text = "Text"; [EOL] String finalText = null; [EOL] String[] variants = null; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = false; [EOL] boolean useAfter = false; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be null", finalText, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain only one element", 1, separator.iParsedForms.length); [EOL] assertEquals("Parsed forms should contain the text", text, separator.iParsedForms[0]); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertFalse("Use before should be false", separator.iUseBefore); [EOL] assertFalse("Use after should be false", separator.iUseAfter); [EOL] }
public void testSeparatorWithEqualTextAndFinalTextAndNoVariants() { [EOL] String text = "Text"; [EOL] String finalText = "Text"; [EOL] String[] variants = new String[0]; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = true; [EOL] boolean useAfter = true; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be equal to text", text, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain only one element", 1, separator.iParsedForms.length); [EOL] assertEquals("Parsed forms should contain the text", text, separator.iParsedForms[0]); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertTrue("Use before should be true", separator.iUseBefore); [EOL] assertTrue("Use after should be true", separator.iUseAfter); [EOL] }
public void testSeparatorWithDifferentTextFinalTextAndVariants() { [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] String[] variants = new String[] {"Variant1", "Variant2"}; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = true; [EOL] boolean useAfter = false; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be set correctly", finalText, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain all elements", 3, separator.iParsedForms.length); [EOL] assertTrue("Parsed forms should contain the text", Arrays.asList(separator.iParsedForms).contains(text)); [EOL] assertTrue("Parsed forms should contain the final text", Arrays.asList(separator.iParsedForms).contains(finalText)); [EOL] assertTrue("Parsed forms should contain variant1", Arrays.asList(separator.iParsedForms).contains("Variant1")); [EOL] assertTrue("Parsed forms should contain variant2", Arrays.asList(separator.iParsedForms).contains("Variant2")); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertTrue("Use before should be true", separator.iUseBefore); [EOL] assertFalse("Use after should be false", separator.iUseAfter); [EOL] }
public void testCountFieldsToPrintStopAtNotReached() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] int stopAt = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter beforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter afterPrinter = mock(PeriodPrinter.class); [EOL] when(beforePrinter.countFieldsToPrint(period, stopAt, locale)).thenReturn(3); [EOL] when(afterPrinter.countFieldsToPrint(period, stopAt, locale)).thenReturn(2); [EOL] PeriodFormatter formatter = new PeriodFormatter(beforePrinter, afterPrinter); [EOL] int result = formatter.countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(5, result); [EOL] }
public void testCountFieldsToPrintStopAtReached() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] int stopAt = 3; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter beforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter afterPrinter = mock(PeriodPrinter.class); [EOL] when(beforePrinter.countFieldsToPrint(period, stopAt, locale)).thenReturn(3); [EOL] when(afterPrinter.countFieldsToPrint(period, stopAt, locale)).thenReturn(1); [EOL] PeriodFormatter formatter = new PeriodFormatter(beforePrinter, afterPrinter); [EOL] int result = formatter.countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(3, result); [EOL] }
public void testCalculatePrintedLength_BothBeforeAndAfterUsedWithMultipleFields() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, mockLocale)).thenReturn(2); [EOL] when(iText.length()).thenReturn(4); [EOL] when(iFinalText.length()).thenReturn(6); [EOL] iUseBefore = true; [EOL] iUseAfter = true; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(14, result); [EOL] }
public void testCalculatePrintedLength_OnlyBeforeUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] iUseBefore = true; [EOL] iUseAfter = false; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(5, result); [EOL] }
public void testCalculatePrintedLength_OnlyAfterUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(iText.length()).thenReturn(4); [EOL] iUseBefore = false; [EOL] iUseAfter = true; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(7, result); [EOL] }
public void testCalculatePrintedLength_NoFieldsPrinted() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] iUseBefore = true; [EOL] iUseAfter = true; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(8, result); [EOL] }
public void testPrintToWithBeforeAndAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(1, "BeforeText"); [EOL] PeriodPrinter after = createMockPeriodPrinter(1, "AfterText"); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = true; [EOL] boolean useAfter = true; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("BeforeTextTextAfterText", buf.toString()); [EOL] }
public void testPrintToWithBeforeOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(1, "BeforeText"); [EOL] PeriodPrinter after = createMockPeriodPrinter(0, ""); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = true; [EOL] boolean useAfter = false; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("BeforeTextText", buf.toString()); [EOL] }
public void testPrintToWithAfterOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(0, ""); [EOL] PeriodPrinter after = createMockPeriodPrinter(1, "AfterText"); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = false; [EOL] boolean useAfter = true; [EOL] String text = "Text"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, ""); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("TextAfterText", buf.toString()); [EOL] }
public void testPrintToWithNeitherBeforeNorAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(0, ""); [EOL] PeriodPrinter after = createMockPeriodPrinter(0, ""); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = false; [EOL] boolean useAfter = false; [EOL] String text = "Text"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, ""); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testParseIntoWithNegativePosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = -1; [EOL] Locale locale = Locale.getDefault(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Negative initial position should return negative", position, result); [EOL] } [EOL] public void testParseIntoWithFoundParsedForm() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setParsedForms(new String[]{"Form"}); [EOL] setBeforeParser(new MockParser(5)); [EOL] setAfterParser(new MockParser(10)); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Position should be updated correctly when parsed form is found", 10, result); [EOL] } [EOL] public void testParseIntoWithNotFoundParsedFormAndUseBeforeFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setParsedForms(new String[]{""}); // Assuming empty string represents not found [EOL] setBeforeParser(new MockParser(5)); [EOL] setAfterParser(new MockParser(10)); [EOL] setUseBefore(false); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Position should be negated when parsed form is not found and useBefore is false", ~5, result); [EOL] } [EOL] public void testParseIntoWithFoundParsedFormAndNoChangeInPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setParsedForms(new String[]{"Form"}); [EOL] setBeforeParser(new MockParser(5)); [EOL] setAfterParser(new MockParser(5)); // No change in position after parsing [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Position should be negated when parsed form is found but no change in position", ~5, result); [EOL] } [EOL] private ReadWritablePeriod createMockPeriod() { [EOL] return null; [EOL] } [EOL] private void setParsedForms(String[] parsedForms) { [EOL] } [EOL] private void setBeforeParser(MockParser beforeParser) { [EOL] } [EOL] private void setAfterParser(MockParser afterParser) { [EOL] } [EOL] private void setUseBefore(boolean useBefore) { [EOL] } [EOL] class MockParser { [EOL] private final int advanceBy; [EOL] MockParser(int advanceBy) { [EOL] this.advanceBy = advanceBy; [EOL] } [EOL] int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL] return position + advanceBy; [EOL] } [EOL] }
public void testFinishWithNonNullAfterPrinterAndParser() { [EOL] Separator sep = new Separator(); [EOL] PeriodPrinter mockPrinter = mock(PeriodPrinter.class); [EOL] PeriodParser mockParser = mock(PeriodParser.class); [EOL] Separator result = sep.finish(mockPrinter, mockParser); [EOL] assertNotNull(result); [EOL] assertSame(sep, result); [EOL] }
public void testFinishWithNullAfterPrinterAndParser() { [EOL] Separator sep = new Separator(); [EOL] Separator result = sep.finish(null, null); [EOL] assertNotNull(result); [EOL] assertSame(sep, result); [EOL] }
public void testParseInto_ThrowsUnsupportedOperationException() { [EOL] try { [EOL] PeriodFormatter pf = new PeriodFormatter(null, null); [EOL] pf.parseInto(null, "", 0, Locale.getDefault()); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testParseInto_ValidInput() { [EOL] PeriodParser parser1 = mock(PeriodParser.class); [EOL] PeriodParser parser2 = mock(PeriodParser.class); [EOL] ReadWritablePeriod period = mock(ReadWritablePeriod.class); [EOL] String periodStr = "P1Y2M3D"; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodParser[] parsers = new PeriodParser[] {parser1, parser2}; [EOL] when(parser1.parseInto(period, periodStr, 0, locale)).thenReturn(3); [EOL] when(parser2.parseInto(period, periodStr, 3, locale)).thenReturn(7); [EOL] PeriodFormatter pf = new PeriodFormatter(parsers, null); [EOL] int position = pf.parseInto(period, periodStr, 0, locale); [EOL] assertEquals(7, position); [EOL] verify(parser1).parseInto(period, periodStr, 0, locale); [EOL] verify(parser2).parseInto(period, periodStr, 3, locale); [EOL] }
public void testParseInto_EarlyTermination() { [EOL] PeriodParser parser1 = mock(PeriodParser.class); [EOL] ReadWritablePeriod period = mock(ReadWritablePeriod.class); [EOL] String periodStr = "P1Y2M3D"; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodParser[] parsers = new PeriodParser[] {parser1}; [EOL] when(parser1.parseInto(period, periodStr, 0, locale)).thenReturn(-1); [EOL] PeriodFormatter pf = new PeriodFormatter(parsers, null); [EOL] int position = pf.parseInto(period, periodStr, 0, locale); [EOL] assertEquals(-1, position); [EOL] verify(parser1).parseInto(period, periodStr, 0, locale); [EOL] }
public void testDecomposeWithEmptyList() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertTrue(printerList.isEmpty()); [EOL] assertTrue(parserList.isEmpty()); [EOL] }
public void testDecomposeWithNonCompositePrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] PeriodPrinter printer = new SimplePeriodPrinter(); [EOL] elementPairs.add(printer); [EOL] elementPairs.add(new Object()); // Adding a non-parser object [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(1, printerList.size()); [EOL] assertTrue(printerList.contains(printer)); [EOL] assertTrue(parserList.isEmpty()); [EOL] }
public void testDecomposeWithNonCompositeParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); // Adding a non-printer object [EOL] PeriodParser parser = new SimplePeriodParser(); [EOL] elementPairs.add(parser); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertTrue(printerList.isEmpty()); [EOL] assertEquals(1, parserList.size()); [EOL] assertTrue(parserList.contains(parser)); [EOL] }
public void testDecomposeWithCompositePrinterAndParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] Composite compositePrinter = new Composite(new PeriodPrinter[]{new SimplePeriodPrinter()}); [EOL] Composite compositeParser = new Composite(new PeriodParser[]{new SimplePeriodParser()}); [EOL] elementPairs.add(compositePrinter); [EOL] elementPairs.add(compositeParser); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(1, printerList.size()); [EOL] assertTrue(printerList.containsAll(Arrays.asList(compositePrinter.iPrinters))); [EOL] assertEquals(1, parserList.size()); [EOL] assertTrue(parserList.containsAll(Arrays.asList(compositeParser.iParsers))); [EOL] }
public void testAddArrayToListWithNonNullArray() { [EOL] List<Object> list = new ArrayList<>(); [EOL] Object[] array = {1, 2, 3}; [EOL] addArrayToList(list, array); [EOL] assertEquals(3, list.size()); [EOL] assertEquals(1, list.get(0)); [EOL] assertEquals(2, list.get(1)); [EOL] assertEquals(3, list.get(2)); [EOL] }
public void testAddArrayToListWithNullArray() { [EOL] List<Object> list = new ArrayList<>(); [EOL] addArrayToList(list, null); [EOL] assertTrue(list.isEmpty()); [EOL] }
public void testGetWithValidInstant() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with an actual instant value [EOL] int expectedWeekyear = EXPECTED_WEEKYEAR; // Replace with the expected weekyear [EOL] int actualWeekyear = instance.get(instant); [EOL] assertEquals(expectedWeekyear, actualWeekyear); [EOL] }
public void testGetRangeDurationField_ReturnsNull() { [EOL] Time time = new Time(); [EOL] assertNull("Range duration field should be null", time.getRangeDurationField()); [EOL] }
public void testGetLeapDurationField() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeField field = new DateTimeField(chronology); [EOL] DurationField leapDurationField = field.getLeapDurationField(); [EOL] assertNotNull(leapDurationField); [EOL] assertEquals("weeks", leapDurationField.getType().getName()); [EOL] }
public static DateTimeFormatter shortDate() { [EOL] return createFormatterForStyleIndex(SHORT, NONE); [EOL] }
public static DateTimeFormatter fullDate() { [EOL] return createFormatterForStyleIndex(FULL, NONE); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] parsePatternTo(builder, pattern); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] int length = pattern.length(); [EOL] int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] String token = parseToken(pattern, indexRef); [EOL] i = indexRef[0]; [EOL] int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] builder.appendEraText(); [EOL] break; [EOL] case 'C': [EOL] builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL] break; [EOL] case 'x': [EOL] case 'y': [EOL] case 'Y': [EOL] if (tokenLen == 2) { [EOL] boolean lenientParse = true; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] lenientParse = false; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL] break; [EOL] case 'y': [EOL] case 'Y': [EOL] default: [EOL] builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL] break; [EOL] } [EOL] } else { [EOL] int maxDigits = 9; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] maxDigits = tokenLen; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendWeekyear(tokenLen, maxDigits); [EOL] break; [EOL] case 'y': [EOL] builder.appendYear(tokenLen, maxDigits); [EOL] break; [EOL] case 'Y': [EOL] builder.appendYearOfEra(tokenLen, maxDigits); [EOL] break; [EOL] } [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 3) { [EOL] if (tokenLen >= 4) { [EOL] builder.appendMonthOfYearText(); [EOL] } else { [EOL] builder.appendMonthOfYearShortText(); [EOL] } [EOL] } else { [EOL] builder.appendMonthOfYear(tokenLen); [EOL] } [EOL] break; [EOL] case 'd': [EOL] builder.appendDayOfMonth(tokenLen); [EOL] break; [EOL] case 'a': [EOL] builder.appendHalfdayOfDayText(); [EOL] break; [EOL] case 'h': [EOL] builder.appendClockhourOfHalfday(tokenLen); [EOL] break; [EOL] case 'H': [EOL] builder.appendHourOfDay(tokenLen); [EOL] break; [EOL] case 'k': [EOL] builder.appendClockhourOfDay(tokenLen); [EOL] break; [EOL] case 'K': [EOL] builder.appendHourOfHalfday(tokenLen); [EOL] break; [EOL] case 'm': [EOL] builder.appendMinuteOfHour(tokenLen); [EOL] break; [EOL] case 's': [EOL] builder.appendSecondOfMinute(tokenLen); [EOL] break; [EOL] case 'S': [EOL] builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL] break; [EOL] case 'e': [EOL] builder.appendDayOfWeek(tokenLen); [EOL] break; [EOL] case 'E': [EOL] if (tokenLen >= 4) { [EOL] builder.appendDayOfWeekText(); [EOL] } else { [EOL] builder.appendDayOfWeekShortText(); [EOL] } [EOL] break; [EOL] case 'D': [EOL] builder.appendDayOfYear(tokenLen); [EOL] break; [EOL] case 'w': [EOL] builder.appendWeekOfWeekyear(tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] builder.appendTimeZoneName(); [EOL] } else { [EOL] builder.appendTimeZoneShortName(null); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL] } else if (tokenLen == 2) { [EOL] builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL] } else { [EOL] builder.appendTimeZoneId(); [EOL] } [EOL] break; [EOL] case '\'': [EOL] String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] builder.appendLiteral(sub.charAt(0)); [EOL] } else { [EOL] builder.appendLiteral(new String(sub)); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] } [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ; [EOL] private static final long serialVersionUID = 23L;; ; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
private static String parseToken(String pattern, int[] indexRef) { [EOL] StringBuilder buf = new StringBuilder(); [EOL] int i = indexRef[0]; [EOL] int length = pattern.length(); [EOL] char c = pattern.charAt(i); [EOL] if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL] buf.append(c); [EOL] while (i + 1 < length) { [EOL] char peek = pattern.charAt(i + 1); [EOL] if (peek == c) { [EOL] buf.append(c); [EOL] i++; [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] } else { [EOL] buf.append('\''); [EOL] boolean inLiteral = false; [EOL] for (; i < length; i++) { [EOL] c = pattern.charAt(i); [EOL] if (c == '\'') { [EOL] if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL] i++; [EOL] buf.append(c); [EOL] } else { [EOL] inLiteral = !inLiteral; [EOL] } [EOL] } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL] i--; [EOL] break; [EOL] } else { [EOL] buf.append(c); [EOL] } [EOL] } [EOL] } [EOL] indexRef[0] = i; [EOL] return buf.toString(); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ; [EOL] private static final long serialVersionUID = 23L;; ; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
public void testIsNumericTokenWithSingleCharacter() { [EOL] assertTrue(isNumericToken("c")); [EOL] assertTrue(isNumericToken("C")); [EOL] assertTrue(isNumericToken("x")); [EOL] assertTrue(isNumericToken("y")); [EOL] assertTrue(isNumericToken("Y")); [EOL] assertTrue(isNumericToken("d")); [EOL] assertTrue(isNumericToken("h")); [EOL] assertTrue(isNumericToken("H")); [EOL] assertTrue(isNumericToken("m")); [EOL] assertTrue(isNumericToken("s")); [EOL] assertTrue(isNumericToken("S")); [EOL] assertTrue(isNumericToken("e")); [EOL] assertTrue(isNumericToken("D")); [EOL] assertTrue(isNumericToken("F")); [EOL] assertTrue(isNumericToken("w")); [EOL] assertTrue(isNumericToken("W")); [EOL] assertTrue(isNumericToken("k")); [EOL] assertTrue(isNumericToken("K")); [EOL] assertFalse(isNumericToken("A")); // Test a character that is not in the switch [EOL] assertFalse(isNumericToken("")); // Test an empty string [EOL] }
public void testIsNumericTokenWithMultipleCharacters() { [EOL] assertTrue(isNumericToken("M")); [EOL] assertFalse(isNumericToken("MM")); [EOL] assertFalse(isNumericToken("MMM")); // Test a string longer than 2 characters [EOL] assertFalse(isNumericToken("1")); // Test a numeric character [EOL] }
public void testCreateFormatterForPatternWithNullPattern() { [EOL] try { [EOL] Time.createFormatterForPattern(null); [EOL] fail("Should have thrown IllegalArgumentException for null pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid pattern specification", e.getMessage()); [EOL] } [EOL] } [EOL] public void testCreateFormatterForPatternWithEmptyPattern() { [EOL] try { [EOL] Time.createFormatterForPattern(""); [EOL] fail("Should have thrown IllegalArgumentException for empty pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid pattern specification", e.getMessage()); [EOL] } [EOL] } [EOL] public void testCreateFormatterForPatternWithValidPattern() { [EOL] String validPattern = "yyyy-MM-dd"; [EOL] DateTimeFormatter formatter = Time.createFormatterForPattern(validPattern); [EOL] assertNotNull("Formatter should not be null for valid pattern", formatter); [EOL] }
public void testCreateFormatterForPatternWithCachedPattern() { [EOL] String cachedPattern = "yyyy-MM-dd"; [EOL] DateTimeFormatter cachedFormatter = new DateTimeFormatterBuilder().appendPattern(cachedPattern).toFormatter(); [EOL] Time.PATTERN_CACHE.put(cachedPattern, cachedFormatter); [EOL] DateTimeFormatter formatter = Time.createFormatterForPattern(cachedPattern); [EOL] assertSame("Should return the cached formatter", cachedFormatter, formatter); [EOL] }
public void testSelectStyleWithShort() { [EOL] int result = selectStyle('S'); [EOL] assertEquals(SHORT, result); [EOL] }
public void testSelectStyleWithMedium() { [EOL] int result = selectStyle('M'); [EOL] assertEquals(MEDIUM, result); [EOL] }
public void testSelectStyleWithLong() { [EOL] int result = selectStyle('L'); [EOL] assertEquals(LONG, result); [EOL] }
public void testSelectStyleWithFull() { [EOL] int result = selectStyle('F'); [EOL] assertEquals(FULL, result); [EOL] }
public void testSelectStyleWithNone() { [EOL] int result = selectStyle('-'); [EOL] assertEquals(NONE, result); [EOL] }
public void testSelectStyleWithInvalidCharacter() { [EOL] try { [EOL] selectStyle('X'); [EOL] fail("Expected IllegalArgumentException for invalid style character"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStandardSeconds_Zero() { [EOL] Duration result = Time.standardSeconds(0); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testStandardSeconds_Positive() { [EOL] long seconds = 1; [EOL] Duration result = Time.standardSeconds(seconds); [EOL] assertEquals(new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND), result); [EOL] }
public void testStandardSeconds_Negative() { [EOL] long seconds = -1; [EOL] Duration result = Time.standardSeconds(seconds); [EOL] assertEquals(new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND), result); [EOL] }
public void testMillis_Zero() { [EOL] Duration result = Time.millis(0); [EOL] assertEquals(Time.ZERO, result); [EOL] }
public void testMillis_Positive() { [EOL] long input = 123L; [EOL] Duration result = Time.millis(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.toMillis()); [EOL] }
public void testMillis_Negative() { [EOL] long input = -123L; [EOL] Duration result = Time.millis(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.toMillis()); [EOL] }
public Duration toDuration() { [EOL] return this; [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.withDurationAdded(0, 1); [EOL] assertEquals(duration, result); [EOL] } [EOL] public void testWithDurationAdded_ZeroScalar() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.withDurationAdded(1, 0); [EOL] assertEquals(duration, result); [EOL] } [EOL] public void testWithDurationAdded_NonZeroValues() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.withDurationAdded(100, 2); [EOL] assertEquals(new Duration(1200), result); [EOL] }
public void testWithDurationAdded_MaxLong() { [EOL] Duration duration = new Duration(1000); [EOL] try { [EOL] duration.withDurationAdded(Long.MAX_VALUE, 1); [EOL] fail("Should have thrown an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testWithDurationAdded_MaxInt() { [EOL] Duration duration = new Duration(1000); [EOL] try { [EOL] duration.withDurationAdded(1, Integer.MAX_VALUE); [EOL] fail("Should have thrown an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testPlus_withNullAmount() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.plus(null); [EOL] assertEquals(duration, result); [EOL] }
public void testPlus_withValidAmount() { [EOL] Duration duration = new Duration(1000); [EOL] ReadableDuration amount = new Duration(500); [EOL] Duration result = duration.plus(amount); [EOL] assertEquals(new Duration(1500), result); [EOL] }
public void testMultipliedByOne() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(1); [EOL] assertSame(duration, result); [EOL] }
public void testMultipliedByPositive() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(2); [EOL] assertEquals(new Duration(2000), result); [EOL] }
public void testMultipliedByNegative() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(-1); [EOL] assertEquals(new Duration(-1000), result); [EOL] }
public void testMultipliedByZero() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(0); [EOL] assertEquals(new Duration(0), result); [EOL] }
public void testAlternateExtended_InitialCreation() { [EOL] PeriodFormatter formatter = Time.alternateExtended(); [EOL] assertNotNull(formatter); [EOL] assertEquals("P0000Y-00M-00DT00:00:00.000", formatter.toString()); [EOL] }
public void testAlternateExtended_SubsequentCallsReturnSameInstance() { [EOL] PeriodFormatter firstCallFormatter = Time.alternateExtended(); [EOL] PeriodFormatter secondCallFormatter = Time.alternateExtended(); [EOL] assertSame(firstCallFormatter, secondCallFormatter); [EOL] }
public void testGet_WhenWrappedFieldValueIsNotZero() { [EOL] long instant = 123456789L; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.get(instant)).thenReturn(10); [EOL] DateTimeField testField = new DelegatedDateTimeField(mockField); [EOL] int result = testField.get(instant); [EOL] assertEquals(10, result); [EOL] }
public void testGet_WhenWrappedFieldValueIsZero() { [EOL] long instant = 123456789L; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.get(instant)).thenReturn(0); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(100); [EOL] DateTimeField testField = new DelegatedDateTimeField(mockField); [EOL] int result = testField.get(instant); [EOL] assertEquals(100, result); [EOL] }
public int getMaximumValue() { [EOL] return getWrappedField().getMaximumValue() + 1; [EOL] }
public void testReadFromWithFixedDateTimeZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'F'); [EOL] when(in.readUTF()).thenReturn("UTC"); [EOL] when(in.readLong()).thenReturn(0L); [EOL] DateTimeZone result = MyClass.readFrom(in, "UTC"); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] } [EOL] public void testReadFromWithCachedDateTimeZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'C'); [EOL] PrecalculatedZone precalculatedZone = mock(PrecalculatedZone.class); [EOL] when(PrecalculatedZone.readFrom(in, "CET")).thenReturn(precalculatedZone); [EOL] DateTimeZone result = MyClass.readFrom(in, "CET"); [EOL] assertTrue(result instanceof CachedDateTimeZone); [EOL] } [EOL] public void testReadFromWithPrecalculatedZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'P'); [EOL] PrecalculatedZone precalculatedZone = mock(PrecalculatedZone.class); [EOL] when(PrecalculatedZone.readFrom(in, "PST")).thenReturn(precalculatedZone); [EOL] DateTimeZone result = MyClass.readFrom(in, "PST"); [EOL] assertEquals(precalculatedZone, result); [EOL] } [EOL] public void testReadFromWithInvalidEncoding() { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'X'); [EOL] assertThrows(IOException.class, () -> MyClass.readFrom(in, "Invalid")); [EOL] }
public void testBuildFixedZone_ReturnsUTC() { [EOL] DateTimeZone result = buildFixedZone("UTC", "UTC", 0, 0); [EOL] assertSame(DateTimeZone.UTC, result); [EOL] }
public void testBuildFixedZone_ReturnsFixedDateTimeZone() { [EOL] DateTimeZone result = buildFixedZone("ID", "NAMEKEY", 1, 1); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof FixedDateTimeZone); [EOL] assertEquals("ID", result.getID()); [EOL] }
public void testDateTimeZoneBuilderConstructor() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] assertNotNull("RuleSets list should not be null", builder.iRuleSets); [EOL] assertEquals("RuleSets list should be empty", 0, builder.iRuleSets.size()); [EOL] }
public void testAddCutoverWithEmptyRuleSets() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addCutover(2023, 'w', 3, 10, 2, true, 7200000); [EOL] }
public void testAddCutoverWithNonEmptyRuleSets() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addCutover(2022, 'u', 2, 15, 1, false, 3600000); [EOL] builder.addCutover(2023, 'w', 3, 10, 2, true, 7200000); [EOL] }
public void testSetStandardOffset_PositiveOffset() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] int standardOffset = 3600; // +1 hour [EOL] builder.setStandardOffset(standardOffset); [EOL] assertEquals(standardOffset, builder.getLastRuleSet().getStandardOffset()); [EOL] }
public void testSetStandardOffset_NegativeOffset() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] int standardOffset = -3600; // -1 hour [EOL] builder.setStandardOffset(standardOffset); [EOL] assertEquals(standardOffset, builder.getLastRuleSet().getStandardOffset()); [EOL] }
public void testSetStandardOffset_ZeroOffset() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] int standardOffset = 0; // UTC [EOL] builder.setStandardOffset(standardOffset); [EOL] assertEquals(standardOffset, builder.getLastRuleSet().getStandardOffset()); [EOL] }
public void testAddRecurringSavings_ValidYears() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addRecurringSavings("test", 3600000, 2000, 2010, 'w', 3, 10, 2, false, 7200000); [EOL] }
public void testAddRecurringSavings_SameStartAndEndYear() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addRecurringSavings("test", 3600000, 2005, 2005, 'w', 3, 10, 2, false, 7200000); [EOL] }
public void testAddRecurringSavings_StartYearGreaterThanEndYear() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addRecurringSavings("test", 3600000, 2011, 2010, 'w', 3, 10, 2, false, 7200000); [EOL] }
public void testGetLastRuleSet_EmptyRuleSet() { [EOL] instance.iRuleSets.clear(); // Ensure iRuleSets is empty [EOL] RuleSet result = instance.getLastRuleSet(); [EOL] assertNotNull(result); // Check that a RuleSet is returned [EOL] assertEquals(1, instance.iRuleSets.size()); // Check that a RuleSet was added [EOL] }
public void testGetLastRuleSet_NonEmptyRuleSet() { [EOL] RuleSet existingRuleSet = new RuleSet(); // Create a RuleSet [EOL] instance.iRuleSets.add(existingRuleSet); // Add RuleSet to iRuleSets [EOL] RuleSet result = instance.getLastRuleSet(); [EOL] assertSame(existingRuleSet, result); // Check that the existing RuleSet is returned [EOL] }
public void testToDateTimeZone_NullId_ThrowsIllegalArgumentException() { [EOL] try { [EOL] toDateTimeZone(null, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToDateTimeZone_EmptyRuleSets_ReturnsFixedZone() { [EOL] iRuleSets.clear(); [EOL] DateTimeZone result = toDateTimeZone("TestID", true); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeZone_SingleTransitionNoTailZone_ReturnsFixedZone() { [EOL] iRuleSets.clear(); [EOL] RuleSet mockRuleSet = mock(RuleSet.class); [EOL] Transition mockTransition = mock(Transition.class); [EOL] when(mockRuleSet.firstTransition(anyLong())).thenReturn(mockTransition); [EOL] when(mockRuleSet.nextTransition(anyLong(), anyInt())).thenReturn(null); [EOL] iRuleSets.add(mockRuleSet); [EOL] DateTimeZone result = toDateTimeZone("TestID", true); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeZone_MultipleTransitionsWithTailZone_ReturnsPrecalculatedZone() { [EOL] iRuleSets.clear(); [EOL] RuleSet mockRuleSet = mock(RuleSet.class); [EOL] Transition mockTransition1 = mock(Transition.class); [EOL] Transition mockTransition2 = mock(Transition.class); [EOL] when(mockRuleSet.firstTransition(anyLong())).thenReturn(mockTransition1); [EOL] when(mockRuleSet.nextTransition(anyLong(), anyInt())).thenReturn(mockTransition2).thenReturn(null); [EOL] when(mockRuleSet.buildTailZone(anyString())).thenReturn(mock(DSTZone.class)); [EOL] iRuleSets.add(mockRuleSet); [EOL] DateTimeZone result = toDateTimeZone("TestID", true); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeZone_MultipleTransitionsNoTailZone_ReturnsPrecalculatedZone() { [EOL] iRuleSets.clear(); [EOL] RuleSet mockRuleSet = mock(RuleSet.class); [EOL] Transition mockTransition1 = mock(Transition.class); [EOL] Transition mockTransition2 = mock(Transition.class); [EOL] when(mockRuleSet.firstTransition(anyLong())).thenReturn(mockTransition1); [EOL] when(mockRuleSet.nextTransition(anyLong(), anyInt())).thenReturn(mockTransition2).thenReturn(null); [EOL] iRuleSets.add(mockRuleSet); [EOL] DateTimeZone result = toDateTimeZone("TestID", true); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeZone_TransitionsWithCachableZone_ReturnsCachedDateTimeZone() { [EOL] iRuleSets.clear(); [EOL] RuleSet mockRuleSet = mock(RuleSet.class); [EOL] Transition mockTransition1 = mock(Transition.class); [EOL] Transition mockTransition2 = mock(Transition.class); [EOL] when(mockRuleSet.firstTransition(anyLong())).thenReturn(mockTransition1); [EOL] when(mockRuleSet.nextTransition(anyLong(), anyInt())).thenReturn(mockTransition2).thenReturn(null); [EOL] when(mockRuleSet.buildTailZone(anyString())).thenReturn(null); [EOL] iRuleSets.add(mockRuleSet); [EOL] PrecalculatedZone mockPrecalculatedZone = mock(PrecalculatedZone.class); [EOL] when(mockPrecalculatedZone.isCachable()).thenReturn(true); [EOL] DateTimeZone result = toDateTimeZone("TestID", true); [EOL] assertNotNull(result); [EOL] }
public void testAddTransitionWithEmptyList() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr = new Transition(); // Assume Transition is a valid class and tr is a valid instance [EOL] boolean result = addTransition(transitions, tr); [EOL] assertTrue(result); [EOL] assertEquals(1, transitions.size()); [EOL] assertTrue(transitions.contains(tr)); [EOL] }
public void testAddTransitionWithNonEmptyListValidTransition() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assume Transition is a valid class and tr1 is a valid instance [EOL] Transition tr2 = new Transition(); // Assume Transition is a valid class and tr2 is a valid instance [EOL] transitions.add(tr1); [EOL] when(tr2.isTransitionFrom(tr1)).thenReturn(true); [EOL] when(tr1.getWallOffset()).thenReturn(0); [EOL] when(tr2.getWallOffset()).thenReturn(0); [EOL] when(tr1.getMillis()).thenReturn(100L); [EOL] when(tr2.getMillis()).thenReturn(200L); [EOL] boolean result = addTransition(transitions, tr2); [EOL] assertTrue(result); [EOL] assertEquals(2, transitions.size()); [EOL] assertTrue(transitions.contains(tr2)); [EOL] }
public void testAddTransitionWithNonEmptyListInvalidTransition() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assume Transition is a valid class and tr1 is a valid instance [EOL] Transition tr2 = new Transition(); // Assume Transition is a valid class and tr2 is a valid instance [EOL] transitions.add(tr1); [EOL] when(tr2.isTransitionFrom(tr1)).thenReturn(false); [EOL] boolean result = addTransition(transitions, tr2); [EOL] assertFalse(result); [EOL] assertEquals(1, transitions.size()); [EOL] assertFalse(transitions.contains(tr2)); [EOL] }
public void testAddTransitionWithLastLocalEqualToNewLocal() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assume Transition is a valid class and tr1 is a valid instance [EOL] Transition tr2 = new Transition(); // Assume Transition is a valid class and tr2 is a valid instance [EOL] transitions.add(tr1); [EOL] when(tr2.isTransitionFrom(tr1)).thenReturn(true); [EOL] when(tr1.getWallOffset()).thenReturn(0); [EOL] when(tr2.getWallOffset()).thenReturn(0); [EOL] when(tr1.getMillis()).thenReturn(100L); [EOL] when(tr2.getMillis()).thenReturn(100L); // Same millis to make lastLocal equal to newLocal [EOL] boolean result = addTransition(transitions, tr2); [EOL] assertTrue(result); [EOL] assertEquals(1, transitions.size()); [EOL] assertTrue(transitions.contains(tr2)); [EOL] assertFalse(transitions.contains(tr1)); [EOL] }
public void testWriteToWithFixedDateTimeZone() throws IOException { [EOL] String zoneID = "UTC"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] writeTo(zoneID, out); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] assertEquals('F', bytes[0]); [EOL] }
public void testWriteToWithCachedDateTimeZone() throws IOException { [EOL] String zoneID = "America/New_York"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] writeTo(zoneID, out); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] assertEquals('C', bytes[0]); [EOL] }
public void testWriteToWithPrecalculatedZone() throws IOException { [EOL] String zoneID = "Europe/London"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] writeTo(zoneID, out); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] assertEquals('P', bytes[0]); [EOL] }
public void testOfYearWithUnknownMode() { [EOL] try { [EOL] ofYear('x', 1, 1, 1, false, 0); [EOL] fail("Should have thrown IllegalArgumentException for unknown mode"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Unknown mode: x", e.getMessage()); [EOL] } [EOL] }
public void testOfYearWithValidModeU() { [EOL] ofYear('u', 1, 1, 1, false, 0); [EOL] }
public void testOfYearWithValidModeW() { [EOL] ofYear('w', 1, 1, 1, false, 0); [EOL] }
public void testOfYearWithValidModeS() { [EOL] ofYear('s', 1, 1, 1, false, 0); [EOL] }
public void testNextWithModeW() { [EOL] Time time = new Time('w', 5, 10); // Example values for iMode, iMonthOfYear, iMillisOfDay [EOL] long instant = 1000L; [EOL] int standardOffset = 2; [EOL] int saveMillis = 3; [EOL] long expected = 1005L; // Expected value after calculation [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithModeS() { [EOL] Time time = new Time('s', 5, 10); // Example values for iMode, iMonthOfYear, iMillisOfDay [EOL] long instant = 1000L; [EOL] int standardOffset = 2; [EOL] int saveMillis = 3; [EOL] long expected = 1002L; // Expected value after calculation [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithModeOther() { [EOL] Time time = new Time('x', 5, 10); // Example values for iMode, iMonthOfYear, iMillisOfDay [EOL] long instant = 1000L; [EOL] int standardOffset = 2; [EOL] int saveMillis = 3; [EOL] long expected = 1000L; // Expected value after calculation [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithDayOfWeekZeroAndNextLessThanInstant() { [EOL] Time time = new Time('w', 5, 10, 0); // Example values for iMode, iMonthOfYear, iMillisOfDay, iDayOfWeek [EOL] long instant = 1000L; [EOL] int standardOffset = 2; [EOL] int saveMillis = 3; [EOL] long expected = 1005L; // Expected value after calculation [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithDayOfWeekNonZeroAndNextLessThanInstant() { [EOL] Time time = new Time('w', 5, 10, 2); // Example values for iMode, iMonthOfYear, iMillisOfDay, iDayOfWeek [EOL] long instant = 1000L; [EOL] int standardOffset = 2; [EOL] int saveMillis = 3; [EOL] long expected = 1005L; // Expected value after calculation [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testEquals_Reflexive() { [EOL] OfYear ofYear = new OfYear(1, 2, 3, 4, true, 500); [EOL] assertTrue(ofYear.equals(ofYear)); [EOL] } [EOL] public void testEquals_Symmetric() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 3, 4, true, 500); [EOL] assertTrue(ofYear1.equals(ofYear2)); [EOL] assertTrue(ofYear2.equals(ofYear1)); [EOL] } [EOL] public void testEquals_Null() { [EOL] OfYear ofYear = new OfYear(1, 2, 3, 4, true, 500); [EOL] assertFalse(ofYear.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] OfYear ofYear = new OfYear(1, 2, 3, 4, true, 500); [EOL] Object other = new Object(); [EOL] assertFalse(ofYear.equals(other)); [EOL] } [EOL] public void testEquals_DifferentContent() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 3, 4, false, 500); // Different advance [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testEquals_DifferentMonth() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 3, 3, 4, true, 500); // Different month [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testEquals_DifferentDayOfMonth() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 4, 4, true, 500); // Different day of month [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testEquals_DifferentDayOfWeek() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 3, 5, true, 500); // Different day of week [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testEquals_DifferentAdvance() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 3, 4, false, 500); // Different advance [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testEquals_DifferentMillisOfDay() { [EOL] OfYear ofYear1 = new OfYear(1, 2, 3, 4, true, 500); [EOL] OfYear ofYear2 = new OfYear(1, 2, 3, 4, true, 600); // Different millis of day [EOL] assertFalse(ofYear1.equals(ofYear2)); [EOL] }
public void testSetDayOfMonthNext_ValidDate() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initial = chrono.dayOfMonth().set(chrono.year().set(0, 2020), 15); // February 15, 2020 [EOL] long next = initial + Days.days(1).toStandardDuration().getMillis(); [EOL] long updated = setDayOfMonthNext(chrono, next); [EOL] assertEquals(chrono.dayOfMonth().get(updated), 16); [EOL] } [EOL] public void testSetDayOfMonthNext_LeapYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initial = chrono.dayOfMonth().set(chrono.year().set(0, 2020), 29); // February 29, 2020 [EOL] long next = initial + Days.days(1).toStandardDuration().getMillis(); [EOL] long updated = setDayOfMonthNext(chrono, next); [EOL] assertEquals(chrono.dayOfMonth().get(updated), 1); [EOL] assertEquals(chrono.monthOfYear().get(updated), 3); // March [EOL] } [EOL] public void testSetDayOfMonthNext_NonLeapYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initial = chrono.dayOfMonth().set(chrono.year().set(0, 2021), 28); // February 28, 2021 [EOL] long next = initial + Days.days(1).toStandardDuration().getMillis(); [EOL] try { [EOL] setDayOfMonthNext(chrono, next); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetDayOfMonthNext_LeapYearException() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initial = chrono.dayOfMonth().set(chrono.year().set(0, 2021), 29); // February 29, 2021, invalid date [EOL] long next = initial + Days.days(1).toStandardDuration().getMillis(); [EOL] long updated = setDayOfMonthNext(chrono, next); [EOL] assertEquals(chrono.dayOfMonth().get(updated), 29); [EOL] assertEquals(chrono.monthOfYear().get(updated), 2); // February [EOL] assertTrue(chrono.year().isLeap(updated)); // Should be a leap year now [EOL] }
public void testSetDayOfMonth_PositiveDay() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initialInstant = chrono.dayOfMonth().set(0L, 1); [EOL] int dayOfMonth = 15; [EOL] long updatedInstant = setDayOfMonth(chrono, initialInstant, dayOfMonth); [EOL] int resultDayOfMonth = chrono.dayOfMonth().get(updatedInstant); [EOL] assertEquals(dayOfMonth, resultDayOfMonth); [EOL] }
public void testSetDayOfMonth_NegativeDay() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long initialInstant = chrono.dayOfMonth().set(0L, 1); [EOL] int dayOfMonth = -1; [EOL] long updatedInstant = setDayOfMonth(chrono, initialInstant, dayOfMonth); [EOL] int resultDayOfMonth = chrono.dayOfMonth().get(updatedInstant); [EOL] int expectedDayOfMonth = chrono.dayOfMonth().getMaximumValue(updatedInstant) + dayOfMonth + 1; [EOL] assertEquals(expectedDayOfMonth, resultDayOfMonth); [EOL] }
public void testSetDayOfWeek_SameDay() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, dayOfWeek, true); [EOL] assertEquals("Setting the same day of week should not change the instant", instant, updatedInstant); [EOL] }
public void testSetDayOfWeek_NextWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek % 7) + 1, true); [EOL] assertTrue("Setting the next week's same day should move the instant forward", updatedInstant > instant); [EOL] }
public void testSetDayOfWeek_PreviousWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek + 6) % 7 + 1, false); [EOL] assertTrue("Setting the previous week's same day should move the instant backward", updatedInstant < instant); [EOL] }
public void testRecurrenceConstructor() { [EOL] OfYear ofYear = new OfYear(); [EOL] String nameKey = "testNameKey"; [EOL] int saveMillis = 3600000; [EOL] Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); [EOL] assertNotNull(recurrence.iOfYear); [EOL] assertEquals(nameKey, recurrence.iNameKey); [EOL] assertEquals(saveMillis, recurrence.iSaveMillis); [EOL] }
public void testNext() { [EOL] long expected = 123456789L; [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] when(iOfYear.next(instant, standardOffset, saveMillis)).thenReturn(expected); [EOL] long result = next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, result); [EOL] }
public int getSaveMillis() { [EOL] return iSaveMillis; [EOL] }
public void testEquals_SameObject() { [EOL] Recurrence recurrence = new Recurrence(1000, "testKey", new Year(2021)); [EOL] assertTrue(recurrence.equals(recurrence)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Recurrence recurrence = new Recurrence(1000, "testKey", new Year(2021)); [EOL] Object other = new Object(); [EOL] assertFalse(recurrence.equals(other)); [EOL] }
public void testEquals_Null() { [EOL] Recurrence recurrence = new Recurrence(1000, "testKey", new Year(2021)); [EOL] assertFalse(recurrence.equals(null)); [EOL] }
public void testEquals_EqualRecurrence() { [EOL] Recurrence recurrence1 = new Recurrence(1000, "testKey", new Year(2021)); [EOL] Recurrence recurrence2 = new Recurrence(1000, "testKey", new Year(2021)); [EOL] assertTrue(recurrence1.equals(recurrence2)); [EOL] }
public void testEquals_DifferentSaveMillis() { [EOL] Recurrence recurrence1 = new Recurrence(1000, "testKey", new Year(2021)); [EOL] Recurrence recurrence2 = new Recurrence(2000, "testKey", new Year(2021)); [EOL] assertFalse(recurrence1.equals(recurrence2)); [EOL] }
public void testEquals_DifferentNameKey() { [EOL] Recurrence recurrence1 = new Recurrence(1000, "testKey", new Year(2021)); [EOL] Recurrence recurrence2 = new Recurrence(1000, "differentKey", new Year(2021)); [EOL] assertFalse(recurrence1.equals(recurrence2)); [EOL] }
public void testEquals_DifferentOfYear() { [EOL] Recurrence recurrence1 = new Recurrence(1000, "testKey", new Year(2021)); [EOL] Recurrence recurrence2 = new Recurrence(1000, "testKey", new Year(2022)); [EOL] assertFalse(recurrence1.equals(recurrence2)); [EOL] }
public void testRenameWithNonNullNameKey() { [EOL] Recurrence originalRecurrence = new Recurrence(iOfYear, "oldName", iSaveMillis); [EOL] Recurrence renamedRecurrence = originalRecurrence.rename("newName"); [EOL] assertNotNull(renamedRecurrence); [EOL] assertEquals("newName", renamedRecurrence.getNameKey()); [EOL] assertEquals(iOfYear, renamedRecurrence.getYear()); [EOL] assertEquals(iSaveMillis, renamedRecurrence.getSaveMillis()); [EOL] }
public void testRenameWithNullNameKey() { [EOL] Recurrence originalRecurrence = new Recurrence(iOfYear, "oldName", iSaveMillis); [EOL] Recurrence renamedRecurrence = originalRecurrence.rename(null); [EOL] assertNotNull(renamedRecurrence); [EOL] assertNull(renamedRecurrence.getNameKey()); [EOL] assertEquals(iOfYear, renamedRecurrence.getYear()); [EOL] assertEquals(iSaveMillis, renamedRecurrence.getSaveMillis()); [EOL] }
public void testRenameAppendWithNonNullAppendNameKey() { [EOL] String appendNameKey = "TestKey"; [EOL] Recurrence instance = new Recurrence("InitialKey"); [EOL] Recurrence result = instance.renameAppend(appendNameKey); [EOL] assertNotNull(result); [EOL] assertEquals("InitialKeyTestKey", result.getNameKey()); [EOL] }
public void testRenameAppendWithEmptyAppendNameKey() { [EOL] String appendNameKey = ""; [EOL] Recurrence instance = new Recurrence("InitialKey"); [EOL] Recurrence result = instance.renameAppend(appendNameKey); [EOL] assertNotNull(result); [EOL] assertEquals("InitialKey", result.getNameKey()); [EOL] }
public void testRenameAppendWithNullAppendNameKey() { [EOL] String appendNameKey = null; [EOL] Recurrence instance = new Recurrence("InitialKey"); [EOL] try { [EOL] instance.renameAppend(appendNameKey); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRuleConstructorWithValidInput() { [EOL] Recurrence validRecurrence = new Recurrence("DAILY", 1); [EOL] int fromYear = 2021; [EOL] int toYear = 2023; [EOL] Rule rule = new Rule(validRecurrence, fromYear, toYear); [EOL] assertNotNull(rule); [EOL] assertEquals(validRecurrence, rule.getRecurrence()); [EOL] assertEquals(fromYear, rule.getFromYear()); [EOL] assertEquals(toYear, rule.getToYear()); [EOL] }
public void testGetToYear() { [EOL] Time time = new Time(); [EOL] int expected = 2023; // Assuming the expected value of iToYear is 2023 [EOL] time.iToYear = expected; // Directly setting the value of iToYear for testing purposes [EOL] int actual = time.getToYear(); [EOL] assertEquals(expected, actual); [EOL] }
public String getNameKey() { [EOL] return iRecurrence.getNameKey(); [EOL] }
public void testGetSaveMillis() { [EOL] Recurrence recurrence = mock(Recurrence.class); [EOL] when(recurrence.getSaveMillis()).thenReturn(1000); [EOL] Time time = new Time(recurrence); [EOL] int saveMillis = time.getSaveMillis(); [EOL] assertEquals(1000, saveMillis); [EOL] }
public long next(final long instant, int standardOffset, int saveMillis) { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] final int wallOffset = standardOffset + saveMillis; [EOL] long testInstant = instant; [EOL] int year; [EOL] if (instant == Long.MIN_VALUE) { [EOL] year = Integer.MIN_VALUE; [EOL] } else { [EOL] year = chrono.year().get(instant + wallOffset); [EOL] } [EOL] if (year < iFromYear) { [EOL] testInstant = chrono.year().set(0, iFromYear) - wallOffset; [EOL] testInstant -= 1; [EOL] } [EOL] long next = iRecurrence.next(testInstant, standardOffset, saveMillis); [EOL] if (next > instant) { [EOL] year = chrono.year().get(next + wallOffset); [EOL] if (year > iToYear) { [EOL] next = instant; [EOL] } [EOL] } [EOL] return next; [EOL] }
public void testTransitionWithPositiveStandardOffset() { [EOL] long millis = 1000L; [EOL] Rule rule = new Rule("TestKey", 3600); // Assuming Rule has a constructor Rule(String nameKey, int saveMillis) [EOL] int standardOffset = 2000; [EOL] Transition transition = new Transition(millis, rule, standardOffset); [EOL] assertEquals(1000L, transition.iMillis); [EOL] assertEquals("TestKey", transition.iNameKey); [EOL] assertEquals(5600, transition.iWallOffset); [EOL] assertEquals(2000, transition.iStandardOffset); [EOL] }
public void testTransitionWithNegativeStandardOffset() { [EOL] long millis = -1000L; [EOL] Rule rule = new Rule("NegativeKey", -3600); // Assuming Rule has a constructor Rule(String nameKey, int saveMillis) [EOL] int standardOffset = -2000; [EOL] Transition transition = new Transition(millis, rule, standardOffset); [EOL] assertEquals(-1000L, transition.iMillis); [EOL] assertEquals("NegativeKey", transition.iNameKey); [EOL] assertEquals(-5600, transition.iWallOffset); [EOL] assertEquals(-2000, transition.iStandardOffset); [EOL] }
public void testGetMillis() { [EOL] long expectedMillis = 123456789L; // Replace with the expected value [EOL] Time time = new Time(expectedMillis); // Assuming there is a constructor that sets iMillis [EOL] long actualMillis = time.getMillis(); [EOL] assertEquals("The millis should match the expected value", expectedMillis, actualMillis); [EOL] }
public void testGetNameKey() { [EOL] MyClass instance = new MyClass("expectedKey"); [EOL] String result = instance.getNameKey(); [EOL] assertEquals("expectedKey", result); [EOL] }
public void testGetWallOffset() { [EOL] Time time = new Time(); [EOL] int expectedWallOffset = 0; // Assuming default wall offset is 0 [EOL] time.iWallOffset = expectedWallOffset; [EOL] int actualWallOffset = time.getWallOffset(); [EOL] assertEquals(expectedWallOffset, actualWallOffset); [EOL] }
public int getStandardOffsetTest() { [EOL] int expected = 3600000; // Expected standard offset for the instance [EOL] int actual = instance.getStandardOffset(); [EOL] assertEqual(expected, actual, "The standard offset should be equal to the initialized value"); [EOL] }
public void testGetSaveMillis_PositiveOffset() { [EOL] int iWallOffset = 3000; [EOL] int iStandardOffset = 1000; [EOL] DateTimeZoneMock zone = new DateTimeZoneMock(iWallOffset, iStandardOffset); [EOL] int saveMillis = zone.getSaveMillis(); [EOL] assertEquals(2000, saveMillis); [EOL] }
public void testGetSaveMillis_NegativeOffset() { [EOL] int iWallOffset = -2000; [EOL] int iStandardOffset = -3000; [EOL] DateTimeZoneMock zone = new DateTimeZoneMock(iWallOffset, iStandardOffset); [EOL] int saveMillis = zone.getSaveMillis(); [EOL] assertEquals(1000, saveMillis); [EOL] }
public void testGetSaveMillis_ZeroOffset() { [EOL] int iWallOffset = 0; [EOL] int iStandardOffset = 0; [EOL] DateTimeZoneMock zone = new DateTimeZoneMock(iWallOffset, iStandardOffset); [EOL] int saveMillis = zone.getSaveMillis(); [EOL] assertEquals(0, saveMillis); [EOL] }
public void testIsTransitionFromWithNullOther() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] boolean result = transition.isTransitionFrom(null); [EOL] assertTrue(result); [EOL] }
public void testIsTransitionFromWithEarlierOther() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] Transition other = new Transition(500, 10, "UTC"); [EOL] boolean result = transition.isTransitionFrom(other); [EOL] assertTrue(result); [EOL] }
public void testIsTransitionFromWithLaterOther() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] Transition other = new Transition(1500, 10, "UTC"); [EOL] boolean result = transition.isTransitionFrom(other); [EOL] assertFalse(result); [EOL] }
public void testIsTransitionFromWithSameMillisAndDifferentWallOffset() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] Transition other = new Transition(1000, 20, "UTC"); [EOL] boolean result = transition.isTransitionFrom(other); [EOL] assertTrue(result); [EOL] }
public void testIsTransitionFromWithSameMillisAndWallOffsetButDifferentNameKey() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] Transition other = new Transition(1000, 10, "GMT"); [EOL] boolean result = transition.isTransitionFrom(other); [EOL] assertTrue(result); [EOL] }
public void testIsTransitionFromWithSameMillisWallOffsetAndNameKey() { [EOL] Transition transition = new Transition(1000, 10, "UTC"); [EOL] Transition other = new Transition(1000, 10, "UTC"); [EOL] boolean result = transition.isTransitionFrom(other); [EOL] assertFalse(result); [EOL] }
public void testRuleSetInitialization() { [EOL] RuleSet ruleSet = new RuleSet(); [EOL] assertNotNull("Rule list should not be null", ruleSet.iRules); [EOL] assertEquals("Rule list should be initialized with size 10", 10, ruleSet.iRules.size()); [EOL] assertEquals("Upper year should be Integer.MAX_VALUE", Integer.MAX_VALUE, ruleSet.iUpperYear); [EOL] }
public void testRuleSetCopyConstructor() { [EOL] RuleSet original = new RuleSet(); [EOL] original.iStandardOffset = 3600; [EOL] original.iRules = new ArrayList<Rule>(); [EOL] original.iInitialNameKey = "TestNameKey"; [EOL] original.iInitialSaveMillis = 1000; [EOL] original.iUpperYear = 2023; [EOL] original.iUpperOfYear = new DateTime(2023, 4, 1, 0, 0); [EOL] RuleSet copy = new RuleSet(original); [EOL] assertEquals(3600, copy.iStandardOffset); [EOL] assertEquals("TestNameKey", copy.iInitialNameKey); [EOL] assertEquals(1000, copy.iInitialSaveMillis); [EOL] assertEquals(2023, copy.iUpperYear); [EOL] assertNotNull(copy.iUpperOfYear); [EOL] assertEquals(new DateTime(2023, 4, 1, 0, 0), copy.iUpperOfYear); [EOL] assertEquals(original.iRules.size(), copy.iRules.size()); [EOL] }
public void testSetStandardOffset() { [EOL] Time time = new Time(); [EOL] int standardOffset = 5; [EOL] time.setStandardOffset(standardOffset); [EOL] assertEquals(standardOffset, time.getStandardOffset()); [EOL] }
public void testAddRule_NewRule() { [EOL] Rule newRule = new Rule(); [EOL] time.addRule(newRule); [EOL] assertTrue(time.getRules().contains(newRule)); [EOL] }
public void testAddRule_ExistingRule() { [EOL] Rule existingRule = new Rule(); [EOL] time.addRule(existingRule); [EOL] int initialSize = time.getRules().size(); [EOL] time.addRule(existingRule); [EOL] assertEquals(initialSize, time.getRules().size()); [EOL] }
public void testFirstTransition_InitialNameKeyNotNull() { [EOL] long firstMillis = 123456789L; [EOL] Transition result = firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertEquals(iInitialNameKey, result.getNameKey()); [EOL] assertEquals(iStandardOffset + iInitialSaveMillis, result.getWallOffset()); [EOL] assertEquals(iStandardOffset, result.getStandardOffset()); [EOL] }
public void testFirstTransition_NoInitialNameKey_TransitionOnFirstMillis() { [EOL] long firstMillis = 123456789L; [EOL] Transition result = firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertEquals(firstMillis, result.getMillis()); [EOL] }
public void testFirstTransition_NoInitialNameKey_TransitionAfterFirstMillis() { [EOL] long firstMillis = 123456789L; [EOL] Transition result = firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] }
public void testFirstTransition_NoInitialNameKey_NoTransition() { [EOL] long firstMillis = 123456789L; [EOL] Transition result = firstTransition(firstMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_NoRules() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_RuleBeforeInstant() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_RuleAfterInstant() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNotNull(result); [EOL] }
public void testNextTransition_YearAtLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_YearAboveLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_UpperYearBeforeLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNotNull(result); [EOL] }
public void testNextTransition_UpperYearAtLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testGetUpperLimit_MaxValue() { [EOL] TimeTestClass testClass = new TimeTestClass(Integer.MAX_VALUE, 0, 0); // Assuming constructor exists [EOL] long result = testClass.getUpperLimit(0); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetUpperLimit_Standard() { [EOL] TimeTestClass testClass = new TimeTestClass(2023, 0, 0); // Assuming constructor exists [EOL] int saveMillis = 1000; // Example value for saveMillis [EOL] long expected = 123456789L; // Expected value from iUpperOfYear.setInstant [EOL] long result = testClass.getUpperLimit(saveMillis); [EOL] assertEquals(expected, result); [EOL] }
public void testBuildTailZoneWithTwoRulesBothInfinite() { [EOL] Rule startRule = new Rule(...); // Mock with toYear = Integer.MAX_VALUE [EOL] Rule endRule = new Rule(...); // Mock with toYear = Integer.MAX_VALUE [EOL] List<Rule> rules = Arrays.asList(startRule, endRule); [EOL] DSTZoneBuilder builder = new DSTZoneBuilder(rules, ...); // other necessary parameters [EOL] DSTZone result = builder.buildTailZone("testZone"); [EOL] assertNotNull(result); [EOL] assertEquals("testZone", result.getID()); [EOL] }
public void testBuildTailZoneWithTwoRulesNotBothInfinite() { [EOL] Rule startRule = new Rule(...); // Mock with toYear = Integer.MAX_VALUE [EOL] Rule endRule = new Rule(...); // Mock with toYear != Integer.MAX_VALUE [EOL] List<Rule> rules = Arrays.asList(startRule, endRule); [EOL] DSTZoneBuilder builder = new DSTZoneBuilder(rules, ...); // other necessary parameters [EOL] DSTZone result = builder.buildTailZone("testZone"); [EOL] assertNull(result); [EOL] }
public void testBuildTailZoneWithLessThanTwoRules() { [EOL] Rule startRule = new Rule(...); // Mock with any toYear [EOL] List<Rule> rules = Collections.singletonList(startRule); [EOL] DSTZoneBuilder builder = new DSTZoneBuilder(rules, ...); // other necessary parameters [EOL] DSTZone result = builder.buildTailZone("testZone"); [EOL] assertNull(result); [EOL] }
public void testDSTZoneWithValidParameters() { [EOL] String id = "DST"; [EOL] int standardOffset = 3600; [EOL] Recurrence startRecurrence = new Recurrence(...); [EOL] Recurrence endRecurrence = new Recurrence(...); [EOL] DSTZone zone = new DSTZone(id, standardOffset, startRecurrence, endRecurrence); [EOL] assertEquals(id, zone.getID()); [EOL] assertEquals(standardOffset, zone.getStandardOffset()); [EOL] assertEquals(startRecurrence, zone.getStartRecurrence()); [EOL] assertEquals(endRecurrence, zone.getEndRecurrence()); [EOL] }
public void testEquals_Reflexive() { [EOL] DSTZone zone = new DSTZone("id", 0, null, null); [EOL] assertTrue(zone.equals(zone)); [EOL] }
public void testEquals_SameIDAndProperties() { [EOL] DSTZone zone1 = new DSTZone("id", 0, new Recurrence(), new Recurrence()); [EOL] DSTZone zone2 = new DSTZone("id", 0, new Recurrence(), new Recurrence()); [EOL] assertTrue(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentID() { [EOL] DSTZone zone1 = new DSTZone("id1", 0, new Recurrence(), new Recurrence()); [EOL] DSTZone zone2 = new DSTZone("id2", 0, new Recurrence(), new Recurrence()); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentStandardOffset() { [EOL] DSTZone zone1 = new DSTZone("id", 0, new Recurrence(), new Recurrence()); [EOL] DSTZone zone2 = new DSTZone("id", 1, new Recurrence(), new Recurrence()); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentStartRecurrence() { [EOL] Recurrence startRecurrence1 = new Recurrence(); [EOL] Recurrence startRecurrence2 = new Recurrence(); [EOL] DSTZone zone1 = new DSTZone("id", 0, startRecurrence1, new Recurrence()); [EOL] DSTZone zone2 = new DSTZone("id", 0, startRecurrence2, new Recurrence()); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentEndRecurrence() { [EOL] Recurrence endRecurrence1 = new Recurrence(); [EOL] Recurrence endRecurrence2 = new Recurrence(); [EOL] DSTZone zone1 = new DSTZone("id", 0, new Recurrence(), endRecurrence1); [EOL] DSTZone zone2 = new DSTZone("id", 0, new Recurrence(), endRecurrence2); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_Null() { [EOL] DSTZone zone = new DSTZone("id", 0, new Recurrence(), new Recurrence()); [EOL] assertFalse(zone.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] DSTZone zone = new DSTZone("id", 0, new Recurrence(), new Recurrence()); [EOL] Object other = new Object(); [EOL] assertFalse(zone.equals(other)); [EOL] }
static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { [EOL] int size = transitions.size(); [EOL] if (size == 0) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] long[] trans = new long[size]; [EOL] int[] wallOffsets = new int[size]; [EOL] int[] standardOffsets = new int[size]; [EOL] String[] nameKeys = new String[size]; [EOL] Transition last = null; [EOL] for (int i = 0; i < size; i++) { [EOL] Transition tr = transitions.get(i); [EOL] if (!tr.isTransitionFrom(last)) { [EOL] throw new IllegalArgumentException(id); [EOL] } [EOL] trans[i] = tr.getMillis(); [EOL] wallOffsets[i] = tr.getWallOffset(); [EOL] standardOffsets[i] = tr.getStandardOffset(); [EOL] nameKeys[i] = tr.getNameKey(); [EOL] last = tr; [EOL] } [EOL] String[] zoneNameData = new String[5]; [EOL] String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL] for (int j = 0; j < zoneStrings.length; j++) { [EOL] String[] set = zoneStrings[j]; [EOL] if (set != null && set.length == 5 && id.equals(set[0])) { [EOL] zoneNameData = set; [EOL] } [EOL] } [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] for (int i = 0; i < nameKeys.length - 1; i++) { [EOL] String curNameKey = nameKeys[i]; [EOL] String nextNameKey = nameKeys[i + 1]; [EOL] long curOffset = wallOffsets[i]; [EOL] long nextOffset = wallOffsets[i + 1]; [EOL] long curStdOffset = standardOffsets[i]; [EOL] long nextStdOffset = standardOffsets[i + 1]; [EOL] Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono); [EOL] if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) { [EOL] if (ZoneInfoCompiler.verbose()) { [EOL] System.out.println("Fixing duplicate name key - " + nextNameKey); [EOL] System.out.println("     - " + new DateTime(trans[i], chrono) + " - " + new DateTime(trans[i + 1], chrono)); [EOL] } [EOL] if (curOffset > nextOffset) { [EOL] nameKeys[i] = (curNameKey + "-Summer").intern(); [EOL] } else if (curOffset < nextOffset) { [EOL] nameKeys[i + 1] = (nextNameKey + "-Summer").intern(); [EOL] i++; [EOL] } [EOL] } [EOL] } [EOL] if (tailZone != null) { [EOL] if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) { [EOL] if (ZoneInfoCompiler.verbose()) { [EOL] System.out.println("Fixing duplicate recurrent name key - " + tailZone.iStartRecurrence.getNameKey()); [EOL] } [EOL] if (tailZone.iStartRecurrence.getSaveMillis() > 0) { [EOL] tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend("-Summer"), tailZone.iEndRecurrence); [EOL] } else { [EOL] tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend("-Summer")); [EOL] } [EOL] } [EOL] } [EOL] return new PrecalculatedZone((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
public void testPrecalculatedZoneConstructor() { [EOL] String id = "testZone"; [EOL] long[] transitions = new long[] {1000L, 2000L}; [EOL] int[] wallOffsets = new int[] {3600, 7200}; [EOL] int[] standardOffsets = new int[] {3600, 7200}; [EOL] String[] nameKeys = new String[] {"UTC", "BST"}; [EOL] DSTZone tailZone = new DSTZone("tailZoneId", 3600); [EOL] PrecalculatedZone zone = new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] assertNotNull(zone); [EOL] assertEquals("testZone", zone.getID()); [EOL] assertArrayEquals(transitions, zone.iTransitions); [EOL] assertArrayEquals(wallOffsets, zone.iWallOffsets); [EOL] assertArrayEquals(standardOffsets, zone.iStandardOffsets); [EOL] assertArrayEquals(nameKeys, zone.iNameKeys); [EOL] assertEquals(tailZone, zone.iTailZone); [EOL] }
public int getOffset(long instant) { [EOL] long[] transitions = iTransitions; [EOL] int i = Arrays.binarySearch(transitions, instant); [EOL] if (i >= 0) { [EOL] return iWallOffsets[i]; [EOL] } [EOL] i = ~i; [EOL] if (i < transitions.length) { [EOL] if (i > 0) { [EOL] return iWallOffsets[i - 1]; [EOL] } [EOL] return 0; [EOL] } [EOL] if (iTailZone == null) { [EOL] return iWallOffsets[i - 1]; [EOL] } [EOL] return iTailZone.getOffset(instant); [EOL] }
public long previousTransition(long instant) { [EOL] long[] transitions = iTransitions; [EOL] int i = Arrays.binarySearch(transitions, instant); [EOL] if (i >= 0) { [EOL] if (instant > Long.MIN_VALUE) { [EOL] return instant - 1; [EOL] } [EOL] return instant; [EOL] } [EOL] i = ~i; [EOL] if (i < transitions.length) { [EOL] if (i > 0) { [EOL] long prev = transitions[i - 1]; [EOL] if (prev > Long.MIN_VALUE) { [EOL] return prev - 1; [EOL] } [EOL] } [EOL] return instant; [EOL] } [EOL] if (iTailZone != null) { [EOL] long prev = iTailZone.previousTransition(instant); [EOL] if (prev < instant) { [EOL] return prev; [EOL] } [EOL] } [EOL] long prev = transitions[i - 1]; [EOL] if (prev > Long.MIN_VALUE) { [EOL] return prev - 1; [EOL] } [EOL] return instant; [EOL] }
public void testEquals_Reflexive() { [EOL] PrecalculatedZone zone = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] assertTrue(zone.equals(zone)); [EOL] } [EOL] public void testEquals_Null() { [EOL] PrecalculatedZone zone = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] assertFalse(zone.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] PrecalculatedZone zone = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] Object other = new Object(); [EOL] assertFalse(zone.equals(other)); [EOL] } [EOL] public void testEquals_EqualProperties() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", new int[]{1, 2, 3}, new String[]{"A", "B", "C"}, new int[]{4, 5, 6}, new int[]{7, 8, 9}, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", new int[]{1, 2, 3}, new String[]{"A", "B", "C"}, new int[]{4, 5, 6}, new int[]{7, 8, 9}, null); [EOL] assertTrue(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentID() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone1", null, null, null, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone2", null, null, null, null, null); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentTransitions() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", new int[]{1, 2, 3}, null, null, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", new int[]{1, 2, 4}, null, null, null, null); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentNameKeys() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, new String[]{"A", "B", "C"}, null, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, new String[]{"A", "B", "D"}, null, null, null); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentWallOffsets() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, new int[]{4, 5, 6}, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, new int[]{4, 5, 7}, null, null); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentStandardOffsets() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, null, new int[]{7, 8, 9}, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, null, new int[]{7, 8, 10}, null); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_DifferentTailZone() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, null, null, new TailZone("TailZone1")); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, null, null, new TailZone("TailZone2")); [EOL] assertFalse(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_SameTailZone() { [EOL] TailZone tailZone = new TailZone("TailZone"); [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, null, null, tailZone); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, null, null, tailZone); [EOL] assertTrue(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_NullTailZoneInBoth() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] assertTrue(zone1.equals(zone2)); [EOL] } [EOL] public void testEquals_NullTailZoneInOne() { [EOL] PrecalculatedZone zone1 = new PrecalculatedZone("TestZone", null, null, null, null, null); [EOL] PrecalculatedZone zone2 = new PrecalculatedZone("TestZone", null, null, null, null, new TailZone("TailZone")); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testIsCachableWithTailZoneNotNull() { [EOL] setTailZone(new MockZone()); [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public void testIsCachableWithEmptyTransitions() { [EOL] iTransitions = new long[0]; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithSingleTransition() { [EOL] iTransitions = new long[]{System.currentTimeMillis()}; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithTransitionsLessThanYearApart() { [EOL] iTransitions = new long[]{0L, (365L * 24 * 60 * 60 * 1000) - 1}; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithTransitionsMoreThanYearApart() { [EOL] iTransitions = new long[]{0L, (366L + 365) * 24 * 60 * 60 * 1000}; [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public void testIsCachableWithAverageDistanceLessThan25() { [EOL] iTransitions = new long[]{0L, 10L * 24 * 60 * 60 * 1000, 20L * 24 * 60 * 60 * 1000}; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithAverageDistanceMoreThan25() { [EOL] iTransitions = new long[]{0L, 30L * 24 * 60 * 60 * 1000, 60L * 24 * 60 * 60 * 1000}; [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public void testEquals_Reflexive() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] assertTrue(zone.equals(zone)); [EOL] }
public void testEquals_SameUnderlyingZone() { [EOL] CachedDateTimeZone zone1 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone zone2 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] assertTrue(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentUnderlyingZone() { [EOL] CachedDateTimeZone zone1 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone zone2 = CachedDateTimeZone.forZone(DateTimeZone.forID("Europe/London")); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_Null() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] assertFalse(zone.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] assertFalse(zone.equals("Not a CachedDateTimeZone")); [EOL] }
public void testAdd_withZero() { [EOL] long instant = System.currentTimeMillis(); [EOL] long value = 0; [EOL] long result = add(instant, value); [EOL] assertEquals("Adding zero should not change instant", instant, result); [EOL] } [EOL] public void testAdd_withPositive() { [EOL] long instant = System.currentTimeMillis(); [EOL] long value = 1; [EOL] long result = add(instant, value); [EOL] assertTrue("Adding a positive value should increase instant", result > instant); [EOL] } [EOL] public void testAdd_withNegative() { [EOL] long instant = System.currentTimeMillis(); [EOL] long value = -1; [EOL] long result = add(instant, value); [EOL] assertTrue("Adding a negative value should decrease instant", result < instant); [EOL] } [EOL] public void testAdd_withMaxValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] long value = Long.MAX_VALUE; [EOL] try { [EOL] add(instant, value); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testAdd_withMinValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] long value = Long.MIN_VALUE; [EOL] try { [EOL] add(instant, value); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testGetDifferenceWithPositiveScalar() { [EOL] int scalar = 5; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.getDifference(10L, 5L)).thenReturn(10); [EOL] DelegatedDateTimeField field = new DelegatedDateTimeField(mockField, scalar); [EOL] int result = field.getDifference(10L, 5L); [EOL] assertEquals(2, result); [EOL] }
public void testGetDifferenceWithNegativeScalar() { [EOL] int scalar = -5; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.getDifference(20L, 10L)).thenReturn(-15); [EOL] DelegatedDateTimeField field = new DelegatedDateTimeField(mockField, scalar); [EOL] int result = field.getDifference(20L, 10L); [EOL] assertEquals(3, result); [EOL] }
public void testGetDifferenceWithZeroScalar() { [EOL] int scalar = 0; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.getDifference(30L, 15L)).thenReturn(30); [EOL] DelegatedDateTimeField field = new DelegatedDateTimeField(mockField, scalar); [EOL] try { [EOL] field.getDifference(30L, 15L); [EOL] fail("Should have thrown ArithmeticException due to division by zero"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testWithZoneSameAsCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] DateTimeZone currentZone = chronology.getZone(); [EOL] Chronology result = chronology.withZone(currentZone); [EOL] assertSame("Should be the same chronology because zones are equal", chronology, result); [EOL] }
public void testWithZoneDifferentFromCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] DateTimeZone differentZone = ...; // Initialize with a different zone [EOL] Chronology result = chronology.withZone(differentZone); [EOL] assertNotSame("Should not be the same chronology because zones are different", chronology, result); [EOL] assertEquals("The new chronology should have the new zone", differentZone, result.getZone()); [EOL] }
public void testWithZoneNull() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] Chronology result = chronology.withZone(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] assertEquals("The new chronology should have the default zone", defaultZone, result.getZone()); [EOL] }
public int hashCode() { [EOL] return "ISO".hashCode() * 11 + getZone().hashCode(); [EOL] }
public void testGetType() { [EOL] DurationFieldType type = DurationFieldType.minutes(); [EOL] DurationField field = type.getField(ISOChronology.getInstanceUTC()); [EOL] assertEquals(type, field.getType()); [EOL] }
public final boolean isSupported() { [EOL] return true; [EOL] }
public int getValue(long duration) { [EOL] return FieldUtils.safeToInt(getValueAsLong(duration)); [EOL] }
public int getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL] long difference = minuendInstant - subtrahendInstant; [EOL] return difference; [EOL] } [EOL] public void testGetDifferenceWithPositiveDifference() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expected = 500; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceWithNegativeDifference() { [EOL] long minuendInstant = 500L; [EOL] long subtrahendInstant = 1000L; [EOL] int expected = -500; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceWithNoDifference() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] int expected = 0; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceWithMaxIntDifference() { [EOL] long minuendInstant = Integer.MAX_VALUE; [EOL] long subtrahendInstant = 0L; [EOL] int expected = Integer.MAX_VALUE; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceWithMinIntDifference() { [EOL] long minuendInstant = 0L; [EOL] long subtrahendInstant = Integer.MAX_VALUE; [EOL] int expected = -Integer.MAX_VALUE; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testCompareTo_EqualDurationFields() { [EOL] DurationField field1 = new DurationField(1000); // Assuming constructor takes milliseconds [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LessThanOtherDurationField() { [EOL] DurationField field1 = new DurationField(500); [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_GreaterThanOtherDurationField() { [EOL] DurationField field1 = new DurationField(1500); [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(1, result); [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeRelativeYear() { [EOL] int year = 1686; // relativeYear will be -1 [EOL] long expectedMillis = ...; // calculate expected millis based on the logic and constants [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForLeapYear() { [EOL] int year = 1692; // relativeYear will be 5, and it's a leap year [EOL] long expectedMillis = ...; // calculate expected millis based on the logic and constants [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForNonLeapYear() { [EOL] int year = 1693; // relativeYear will be 6, and it's not a leap year [EOL] long expectedMillis = ...; // calculate expected millis based on the logic and constants [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMinYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MIN_YEAR; [EOL] int actual = time.getMinYear(); [EOL] assertEquals(expected, actual); [EOL] }
private Object readResolve() { [EOL] return Months.months(getValue()); [EOL] }
public void testDividedBy_DivisorIsOne() { [EOL] Months months = Months.months(5); [EOL] Months result = months.dividedBy(1); [EOL] assertEquals(months, result); [EOL] }
public void testDividedBy_DivisorIsNotOne() { [EOL] Months months = Months.months(5); [EOL] Months result = months.dividedBy(2); [EOL] assertEquals(Months.months(2), result); [EOL] }
public void testDividedBy_DivisorIsZero() { [EOL] Months months = Months.months(5); [EOL] try { [EOL] months.dividedBy(0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Months testMonths = Months.months(5); [EOL] boolean result = testMonths.isLessThan(null); [EOL] assert result == (testMonths.getValue() < 0); [EOL] }
public void testIsLessThanWithLesserOther() { [EOL] Months testMonths = Months.months(5); [EOL] Months otherMonths = Months.months(10); [EOL] boolean result = testMonths.isLessThan(otherMonths); [EOL] assert result == true; [EOL] }
public void testIsLessThanWithGreaterOther() { [EOL] Months testMonths = Months.months(5); [EOL] Months otherMonths = Months.months(1); [EOL] boolean result = testMonths.isLessThan(otherMonths); [EOL] assert result == false; [EOL] }
public void testIsLessThanWithEqualOther() { [EOL] Months testMonths = Months.months(5); [EOL] Months otherMonths = Months.months(5); [EOL] boolean result = testMonths.isLessThan(otherMonths); [EOL] assert result == false; [EOL] }
public void testIntervalConstructorWithValidInput() { [EOL] Object validInterval = // initialize with a valid interval object [EOL] Interval interval = new Interval(validInterval); [EOL] assertNotNull(interval); [EOL] }
public void testGap_ThisStartAfterOtherEnd() { [EOL] ReadableInterval inputInterval = new MockReadableInterval(new DateTime(2020, 1, 1, 0, 0), new DateTime(2020, 1, 2, 0, 0)); [EOL] Interval testInterval = new Interval(new DateTime(2020, 1, 3, 0, 0), new DateTime(2020, 1, 4, 0, 0)); [EOL] Interval expected = new Interval(new DateTime(2020, 1, 2, 0, 0), new DateTime(2020, 1, 3, 0, 0)); [EOL] Interval actual = testInterval.gap(inputInterval); [EOL] assertEquals(expected, actual); [EOL] }
public void testGap_OtherStartAfterThisEnd() { [EOL] ReadableInterval inputInterval = new MockReadableInterval(new DateTime(2020, 1, 5, 0, 0), new DateTime(2020, 1, 6, 0, 0)); [EOL] Interval testInterval = new Interval(new DateTime(2020, 1, 3, 0, 0), new DateTime(2020, 1, 4, 0, 0)); [EOL] Interval expected = new Interval(new DateTime(2020, 1, 4, 0, 0), new DateTime(2020, 1, 5, 0, 0)); [EOL] Interval actual = testInterval.gap(inputInterval); [EOL] assertEquals(expected, actual); [EOL] }
public void testGap_NoGap() { [EOL] ReadableInterval inputInterval = new MockReadableInterval(new DateTime(2020, 1, 2, 0, 0), new DateTime(2020, 1, 3, 0, 0)); [EOL] Interval testInterval = new Interval(new DateTime(2020, 1, 1, 0, 0), new DateTime(2020, 1, 4, 0, 0)); [EOL] Interval actual = testInterval.gap(inputInterval); [EOL] assertNull(actual); [EOL] }
public void testAbutsWithNullInterval() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = null; [EOL] MyInterval testInterval = new MyInterval(now - 1000, now); [EOL] boolean result = testInterval.abuts(interval); [EOL] assertTrue(result); [EOL] }
public void testAbutsWithNonAbuttingInterval() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = new MyInterval(now + 1000, now + 2000); [EOL] MyInterval testInterval = new MyInterval(now - 2000, now - 1000); [EOL] boolean result = testInterval.abuts(interval); [EOL] assertFalse(result); [EOL] }
public void testAbutsWithAbuttingIntervalAtStart() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = new MyInterval(now - 2000, now - 1000); [EOL] MyInterval testInterval = new MyInterval(now - 1000, now); [EOL] boolean result = testInterval.abuts(interval); [EOL] assertTrue(result); [EOL] }
public void testAbutsWithAbuttingIntervalAtEnd() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = new MyInterval(now, now + 1000); [EOL] MyInterval testInterval = new MyInterval(now - 1000, now); [EOL] boolean result = testInterval.abuts(interval); [EOL] assertTrue(result); [EOL] }
public void testWithDurationAfterStart_SameDuration() { [EOL] Interval interval = new Interval(0, 1000); // Assuming Interval and ReadableDuration are existing classes [EOL] ReadableDuration duration = new Duration(1000); // Assuming Duration implements ReadableDuration [EOL] Interval result = interval.withDurationAfterStart(duration); [EOL] assertEquals(interval, result); [EOL] }
public void testWithDurationAfterStart_DifferentDuration() { [EOL] Interval interval = new Interval(0, 1000); [EOL] ReadableDuration duration = new Duration(2000); [EOL] Interval result = interval.withDurationAfterStart(duration); [EOL] assertNotSame(interval, result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(2000, result.getEndMillis()); [EOL] }
public void testWithDurationBeforeEnd_SameDuration() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Duration duration = new Duration(1000); [EOL] Interval result = interval.withDurationBeforeEnd(duration); [EOL] assertEquals(interval, result); [EOL] }
public void testWithDurationBeforeEnd_DifferentDuration() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Duration duration = new Duration(500); [EOL] Interval result = interval.withDurationBeforeEnd(duration); [EOL] assertEquals(endMillis - 500, result.getStartMillis()); [EOL] assertEquals(endMillis, result.getEndMillis()); [EOL] }
public void testWithDurationBeforeEnd_NullDuration() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withDurationBeforeEnd(null); [EOL] assertEquals(endMillis, result.getStartMillis()); [EOL] assertEquals(endMillis, result.getEndMillis()); [EOL] }
public void testWithPeriodAfterStartWithNullPeriod() { [EOL] Interval interval = new Interval(0, 10); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] Interval result = interval.withPeriodAfterStart(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(10, result.getEndMillis()); [EOL] }
public void testWithPeriodAfterStartWithNonNullPeriod() { [EOL] Interval interval = new Interval(0, 10); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] ReadablePeriod period = new Period(0, 0, 0, 1); // Assuming Period constructor Period(hours, minutes, seconds, millis) [EOL] Interval result = interval.withPeriodAfterStart(period); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(1, result.getEndMillis()); [EOL] }
public void testYearMonthLongConstructor() { [EOL] long testInstant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(testInstant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthLongChronologyConstructor() { [EOL] long testInstant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(testInstant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthNowZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthParseString() { [EOL] String str = "2023-04"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthParseStringFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 1); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.YEAR), yearMonth.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonth_Object() { [EOL] Object instant = new Date(); // Assuming Date can be converted to YearMonth [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_DefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_LongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_LongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ObjectChronologyConstructor() { [EOL] Object instant = new Date(); // Assuming Date can be converted to YearMonth [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_IntIntConstructor() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonth_IntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthConstructorWithYearAndMonth() { [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthConstructorWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthConstructorWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, ISOChronology.getInstanceUTC()), yearMonth); [EOL] }
public void testYearMonthConstructorWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, chronology), yearMonth); [EOL] }
public void testYearMonthConstructorWithObject() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, ISOChronology.getInstance()), yearMonth); [EOL] }
public void testYearMonthConstructorWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, chronology), yearMonth); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now(ISOChronology.getInstance()), yearMonth); [EOL] }
public void testYearMonthNowWithDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now(zone.getChronology()), yearMonth); [EOL] }
public void testYearMonthNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now(chronology), yearMonth); [EOL] }
public void testYearMonthParseString() { [EOL] String str = "2020-06"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(2020, 6), yearMonth); [EOL] }
public void testYearMonthParseStringWithFormatter() { [EOL] String str = "2020-06"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(2020, 6), yearMonth); [EOL] }
public void testYearMonthFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1), yearMonth); [EOL] }
public void testYearMonthFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] assertNotNull(yearMonth); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1), yearMonth); [EOL] }
public void testYearMonthWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthWithNullChronology() { [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, null); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] assertNotNull(yearMonth.getChronology()); [EOL] }
public void testYearMonthWithInvalidMonth() { [EOL] try { [EOL] new YearMonth(2020, 13, ISOChronology.getInstance()); [EOL] fail("Should have thrown an exception for invalid month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testYearMonthWithInvalidYear() { [EOL] try { [EOL] new YearMonth(Integer.MIN_VALUE, 1, ISOChronology.getInstance()); [EOL] fail("Should have thrown an exception for invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testYearMonthWithPartialAndValues() { [EOL] YearMonth partial = new YearMonth(2020, 1); [EOL] int[] values = new int[] {2021, 2}; [EOL] YearMonth result = new YearMonth(partial, values); [EOL] assertEquals(2021, result.getYear()); [EOL] assertEquals(2, result.getMonthOfYear()); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth result = new YearMonth(); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth result = new YearMonth(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getChronology().getZone()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth result = new YearMonth(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth result = new YearMonth(instant); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth result = new YearMonth(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth result = new YearMonth(instant); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth result = new YearMonth(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth partial = new YearMonth(2020, 1); [EOL] YearMonth result = new YearMonth(partial); [EOL] assertEquals(partial, result); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth partial = new YearMonth(2020, 1); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth result = new YearMonth(partial, chronology); [EOL] assertEquals(partial.getYear(), result.getYear()); [EOL] assertEquals(partial.getMonthOfYear(), result.getMonthOfYear()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] YearMonth result = new YearMonth(2020, 1); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth result = new YearMonth(2020, 1, chronology); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public int size() { [EOL] return 2; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case YEAR: [EOL] return chrono.year(); [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public YearMonth(); [EOL] public YearMonth(DateTimeZone zone); [EOL] public YearMonth(Chronology chronology); [EOL] public YearMonth(long instant); [EOL] public YearMonth(long instant, Chronology chronology); [EOL] public YearMonth(Object instant); [EOL] public YearMonth(Object instant, Chronology chronology); [EOL] public YearMonth(int year, int monthOfYear); [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology); [EOL] YearMonth(YearMonth partial, int[] values); [EOL] YearMonth(YearMonth partial, Chronology chrono); [EOL] Property(YearMonth partial, int fieldIndex); [EOL] public static YearMonth now(); [EOL] public static YearMonth now(DateTimeZone zone); [EOL] public static YearMonth now(Chronology chronology); [EOL] public static YearMonth parse(String str); [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter); [EOL] public static YearMonth fromCalendarFields(Calendar calendar); [EOL] public static YearMonth fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonth plus(ReadablePeriod period); [EOL] public YearMonth plusYears(int years); [EOL] public YearMonth plusMonths(int months); [EOL] public YearMonth minus(ReadablePeriod period); [EOL] public YearMonth minusYears(int years); [EOL] public YearMonth minusMonths(int months); [EOL] public LocalDate toLocalDate(int dayOfMonth); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public YearMonth withYear(int year); [EOL] public YearMonth withMonthOfYear(int monthOfYear); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonth getYearMonth(); [EOL] public int get(); [EOL] public YearMonth addToCopy(int valueToAdd); [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonth setCopy(int value); [EOL] public YearMonth setCopy(String text, Locale locale); [EOL] public YearMonth setCopy(String text); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }]
public void testGetFieldTypes() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] DateTimeFieldType[] fieldTypes = yearMonth.getFieldTypes(); [EOL] assertNotNull(fieldTypes); [EOL] assertEquals(2, fieldTypes.length); [EOL] assertEquals(DateTimeFieldType.year(), fieldTypes[0]); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), fieldTypes[1]); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] int[] values = new int[] {2023, 4}; [EOL] YearMonth yearMonth = new YearMonth(original, values); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(original, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(2023, 4, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testNow() { [EOL] YearMonth now = YearMonth.now(); [EOL] assertNotNull(now); [EOL] }
public void testNowZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth now = YearMonth.now(zone); [EOL] assertNotNull(now); [EOL] assertEquals(zone, now.getChronology().getZone()); [EOL] }
public void testNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth now = YearMonth.now(chronology); [EOL] assertNotNull(now); [EOL] assertEquals(chronology, now.getChronology()); [EOL] }
public void testParseString() { [EOL] String str = "2023-04"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testParseStringFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 1); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] assertNotNull(yearMonth); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] YearMonth original = new YearMonth(); // Assuming default constructor uses current system chronology [EOL] Chronology originalChronology = original.getChronology(); [EOL] YearMonth result = original.withChronologyRetainFields(originalChronology); [EOL] assertSame("Expected same YearMonth object as chronology is same", original, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] YearMonth original = new YearMonth(); // Assuming default constructor uses current system chronology [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); // Different chronology [EOL] if (original.getChronology().equals(newChronology)) { [EOL] return; // Skip test if the chronologies are the same [EOL] } [EOL] YearMonth result = original.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Expected different YearMonth object as chronology is different", original, result); [EOL] assertEquals("Expected new chronology in result", newChronology, result.getChronology()); [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.withFieldAdded(DurationFieldType.months(), 0); [EOL] assertEquals(yearMonth, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.withFieldAdded(DurationFieldType.months(), 1); [EOL] assertNotEquals(yearMonth, result); [EOL] assertEquals(new YearMonth(2023, 5), result); [EOL] }
public void testWithFieldAdded_UnsupportedField() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] try { [EOL] yearMonth.withFieldAdded(DurationFieldType.seconds(), 1); [EOL] fail("Should have thrown an exception for unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.withPeriodAdded(null, 1); [EOL] assertEquals(yearMonth, result); [EOL] }
public void testWithPeriodAdded_ZeroScalar() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] Period period = new Period().withYears(1); [EOL] YearMonth result = yearMonth.withPeriodAdded(period, 0); [EOL] assertEquals(yearMonth, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodPositiveScalar() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] Period period = new Period().withYears(1); [EOL] YearMonth result = yearMonth.withPeriodAdded(period, 1); [EOL] assertNotEquals(yearMonth, result); [EOL] assertEquals(new YearMonth(2024, 4), result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodNegativeScalar() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] Period period = new Period().withYears(1); [EOL] YearMonth result = yearMonth.withPeriodAdded(period, -1); [EOL] assertNotEquals(yearMonth, result); [EOL] assertEquals(new YearMonth(2022, 4), result); [EOL] }
public void testWithPeriodAdded_PeriodWithUnsupportedField() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] Period period = new Period().withDays(1); // Assuming YearMonth does not support days [EOL] YearMonth result = yearMonth.withPeriodAdded(period, 1); [EOL] assertEquals(yearMonth, result); // No change expected [EOL] }
public void testPlus_withNullPeriod() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Any arbitrary date [EOL] YearMonth result = yearMonth.plus(null); [EOL] assertEquals("Adding a null period should not change the YearMonth", yearMonth, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Any arbitrary date [EOL] ReadablePeriod period = new Period().withYears(1); // Any non-null period [EOL] YearMonth expected = new YearMonth(2024, 4); // Expected YearMonth after adding the period [EOL] YearMonth result = yearMonth.plus(period); [EOL] assertEquals("Adding a period of 1 year should result in the YearMonth 2024-04", expected, result); [EOL] }
public void testPlusYears_Normal() { [EOL] YearMonth test = new YearMonth(2020, 6); // Any arbitrary YearMonth [EOL] YearMonth expected = new YearMonth(2023, 6); // Expected YearMonth after adding 3 years [EOL] YearMonth result = test.plusYears(3); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusYears_Negative() { [EOL] YearMonth test = new YearMonth(2020, 6); // Any arbitrary YearMonth [EOL] YearMonth expected = new YearMonth(2017, 6); // Expected YearMonth after subtracting 3 years [EOL] YearMonth result = test.plusYears(-3); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusYears_Zero() { [EOL] YearMonth test = new YearMonth(2020, 6); // Any arbitrary YearMonth [EOL] YearMonth expected = new YearMonth(2020, 6); // Expected YearMonth should be the same [EOL] YearMonth result = test.plusYears(0); [EOL] assertEquals(expected, result); [EOL] }
public YearMonth plusMonths(int months) { [EOL] return withFieldAdded(DurationFieldType.months(), months); [EOL] } [EOL] public YearMonth() {} [EOL] public YearMonth(DateTimeZone zone) {} [EOL] public YearMonth(Chronology chronology) {} [EOL] public YearMonth(long instant) {} [EOL] public YearMonth(long instant, Chronology chronology) {} [EOL] public YearMonth(Object instant) {} [EOL] public YearMonth(Object instant, Chronology chronology) {} [EOL] public YearMonth(int year, int monthOfYear) {} [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) {} [EOL] YearMonth(YearMonth partial, int[] values) {} [EOL] YearMonth(YearMonth partial, Chronology chrono) {} [EOL] Property(YearMonth partial, int fieldIndex) {} [EOL] public static YearMonth now() {} [EOL] public static YearMonth now(DateTimeZone zone) {} [EOL] public static YearMonth now(Chronology chronology) {} [EOL] public static YearMonth parse(String str) {} [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) {} [EOL] public static YearMonth fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonth fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonth plus(ReadablePeriod period) {} [EOL] public YearMonth plusYears(int years) {} [EOL] public YearMonth minus(ReadablePeriod period) {} [EOL] public YearMonth minusYears(int years) {} [EOL] public YearMonth minusMonths(int months) {} [EOL] public LocalDate toLocalDate(int dayOfMonth) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public YearMonth withYear(int year) {} [EOL] public YearMonth withMonthOfYear(int monthOfYear) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonth getYearMonth() {} [EOL] public int get() {} [EOL] public YearMonth addToCopy(int valueToAdd) {} [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonth setCopy(int value) {} [EOL] public YearMonth setCopy(String text, Locale locale) {} [EOL] public YearMonth setCopy(String text) {} [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public void testMinus_withNullPeriod() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Example YearMonth [EOL] YearMonth result = yearMonth.minus(null); [EOL] assertEquals("Minus with null period should return the same YearMonth", yearMonth, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Example YearMonth [EOL] ReadablePeriod period = new Period().withYears(1); // Example period of 1 year [EOL] YearMonth expected = new YearMonth(2022, 4); // Expected YearMonth after subtraction [EOL] YearMonth result = yearMonth.minus(period); [EOL] assertEquals("Minus with a valid period should return the correct YearMonth", expected, result); [EOL] }
public void testToLocalDate_ValidDayOfMonth() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Assuming a constructor with year and month exists [EOL] LocalDate result = yearMonth.toLocalDate(15); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(15, result.getDayOfMonth()); [EOL] }
public void testToLocalDate_InvalidDayOfMonth() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // Assuming a constructor with year and month exists [EOL] try { [EOL] LocalDate result = yearMonth.toLocalDate(32); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNow() { [EOL] YearMonth result = YearMonth.now(); [EOL] assertNotNull(result); [EOL] }
public void testNow_WithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("America/New_York"); [EOL] YearMonth result = YearMonth.now(zone); [EOL] assertNotNull(result); [EOL] }
public void testNow_WithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth result = YearMonth.now(chronology); [EOL] assertNotNull(result); [EOL] }
public void testParse_String() { [EOL] String str = "2023-04"; [EOL] YearMonth result = YearMonth.parse(str); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testParse_StringFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth result = YearMonth.parse(str, formatter); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 15); [EOL] YearMonth result = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.APRIL, 15).getTime(); [EOL] YearMonth result = YearMonth.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testWithYear() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.withYear(2022); [EOL] assertNotNull(result); [EOL] assertEquals(2022, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.withMonthOfYear(5); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(5, result.getMonthOfYear()); [EOL] }
public void testPlusYears() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.plusYears(1); [EOL] assertNotNull(result); [EOL] assertEquals(2024, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testPlusMonths() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.plusMonths(2); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(6, result.getMonthOfYear()); [EOL] }
public void testMinusYears() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.minusYears(1); [EOL] assertNotNull(result); [EOL] assertEquals(2022, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] }
public void testMinusMonths() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.minusMonths(2); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(2, result.getMonthOfYear()); [EOL] }
public void testToInterval() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] Interval result = yearMonth.toInterval(); [EOL] assertNotNull(result); [EOL] }
public void testToInterval_WithZone() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] DateTimeZone zone = DateTimeZone.forID("America/New_York"); [EOL] Interval result = yearMonth.toInterval(zone); [EOL] assertNotNull(result); [EOL] }
public void testToInterval_NullZone() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] Interval interval = yearMonth.toInterval(null); [EOL] assertNotNull(interval); [EOL] }
public void testYearMonth_DefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_InstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_InstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_YearMonthConstructor() { [EOL] YearMonth partial = new YearMonth(); [EOL] int[] values = new int[] {2023, 4}; [EOL] YearMonth yearMonth = new YearMonth(partial, values); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_YearMonthChronoConstructor() { [EOL] YearMonth partial = new YearMonth(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(partial, chrono); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_IntIntConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_IntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(2023, 4, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_Now() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_NowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_NowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ParseString() { [EOL] String str = "2023-04"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_ParseStringFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_FromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_FromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] assertNotNull(yearMonth); [EOL] }
public Interval toInterval(DateTimeZone zone) { [EOL] zone = DateTimeUtils.getZone(zone); [EOL] DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone); [EOL] DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone); [EOL] return new Interval(start, end); [EOL] }
public int getYear() { [EOL] return getValue(YEAR); [EOL] } [EOL] public YearMonth() {} [EOL] public YearMonth(DateTimeZone zone) {} [EOL] public YearMonth(Chronology chronology) {} [EOL] public YearMonth(long instant) {} [EOL] public YearMonth(long instant, Chronology chronology) {} [EOL] public YearMonth(Object instant) {} [EOL] public YearMonth(Object instant, Chronology chronology) {} [EOL] public YearMonth(int year, int monthOfYear) {} [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) {} [EOL] YearMonth(YearMonth partial, int[] values) {} [EOL] YearMonth(YearMonth partial, Chronology chrono) {} [EOL] Property(YearMonth partial, int fieldIndex) {} [EOL] public static YearMonth now() {} [EOL] public static YearMonth now(DateTimeZone zone) {} [EOL] public static YearMonth now(Chronology chronology) {} [EOL] public static YearMonth parse(String str) {} [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) {} [EOL] public static YearMonth fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonth fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonth plus(ReadablePeriod period) {} [EOL] public YearMonth plusYears(int years) {} [EOL] public YearMonth plusMonths(int months) {} [EOL] public YearMonth minus(ReadablePeriod period) {} [EOL] public YearMonth minusYears(int years) {} [EOL] public YearMonth minusMonths(int months) {} [EOL] public LocalDate toLocalDate(int dayOfMonth) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public YearMonth withYear(int year) {} [EOL] public YearMonth withMonthOfYear(int monthOfYear) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonth getYearMonth() {} [EOL] public int get() {} [EOL] public YearMonth addToCopy(int valueToAdd) {} [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonth setCopy(int value) {} [EOL] public YearMonth setCopy(String text, Locale locale) {} [EOL] public YearMonth setCopy(String text) {} [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public void testGetMonthOfYear() { [EOL] YearMonth ym = new YearMonth(); [EOL] int monthOfYear = ym.getMonthOfYear(); [EOL] }
public void testYearMonthWithChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth ym = new YearMonth(chrono); [EOL] }
public void testYearMonthWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth ym = new YearMonth(instant); [EOL] }
public void testYearMonthWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth ym = new YearMonth(instant, chrono); [EOL] }
public void testYearMonthWithObject() { [EOL] Object instant = new Date(); [EOL] YearMonth ym = new YearMonth(instant); [EOL] }
public void testYearMonthWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth ym = new YearMonth(instant, chrono); [EOL] }
public void testYearMonthWithYearAndMonth() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] YearMonth ym = new YearMonth(year, monthOfYear); [EOL] }
public void testYearMonthWithYearMonthAndChronology() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth ym = new YearMonth(year, monthOfYear, chrono); [EOL] }
public void testNow() { [EOL] YearMonth ym = YearMonth.now(); [EOL] }
public void testNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] YearMonth ym = YearMonth.now(zone); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonth ym = YearMonth.now(chrono); [EOL] }
public void testParseString() { [EOL] String str = "2023-04"; [EOL] YearMonth ym = YearMonth.parse(str); [EOL] }
public void testParseStringWithFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth ym = YearMonth.parse(str, formatter); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonth ym = YearMonth.fromCalendarFields(calendar); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth ym = YearMonth.fromDateFields(date); [EOL] }
public Property monthOfYear() { [EOL] return new Property(this, MONTH_OF_YEAR); [EOL] } [EOL] public YearMonth() { [EOL] } [EOL] public YearMonth(DateTimeZone zone) { [EOL] } [EOL] public YearMonth(Chronology chronology) { [EOL] } [EOL] public YearMonth(long instant) { [EOL] } [EOL] public YearMonth(long instant, Chronology chronology) { [EOL] } [EOL] public YearMonth(Object instant) { [EOL] } [EOL] public YearMonth(Object instant, Chronology chronology) { [EOL] } [EOL] public YearMonth(int year, int monthOfYear) { [EOL] } [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) { [EOL] } [EOL] YearMonth(YearMonth partial, int[] values) { [EOL] } [EOL] YearMonth(YearMonth partial, Chronology chrono) { [EOL] } [EOL] Property(YearMonth partial, int fieldIndex) { [EOL] } [EOL] public static YearMonth now() { [EOL] } [EOL] public static YearMonth now(DateTimeZone zone) { [EOL] } [EOL] public static YearMonth now(Chronology chronology) { [EOL] } [EOL] public static YearMonth parse(String str) { [EOL] } [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) { [EOL] } [EOL] public static YearMonth fromCalendarFields(Calendar calendar) { [EOL] } [EOL] public static YearMonth fromDateFields(Date date) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] public int size() { [EOL] } [EOL] protected DateTimeField getField(int index, Chronology chrono) { [EOL] } [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] } [EOL] public DateTimeFieldType[] getFieldTypes() { [EOL] } [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) { [EOL] } [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) { [EOL] } [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) { [EOL] } [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL] } [EOL] public YearMonth plus(ReadablePeriod period) { [EOL] } [EOL] public YearMonth plusYears(int years) { [EOL] } [EOL] public YearMonth plusMonths(int months) { [EOL] } [EOL] public YearMonth minus(ReadablePeriod period) { [EOL] } [EOL] public YearMonth minusYears(int years) { [EOL] } [EOL] public YearMonth minusMonths(int months) { [EOL] } [EOL] public LocalDate toLocalDate(int dayOfMonth) { [EOL] } [EOL] public Interval toInterval() { [EOL] } [EOL] public Interval toInterval(DateTimeZone zone) { [EOL] } [EOL] public int getYear() { [EOL] } [EOL] public int getMonthOfYear() { [EOL] } [EOL] public YearMonth withYear(int year) { [EOL] } [EOL] public YearMonth withMonthOfYear(int monthOfYear) { [EOL] } [EOL] public Property property(DateTimeFieldType type) { [EOL] } [EOL] public Property year() { [EOL] } [EOL] public Property monthOfYear() { [EOL] } [EOL] public String toString() { [EOL] } [EOL] public String toString(String pattern) { [EOL] } [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL] } [EOL] public DateTimeField getField() { [EOL] } [EOL] protected ReadablePartial getReadablePartial() { [EOL] } [EOL] public YearMonth getYearMonth() { [EOL] } [EOL] public int get() { [EOL] } [EOL] public YearMonth addToCopy(int valueToAdd) { [EOL] } [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL] } [EOL] public YearMonth setCopy(int value) { [EOL] } [EOL] public YearMonth setCopy(String text, Locale locale) { [EOL] } [EOL] public YearMonth setCopy(String text) { [EOL] } [EOL] long serialVersionUID = 797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public void testPropertyConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2020, 4); [EOL] int fieldIndex = 0; [EOL] Property property = new Property(yearMonth, fieldIndex); [EOL] assertNotNull(property); [EOL] assertEquals(yearMonth, property.getYearMonth()); [EOL] assertEquals(fieldIndex, property.getField().getIndex()); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth original = new YearMonth(2020, 4); [EOL] int[] values = new int[] {2021, 5}; [EOL] YearMonth yearMonth = new YearMonth(original, values); [EOL] assertNotNull(yearMonth); [EOL] assertNotEquals(original, yearMonth); [EOL] assertEquals(2021, yearMonth.getYear()); [EOL] assertEquals(5, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth original = new YearMonth(2020, 4); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(original, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public DateTimeField getField() { [EOL] return iBase.getField(iFieldIndex); [EOL] } [EOL] public YearMonth() {} [EOL] public YearMonth(DateTimeZone zone) {} [EOL] public YearMonth(Chronology chronology) {} [EOL] public YearMonth(long instant) {} [EOL] public YearMonth(long instant, Chronology chronology) {} [EOL] public YearMonth(Object instant) {} [EOL] public YearMonth(Object instant, Chronology chronology) {} [EOL] public YearMonth(int year, int monthOfYear) {} [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) {} [EOL] YearMonth(YearMonth partial, int[] values) {} [EOL] YearMonth(YearMonth partial, Chronology chrono) {} [EOL] Property(YearMonth partial, int fieldIndex) {} [EOL] public static YearMonth now() {} [EOL] public static YearMonth now(DateTimeZone zone) {} [EOL] public static YearMonth now(Chronology chronology) {} [EOL] public static YearMonth parse(String str) {} [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) {} [EOL] public static YearMonth fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonth fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonth plus(ReadablePeriod period) {} [EOL] public YearMonth plusYears(int years) {} [EOL] public YearMonth plusMonths(int months) {} [EOL] public YearMonth minus(ReadablePeriod period) {} [EOL] public YearMonth minusYears(int years) {} [EOL] public YearMonth minusMonths(int months) {} [EOL] public LocalDate toLocalDate(int dayOfMonth) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public YearMonth withYear(int year) {} [EOL] public YearMonth withMonthOfYear(int monthOfYear) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonth getYearMonth() {} [EOL] public int get() {} [EOL] public YearMonth addToCopy(int valueToAdd) {} [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonth setCopy(int value) {} [EOL] public YearMonth setCopy(String text, Locale locale) {} [EOL] public YearMonth setCopy(String text) {} [EOL] long serialVersionUID = 797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public void testGetYearMonth() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] YearMonth result = yearMonth.getYearMonth(); [EOL] assertNotNull(result); [EOL] assertEquals(yearMonth, result); [EOL] }
public void testYearMonthWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, ISOChronology.getInstance()), yearMonth); [EOL] }
public void testYearMonthWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, chronology), yearMonth); [EOL] }
public void testYearMonthWithObject() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant), yearMonth); [EOL] }
public void testYearMonthWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant, chronology), yearMonth); [EOL] }
public void testYearMonthWithYearAndMonth() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthWithYearMonthAndChronology() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testNow() { [EOL] YearMonth now = YearMonth.now(); [EOL] assertNotNull(now); [EOL] assertEquals(new YearMonth(), now); [EOL] }
public void testNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth now = YearMonth.now(zone); [EOL] assertNotNull(now); [EOL] assertEquals(ISOChronology.getInstance(zone), now.getChronology()); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth now = YearMonth.now(chronology); [EOL] assertNotNull(now); [EOL] assertEquals(chronology, now.getChronology()); [EOL] }
public void testGet() { [EOL] Property property = new YearMonth().year(); [EOL] int fieldValue = property.get(); [EOL] assertEquals(property.getYearMonth().getYear(), fieldValue); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] int[] values = new int[] {original.getYear(), original.getMonthOfYear()}; [EOL] YearMonth yearMonth = new YearMonth(original, values); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(original, yearMonth); [EOL] }
public void testYearMonthYearMonthChronoConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(original, chrono); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chrono, yearMonth.getChronology()); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] int year = 2021; [EOL] int month = 5; [EOL] YearMonth yearMonth = new YearMonth(year, month); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(month, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronoConstructor() { [EOL] int year = 2021; [EOL] int month = 5; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(year, month, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(month, yearMonth.getMonthOfYear()); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testNow() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testNowZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testParseString() { [EOL] String str = "2021-05"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2021, yearMonth.getYear()); [EOL] assertEquals(5, yearMonth.getMonthOfYear()); [EOL] }
public void testParseStringFormatter() { [EOL] String str = "2021-05"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2021, yearMonth.getYear()); [EOL] assertEquals(5, yearMonth.getMonthOfYear()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(calendar.get(Calendar.YEAR), yearMonth.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, yearMonth.getMonthOfYear()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] assertNotNull(yearMonth); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.YEAR), yearMonth.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, yearMonth.getMonthOfYear()); [EOL] }
public void testSetCopy_ValidValue() { [EOL] YearMonth original = new YearMonth(2020, 6); [EOL] int newValue = 2021; [EOL] YearMonth updated = original.setCopy(newValue); [EOL] assertEquals(newValue, updated.getYear()); [EOL] assertEquals(original.getMonthOfYear(), updated.getMonthOfYear()); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] YearMonth original = new YearMonth(2020, 6); [EOL] int invalidValue = -1; // Assuming the value is invalid [EOL] try { [EOL] original.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_MaxIntValue() { [EOL] YearMonth original = new YearMonth(2020, 6); [EOL] int maxValue = Integer.MAX_VALUE; [EOL] try { [EOL] YearMonth updated = original.setCopy(maxValue); [EOL] assertEquals(maxValue, updated.getYear()); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_MinIntValue() { [EOL] YearMonth original = new YearMonth(2020, 6); [EOL] int minValue = Integer.MIN_VALUE; [EOL] try { [EOL] YearMonth updated = original.setCopy(minValue); [EOL] assertEquals(minValue, updated.getYear()); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public String getAsTextTestWithValidPartial() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] String expected = "ExpectedText"; [EOL] Mockito.when(this.getAsText(fieldValue, locale)).thenReturn(expected); [EOL] String result = this.getAsText(mockPartial, fieldValue, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapPartial_ValueToAddIsZero() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, 0); [EOL] assertArrayEquals(values, result); [EOL] }
public void testAddWrapPartial_ValueToAddPositiveWithoutWrap() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int[] expected = new int[] {1, 5, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, 3); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddWrapPartial_ValueToAddPositiveWithWrap() { [EOL] int[] values = new int[] {1, 9, 3}; [EOL] int[] expected = new int[] {2, 1, 3}; // Assuming getMaximumValue returns 9 and getMinimumValue returns 1 [EOL] int[] result = addWrapPartial(instant, 1, values, 2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddWrapPartial_ValueToAddNegativeWithoutWrap() { [EOL] int[] values = new int[] {1, 5, 3}; [EOL] int[] expected = new int[] {1, 3, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, -2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddWrapPartial_ValueToAddNegativeWithWrap() { [EOL] int[] values = new int[] {1, 1, 3}; [EOL] int[] expected = new int[] {0, 9, 3}; // Assuming getMaximumValue returns 9 and getMinimumValue returns 1 [EOL] int[] result = addWrapPartial(instant, 1, values, -2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddWrapPartial_InvalidFieldIndex() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] addWrapPartial(instant, -1, values, 1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddWrapPartial_FieldInvalidForAdd() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] addWrapPartial(instant, 1, values, 1); // Assuming that the field at index 1 is invalid for add operation [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBasicDayOfMonthDateTimeFieldWithNonNullChronology() { [EOL] BasicChronology chronology = new GregorianChronology(); [EOL] DurationField days = chronology.days(); [EOL] BasicDayOfMonthDateTimeField field = new BasicDayOfMonthDateTimeField(chronology, days); [EOL] assertNotNull(field); [EOL] assertEquals(DateTimeFieldType.dayOfMonth(), field.getType()); [EOL] assertEquals(days, field.getDurationField()); [EOL] assertEquals(chronology, field.iChronology); [EOL] }
public void testBasicDayOfMonthDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new BasicDayOfMonthDateTimeField(null, new MockDurationField()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetRangeDurationField() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeField field = fieldType.getField(chronology); [EOL] DurationField rangeDurationField = field.getRangeDurationField(); [EOL] assertNotNull(rangeDurationField); [EOL] assertEquals("months", rangeDurationField.getType().getName()); [EOL] }
public void testGetMaximumValueWithMonthOfYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 2021}; // Assuming index 1 is monthOfYear and index 2 is year [EOL] Mockito.when(mockPartial.size()).thenReturn(3); [EOL] Mockito.when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] Mockito.when(mockPartial.getFieldType(2)).thenReturn(DateTimeFieldType.year()); [EOL] Mockito.when(iChronology.getDaysInYearMonth(2021, 2)).thenReturn(28); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(28, result); [EOL] }
public void testGetMaximumValueWithMonthOfYearButNoYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2}; // Assuming index 1 is monthOfYear [EOL] Mockito.when(mockPartial.size()).thenReturn(2); [EOL] Mockito.when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] Mockito.when(iChronology.getDaysInMonthMax(2)).thenReturn(29); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(29, result); [EOL] }
public void testGetMaximumValueWithoutMonthOfYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {}; // No monthOfYear or year [EOL] Mockito.when(mockPartial.size()).thenReturn(0); [EOL] Mockito.when(iChronology.getMaximumValue()).thenReturn(31); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(31, result); [EOL] }
public void testAppendPaddedInteger_NegativeValueNotMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, -1, 3); [EOL] assertEquals("-01", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_NegativeMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, Integer.MIN_VALUE, 12); [EOL] assertEquals("-0002147483648", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_SingleDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 5, 2); [EOL] assertEquals("05", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_TwoDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 50, 3); [EOL] assertEquals("050", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_ThreeDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123, 3); [EOL] assertEquals("123", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_FourDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 1234, 4); [EOL] assertEquals("1234", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_MultiDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 12345, 5); [EOL] assertEquals("12345", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_NegativeValueNotMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, -1); [EOL] assertEquals("-1", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_NegativeMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, Integer.MIN_VALUE); [EOL] assertEquals("-" + -(long) Integer.MIN_VALUE, buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_SingleDigit() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 5); [EOL] assertEquals("5", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_TwoDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 42); [EOL] assertEquals("42", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_MultipleDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 123); [EOL] assertEquals("123", buf.toString()); [EOL] }

public void testAppendUnpaddedIntegerWithIntValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long value = 123; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testAppendUnpaddedIntegerWithLongValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long value = Integer.MAX_VALUE + 1L; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals(Long.toString(Integer.MAX_VALUE + 1L), buf.toString()); [EOL] }
public void testCreateErrorMessageWithShortTextAndNegativeErrorPos() { [EOL] String result = createErrorMessage("short text", -1); [EOL] assertEquals("Invalid format: \"short text\"", result); [EOL] }
public void testCreateErrorMessageWithShortTextAndErrorPosBeyondLength() { [EOL] String result = createErrorMessage("short text", 20); [EOL] assertEquals("Invalid format: \"short text\" is too short", result); [EOL] }
public void testCreateErrorMessageWithShortTextAndValidErrorPos() { [EOL] String result = createErrorMessage("short text", 5); [EOL] assertEquals("Invalid format: \"short text\" is malformed at \"t text\"", result); [EOL] }
public void testCreateErrorMessageWithLongTextAndValidErrorPos() { [EOL] String result = createErrorMessage("this is a very long text that exceeds the limit of the sample length", 10); [EOL] assertEquals("Invalid format: \"this is a very long text that exceeds the...\" is malformed at \"very long text that exceeds the...\"", result); [EOL] }
public void testCreateErrorMessageWithLongTextAndErrorPosAtLimit() { [EOL] String result = createErrorMessage("this is a very long text that exceeds the limit of the sample length", 32); [EOL] assertEquals("Invalid format: \"this is a very long text that exceeds the...\" is malformed at \"that exceeds the...\"", result); [EOL] }
public void testGetInstanceUTC() { [EOL] JulianChronology instance = JulianChronology.getInstanceUTC(); [EOL] assertNotNull("Instance should not be null", instance); [EOL] assertSame("Instances should be the same", JulianChronology.INSTANCE_UTC, instance); [EOL] }
public void testGetInstance() { [EOL] JulianChronology instance = JulianChronology.getInstance(); [EOL] assertNotNull(instance); [EOL] assertEquals(DateTimeZone.getDefault(), instance.getZone()); [EOL] assertEquals(4, instance.getMinimumDaysInFirstWeek()); [EOL] }
public static JulianChronology getInstance(DateTimeZone zone) { [EOL] return getInstance(zone, 4); [EOL] }
public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL] if (zone == null) { [EOL] zone = DateTimeZone.getDefault(); [EOL] } [EOL] JulianChronology chrono; [EOL] synchronized (cCache) { [EOL] JulianChronology[] chronos = cCache.get(zone); [EOL] if (chronos == null) { [EOL] chronos = new JulianChronology[7]; [EOL] cCache.put(zone, chronos); [EOL] } [EOL] try { [EOL] chrono = chronos[minDaysInFirstWeek - 1]; [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL] } [EOL] if (chrono == null) { [EOL] if (zone == DateTimeZone.UTC) { [EOL] chrono = new JulianChronology(null, null, minDaysInFirstWeek); [EOL] } else { [EOL] chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL] chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL] } [EOL] chronos[minDaysInFirstWeek - 1] = chrono; [EOL] } [EOL] } [EOL] return chrono; [EOL] }
public void testJulianChronologyConstructor() { [EOL] Chronology base = null; // Assuming Chronology is an interface or class we can mock or instantiate [EOL] Object param = new Object(); [EOL] int minDaysInFirstWeek = 1; [EOL] try { [EOL] JulianChronology julianChronology = new JulianChronology(base, param, minDaysInFirstWeek); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testWithUTC() { [EOL] Chronology chronology = new SpecificChronology(); // Assuming SpecificChronology is a concrete implementation [EOL] Chronology utcChronology = chronology.withUTC(); [EOL] assertSame("Expected the UTC instance of Chronology", SpecificChronology.INSTANCE_UTC, utcChronology); [EOL] }
protected void assemble(Fields fields) { [EOL] if (getBase() == null) { [EOL] super.assemble(fields); [EOL] fields.year = new SkipDateTimeField(this, fields.year); [EOL] fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL] } [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(ReadableInstant.class, supportedType); [EOL] }
public void testEquals_SameObject() { [EOL] BuddhistChronology chrono1 = BuddhistChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono1)); [EOL] }
public void testEquals_DifferentObjectSameZone() { [EOL] BuddhistChronology chrono1 = BuddhistChronology.getInstance(); [EOL] BuddhistChronology chrono2 = BuddhistChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentObjectDifferentZone() { [EOL] BuddhistChronology chrono1 = BuddhistChronology.getInstance(); [EOL] BuddhistChronology chrono2 = BuddhistChronology.getInstance(ZoneId.of("Asia/Tokyo")); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_Null() { [EOL] BuddhistChronology chrono = BuddhistChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_NonChronologyObject() { [EOL] BuddhistChronology chrono = BuddhistChronology.getInstance(); [EOL] Object nonChrono = new Object(); [EOL] assertFalse(chrono.equals(nonChrono)); [EOL] }
public void testAbstractPartialFieldPropertyInstantiation() { [EOL] ConcretePartialFieldProperty instance = new ConcretePartialFieldProperty(); [EOL] assertNotNull(instance); [EOL] }
public DateTimeFieldType getFieldType() { [EOL] return getField().getType(); [EOL] }
public void testGetName() { [EOL] YourClass instance = new YourClass(); [EOL] Field field = mock(Field.class); [EOL] when(field.getName()).thenReturn("expectedName"); [EOL] instance.setField(field); // Assuming there's a method to set the field [EOL] String result = instance.getName(); [EOL] assertEquals("expectedName", result); [EOL] }
public void testGetAsString() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains getAsString [EOL] int expectedValue = 10; // Example value [EOL] instance.set(expectedValue); // Assuming there is a set method to set the internal state [EOL] String result = instance.getAsString(); [EOL] assertEquals("10", result); [EOL] }
public String getAsText() { [EOL] return getAsText(null); [EOL] }
public void testGetAsTextWithNullLocale() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] ReadablePartial readablePartial = mock(ReadablePartial.class); [EOL] int fieldValue = 10; // Example value [EOL] when(field.getAsText(readablePartial, fieldValue, null)).thenReturn("ExpectedText"); [EOL] YourClass yourClassInstance = new YourClass(field, readablePartial, fieldValue); [EOL] String result = yourClassInstance.getAsText(null); [EOL] assertEquals("ExpectedText", result); [EOL] }
public void testGetAsTextWithNonNullLocale() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] ReadablePartial readablePartial = mock(ReadablePartial.class); [EOL] int fieldValue = 10; // Example value [EOL] Locale testLocale = Locale.ENGLISH; [EOL] when(field.getAsText(readablePartial, fieldValue, testLocale)).thenReturn("ExpectedText"); [EOL] YourClass yourClassInstance = new YourClass(field, readablePartial, fieldValue); [EOL] String result = yourClassInstance.getAsText(testLocale); [EOL] assertEquals("ExpectedText", result); [EOL] }
public String getAsShortTextTest() { [EOL] Time time = new Time(); [EOL] String result = time.getAsShortText(); [EOL] assertNotNull(result); [EOL] assertEquals("expectedShortText", result); [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] int fieldValue = 5; // Example field value [EOL] when(mockPartial.getField()).thenReturn(mockField); [EOL] when(mockPartial.get()).thenReturn(fieldValue); [EOL] when(mockField.getAsShortText(mockPartial, fieldValue, null)).thenReturn("ShortText"); [EOL] String result = mockPartial.getAsShortText(null); [EOL] assertEquals("ShortText", result); [EOL] }
public void testGetAsShortTextWithNonNullLocale() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] int fieldValue = 5; // Example field value [EOL] Locale testLocale = Locale.FRENCH; // Example non-null locale [EOL] when(mockPartial.getField()).thenReturn(mockField); [EOL] when(mockPartial.get()).thenReturn(fieldValue); [EOL] when(mockField.getAsShortText(mockPartial, fieldValue, testLocale)).thenReturn("TexteCourt"); [EOL] String result = mockPartial.getAsShortText(testLocale); [EOL] assertEquals("TexteCourt", result); [EOL] }
public void testGetDurationField() { [EOL] Time time = new Time(); [EOL] DurationField result = time.getDurationField(); [EOL] assertNotNull("DurationField should not be null", result); [EOL] DurationField expected = new DurationField(); // Replace with actual creation of a DurationField [EOL] assertEquals("The DurationField returned was not as expected", expected, result); [EOL] }
public void testGetRangeDurationField_Coverage() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] DurationField expectedRangeDurationField = mock(DurationField.class); [EOL] when(mockField.getRangeDurationField()).thenReturn(expectedRangeDurationField); [EOL] Time time = new Time(mockField); [EOL] DurationField actualRangeDurationField = time.getRangeDurationField(); [EOL] assertNotNull(actualRangeDurationField); [EOL] assertSame(expectedRangeDurationField, actualRangeDurationField); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL] return getField().getMaximumTextLength(locale); [EOL] }
public int getMaximumShortTextLengthTestWithValidLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] int result = getMaximumShortTextLength(locale); [EOL] assertTrue(result >= 0); // Assuming that the maximum short text length should be non-negative [EOL] }
public int getMaximumShortTextLengthTestWithNullLocale() { [EOL] Locale locale = null; [EOL] try { [EOL] getMaximumShortTextLength(locale); [EOL] fail("Should have thrown IllegalArgumentException for null locale"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCompareTo_WithNullInstant_ThrowsIllegalArgumentException() { [EOL] ReadableInstant testInstant = null; [EOL] YourClass instance = new YourClass(); // Replace with actual constructor [EOL] try { [EOL] instance.compareTo(testInstant); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testCompareTo_WithSmallerInstantValue_ReturnsNegativeOne() { [EOL] ReadableInstant testInstant = createMockReadableInstantWithFieldValue(5); // Replace with actual method to create a mock with specified field value [EOL] YourClass instance = new YourClass(10); // Replace with actual constructor and value [EOL] int result = instance.compareTo(testInstant); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_WithLargerInstantValue_ReturnsOne() { [EOL] ReadableInstant testInstant = createMockReadableInstantWithFieldValue(15); // Replace with actual method to create a mock with specified field value [EOL] YourClass instance = new YourClass(10); // Replace with actual constructor and value [EOL] int result = instance.compareTo(testInstant); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_WithEqualInstantValue_ReturnsZero() { [EOL] ReadableInstant testInstant = createMockReadableInstantWithFieldValue(10); // Replace with actual method to create a mock with specified field value [EOL] YourClass instance = new YourClass(10); // Replace with actual constructor and value [EOL] int result = instance.compareTo(testInstant); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_NullInstant_ThrowsIllegalArgumentException() { [EOL] try { [EOL] someObject.compareTo(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCompareTo_LessThan_ReturnsNegativeOne() { [EOL] ReadablePartial mockPartial = createMockPartialWithFieldValue(1); // Assuming createMockPartialWithFieldValue sets up a partial with the desired field value [EOL] when(someObject.get()).thenReturn(0); [EOL] int result = someObject.compareTo(mockPartial); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_GreaterThan_ReturnsOne() { [EOL] ReadablePartial mockPartial = createMockPartialWithFieldValue(0); // Assuming createMockPartialWithFieldValue sets up a partial with the desired field value [EOL] when(someObject.get()).thenReturn(1); [EOL] int result = someObject.compareTo(mockPartial); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_Equal_ReturnsZero() { [EOL] ReadablePartial mockPartial = createMockPartialWithFieldValue(0); // Assuming createMockPartialWithFieldValue sets up a partial with the desired field value [EOL] when(someObject.get()).thenReturn(0); [EOL] int result = someObject.compareTo(mockPartial); [EOL] assertEquals(0, result); [EOL] }
public void testEquals_SameObject() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] assertTrue(property.equals(property)); [EOL] }
public void testEquals_DifferentClass() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] Object other = new Object(); [EOL] assertFalse(property.equals(other)); [EOL] }
public void testEquals_Null() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] Object other = null; [EOL] assertFalse(property.equals(other)); [EOL] }
public void testEquals_EqualProperties() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] assertTrue(property1.equals(property2)); [EOL] }
public void testEquals_DifferentValues() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] when(property2.get()).thenReturn(2); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentFieldTypes() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.year()); [EOL] when(property2.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentChronologies() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getReadablePartial().getChronology()).thenReturn(IsoChronology.getInstanceUTC()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getReadablePartial().getChronology()).thenReturn(CopticChronology.getInstance()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testToString() { [EOL] Property property = new Property(); [EOL] property.setName("TestName"); [EOL] String result = property.toString(); [EOL] assertEquals("Property[TestName]", result); [EOL] }
public void testGetMillisWithZeroValue() { [EOL] int value = 0; [EOL] long instant = 123456789L; [EOL] long expected = 0L; [EOL] long actual = getMillis(value, instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMillisWithPositiveValue() { [EOL] int value = 1; [EOL] long instant = 123456789L; [EOL] long expected = iUnitMillis; [EOL] long actual = getMillis(value, instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMillisWithNegativeValue() { [EOL] int value = -1; [EOL] long instant = 123456789L; [EOL] long expected = -iUnitMillis; [EOL] long actual = getMillis(value, instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithZeroValue() { [EOL] long instant = 1234567890L; [EOL] int value = 0; [EOL] long expected = instant; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithPositiveValue() { [EOL] long instant = 1234567890L; [EOL] int value = 10; [EOL] long expected = instant + (value * iUnitMillis); // Assuming iUnitMillis is a known constant in the test context [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithNegativeValue() { [EOL] long instant = 1234567890L; [EOL] int value = -10; [EOL] long expected = instant + (value * iUnitMillis); // Assuming iUnitMillis is a known constant in the test context [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithMaxIntValue() { [EOL] long instant = 1234567890L; [EOL] int value = Integer.MAX_VALUE; [EOL] long expected = FieldUtils.safeAdd(instant, ((long) value) * iUnitMillis); // Assuming FieldUtils.safeAdd handles overflow [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithMinIntValue() { [EOL] long instant = 1234567890L; [EOL] int value = Integer.MIN_VALUE; [EOL] long expected = FieldUtils.safeAdd(instant, ((long) value) * iUnitMillis); // Assuming FieldUtils.safeAdd handles overflow [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testEquals_SameObject() { [EOL] PreciseDurationField field = new PreciseDurationField(someType, someUnitMillis); [EOL] assertTrue(field.equals(field)); [EOL] }
public void testEquals_DifferentClass() { [EOL] PreciseDurationField field = new PreciseDurationField(someType, someUnitMillis); [EOL] Object other = new Object(); [EOL] assertFalse(field.equals(other)); [EOL] }
public void testEquals_EqualPreciseDurationField() { [EOL] PreciseDurationField field1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField field2 = new PreciseDurationField(someType, someUnitMillis); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_NonEqualType() { [EOL] PreciseDurationField field1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField field2 = new PreciseDurationField(differentType, someUnitMillis); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_NonEqualUnitMillis() { [EOL] PreciseDurationField field1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField field2 = new PreciseDurationField(someType, differentUnitMillis); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testAdd_ValueToAddIsZero() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(values, result); [EOL] }
public void testAdd_WithMonthOfYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] when(mockPartial.getValue(0)).thenReturn(5); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {5, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = set(mockPartial, 0, values, 6); // Assuming set method returns the expected result [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithContiguousPartial() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(2); [EOL] when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(true); [EOL] when(mockPartial.getFieldType(anyInt())).thenReturn(mock(DateTimeFieldType.class)); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockPartial.getFieldType(anyInt()).getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.set(anyLong(), anyInt())).thenReturn(1L); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2}; [EOL] int valueToAdd = 3; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = iChronology.get(mockPartial, 1L); // Assuming iChronology.get method returns the expected result [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithNonContiguousPartial() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(false); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 4; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = super.add(mockPartial, fieldIndex, values, valueToAdd); // Assuming super.add method returns the expected result [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddWrapField_Min() { [EOL] long instant = MIN; [EOL] int monthsToAdd = 1; [EOL] long expected = set(instant, FieldUtils.getWrappedValue(get(instant), monthsToAdd, MIN, iMax)); [EOL] long result = addWrapField(instant, monthsToAdd); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_Max() { [EOL] long instant = iMax; [EOL] int monthsToAdd = 1; [EOL] long expected = set(instant, FieldUtils.getWrappedValue(get(instant), monthsToAdd, MIN, iMax)); [EOL] long result = addWrapField(instant, monthsToAdd); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_Wrap() { [EOL] long instant = iMax; [EOL] int monthsToAdd = -1; [EOL] long expected = set(instant, FieldUtils.getWrappedValue(get(instant), monthsToAdd, MIN, iMax)); [EOL] long result = addWrapField(instant, monthsToAdd); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_MinuendLessThanSubtrahend() { [EOL] long minuendInstant = 0L; [EOL] long subtrahendInstant = 1L; [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] long expected = -time.getDifference(subtrahendInstant, minuendInstant); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_MinuendGreaterThanSubtrahend() { [EOL] long minuendInstant = 1L; [EOL] long subtrahendInstant = 0L; [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] long expected = (1L * iMax) + 0; // Simplified example, actual calculation may vary [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_LastDayOfMonthAdjustment() { [EOL] long minuendInstant = iChronology.dayOfMonth().set(0L, iChronology.getDaysInYearMonth(0, 1)); [EOL] long subtrahendInstant = 0L; [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] long expected = 0; // Simplified example, actual calculation may vary [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_RemainderAdjustment() { [EOL] long minuendInstant = iChronology.getYearMonthMillis(1, 1) + 1; [EOL] long subtrahendInstant = iChronology.getYearMonthMillis(1, 1); [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] long expected = 1; // Simplified example, actual calculation may vary [EOL] assertEquals(expected, result); [EOL] }
public void testGetRangeDurationField() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.centuryOfEra(); [EOL] DurationField field = fieldType.getRangeDurationField(); [EOL] assertNotNull(field); [EOL] assertEquals("years", field.getName()); [EOL] }
public int getDayOfYearTestWithValidInstant() { [EOL] long instant = /* valid instant representing a specific day of the year */; [EOL] int expectedDayOfYear = /* expected day of the year for the given instant */; [EOL] int actualDayOfYear = instance.get(instant); [EOL] assertEquals(expectedDayOfYear, actualDayOfYear); [EOL] }
public int getMinimumValue() { [EOL] return 1; [EOL] }
public void testGetMaximumValue_ForTypicalYear() { [EOL] long instant = new DateTime(2021, 1, 1, 0, 0, iChronology).getMillis(); [EOL] int maxValue = getMaximumValue(instant); [EOL] assertEquals(365, maxValue); [EOL] }
public void testGetMaximumValue_ForLeapYear() { [EOL] long instant = new DateTime(2020, 1, 1, 0, 0, iChronology).getMillis(); [EOL] int maxValue = getMaximumValue(instant); [EOL] assertEquals(366, maxValue); [EOL] }
public void testGetMaximumValueForSet_ValueGreaterThanMaxLessOne() { [EOL] long instant = System.currentTimeMillis(); // Use any instant for testing [EOL] int value = iChronology.getDaysInYearMax(); // Value greater than maxLessOne [EOL] int expected = getMaximumValue(instant); // Assuming getMaximumValue is a valid method call [EOL] int actual = getMaximumValueForSet(instant, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaximumValueForSet_ValueEqualToMaxLessOne() { [EOL] long instant = System.currentTimeMillis(); // Use any instant for testing [EOL] int value = iChronology.getDaysInYearMax() - 1; // Value equal to maxLessOne [EOL] int expected = value; [EOL] int actual = getMaximumValueForSet(instant, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaximumValueForSet_ValueLessThanOne() { [EOL] long instant = System.currentTimeMillis(); // Use any instant for testing [EOL] int value = 0; // Value less than 1 [EOL] int expected = getMaximumValue(instant); // Assuming getMaximumValue is a valid method call [EOL] int actual = getMaximumValueForSet(instant, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSafeAdd_NoOverflow() { [EOL] long val1 = 1; [EOL] long val2 = 2; [EOL] long expected = 3; [EOL] long result = time.safeAdd(val1, val2); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeAdd_PositiveOverflow() { [EOL] long val1 = Long.MAX_VALUE; [EOL] long val2 = 1; [EOL] try { [EOL] time.safeAdd(val1, val2); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " + " + val2, e.getMessage()); [EOL] } [EOL] }
public void testSafeAdd_NegativeOverflow() { [EOL] long val1 = Long.MIN_VALUE; [EOL] long val2 = -1; [EOL] try { [EOL] time.safeAdd(val1, val2); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " + " + val2, e.getMessage()); [EOL] } [EOL] }
public void testSafeDivide_MinValueDividedByNegativeOne_ThrowsException() { [EOL] try { [EOL] long result = time.safeDivide(Long.MIN_VALUE, -1L); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Multiplication overflows a long: -9223372036854775808 / -1", e.getMessage()); [EOL] } [EOL] }
public void testSafeDivide_PositiveDividendAndPositiveDivisor_ReturnsProperQuotient() { [EOL] long dividend = 10L; [EOL] long divisor = 2L; [EOL] long expected = 5L; [EOL] long result = time.safeDivide(dividend, divisor); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeDivide_PositiveDividendAndNegativeDivisor_ReturnsProperQuotient() { [EOL] long dividend = 10L; [EOL] long divisor = -2L; [EOL] long expected = -5L; [EOL] long result = time.safeDivide(dividend, divisor); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeDivide_NegativeDividendAndPositiveDivisor_ReturnsProperQuotient() { [EOL] long dividend = -10L; [EOL] long divisor = 2L; [EOL] long expected = -5L; [EOL] long result = time.safeDivide(dividend, divisor); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeDivide_NegativeDividendAndNegativeDivisor_ReturnsProperQuotient() { [EOL] long dividend = -10L; [EOL] long divisor = -2L; [EOL] long expected = 5L; [EOL] long result = time.safeDivide(dividend, divisor); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeDivide_DividendDividedByOne_ReturnsSameValue() { [EOL] long dividend = 10L; [EOL] long divisor = 1L; [EOL] long expected = 10L; [EOL] long result = time.safeDivide(dividend, divisor); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeDivide_DividendDividedByZero_ThrowsException() { [EOL] try { [EOL] long result = time.safeDivide(10L, 0L); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("/ by zero", e.getMessage()); [EOL] } [EOL] }
public void testEqualsWithBothObjectsNull() { [EOL] Object object1 = null; [EOL] Object object2 = null; [EOL] boolean result = equals(object1, object2); [EOL] assertTrue(result); [EOL] }
public void testEqualsWithFirstObjectNull() { [EOL] Object object1 = null; [EOL] Object object2 = new Object(); [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSecondObjectNull() { [EOL] Object object1 = new Object(); [EOL] Object object2 = null; [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithDifferentNonNullObjects() { [EOL] Object object1 = new Object(); [EOL] Object object2 = new Object(); [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSameNonNullObjects() { [EOL] Object object1 = new Object(); [EOL] Object object2 = object1; [EOL] boolean result = equals(object1, object2); [EOL] assertTrue(result); [EOL] }
public void testGetDurationField() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(iField.getDurationField()).thenReturn(field); [EOL] DurationField result = instance.getDurationField(); [EOL] assertNotNull("DurationField should not be null", result); [EOL] assertSame("DurationField should be the same as the mock field", field, result); [EOL] }
public void testGetRangeDurationField() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.getRangeDurationField()).thenReturn(null); [EOL] Time time = new Time(mockField); [EOL] assertNull("Expected null range duration field", time.getRangeDurationField()); [EOL] }
public void testGetRangeDurationFieldWithNonNull() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] DurationField expectedRangeDurationField = new DurationField(); [EOL] when(mockField.getRangeDurationField()).thenReturn(expectedRangeDurationField); [EOL] Time time = new Time(mockField); [EOL] assertSame("Expected non-null range duration field", expectedRangeDurationField, time.getRangeDurationField()); [EOL] }
public void testGetInstantConverterWithNull() { [EOL] try { [EOL] getInstantConverter(null); [EOL] fail("Expected IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No instant converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetInstantConverterWithValidObject() { [EOL] Object validObject = new SomeValidInstantConverterClass(); [EOL] iInstantConverters.register(validObject.getClass(), new SomeInstantConverter()); [EOL] InstantConverter result = getInstantConverter(validObject); [EOL] assertNotNull("Expected non-null InstantConverter", result); [EOL] }
public void testGetInstantConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] getInstantConverter(invalidObject); [EOL] fail("Expected IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No instant converter found for type: " + invalidObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetInstantConverters_WithNonEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new InstantConverter[]{/* some InstantConverter instances */}); [EOL] DateTimeUtils.setInstantConverters(set); [EOL] InstantConverter[] converters = DateTimeUtils.getInstantConverters(); [EOL] assertNotNull("Converters should not be null", converters); [EOL] assertEquals("Converters length should match the set size", set.size(), converters.length); [EOL] }
public void testGetInstantConverters_WithEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new InstantConverter[]{}); [EOL] DateTimeUtils.setInstantConverters(set); [EOL] InstantConverter[] converters = DateTimeUtils.getInstantConverters(); [EOL] assertNotNull("Converters should not be null", converters); [EOL] assertEquals("Converters length should be zero for empty set", 0, converters.length); [EOL] }
public void testAddInstantConverterWithNull() { [EOL] InstantConverter result = timeObject.addInstantConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddInstantConverterWithNonNull() throws SecurityException { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] InstantConverter result = timeObject.addInstantConverter(mockConverter); [EOL] assertNotNull(timeObject.getInstantConverters()); [EOL] assertTrue(Arrays.asList(timeObject.getInstantConverters()).contains(mockConverter)); [EOL] }
public void testAddInstantConverterThrowsSecurityException() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] doThrow(new SecurityException()).when(timeObject).checkAlterInstantConverters(); [EOL] assertThrows(SecurityException.class, () -> { [EOL] timeObject.addInstantConverter(mockConverter); [EOL] }); [EOL] }
public void testRemoveInstantConverter_NullConverter() { [EOL] InstantConverter result = timeObject.removeInstantConverter(null); [EOL] assertNull("Expected null when removing null converter", result); [EOL] } [EOL] public void testRemoveInstantConverter_ValidConverter() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] timeObject.addInstantConverter(mockConverter); [EOL] InstantConverter result = timeObject.removeInstantConverter(mockConverter); [EOL] assertEquals("Expected the removed converter to be returned", mockConverter, result); [EOL] } [EOL] public void testRemoveInstantConverter_NotAddedConverter() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] InstantConverter result = timeObject.removeInstantConverter(mockConverter); [EOL] assertNull("Expected null when removing a converter that was not added", result); [EOL] } [EOL] public void testRemoveInstantConverter_SecurityException() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] timeObject.addInstantConverter(mockConverter); [EOL] System.setSecurityManager(createSecurityManagerThatPreventsInstantConverterChanges()); [EOL] try { [EOL] timeObject.removeInstantConverter(mockConverter); [EOL] fail("Expected SecurityException when removing a converter with security manager set"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterInstantConverters_WithNoSecurityManager() { [EOL] System.setSecurityManager(null); [EOL] try { [EOL] checkAlterInstantConverters(); [EOL] } finally { [EOL] System.setSecurityManager(null); [EOL] } [EOL] }
public void testCheckAlterInstantConverters_WithSecurityManager() throws SecurityException { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission && "ConverterManager.alterInstantConverters".equals(perm.getName())) { [EOL] } else { [EOL] super.checkPermission(perm); [EOL] } [EOL] } [EOL] }; [EOL] System.setSecurityManager(sm); [EOL] checkAlterInstantConverters(); [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); [EOL] } [EOL] }
public void testGetPartialConverterWithNull() { [EOL] try { [EOL] getPartialConverter(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetPartialConverterWithValidObject() { [EOL] Object validObject = new Object() { [EOL] }; [EOL] iPartialConverters.put(validObject.getClass(), new PartialConverter() { [EOL] }); [EOL] PartialConverter result = getPartialConverter(validObject); [EOL] assertNotNull("Expected a non-null PartialConverter", result); [EOL] }
public void testGetPartialConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] getPartialConverter(invalidObject); [EOL] fail("Should have thrown IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: " + invalidObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetPartialConverters_WithNonEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new PartialConverter[]{ /* Add PartialConverter instances here */ }); [EOL] DateTimeFormatter dtf = new DateTimeFormatterBuilder().append(set).toFormatter(); [EOL] PartialConverter[] converters = dtf.getPartialConverters(); [EOL] assertNotNull(converters, "The array of PartialConverter should not be null."); [EOL] assertEquals(set.size(), converters.length, "The length of the converters array should match the size of the ConverterSet."); [EOL] }
public void testGetPartialConverters_WithEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new PartialConverter[]{}); [EOL] DateTimeFormatter dtf = new DateTimeFormatterBuilder().append(set).toFormatter(); [EOL] PartialConverter[] converters = dtf.getPartialConverters(); [EOL] assertNotNull(converters, "The array of PartialConverter should not be null."); [EOL] assertEquals(0, converters.length, "The length of the converters array should be zero for an empty ConverterSet."); [EOL] }
public void testRemovePartialConverter_NullConverter() { [EOL] PartialConverter nullConverter = null; [EOL] PartialConverter result = removePartialConverter(nullConverter); [EOL] assertNull("Expected null result when removing null converter", result); [EOL] }
public void testRemovePartialConverter_ValidConverter() { [EOL] PartialConverter validConverter = new SomePartialConverterImplementation(); [EOL] addPartialConverter(validConverter); // Assuming there is a method to add a converter before removing [EOL] PartialConverter result = removePartialConverter(validConverter); [EOL] assertEquals("Expected the removed converter to be returned", validConverter, result); [EOL] }
public void testRemovePartialConverter_NonExistentConverter() { [EOL] PartialConverter nonExistentConverter = new SomePartialConverterImplementation(); [EOL] PartialConverter result = removePartialConverter(nonExistentConverter); [EOL] assertNull("Expected null result when removing a non-existent converter", result); [EOL] }
public void testCheckAlterPartialConverters_WithNoSecurityManager() { [EOL] System.setSecurityManager(null); [EOL] try { [EOL] checkAlterPartialConverters(); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterPartialConverters_WithSecurityManager() throws SecurityException { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission) { [EOL] if ("ConverterManager.alterPartialConverters".equals(perm.getName())) { [EOL] return; // Permission is granted [EOL] } [EOL] } [EOL] super.checkPermission(perm); [EOL] } [EOL] }; [EOL] System.setSecurityManager(sm); [EOL] checkAlterPartialConverters(); [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); // Reset security manager [EOL] } [EOL] }
public void testAddIntervalConverterWithNull() { [EOL] IntervalConverter result = addIntervalConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddIntervalConverterWithNonNull() throws SecurityException { [EOL] IntervalConverter mockConverter = mock(IntervalConverter.class); [EOL] IntervalConverter result = addIntervalConverter(mockConverter); [EOL] assertNotNull(result); [EOL] }
public void testIsSupported_True() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockFieldType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.isSupported()).thenReturn(true); [EOL] Time time = new Time(mockFieldType); [EOL] assertTrue(time.isSupported()); [EOL] }
public void testIsSupported_False() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockFieldType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.isSupported()).thenReturn(false); [EOL] Time time = new Time(mockFieldType); [EOL] assertFalse(time.isSupported()); [EOL] }
public void testAdd() { [EOL] IField mockField = mock(IField.class); [EOL] long instant = 1000L; [EOL] int value = 5; [EOL] when(mockField.add(instant, value)).thenReturn(1005L); [EOL] MyClass myClass = new MyClass(mockField); [EOL] long result = myClass.add(instant, value); [EOL] assertEquals(1005L, result); [EOL] verify(mockField).add(instant, value); [EOL] }
public long setTestWithValidValue() { [EOL] DateTimeField field = obtainDateTimeField(); // Replace with actual method to obtain a DateTimeField instance [EOL] long instant = System.currentTimeMillis(); [EOL] int value = 10; // Replace with a valid value for the field [EOL] long updatedInstant = field.set(instant, value); [EOL] }
public long setTestWithInvalidValue() { [EOL] DateTimeField field = obtainDateTimeField(); // Replace with actual method to obtain a DateTimeField instance [EOL] long instant = System.currentTimeMillis(); [EOL] int value = -1; // Replace with an invalid value for the field [EOL] try { [EOL] field.set(instant, value); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetRangeDurationField_WithNonNullRangeDurationField() { [EOL] DurationField mockRangeDurationField = mock(DurationField.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getRangeDurationField()).thenReturn(mockRangeDurationField); [EOL] MyClass instance = new MyClass(mockField, mockRangeDurationField); [EOL] DurationField result = instance.getRangeDurationField(); [EOL] assertSame(mockRangeDurationField, result); [EOL] }
public void testGetRangeDurationField_WithNullRangeDurationField() { [EOL] DurationField mockRangeDurationField = null; [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField expectedRangeDurationField = mock(DurationField.class); [EOL] when(mockField.getRangeDurationField()).thenReturn(expectedRangeDurationField); [EOL] MyClass instance = new MyClass(mockField, mockRangeDurationField); [EOL] DurationField result = instance.getRangeDurationField(); [EOL] assertSame(expectedRangeDurationField, result); [EOL] }
public void testGetLeapDurationField() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.getLeapDurationField()).thenReturn(mockField); [EOL] DateTimeFieldType fieldType = new DateTimeFieldType("fieldType") { [EOL] private static final long serialVersionUID = 1L; [EOL] public DurationField getField(Chronology chronology) { [EOL] return mockField; [EOL] } [EOL] }; [EOL] DateTimeField field = fieldType.getField(null); [EOL] DurationField result = field.getLeapDurationField(); [EOL] assertNotNull(result); [EOL] assertSame(mockField, result); [EOL] }
public int testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int expectedValue = Integer.MAX_VALUE; // Assuming iField.getMaximumValue() returns Integer.MAX_VALUE [EOL] int actualValue = time.getMaximumValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public int getMaximumValueTestWithValidInstant() { [EOL] long instant = /* some valid instant value */; [EOL] int expected = /* expected maximum value for the given instant */; [EOL] int actual = getMaximumValue(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_PositiveInstant() { [EOL] long instant = 123456789L; [EOL] long expected = iField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_NegativeInstant() { [EOL] long instant = -123456789L; [EOL] long expected = iField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_ZeroInstant() { [EOL] long instant = 0L; [EOL] long expected = iField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetInstance_BothLimitsNull() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(null, null); [EOL] assertSame(DateTimeComparator.ALL_INSTANCE, result); [EOL] }
public void testGetInstance_LowerLimitDayOfYearUpperLimitNull() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), null); [EOL] assertSame(DateTimeComparator.DATE_INSTANCE, result); [EOL] }
public void testGetInstance_LowerLimitNullUpperLimitDayOfYear() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(null, DateTimeFieldType.dayOfYear()); [EOL] assertSame(DateTimeComparator.TIME_INSTANCE, result); [EOL] }
public void testGetInstance_NonNullLimits() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DateTimeComparator); [EOL] }
public static DateTimeComparator getTimeOnlyInstance() { [EOL] return TIME_INSTANCE; [EOL] }
public void testDateTimeComparatorWithBothLimits() { [EOL] DateTimeFieldType lowerLimit = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeFieldType upperLimit = DateTimeFieldType.monthOfYear(); [EOL] DateTimeComparator comparator = new DateTimeComparator(lowerLimit, upperLimit); [EOL] assertNotNull(comparator); [EOL] assertEquals(lowerLimit, comparator.getLowerLimit()); [EOL] assertEquals(upperLimit, comparator.getUpperLimit()); [EOL] }
public void testDateTimeComparatorWithLowerLimitOnly() { [EOL] DateTimeFieldType lowerLimit = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeComparator comparator = new DateTimeComparator(lowerLimit, null); [EOL] assertNotNull(comparator); [EOL] assertEquals(lowerLimit, comparator.getLowerLimit()); [EOL] assertNull(comparator.getUpperLimit()); [EOL] }
public void testDateTimeComparatorWithUpperLimitOnly() { [EOL] DateTimeFieldType upperLimit = DateTimeFieldType.monthOfYear(); [EOL] DateTimeComparator comparator = new DateTimeComparator(null, upperLimit); [EOL] assertNotNull(comparator); [EOL] assertNull(comparator.getLowerLimit()); [EOL] assertEquals(upperLimit, comparator.getUpperLimit()); [EOL] }
public void testDateTimeComparatorWithNoLimits() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, null); [EOL] assertNotNull(comparator); [EOL] assertNull(comparator.getLowerLimit()); [EOL] assertNull(comparator.getUpperLimit()); [EOL] }
public void testEquals_SameObject() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, null); [EOL] assertTrue(comparator.equals(comparator)); [EOL] }
public void testEquals_DifferentClass() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, null); [EOL] assertFalse(comparator.equals(new Object())); [EOL] }
public void testEquals_EqualComparators() { [EOL] DateTimeComparator comparator1 = new DateTimeComparator(null, null); [EOL] DateTimeComparator comparator2 = new DateTimeComparator(null, null); [EOL] assertTrue(comparator1.equals(comparator2)); [EOL] }
public void testEquals_NonEqualComparators_DifferentLowerLimit() { [EOL] DateTimeComparator comparator1 = new DateTimeComparator("lower1", null); [EOL] DateTimeComparator comparator2 = new DateTimeComparator("lower2", null); [EOL] assertFalse(comparator1.equals(comparator2)); [EOL] }
public void testEquals_NonEqualComparators_DifferentUpperLimit() { [EOL] DateTimeComparator comparator1 = new DateTimeComparator(null, "upper1"); [EOL] DateTimeComparator comparator2 = new DateTimeComparator(null, "upper2"); [EOL] assertFalse(comparator1.equals(comparator2)); [EOL] }
public void testEquals_EqualComparators_NonNullLimits() { [EOL] DateTimeComparator comparator1 = new DateTimeComparator("lower", "upper"); [EOL] DateTimeComparator comparator2 = new DateTimeComparator("lower", "upper"); [EOL] assertTrue(comparator1.equals(comparator2)); [EOL] }
public void testHashCode_BothLimitsNull() { [EOL] TimePeriod period = new TimePeriod(null, null); [EOL] int expectedHashCode = 0; [EOL] assertEquals(expectedHashCode, period.hashCode()); [EOL] } [EOL] public void testHashCode_LowerLimitNotNull_UpperLimitNull() { [EOL] TimePeriod period = new TimePeriod(new Time(10, 30), null); [EOL] int expectedHashCode = new Time(10, 30).hashCode(); [EOL] assertEquals(expectedHashCode, period.hashCode()); [EOL] } [EOL] public void testHashCode_LowerLimitNull_UpperLimitNotNull() { [EOL] TimePeriod period = new TimePeriod(null, new Time(20, 45)); [EOL] int expectedHashCode = 123 * new Time(20, 45).hashCode(); [EOL] assertEquals(expectedHashCode, period.hashCode()); [EOL] } [EOL] public void testHashCode_BothLimitsNotNull() { [EOL] TimePeriod period = new TimePeriod(new Time(10, 30), new Time(20, 45)); [EOL] int expectedHashCode = new Time(10, 30).hashCode() + 123 * new Time(20, 45).hashCode(); [EOL] assertEquals(expectedHashCode, period.hashCode()); [EOL] }
public void testGetFieldType_ValidIndex() { [EOL] DurationFieldType fieldType = instance.getFieldType(0); [EOL] assertNotNull(fieldType); [EOL] }
public void testGetFieldType_InvalidIndex() { [EOL] try { [EOL] instance.getFieldType(1); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] assertEquals("1", ex.getMessage()); [EOL] } [EOL] }
public void testGetInstanceWithNullChronology() { [EOL] try { [EOL] StrictChronology.getInstance(null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetInstanceWithNonNullChronology() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] StrictChronology strictChronology = StrictChronology.getInstance(base); [EOL] assertNotNull("StrictChronology creation with non-null base should not be null", strictChronology); [EOL] }
private StrictChronology(Chronology base) { [EOL] super(base, null); [EOL] }
public void testAssemble_AllFields() { [EOL] Fields fields = new Fields(); [EOL] fields.year = createField(); [EOL] fields.yearOfEra = createField(); [EOL] fields.yearOfCentury = createField(); [EOL] fields.centuryOfEra = createField(); [EOL] fields.era = createField(); [EOL] fields.dayOfWeek = createField(); [EOL] fields.dayOfMonth = createField(); [EOL] fields.dayOfYear = createField(); [EOL] fields.monthOfYear = createField(); [EOL] fields.weekOfWeekyear = createField(); [EOL] fields.weekyear = createField(); [EOL] fields.weekyearOfCentury = createField(); [EOL] fields.millisOfSecond = createField(); [EOL] fields.millisOfDay = createField(); [EOL] fields.secondOfMinute = createField(); [EOL] fields.secondOfDay = createField(); [EOL] fields.minuteOfHour = createField(); [EOL] fields.minuteOfDay = createField(); [EOL] fields.hourOfDay = createField(); [EOL] fields.hourOfHalfday = createField(); [EOL] fields.clockhourOfDay = createField(); [EOL] fields.clockhourOfHalfday = createField(); [EOL] fields.halfdayOfDay = createField(); [EOL] new Time().assemble(fields); [EOL] assertNotNull(fields.year); [EOL] assertNotNull(fields.yearOfEra); [EOL] assertNotNull(fields.yearOfCentury); [EOL] assertNotNull(fields.centuryOfEra); [EOL] assertNotNull(fields.era); [EOL] assertNotNull(fields.dayOfWeek); [EOL] assertNotNull(fields.dayOfMonth); [EOL] assertNotNull(fields.dayOfYear); [EOL] assertNotNull(fields.monthOfYear); [EOL] assertNotNull(fields.weekOfWeekyear); [EOL] assertNotNull(fields.weekyear); [EOL] assertNotNull(fields.weekyearOfCentury); [EOL] assertNotNull(fields.millisOfSecond); [EOL] assertNotNull(fields.millisOfDay); [EOL] assertNotNull(fields.secondOfMinute); [EOL] assertNotNull(fields.secondOfDay); [EOL] assertNotNull(fields.minuteOfHour); [EOL] assertNotNull(fields.minuteOfDay); [EOL] assertNotNull(fields.hourOfDay); [EOL] assertNotNull(fields.hourOfHalfday); [EOL] assertNotNull(fields.clockhourOfDay); [EOL] assertNotNull(fields.clockhourOfHalfday); [EOL] assertNotNull(fields.halfdayOfDay); [EOL] }
public void testConvertFieldWithNonNullField() { [EOL] DateTimeField inputField = new MockDateTimeField(); [EOL] DateTimeField resultField = ClassName.convertField(inputField); [EOL] assertNotNull(resultField); [EOL] assertTrue(resultField instanceof StrictDateTimeField); [EOL] }
public void testConvertFieldWithNullField() { [EOL] try { [EOL] ClassName.convertField(null); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToString() { [EOL] StrictChronology chronology = new StrictChronology(baseChronology); [EOL] String expected = "StrictChronology[" + baseChronology.toString() + ']'; [EOL] String actual = chronology.toString(); [EOL] assertEquals(expected, actual); [EOL] }
int getMonthOfYear(long millis, int year) { [EOL] int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL] return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] } [EOL] BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek); [EOL] int getMonthOfYear(long millis, int year); [EOL] int getDaysInYearMonth(int year, int month); [EOL] int getDaysInMonthMax(int month); [EOL] int getDaysInMonthMaxForSet(long instant, int value); [EOL] long getTotalMillisByYearMonth(int year, int month); [EOL] long getYearDifference(long minuendInstant, long subtrahendInstant); [EOL] long setYear(long instant, int year); [EOL] long serialVersionUID=538276888268L; [EOL] int[] MIN_DAYS_PER_MONTH_ARRAY={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; [EOL] int[] MAX_DAYS_PER_MONTH_ARRAY={ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
public void testSetYearWithNonLeapYearToLeapYear() { [EOL] long instant = /* some instant representing a non-leap year */; [EOL] int year = /* a leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testSetYearWithLeapYearToNonLeapYear() { [EOL] long instant = /* some instant representing a leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testSetYearWithNoChangeInLeapYearStatus() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year with the same leap year status as instant's year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testSetYearBeforeLeapDay() { [EOL] long instant = /* some instant before leap day in a non-leap year */; [EOL] int year = /* a year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSeconds_Zero() { [EOL] Seconds result = Time.seconds(0); [EOL] assertSame(Seconds.ZERO, result); [EOL] } [EOL] public void testSeconds_One() { [EOL] Seconds result = Time.seconds(1); [EOL] assertSame(Seconds.ONE, result); [EOL] } [EOL] public void testSeconds_Two() { [EOL] Seconds result = Time.seconds(2); [EOL] assertSame(Seconds.TWO, result); [EOL] } [EOL] public void testSeconds_Three() { [EOL] Seconds result = Time.seconds(3); [EOL] assertSame(Seconds.THREE, result); [EOL] } [EOL] public void testSeconds_MaxValue() { [EOL] Seconds result = Time.seconds(Integer.MAX_VALUE); [EOL] assertSame(Seconds.MAX_VALUE, result); [EOL] } [EOL] public void testSeconds_MinValue() { [EOL] Seconds result = Time.seconds(Integer.MIN_VALUE); [EOL] assertSame(Seconds.MIN_VALUE, result); [EOL] } [EOL] public void testSeconds_Arbitrary() { [EOL] int arbitraryValue = 5; // Any value other than 0, 1, 2, 3, Integer.MAX_VALUE, Integer.MIN_VALUE [EOL] Seconds result = Time.seconds(arbitraryValue); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryValue, result.getSeconds()); [EOL] }
public void testGetFieldType_ReturnsSeconds() { [EOL] DurationFieldType fieldType = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.seconds(), fieldType); [EOL] }
public void testToStandardWeeks_exactWeeks() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_WEEK * 2); [EOL] Weeks expectedWeeks = Weeks.weeks(2); [EOL] assertEquals(expectedWeeks, seconds.toStandardWeeks()); [EOL] }
public void testToStandardWeeks_lessThanAWeek() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_WEEK - 1); [EOL] Weeks expectedWeeks = Weeks.weeks(0); [EOL] assertEquals(expectedWeeks, seconds.toStandardWeeks()); [EOL] }
public void testToStandardWeeks_moreThanAWeek() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_WEEK + 1); [EOL] Weeks expectedWeeks = Weeks.weeks(1); [EOL] assertEquals(expectedWeeks, seconds.toStandardWeeks()); [EOL] }
public void testToStandardWeeks_negativeSeconds() { [EOL] Seconds seconds = Seconds.seconds(-1 * DateTimeConstants.SECONDS_PER_WEEK); [EOL] Weeks expectedWeeks = Weeks.weeks(-1); [EOL] assertEquals(expectedWeeks, seconds.toStandardWeeks()); [EOL] }
public void testPlus_ZeroSeconds() { [EOL] Seconds original = Seconds.seconds(5); [EOL] Seconds result = original.plus(0); [EOL] assertSame("Expected the same object to be returned", original, result); [EOL] }
public void testPlus_NonZeroSeconds() { [EOL] Seconds original = Seconds.seconds(5); [EOL] Seconds result = original.plus(10); [EOL] assertEquals("Expected the sum of seconds", 15, result.getValue()); [EOL] }
public void testMinusWithNull() { [EOL] Seconds original = new Seconds(5); [EOL] Seconds result = original.minus(null); [EOL] assertEquals(5, result.getValue()); [EOL] }
public void testMinusWithNonNull() { [EOL] Seconds original = new Seconds(5); [EOL] Seconds toSubtract = new Seconds(3); [EOL] Seconds result = original.minus(toSubtract); [EOL] assertEquals(2, result.getValue()); [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Seconds seconds = new Seconds(-1); [EOL] boolean result = seconds.isLessThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNullOtherAndPositiveValue() { [EOL] Seconds seconds = new Seconds(1); [EOL] boolean result = seconds.isLessThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNonNullOtherAndLessValue() { [EOL] Seconds first = new Seconds(1); [EOL] Seconds second = new Seconds(2); [EOL] boolean result = first.isLessThan(second); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNonNullOtherAndGreaterValue() { [EOL] Seconds first = new Seconds(2); [EOL] Seconds second = new Seconds(1); [EOL] boolean result = first.isLessThan(second); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithEqualValues() { [EOL] Seconds first = new Seconds(1); [EOL] Seconds second = new Seconds(1); [EOL] boolean result = first.isLessThan(second); [EOL] assertFalse(result); [EOL] }
public void testGetInstance_BaseIsNull() { [EOL] try { [EOL] LimitChronology.getInstance(null, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Must supply a chronology", e.getMessage()); [EOL] } [EOL] }
public void testGetInstance_LowerLimitAfterUpperLimit() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] ReadableDateTime lowerLimit = new DateTime(2020, 1, 2, 0, 0); [EOL] ReadableDateTime upperLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] try { [EOL] LimitChronology.getInstance(base, lowerLimit, upperLimit); [EOL] fail("Should have thrown IllegalArgumentException for lower limit after upper limit"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The lower limit must be come before than the upper limit", e.getMessage()); [EOL] } [EOL] }
public void testGetInstance_ValidLimits() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] ReadableDateTime lowerLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableDateTime upperLimit = new DateTime(2020, 12, 31, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, lowerLimit, upperLimit); [EOL] assertNotNull(result); [EOL] assertEquals(lowerLimit.toDateTime(), result.getLowerLimit()); [EOL] assertEquals(upperLimit.toDateTime(), result.getUpperLimit()); [EOL] }
public void testGetInstance_NoLimits() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] LimitChronology result = LimitChronology.getInstance(base, null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLowerLimit()); [EOL] assertNull(result.getUpperLimit()); [EOL] }
public void testGetInstance_OnlyLowerLimit() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] ReadableDateTime lowerLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, lowerLimit, null); [EOL] assertNotNull(result); [EOL] assertEquals(lowerLimit.toDateTime(), result.getLowerLimit()); [EOL] assertNull(result.getUpperLimit()); [EOL] }
public void testGetInstance_OnlyUpperLimit() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] ReadableDateTime upperLimit = new DateTime(2020, 12, 31, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, null, upperLimit); [EOL] assertNotNull(result); [EOL] assertNull(result.getLowerLimit()); [EOL] assertEquals(upperLimit.toDateTime(), result.getUpperLimit()); [EOL] }
public void testLimitChronologyWithBothLimits() { [EOL] Chronology baseChronology = ISOChronology.getInstance(); [EOL] DateTime lowerLimit = new DateTime(2000, 1, 1, 0, 0); [EOL] DateTime upperLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] LimitChronology limitChronology = new LimitChronology(baseChronology, lowerLimit, upperLimit); [EOL] assertNotNull(limitChronology); [EOL] assertEquals(lowerLimit, limitChronology.getLowerLimit()); [EOL] assertEquals(upperLimit, limitChronology.getUpperLimit()); [EOL] }
public void testLimitChronologyWithNullLowerLimit() { [EOL] Chronology baseChronology = ISOChronology.getInstance(); [EOL] DateTime upperLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] LimitChronology limitChronology = new LimitChronology(baseChronology, null, upperLimit); [EOL] assertNotNull(limitChronology); [EOL] assertNull(limitChronology.getLowerLimit()); [EOL] assertEquals(upperLimit, limitChronology.getUpperLimit()); [EOL] }
public void testLimitChronologyWithNullUpperLimit() { [EOL] Chronology baseChronology = ISOChronology.getInstance(); [EOL] DateTime lowerLimit = new DateTime(2000, 1, 1, 0, 0); [EOL] LimitChronology limitChronology = new LimitChronology(baseChronology, lowerLimit, null); [EOL] assertNotNull(limitChronology); [EOL] assertEquals(lowerLimit, limitChronology.getLowerLimit()); [EOL] assertNull(limitChronology.getUpperLimit()); [EOL] }
public void testLimitChronologyWithNullLimits() { [EOL] Chronology baseChronology = ISOChronology.getInstance(); [EOL] LimitChronology limitChronology = new LimitChronology(baseChronology, null, null); [EOL] assertNotNull(limitChronology); [EOL] assertNull(limitChronology.getLowerLimit()); [EOL] assertNull(limitChronology.getUpperLimit()); [EOL] }
public void testGetDateTimeMillis_ValidInput() { [EOL] long instant = 0L; // Assuming 0L is a valid instant for the base [EOL] int hourOfDay = 10; // Assuming 10 is within valid hour range [EOL] int minuteOfHour = 30; // Assuming 30 is within valid minute range [EOL] int secondOfMinute = 45; // Assuming 45 is within valid second range [EOL] int millisOfSecond = 200; // Assuming 200 is within valid millisecond range [EOL] long expected = 123456789L; // Expected result (should be set according to the logic of getBase().getDateTimeMillis) [EOL] Time time = new Time(); // Assuming Time is the class where getDateTimeMillis is defined [EOL] long result = time.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_InvalidInstant() { [EOL] long instant = -1L; // Assuming -1L is an invalid instant for the base [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 200; [EOL] Time time = new Time(); [EOL] try { [EOL] time.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException for invalid instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidResultingInstant() { [EOL] long instant = 0L; // Assuming 0L is a valid instant for the base [EOL] int hourOfDay = 24; // Assuming 24 is an invalid hour and will cause the resulting instant to be invalid [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 200; [EOL] Time time = new Time(); [EOL] try { [EOL] time.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException for invalid resulting instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckLimitsLowerBound() { [EOL] long instant = 1000L; [EOL] String desc = "LowerBoundTest"; [EOL] DateTime lowerLimit = new DateTime(2000L); [EOL] Time time = new Time(lowerLimit, null); [EOL] try { [EOL] time.checkLimits(instant, desc); [EOL] fail("Should have thrown LimitException for lower bound"); [EOL] } catch (LimitException e) { [EOL] assertEquals("LowerBoundTest", e.getDescription()); [EOL] assertTrue(e.isLowerLimitViolation()); [EOL] } [EOL] }
public void testCheckLimitsUpperBound() { [EOL] long instant = 3000L; [EOL] String desc = "UpperBoundTest"; [EOL] DateTime upperLimit = new DateTime(2000L); [EOL] Time time = new Time(null, upperLimit); [EOL] try { [EOL] time.checkLimits(instant, desc); [EOL] fail("Should have thrown LimitException for upper bound"); [EOL] } catch (LimitException e) { [EOL] assertEquals("UpperBoundTest", e.getDescription()); [EOL] assertFalse(e.isLowerLimitViolation()); [EOL] } [EOL] }
public void testCheckLimitsWithinBounds() { [EOL] long instant = 1500L; [EOL] String desc = "WithinBoundsTest"; [EOL] DateTime lowerLimit = new DateTime(1000L); [EOL] DateTime upperLimit = new DateTime(2000L); [EOL] Time time = new Time(lowerLimit, upperLimit); [EOL] time.checkLimits(instant, desc); [EOL] }
public void testToString_BaseChronologyWithNoLimits() { [EOL] LimitChronology chronology = new LimitChronology(mock(BaseChronology.class), null, null); [EOL] String expected = "LimitChronology[" + chronology.getBase().toString() + ", NoLimit, NoLimit]"; [EOL] assertEquals(expected, chronology.toString()); [EOL] }
public void testToString_BaseChronologyWithLowerLimit() { [EOL] BaseChronology base = mock(BaseChronology.class); [EOL] DateTime lowerLimit = new DateTime(); [EOL] LimitChronology chronology = new LimitChronology(base, lowerLimit, null); [EOL] String expected = "LimitChronology[" + base.toString() + ", " + lowerLimit.toString() + ", NoLimit]"; [EOL] assertEquals(expected, chronology.toString()); [EOL] }
public void testToString_BaseChronologyWithUpperLimit() { [EOL] BaseChronology base = mock(BaseChronology.class); [EOL] DateTime upperLimit = new DateTime(); [EOL] LimitChronology chronology = new LimitChronology(base, null, upperLimit); [EOL] String expected = "LimitChronology[" + base.toString() + ", NoLimit, " + upperLimit.toString() + "]"; [EOL] assertEquals(expected, chronology.toString()); [EOL] }
public void testToString_BaseChronologyWithBothLimits() { [EOL] BaseChronology base = mock(BaseChronology.class); [EOL] DateTime lowerLimit = new DateTime(); [EOL] DateTime upperLimit = new DateTime(); [EOL] LimitChronology chronology = new LimitChronology(base, lowerLimit, upperLimit); [EOL] String expected = "LimitChronology[" + base.toString() + ", " + lowerLimit.toString() + ", " + upperLimit.toString() + "]"; [EOL] assertEquals(expected, chronology.toString()); [EOL] }
public void testLimitExceptionWithLowTrue() { [EOL] LimitException exception = new LimitException("Low limit reached", true); [EOL] assertTrue("Expected isLow to be true", exception.isLow()); [EOL] }
public void testLimitExceptionWithLowFalse() { [EOL] LimitException exception = new LimitException("High limit reached", false); [EOL] assertFalse("Expected isLow to be false", exception.isLow()); [EOL] }
public void testGetWithNullType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] try { [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetWithValidType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] int dayOfMonth = testDateTime.get(type); [EOL] assertEquals(testDateTime.getDayOfMonth(), dayOfMonth); [EOL] }
public void testWithUTC_AlreadyUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.UTC); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertSame("Should be same as the chronology itself because it's already UTC", chronology, withUTC); [EOL] }
public void testWithUTC_NotUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.getDefault()); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertNotNull("Should not be null because the chronology is not UTC", withUTC); [EOL] assertNotSame("Should not be the same as the chronology itself because it's not UTC", chronology, withUTC); [EOL] assertEquals("The time zone of the returned chronology should be UTC", DateTimeZone.UTC, withUTC.getZone()); [EOL] }
public void testToString() { [EOL] LenientChronology lenientChronology = new LenientChronology(someBaseChronology); [EOL] String result = lenientChronology.toString(); [EOL] assertNotNull("toString() should not return null", result); [EOL] assertTrue("toString() should contain 'LenientChronology'", result.contains("LenientChronology")); [EOL] assertTrue("toString() should contain the base chronology's toString result", result.contains(someBaseChronology.toString())); [EOL] }
public void testGetDurationField() { [EOL] MyClass myClassInstance = new MyClass(durationFieldInstance); [EOL] DurationField result = myClassInstance.getDurationField(); [EOL] assertNotNull(result); [EOL] assertEquals(durationFieldInstance, result); [EOL] }
public boolean isPrecise() { [EOL] return false; [EOL] }
public int testGetValue_WithPositiveDuration() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long duration = 1000L; [EOL] long instant = 0L; [EOL] int expectedValue = field.getDifference(instant + duration, instant); [EOL] int actualValue = field.getValue(duration, instant); [EOL] assert actualValue == expectedValue; [EOL] }
public int testGetValue_WithNegativeDuration() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long duration = -1000L; [EOL] long instant = 0L; [EOL] int expectedValue = field.getDifference(instant + duration, instant); [EOL] int actualValue = field.getValue(duration, instant); [EOL] assert actualValue == expectedValue; [EOL] }
public int testGetValue_WithZeroDuration() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long duration = 0L; [EOL] long instant = 0L; [EOL] int expectedValue = field.getDifference(instant + duration, instant); [EOL] int actualValue = field.getValue(duration, instant); [EOL] assert actualValue == expectedValue; [EOL] }
public void testGetMillisWithPositiveValue() { [EOL] long instant = 1000L; // Some arbitrary instant [EOL] int value = 5; // Positive value to add [EOL] long expectedMillis = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long actualMillis = getMillis(value, instant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMillisWithNegativeValue() { [EOL] long instant = 1000L; // Some arbitrary instant [EOL] int value = -5; // Negative value to subtract [EOL] long expectedMillis = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long actualMillis = getMillis(value, instant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMillisWithZeroValue() { [EOL] long instant = 1000L; // Some arbitrary instant [EOL] int value = 0; // Zero value, should not change the instant [EOL] long expectedMillis = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long actualMillis = getMillis(value, instant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMillisWithPositiveValue() { [EOL] long value = 10; [EOL] long instant = 1000; [EOL] long expected = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithNegativeValue() { [EOL] long value = -10; [EOL] long instant = 1000; [EOL] long expected = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithZeroValue() { [EOL] long value = 0; [EOL] long instant = 1000; [EOL] long expected = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithMaxLongValue() { [EOL] long value = Long.MAX_VALUE; [EOL] long instant = 1000; [EOL] long expected = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithMinLongValue() { [EOL] long value = Long.MIN_VALUE; [EOL] long instant = 1000; [EOL] long expected = ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] }
public void testWeeks_Zero() { [EOL] Weeks result = Time.weeks(0); [EOL] assertSame(Weeks.ZERO, result); [EOL] }
public void testWeeks_One() { [EOL] Weeks result = Time.weeks(1); [EOL] assertSame(Weeks.ONE, result); [EOL] }
public void testWeeks_Two() { [EOL] Weeks result = Time.weeks(2); [EOL] assertSame(Weeks.TWO, result); [EOL] }
public void testWeeks_Three() { [EOL] Weeks result = Time.weeks(3); [EOL] assertSame(Weeks.THREE, result); [EOL] }
public void testWeeks_MaxValue() { [EOL] Weeks result = Time.weeks(Integer.MAX_VALUE); [EOL] assertSame(Weeks.MAX_VALUE, result); [EOL] }
public void testWeeks_MinValue() { [EOL] Weeks result = Time.weeks(Integer.MIN_VALUE); [EOL] assertSame(Weeks.MIN_VALUE, result); [EOL] }
public void testWeeks_Default() { [EOL] int arbitraryWeeks = 4; // Any number that is not 0, 1, 2, 3, Integer.MAX_VALUE, or Integer.MIN_VALUE [EOL] Weeks result = Time.weeks(arbitraryWeeks); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryWeeks, result.getWeeks()); [EOL] }
public void testWeeksBetween_SameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Weeks result = Time.weeksBetween(start, end); [EOL] assertEquals(0, result.getWeeks()); [EOL] }
public void testWeeksBetween_OneWeekApart() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusWeeks(1); [EOL] Weeks result = Time.weeksBetween(start, end); [EOL] assertEquals(1, result.getWeeks()); [EOL] }
public void testWeeksBetween_NegativeWeeks() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.minusWeeks(1); [EOL] Weeks result = Time.weeksBetween(start, end); [EOL] assertEquals(-1, result.getWeeks()); [EOL] }
public void testParseWeeks_NullInput() { [EOL] Weeks result = parseWeeks(null); [EOL] assertEquals(Weeks.ZERO, result); [EOL] }
public void testParseWeeks_ValidInput() { [EOL] Weeks result = parseWeeks("P2W"); [EOL] assertEquals(Weeks.weeks(2), result); [EOL] }
public void testParseWeeks_InvalidInput() { [EOL] try { [EOL] parseWeeks("Invalid"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWeeksConstructor() { [EOL] int weeksValue = 5; [EOL] Weeks weeks = new Weeks(weeksValue); [EOL] assertEquals(weeksValue, weeks.getValue()); [EOL] }
private Object readResolve() { [EOL] return Weeks.weeks(getValue()); [EOL] }
public void testGetFieldType_ReturnsWeeks() { [EOL] DurationFieldType fieldType = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.weeks(), fieldType); [EOL] }
public void testToStandardHours_PositiveWeeks() { [EOL] Weeks weeks = Weeks.weeks(2); [EOL] Hours result = weeks.toStandardHours(); [EOL] assertEquals(336, result.getHours()); [EOL] }
public void testToStandardHours_ZeroWeeks() { [EOL] Weeks weeks = Weeks.weeks(0); [EOL] Hours result = weeks.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_NegativeWeeks() { [EOL] Weeks weeks = Weeks.weeks(-3); [EOL] Hours result = weeks.toStandardHours(); [EOL] assertEquals(-504, result.getHours()); [EOL] }
public int getWeeks() { [EOL] return getValue(); [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime result = ClassName.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] ClassName.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Zone must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDateTimeWithValidInstant() { [EOL] long instant = 1000L; // Any valid long value [EOL] DateTime dateTime = new DateTime(instant); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] }
public void testDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, zone); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testDateTimeWithValidParameters() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testWithEarlierOffsetAtOverlap_NoOverlap() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(2020, 10, 25, 1, 0, zone); // This is a date with no overlap [EOL] DateTime result = dateTime.withEarlierOffsetAtOverlap(); [EOL] assertEquals(dateTime.getMillis(), result.getMillis()); [EOL] } [EOL] public void testWithEarlierOffsetAtOverlap_WithOverlap() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(2020, 10, 25, 2, 0, zone); // This is a date with overlap [EOL] DateTime result = dateTime.withEarlierOffsetAtOverlap(); [EOL] assertNotEquals(dateTime.getMillis(), result.getMillis()); [EOL] }

public void testWithLaterOffsetAtOverlap_NoOverlap() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(2021, 10, 31, 1, 0, 0, zone); // This time has no overlap in London time zone [EOL] DateTime expected = dateTime; // No overlap, so the time should not change [EOL] DateTime result = dateTime.withLaterOffsetAtOverlap(); [EOL] assertEquals(expected, result); [EOL] }
public void testWithLaterOffsetAtOverlap_WithOverlap() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(2021, 10, 31, 2, 0, 0, zone); // This time has an overlap in London time zone [EOL] long newMillis = zone.adjustOffset(dateTime.getMillis(), true); [EOL] DateTime expected = new DateTime(newMillis, zone); // Expected time after adjusting for the later offset [EOL] DateTime result = dateTime.withLaterOffsetAtOverlap(); [EOL] assertEquals(expected, result); [EOL] }
public void testWithDate_Normal() { [EOL] DateTime dt = new DateTime(2020, 1, 1, 0, 0, 0, 0); // Assume this is a valid DateTime object [EOL] DateTime newDt = dt.withDate(2021, 2, 3); [EOL] assertEquals(2021, newDt.getYear()); [EOL] assertEquals(2, newDt.getMonthOfYear()); [EOL] assertEquals(3, newDt.getDayOfMonth()); [EOL] }
public void testWithDate_LeapYear() { [EOL] DateTime dt = new DateTime(2020, 1, 1, 0, 0, 0, 0); // Assume this is a valid DateTime object [EOL] DateTime newDt = dt.withDate(2020, 2, 29); [EOL] assertEquals(2020, newDt.getYear()); [EOL] assertEquals(2, newDt.getMonthOfYear()); [EOL] assertEquals(29, newDt.getDayOfMonth()); [EOL] }
public void testWithDate_InvalidMonth() { [EOL] DateTime dt = new DateTime(2020, 1, 1, 0, 0, 0, 0); // Assume this is a valid DateTime object [EOL] try { [EOL] dt.withDate(2021, 13, 1); [EOL] fail("Should have thrown an exception for invalid month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDate_InvalidDay() { [EOL] DateTime dt = new DateTime(2020, 1, 1, 0, 0, 0, 0); // Assume this is a valid DateTime object [EOL] try { [EOL] dt.withDate(2021, 2, 30); [EOL] fail("Should have thrown an exception for invalid day"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFields_NullPartial() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFields(null); [EOL] assertSame("Expected the same instance when partial is null", dateTime, result); [EOL] }
public void testWithFields_NonNullPartial() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadablePartial mockPartial = new LocalDate(2020, 1, 1); [EOL] Chronology chronology = dateTime.getChronology(); [EOL] long expectedMillis = chronology.set(mockPartial, dateTime.getMillis()); [EOL] DateTime result = dateTime.withFields(mockPartial); [EOL] assertNotNull("Expected a new instance when partial is not null", result); [EOL] assertNotSame("Expected a different instance when partial is not null", dateTime, result); [EOL] assertEquals("Expected the millis to be set by the chronology", expectedMillis, result.getMillis()); [EOL] }
public void testWithField_NullFieldType() { [EOL] DateTime dateTime = new DateTime(); [EOL] try { [EOL] dateTime.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] DateTime updatedDateTime = dateTime.withField(fieldType, value); [EOL] assertEquals(value, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withDurationAdded(0, 1); [EOL] assertSame("Duration added is zero, should return same instance", dateTime, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withDurationAdded(10, 0); [EOL] assertSame("Scalar is zero, should return same instance", dateTime, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] long durationToAdd = 10; [EOL] int scalar = 2; [EOL] DateTime result = dateTime.withDurationAdded(durationToAdd, scalar); [EOL] assertNotSame("Duration and scalar are non-zero, should return new instance", dateTime, result); [EOL] assertTrue("Resulting time should be after original time", result.isAfter(dateTime)); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withPeriodAdded(null, 1); [EOL] assertEquals(dateTime, result); [EOL] } [EOL] public void testWithPeriodAdded_ZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] DateTime result = dateTime.withPeriodAdded(period, 0); [EOL] assertEquals(dateTime, result); [EOL] } [EOL] public void testWithPeriodAdded_NonNullPeriodNonZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] DateTime result = dateTime.withPeriodAdded(period, 1); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.plus(period), result); [EOL] }
public void testPlus_withNullPeriod() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plus(null); [EOL] assertEquals(dateTime, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] DateTime dateTime = new DateTime(); [EOL] Period period = new Period().withDays(1); [EOL] DateTime expected = dateTime.plusDays(1); [EOL] DateTime result = dateTime.plus(period); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusHours_ZeroHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(0); [EOL] assertSame("Expected same instance when adding zero hours", dateTime, result); [EOL] }
public void testPlusHours_PositiveHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(1); [EOL] assertNotSame("Expected different instance when adding positive hours", dateTime, result); [EOL] assertEquals("Expected time to be one hour ahead", dateTime.getMillis() + 3600000, result.getMillis()); [EOL] }
public void testPlusHours_NegativeHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(-1); [EOL] assertNotSame("Expected different instance when adding negative hours", dateTime, result); [EOL] assertEquals("Expected time to be one hour behind", dateTime.getMillis() - 3600000, result.getMillis()); [EOL] }
public void testMinus_withPositiveDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] long duration = 1000; // 1 second [EOL] DateTime result = dateTime.minus(duration); [EOL] assertEquals(dateTime.minusMillis((int) duration), result); [EOL] }
public void testMinus_withNegativeDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] long duration = -1000; // -1 second [EOL] DateTime result = dateTime.minus(duration); [EOL] assertEquals(dateTime.plusMillis((int) -duration), result); [EOL] }
public void testMinus_withZeroDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] long duration = 0; [EOL] DateTime result = dateTime.minus(duration); [EOL] assertEquals(dateTime, result); [EOL] }
public void testCenturyOfEra() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property centuryOfEraProperty = dateTime.centuryOfEra(); [EOL] assertNotNull(centuryOfEraProperty); [EOL] assertEquals(centuryOfEraProperty.getField(), dateTime.getChronology().centuryOfEra()); [EOL] assertEquals(centuryOfEraProperty.get(), dateTime.getChronology().centuryOfEra().get(dateTime.getMillis())); [EOL] }
public void testDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfWeek(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfWeek(), property.getField()); [EOL] assertEquals(dateTime, property.getReadableInstant()); [EOL] }
public void testAddToCopy_PositiveValue() { [EOL] long initialMillis = iInstant.getMillis(); [EOL] long valueToAdd = 10L; // Assuming 10 is a meaningful value to add [EOL] DateTime result = iInstant.addToCopy(valueToAdd); [EOL] long expectedMillis = iField.add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] } [EOL] public void testAddToCopy_NegativeValue() { [EOL] long initialMillis = iInstant.getMillis(); [EOL] long valueToAdd = -10L; // Assuming -10 is a meaningful value to subtract [EOL] DateTime result = iInstant.addToCopy(valueToAdd); [EOL] long expectedMillis = iField.add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] } [EOL] public void testAddToCopy_ZeroValue() { [EOL] long initialMillis = iInstant.getMillis(); [EOL] long valueToAdd = 0L; // Adding zero should not change the instant [EOL] DateTime result = iInstant.addToCopy(valueToAdd); [EOL] long expectedMillis = iField.add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] }
public void testWithMaximumValue_NormalCase() { [EOL] DateTime testDateTime = new DateTime(); // Assuming DateTime is a valid class and has a default constructor [EOL] DateTime maxDateTime = testDateTime.withMaximumValue(); [EOL] assertNotNull(maxDateTime); [EOL] assertEquals(testDateTime.getChronology().getMaximumValue(), maxDateTime.getMillis()); [EOL] } [EOL] public void testWithMaximumValue_IllegalInstantException() { [EOL] DateTime testDateTime = new DateTime() { [EOL] @Override [EOL] public long getMillis() { [EOL] throw new IllegalInstantException("Forced IllegalInstantException for testing"); [EOL] } [EOL] }; [EOL] try { [EOL] testDateTime.withMaximumValue(); [EOL] fail("Expected IllegalInstantException to be thrown"); [EOL] } catch (IllegalInstantException ex) { [EOL] } [EOL] } [EOL] public void testWithMaximumValue_RuntimeException() { [EOL] DateTime testDateTime = new DateTime() { [EOL] @Override [EOL] public long getMillis() { [EOL] throw new RuntimeException("Forced RuntimeException for testing"); [EOL] } [EOL] }; [EOL] try { [EOL] testDateTime.withMaximumValue(); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException ex) { [EOL] } [EOL] }
public void testGetInstanceWithNullField() { [EOL] DateTimeField result = ClassName.getInstance(null); [EOL] assertNull(result); [EOL] }
public void testGetInstanceWithLenientField() { [EOL] DateTimeField lenientField = new LenientDateTimeField(); [EOL] DateTimeField result = ClassName.getInstance(lenientField); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof LenientDateTimeField); [EOL] assertTrue(result instanceof StrictDateTimeField); [EOL] }
public void testGetInstanceWithStrictField() { [EOL] DateTimeField strictField = new StrictDateTimeField(); [EOL] DateTimeField result = ClassName.getInstance(strictField); [EOL] assertSame(strictField, result); [EOL] }
public void testGetZoneWithNullId() { [EOL] DateTimeZone result = getZone(null); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithUnknownId() { [EOL] DateTimeZone result = getZone("Unknown"); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithMatchingId() { [EOL] iZoneInfoMap.put("ValidId", "ValidId"); [EOL] DateTimeZone expectedZone = new DateTimeZone("ValidId"); [EOL] when(loadZoneData("ValidId")).thenReturn(expectedZone); [EOL] DateTimeZone result = getZone("ValidId"); [EOL] assertEquals(expectedZone, result); [EOL] }
public void testGetZoneWithSoftReference() { [EOL] DateTimeZone expectedZone = new DateTimeZone("SoftRefId"); [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(expectedZone); [EOL] iZoneInfoMap.put("SoftRefId", softRef); [EOL] DateTimeZone result = getZone("SoftRefId"); [EOL] assertEquals(expectedZone, result); [EOL] }
public void testGetZoneWithClearedSoftReference() { [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(null); [EOL] iZoneInfoMap.put("ClearedSoftRefId", softRef); [EOL] DateTimeZone expectedZone = new DateTimeZone("ClearedSoftRefId"); [EOL] when(loadZoneData("ClearedSoftRefId")).thenReturn(expectedZone); [EOL] DateTimeZone result = getZone("ClearedSoftRefId"); [EOL] assertEquals(expectedZone, result); [EOL] }
public void testGetZoneWithIndirectReference() { [EOL] String indirectId = "ActualId"; [EOL] DateTimeZone expectedZone = new DateTimeZone(indirectId); [EOL] iZoneInfoMap.put("IndirectRefId", indirectId); [EOL] iZoneInfoMap.put(indirectId, expectedZone); [EOL] DateTimeZone result = getZone("IndirectRefId"); [EOL] assertEquals(expectedZone, result); [EOL] }
public void testOpenResourceWithFileDirNotNull() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = new File("path/to/directory"); [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNotNull() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = this.getClass().getClassLoader(); [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNullResourceExists() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = null; [EOL] time.iResourcePath = "/"; [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNullResourceNotFound() { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = null; [EOL] time.iResourcePath = "/nonexistent/"; [EOL] String resourceName = "testResource.txt"; [EOL] Exception exception = assertThrows(IOException.class, () -> { [EOL] time.openResource(resourceName); [EOL] }); [EOL] String expectedMessage = "Resource not found: \"/nonexistent/testResource.txt\" ClassLoader: system"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testLoadZoneData_Success() throws Exception { [EOL] String id = "validZoneId"; [EOL] DateTimeZone result = loadZoneData(id); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] } [EOL] public void testLoadZoneData_IOExceptionOnOpenResource() throws Exception { [EOL] String id = "invalidZoneId"; [EOL] try { [EOL] loadZoneData(id); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException expected) { [EOL] } [EOL] assertNull(iZoneInfoMap.get(id)); [EOL] } [EOL] public void testLoadZoneData_IOExceptionOnClose() throws Exception { [EOL] String id = "zoneIdWithIOExceptionOnClose"; [EOL] DateTimeZone result = null; [EOL] try { [EOL] result = loadZoneData(id); [EOL] } catch (IOException ex) { [EOL] } [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertTrue(wasIOExceptionIgnored()); [EOL] }
public void testIsPrinter_WhenIPrinterIsNull() { [EOL] Time time = new Time(); [EOL] time.iPrinter = null; [EOL] boolean result = time.isPrinter(); [EOL] assertFalse(result); [EOL] }
public void testIsPrinter_WhenIPrinterIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iPrinter = new Printer(); // Assuming Printer is a valid class that can be instantiated [EOL] boolean result = time.isPrinter(); [EOL] assertTrue(result); [EOL] }
public void testIsParserWhenParserIsNull() { [EOL] Time time = new Time(); [EOL] time.iParser = null; [EOL] assertFalse(time.isParser()); [EOL] }
public void testIsParserWhenParserIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iParser = new Parser(); [EOL] assertTrue(time.isParser()); [EOL] }
public void testGetParser() { [EOL] PeriodParser expectedParser = new MockPeriodParser(); [EOL] MyClass myObject = new MyClass(expectedParser); [EOL] PeriodParser actualParser = myObject.getParser(); [EOL] assertEquals("The getParser method should return the correct PeriodParser", expectedParser, actualParser); [EOL] }
public void testParsePeriodWithNullText() { [EOL] try { [EOL] Period result = parsePeriod(null); [EOL] fail("Should have thrown IllegalArgumentException for null text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParsePeriodWithEmptyText() { [EOL] try { [EOL] Period result = parsePeriod(""); [EOL] fail("Should have thrown IllegalArgumentException for empty text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParsePeriodWithValidText() { [EOL] Period result = parsePeriod("PT1H"); [EOL] assertNotNull("Resulting Period should not be null", result); [EOL] assertEquals("Period hours should be 1", 1, result.getHours()); [EOL] }
public void testParseMutablePeriod_ValidInput() { [EOL] String validInput = "P1Y2M3W4D"; // Assuming this is a valid period format [EOL] MutablePeriod result = parseMutablePeriod(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(2, result.getMonths()); [EOL] assertEquals(3, result.getWeeks()); [EOL] assertEquals(4, result.getDays()); [EOL] }
public void testParseMutablePeriod_EmptyString() { [EOL] String emptyInput = ""; [EOL] try { [EOL] parseMutablePeriod(emptyInput); [EOL] fail("Should have thrown IllegalArgumentException for empty input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutablePeriod_InvalidFormat() { [EOL] String invalidInput = "InvalidFormat"; [EOL] try { [EOL] parseMutablePeriod(invalidInput); [EOL] fail("Should have thrown IllegalArgumentException for invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutablePeriod_NullInput() { [EOL] try { [EOL] parseMutablePeriod(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckParserWithParserNotNull() { [EOL] this.iParser = mock(Parser.class); [EOL] checkParser(); [EOL] }
public void testCheckParserWithParserNull() { [EOL] this.iParser = null; [EOL] try { [EOL] checkParser(); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Parsing not supported", e.getMessage()); [EOL] } [EOL] }
public void testPartialWithNullChronology() { [EOL] Partial partial = new Partial((Chronology) null); [EOL] assertNotNull(partial); [EOL] assertEquals(ISOChronology.getInstanceUTC(), partial.getChronology()); [EOL] assertEquals(0, partial.size()); [EOL] }
public void testPartialWithNonNullChronology() { [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] Partial partial = new Partial(chronology); [EOL] assertNotNull(partial); [EOL] assertEquals(chronology.withUTC(), partial.getChronology()); [EOL] assertEquals(0, partial.size()); [EOL] }
public void testPartialConstructor_NullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}, null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testPartialConstructor_NullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null values array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testPartialConstructor_InequalLengthArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types and values array of different lengths"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must be the same length as the types array", e.getMessage()); [EOL] } [EOL] } [EOL] public void testPartialConstructor_EmptyArrays() { [EOL] Partial partial = new Partial(new DateTimeFieldType[0], new int[0], null); [EOL] assertEquals(0, partial.size()); [EOL] } [EOL] public void testPartialConstructor_NullTypeElement() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{null, DateTimeFieldType.monthOfYear()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for null element in types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain null: index 0")); [EOL] } [EOL] } [EOL] public void testPartialConstructor_UnsupportedType() { [EOL] try { [EOL] DateTimeFieldType unsupportedType = new DateTimeFieldType("unsupported") { [EOL] public DurationFieldType getDurationType() { [EOL] return DurationFieldType.days(); [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(Chronology chronology) { [EOL] return UnsupportedDateTimeField.getInstance(getDurationType(), getRangeDurationType()); [EOL] } [EOL] }; [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), unsupportedType}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for unsupported type following a supported one"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate unsupported: year and unsupported")); [EOL] } [EOL] } [EOL] public void testPartialConstructor_TypesNotInOrder() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types not in order"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must be in order largest-smallest: hourOfDay < year")); [EOL] } [EOL] } [EOL] public void testPartialConstructor_DuplicateTypes() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for duplicate types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate: year and year")); [EOL] } [EOL] }
public int size() { [EOL] return iTypes.length; [EOL] }
public void testGetChronology() { [EOL] Chronology expectedChronology = ...; // Initialize with a mock or actual Chronology object [EOL] MyClass myClassInstance = new MyClass(expectedChronology); [EOL] Chronology actualChronology = myClassInstance.getChronology(); [EOL] assertEquals(expectedChronology, actualChronology); [EOL] }
public void testGetFieldWithValidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] { [EOL] DateTimeFieldType.year(), [EOL] DateTimeFieldType.monthOfYear(), [EOL] DateTimeFieldType.dayOfMonth() [EOL] }; [EOL] DateTimeField[] fields = new DateTimeField[types.length]; [EOL] for (int i = 0; i < types.length; i++) { [EOL] fields[i] = types[i].getField(chrono); [EOL] } [EOL] for (int i = 0; i < types.length; i++) { [EOL] DateTimeField field = getField(i, chrono); [EOL] assertSame(fields[i], field); [EOL] } [EOL] }
public void testGetFieldWithInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int invalidIndex = 3; // Assuming there are only 3 fields in iTypes [EOL] try { [EOL] getField(invalidIndex, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testGetFieldTypes_NonEmptyTypes() { [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] { [EOL] DateTimeFieldType.year(), [EOL] DateTimeFieldType.monthOfYear(), [EOL] DateTimeFieldType.dayOfMonth() [EOL] }; [EOL] DateTimeProperty property = new DateTimeProperty(null, types); [EOL] DateTimeFieldType[] result = property.getFieldTypes(); [EOL] assertNotNull("Result should not be null", result); [EOL] assertNotSame("Result should be a clone, not the same array", types, result); [EOL] assertArrayEquals("Result should contain the same DateTimeFieldTypes", types, result); [EOL] }
public void testGetFieldTypes_EmptyTypes() { [EOL] DateTimeFieldType[] types = new DateTimeFieldType[0]; [EOL] DateTimeProperty property = new DateTimeProperty(null, types); [EOL] DateTimeFieldType[] result = property.getFieldTypes(); [EOL] assertNotNull("Result should not be null", result); [EOL] assertNotSame("Result should be a clone, not the same array", types, result); [EOL] assertEquals("Result should be an empty array", 0, result.length); [EOL] }
public void testWithFieldTypeNull() { [EOL] try { [EOL] Partial partial = new Partial(); [EOL] partial.with(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field type must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldTypeNotInPartial() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] Partial partial = new Partial(); [EOL] int value = 10; [EOL] Partial result = partial.with(fieldType, value); [EOL] assertEquals(1, result.size()); [EOL] assertEquals(fieldType, result.getFieldType(0)); [EOL] assertEquals(value, result.getValue(0)); [EOL] }
public void testWithFieldTypeInPartialSameValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{value}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertSame(partial, result); [EOL] }
public void testWithFieldTypeInPartialDifferentValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{5}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertEquals(value, result.getValue(0)); [EOL] }
public void testWithoutFieldTypePresent() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] Partial partial = new Partial().with(fieldType, 2020); [EOL] int initialSize = partial.size(); [EOL] Partial result = partial.without(fieldType); [EOL] assertEquals(initialSize - 1, result.size()); [EOL] assertEquals(-1, result.indexOf(fieldType)); [EOL] }
public void testWithoutFieldTypeNotPresent() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] DateTimeFieldType missingFieldType = DateTimeFieldType.monthOfYear(); [EOL] Partial partial = new Partial().with(fieldType, 2020); [EOL] Partial result = partial.without(missingFieldType); [EOL] assertSame(partial, result); [EOL] }
public void testGetFormatterWithEmptySize() { [EOL] setTimeSizeTo(0); // This is a hypothetical method to set the size [EOL] DateTimeFormatter formatter = getFormatter(); [EOL] assertNull(formatter); [EOL] }
public void testGetFormatterWithNonEmptySizeAndValidFields() { [EOL] setTimeSizeToNonZero(); // This is a hypothetical method to set the size [EOL] addValidDateTimeFieldType(); // This is a hypothetical method to add a valid DateTimeFieldType [EOL] DateTimeFormatter formatter = getFormatter(); [EOL] assertNotNull(formatter); [EOL] assertEquals(expectedFormatter, formatter); [EOL] }
public void testGetFormatterWithNonEmptySizeAndInvalidFields() { [EOL] setTimeSizeToNonZero(); // This is a hypothetical method to set the size [EOL] addInvalidDateTimeFieldType(); // This is a hypothetical method to add an invalid DateTimeFieldType that causes IllegalArgumentException [EOL] DateTimeFormatter formatter = getFormatter(); [EOL] assertEquals(expectedFormatterAfterException, formatter); [EOL] }
public void testGetFormatterWithCachedFormatter() { [EOL] setCachedFormatter(someCachedFormatter); // This is a hypothetical method to set the cached formatter [EOL] DateTimeFormatter formatter = getFormatter(); [EOL] assertSame(someCachedFormatter, formatter); [EOL] }
public void testToStringWithNullFormatterArray() { [EOL] this.iFormatter = null; // Set the formatter array to null [EOL] String result = this.toString(); [EOL] assertEquals("Expected toStringList output", toStringList(), result); [EOL] }
public void testToStringWithNonNullFormatterButNullElement() { [EOL] this.iFormatter = new DateTimeFormatter[2]; // Create a formatter array with a null element at index 1 [EOL] this.iFormatter[0] = someFormatter; // someFormatter is a valid DateTimeFormatter [EOL] this.iFormatter[1] = null; [EOL] String result = this.toString(); [EOL] assertEquals("Expected toStringList output", toStringList(), result); [EOL] }
public void testToStringWithNonNullFormatters() { [EOL] this.iFormatter = new DateTimeFormatter[2]; // Create a formatter array with non-null elements [EOL] this.iFormatter[0] = someFormatter; // someFormatter is a valid DateTimeFormatter [EOL] this.iFormatter[1] = anotherFormatter; // anotherFormatter is another valid DateTimeFormatter [EOL] when(anotherFormatter.print(this)).thenReturn("Formatted output"); // Stubbing the print method [EOL] String result = this.toString(); [EOL] assertEquals("Expected formatted output", "Formatted output", result); [EOL] }
public void testGetPartial() { [EOL] Partial expected = new Partial(); [EOL] MyClass myClass = new MyClass(expected); [EOL] Partial result = myClass.getPartial(); [EOL] assertEquals(expected, result); [EOL] }
public int get() { [EOL] return iPartial.getValue(iFieldIndex); [EOL] }
public void testBaseDuration_WithSameStartAndEnd() { [EOL] ReadableInstant start = new Instant(); [EOL] ReadableInstant end = start; [EOL] BaseDuration duration = new BaseDuration(start, end); [EOL] assertEquals(0L, duration.getMillis()); [EOL] }
public void testBaseDuration_WithDifferentStartAndEnd() { [EOL] ReadableInstant start = new Instant(0L); [EOL] ReadableInstant end = new Instant(1000L); [EOL] BaseDuration duration = new BaseDuration(start, end); [EOL] assertEquals(1000L, duration.getMillis()); [EOL] }
public void testToPeriodWithNullChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Period result = dateTime.toPeriod(null); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getMillis(), result.getStartMillis()); [EOL] }
public void testToPeriodWithNonNullChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] Period result = dateTime.toPeriod(chrono); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getMillis(), result.getStartMillis()); [EOL] assertEquals(chrono, result.getChronology()); [EOL] }
public void testToPeriodWithNullTypeAndChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Period result = dateTime.toPeriod(null, null); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getMillis(), result.toDurationFrom(new DateTime(0)).getMillis()); [EOL] }
public void testToPeriodWithTypeAndChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] Period result = dateTime.toPeriod(type, chrono); [EOL] assertNotNull(result); [EOL] assertEquals(type, result.getPeriodType()); [EOL] assertEquals(chrono, result.getChronology()); [EOL] }
public void testToPeriodFromWithNullType() { [EOL] DateTime endInstant = new DateTime(); [EOL] ReadableInstant startInstant = new DateTime(endInstant.minusHours(1)); [EOL] Period result = endInstant.toPeriodFrom(startInstant, null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getHours()); [EOL] }
public void testToPeriodFromWithNonNullType() { [EOL] DateTime endInstant = new DateTime(); [EOL] ReadableInstant startInstant = new DateTime(endInstant.minusHours(1)); [EOL] PeriodType type = PeriodType.standard(); [EOL] Period result = endInstant.toPeriodFrom(startInstant, type); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getHours()); [EOL] }
public void testYearsZero() { [EOL] Years result = Time.years(0); [EOL] assertSame(Years.ZERO, result); [EOL] }
public void testYearsOne() { [EOL] Years result = Time.years(1); [EOL] assertSame(Years.ONE, result); [EOL] }
public void testYearsTwo() { [EOL] Years result = Time.years(2); [EOL] assertSame(Years.TWO, result); [EOL] }
public void testYearsThree() { [EOL] Years result = Time.years(3); [EOL] assertSame(Years.THREE, result); [EOL] }
public void testYearsMaxValue() { [EOL] Years result = Time.years(Integer.MAX_VALUE); [EOL] assertSame(Years.MAX_VALUE, result); [EOL] }
public void testYearsMinValue() { [EOL] Years result = Time.years(Integer.MIN_VALUE); [EOL] assertSame(Years.MIN_VALUE, result); [EOL] }
public void testYearsDefault() { [EOL] int arbitraryYears = 10; [EOL] Years result = Time.years(arbitraryYears); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryYears, result.getYears()); [EOL] }
public void testYearsBetween_SameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Years result = Time.yearsBetween(start, end); [EOL] assertEquals(0, result.getYears()); [EOL] }
public void testYearsBetween_OneYearApart() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusYears(1); [EOL] Years result = Time.yearsBetween(start, end); [EOL] assertEquals(1, result.getYears()); [EOL] }
public void testYearsBetween_OneYearApartNegative() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.minusYears(1); [EOL] Years result = Time.yearsBetween(end, start); [EOL] assertEquals(1, result.getYears()); [EOL] }
public void testYearsBetweenWithLocalDates() { [EOL] LocalDate start = new LocalDate(2020, 1, 1); [EOL] LocalDate end = new LocalDate(2023, 1, 1); [EOL] Years result = time.yearsBetween(start, end); [EOL] assertEquals(3, result.getYears()); [EOL] }
public void testYearsBetweenWithNonLocalDates() { [EOL] ReadablePartial start = new YearMonth(2020, 1); [EOL] ReadablePartial end = new YearMonth(2023, 1); [EOL] Years result = time.yearsBetween(start, end); [EOL] assertEquals(3, result.getYears()); [EOL] }
public void testYearsConstructor() { [EOL] int expectedYears = 5; [EOL] Years yearsInstance = new Years(expectedYears); [EOL] assertEquals(expectedYears, yearsInstance.getYears()); [EOL] }
public int getYears() { [EOL] return getValue(); [EOL] }
public void testNegated_Zero() { [EOL] Years zeroYears = Years.years(0); [EOL] Years result = zeroYears.negated(); [EOL] assertEquals("Negating zero should give zero", 0, result.getValue()); [EOL] }
public void testNegated_Positive() { [EOL] Years positiveYears = Years.years(5); [EOL] Years result = positiveYears.negated(); [EOL] assertEquals("Negating a positive value should give negative", -5, result.getValue()); [EOL] }
public void testNegated_Negative() { [EOL] Years negativeYears = Years.years(-3); [EOL] Years result = negativeYears.negated(); [EOL] assertEquals("Negating a negative value should give positive", 3, result.getValue()); [EOL] }
public void testNegated_MaxValue() { [EOL] Years maxYears = Years.years(Integer.MAX_VALUE); [EOL] Years result = maxYears.negated(); [EOL] assertEquals("Negating MAX_VALUE should give MIN_VALUE + 1", Integer.MIN_VALUE + 1, result.getValue()); [EOL] }
public void testNegated_MinValue() { [EOL] Years minYears = Years.years(Integer.MIN_VALUE); [EOL] try { [EOL] minYears.negated(); [EOL] fail("Negating MIN_VALUE should throw an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsGreaterThanWithNull() { [EOL] Years years = new Years(5); [EOL] boolean result = years.isGreaterThan(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithGreaterValue() { [EOL] Years years = new Years(5); [EOL] Years other = new Years(3); [EOL] boolean result = years.isGreaterThan(other); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithLesserValue() { [EOL] Years years = new Years(2); [EOL] Years other = new Years(3); [EOL] boolean result = years.isGreaterThan(other); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGreaterThanWithEqualValue() { [EOL] Years years = new Years(3); [EOL] Years other = new Years(3); [EOL] boolean result = years.isGreaterThan(other); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNull() { [EOL] Years years = new Years(-1); [EOL] boolean result = years.isLessThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNullAndPositiveYears() { [EOL] Years years = new Years(1); [EOL] boolean result = years.isLessThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNonNull() { [EOL] Years years1 = new Years(1); [EOL] Years years2 = new Years(2); [EOL] boolean result = years1.isLessThan(years2); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithEqualYears() { [EOL] Years years1 = new Years(1); [EOL] Years years2 = new Years(1); [EOL] boolean result = years1.isLessThan(years2); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithGreaterYears() { [EOL] Years years1 = new Years(2); [EOL] Years years2 = new Years(1); [EOL] boolean result = years1.isLessThan(years2); [EOL] assertFalse(result); [EOL] }
public void testToString_ReturnsCorrectFormat() { [EOL] Time time = new Time(5); // Assuming there is a constructor that sets the value [EOL] String result = time.toString(); [EOL] assertEquals("P5Y", result); [EOL] }
public void testInstantConstructor() { [EOL] Instant instant = new Instant(); [EOL] assertNotNull(instant); [EOL] assertEquals(DateTimeUtils.currentTimeMillis(), instant.getMillis()); [EOL] }
public void testInstantWithNull() { [EOL] try { [EOL] new Instant((Object) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testInstantWithCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTimeInMillis(1234567890L); [EOL] Instant instant = new Instant(calendar); [EOL] assertEquals(1234567890L, instant.getMillis()); [EOL] } [EOL] public void testInstantWithDate() { [EOL] Date date = new Date(1234567890L); [EOL] Instant instant = new Instant(date); [EOL] assertEquals(1234567890L, instant.getMillis()); [EOL] } [EOL] public void testInstantWithLong() { [EOL] Long millis = 1234567890L; [EOL] Instant instant = new Instant(millis); [EOL] assertEquals(1234567890L, instant.getMillis()); [EOL] } [EOL] public void testInstantWithInstant() { [EOL] Instant base = new Instant(1234567890L); [EOL] Instant instant = new Instant(base); [EOL] assertEquals(1234567890L, instant.getMillis()); [EOL] }

public Instant toInstant() { [EOL] return this; [EOL] }
public static LocalDate now() { [EOL] return new LocalDate(); [EOL] }
public void testParseWithValidString() { [EOL] String validDateString = "2023-01-01"; [EOL] LocalDate expectedDate = LocalDate.of(2023, 1, 1); [EOL] LocalDate actualDate = YourClass.parse(validDateString); [EOL] assertEquals(expectedDate, actualDate); [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidDateString = "invalid-date"; [EOL] try { [EOL] YourClass.parse(invalidDateString); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testParseValidDate() { [EOL] String str = "2020-01-01"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] LocalDate expected = LocalDate.of(2020, 1, 1); [EOL] LocalDate actual = parse(str, formatter); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseInvalidDate() { [EOL] String str = "invalid-date"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] try { [EOL] parse(str, formatter); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testParseWithNullFormatter() { [EOL] String str = "2020-01-01"; [EOL] try { [EOL] parse(str, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testParseWithNullString() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] try { [EOL] parse(null, formatter); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDate.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The date must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNegativeTime() { [EOL] Date date = new Date(-1); // Date before epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] }
public void testFromDateFieldsWithPositiveTime() { [EOL] Date date = new Date(1); // Date after epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] assertEquals(1970, localDate.getYear()); [EOL] assertEquals(1, localDate.getMonthOfYear()); [EOL] assertEquals(1, localDate.getDayOfMonth()); [EOL] }
public void testLocalDateWithNullChronology() { [EOL] try { [EOL] new LocalDate(null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalDate localDate = new LocalDate(chronology); [EOL] assertNotNull("LocalDate should not be null", localDate); [EOL] assertEquals("Chronology should match", chronology, localDate.getChronology()); [EOL] }
public void testLocalDateWithInstantAndZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] LocalDate localDate = new LocalDate(instant, zone); [EOL] assertNotNull(localDate); [EOL] assertEquals(DateTimeZone.UTC, localDate.getChronology().getZone()); [EOL] }
public void testLocalDateWithNullInstantAndZone() { [EOL] Object instant = null; [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] try { [EOL] new LocalDate(instant, zone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithInstantAndNullZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = null; [EOL] LocalDate localDate = new LocalDate(instant, zone); [EOL] assertNotNull(localDate); [EOL] assertEquals(DateTimeZone.UTC, localDate.getChronology().getZone()); [EOL] }
public void testLocalDateWithNullInstantAndNullZone() { [EOL] Object instant = null; [EOL] DateTimeZone zone = null; [EOL] try { [EOL] new LocalDate(instant, zone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadResolve_ChronologyNull() { [EOL] TestObject testObject = new TestObject(null, iLocalMillis); [EOL] Object result = testObject.readResolve(); [EOL] assertTrue(result instanceof LocalDate); [EOL] assertEquals(ISOChronology.getInstanceUTC(), ((LocalDate) result).getChronology()); [EOL] }
public void testReadResolve_ChronologyNotNull_ZoneNotUTC() { [EOL] Chronology nonUTCChronology = ISOChronology.getInstance(DateTimeZone.forID("Europe/Paris")); [EOL] TestObject testObject = new TestObject(nonUTCChronology, iLocalMillis); [EOL] Object result = testObject.readResolve(); [EOL] assertTrue(result instanceof LocalDate); [EOL] assertEquals(ISOChronology.getInstanceUTC(), ((LocalDate) result).getChronology()); [EOL] }
public void testReadResolve_ChronologyNotNull_ZoneUTC() { [EOL] Chronology utcChronology = ISOChronology.getInstanceUTC(); [EOL] TestObject testObject = new TestObject(utcChronology, iLocalMillis); [EOL] Object result = testObject.readResolve(); [EOL] assertSame(testObject, result); [EOL] }
public void testGetWithNullFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithUnsupportedFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = UnsupportedDateTimeFieldType.getInstance(); [EOL] testDateTime.get(fieldType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testGetWithSupportedFieldType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] int year = testDateTime.get(fieldType); [EOL] assertEquals(testDateTime.getYear(), year); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial sameInstance = this; // Assuming 'this' is an instance of the class containing the compareTo method [EOL] int result = this.compareTo(sameInstance); [EOL] assert result == 0; [EOL] } [EOL] public void testCompareTo_LocalDateWithSameChronologyAndTime() { [EOL] LocalDate other = new LocalDate(iChronology, iLocalMillis); // Assuming these are valid arguments for LocalDate constructor [EOL] int result = this.compareTo(other); [EOL] assert result == 0; [EOL] } [EOL] public void testCompareTo_LocalDateWithSameChronologyAndEarlierTime() { [EOL] LocalDate other = new LocalDate(iChronology, iLocalMillis - 1); // Assuming 'iLocalMillis - 1' is before 'this.iLocalMillis' [EOL] int result = this.compareTo(other); [EOL] assert result == 1; [EOL] } [EOL] public void testCompareTo_LocalDateWithSameChronologyAndLaterTime() { [EOL] LocalDate other = new LocalDate(iChronology, iLocalMillis + 1); // Assuming 'iLocalMillis + 1' is after 'this.iLocalMillis' [EOL] int result = this.compareTo(other); [EOL] assert result == -1; [EOL] } [EOL] public void testCompareTo_LocalDateWithDifferentChronology() { [EOL] Chronology otherChronology = ...; // Some other chronology [EOL] LocalDate other = new LocalDate(otherChronology, iLocalMillis); [EOL] int result = this.compareTo(other); [EOL] } [EOL] public void testCompareTo_NonLocalDateReadablePartial() { [EOL] ReadablePartial nonLocalDatePartial = ...; // Some other implementation of ReadablePartial [EOL] int result = this.compareTo(nonLocalDatePartial); [EOL] }
public void testToDateTimeAtMidnight_WithNullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeAtMidnight(); [EOL] assertNotNull(result); [EOL] assertEquals(result.getHourOfDay(), 0); [EOL] assertEquals(result.getMinuteOfHour(), 0); [EOL] assertEquals(result.getSecondOfMinute(), 0); [EOL] assertEquals(result.getMillisOfSecond(), 0); [EOL] }
public void testToDateTimeAtMidnight_WithNonNullZone() { [EOL] DateTime inputDateTime = new DateTime(2023, 3, 25, 15, 30, DateTimeZone.UTC); [EOL] DateTimeZone testZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime result = inputDateTime.toDateTimeAtMidnight(testZone); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(25, result.getDayOfMonth()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); [EOL] assertEquals(testZone, result.getZone()); [EOL] }
public void testToDateTimeAtMidnight_WithNullZone() { [EOL] DateTime inputDateTime = new DateTime(2023, 3, 25, 15, 30); [EOL] DateTime result = inputDateTime.toDateTimeAtMidnight(null); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(25, result.getDayOfMonth()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); [EOL] assertNotNull(result.getZone()); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testToLocalDateTimeWithNullTime() { [EOL] LocalDate date = new LocalDate(2023, 4, 1); // Assuming LocalDate has a constructor with year, month, day [EOL] try { [EOL] date.toLocalDateTime(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The time must not be null", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithDifferentChronology() { [EOL] LocalDate date = new LocalDate(2023, 4, 1); // Assuming LocalDate has a constructor with year, month, day [EOL] LocalTime time = new LocalTime(10, 0); // Assuming LocalTime has a constructor with hour, minute [EOL] LocalTime timeWithDifferentChronology = time.withChronology(ISOChronology.getInstanceUTC()); [EOL] try { [EOL] date.toLocalDateTime(timeWithDifferentChronology); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The chronology of the time does not match", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithSameChronology() { [EOL] LocalDate date = new LocalDate(2023, 4, 1); // Assuming LocalDate has a constructor with year, month, day [EOL] LocalTime time = new LocalTime(10, 0); // Assuming LocalTime has a constructor with hour, minute [EOL] LocalTime timeWithSameChronology = time.withChronology(date.getChronology()); [EOL] LocalDateTime expected = new LocalDateTime(date.getLocalMillis() + timeWithSameChronology.getLocalMillis(), date.getChronology()); [EOL] LocalDateTime actual = date.toLocalDateTime(timeWithSameChronology); [EOL] assertEquals(expected, actual); [EOL] }
public void testToDateTimeWithNullTimeAndMatchingChronology() { [EOL] LocalTime time = null; [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.toDateTime(time, zone); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeWithNonNullTimeAndMatchingChronology() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] DateTime dateTime = new DateTime(time.getChronology()); [EOL] DateTime result = dateTime.toDateTime(time, zone); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeWithNonNullTimeAndMismatchingChronology() { [EOL] LocalTime time = new LocalTime(ISOChronology.getInstanceUTC()); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] DateTime dateTime = new DateTime(GJChronology.getInstance()); [EOL] try { [EOL] dateTime.toDateTime(time, zone); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToIntervalWithNonNullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] Interval result = localDate.toInterval(zone); [EOL] DateTime start = localDate.toDateTimeAtStartOfDay(zone); [EOL] DateTime end = localDate.plusDays(1).toDateTimeAtStartOfDay(zone); [EOL] assertEquals(start, result.getStart()); [EOL] assertEquals(end, result.getEnd()); [EOL] }
public void testToIntervalWithNullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] Interval result = localDate.toInterval(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] DateTime start = localDate.toDateTimeAtStartOfDay(defaultZone); [EOL] DateTime end = localDate.plusDays(1).toDateTimeAtStartOfDay(defaultZone); [EOL] assertEquals(start, result.getStart()); [EOL] assertEquals(end, result.getEnd()); [EOL] }
public void testToDateBeforeCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(14, result.getDate()); // Assuming the current date is after the 15th [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testToDateEqualToCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(15, result.getDate()); [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testToDateAfterCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(16, result.getDate()); // Assuming the current date is before the 15th [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testWithLocalMillis_sameMillisAsCurrent() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalDate currentDate = new LocalDate(currentMillis, ISOChronology.getInstanceUTC()); [EOL] LocalDate resultDate = currentDate.withLocalMillis(currentMillis); [EOL] assertSame("Expected same instance of LocalDate as no change in millis", currentDate, resultDate); [EOL] } [EOL] public void testWithLocalMillis_differentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalDate currentDate = new LocalDate(currentMillis, ISOChronology.getInstanceUTC()); [EOL] long newMillis = currentMillis + 24 * 60 * 60 * 1000; // Add one day [EOL] LocalDate resultDate = currentDate.withLocalMillis(newMillis); [EOL] assertNotSame("Expected different instance of LocalDate as millis changed", currentDate, resultDate); [EOL] assertEquals("Expected millis to be rounded to start of the day", [EOL] currentDate.getChronology().dayOfMonth().roundFloor(newMillis), [EOL] resultDate.getLocalMillis()); [EOL] }

public void testWithField_NullField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] try { [EOL] testDate.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming hourOfDay is not supported by LocalDate [EOL] try { [EOL] testDate.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_SupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming dayOfMonth is supported by LocalDate [EOL] int value = 15; [EOL] LocalDate updatedDate = testDate.withField(fieldType, value); [EOL] assertEquals("Field should be updated to the value", value, updatedDate.get(fieldType)); [EOL] }
public void testWithFieldAdded_NullFieldType_ThrowsIllegalArgumentException() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] try { [EOL] testDate.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType_ThrowsIllegalArgumentException() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] DurationFieldType unsupportedFieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] try { [EOL] testDate.withFieldAdded(unsupportedFieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '" + unsupportedFieldType + "' is not supported")); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount_ReturnsSameInstance() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] LocalDate resultDate = testDate.withFieldAdded(fieldType, 0); [EOL] assertSame("Adding zero should return the same instance", testDate, resultDate); [EOL] }
public void testWithFieldAdded_ValidFieldAndAmount_ReturnsNewInstance() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] int amountToAdd = 10; [EOL] LocalDate resultDate = testDate.withFieldAdded(fieldType, amountToAdd); [EOL] assertNotSame("Adding a non-zero amount should return a new instance", testDate, resultDate); [EOL] assertTrue("The result date should be after the original date", resultDate.isAfter(testDate)); [EOL] }
public void testPlusWeeks_ZeroWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusWeeks(0); [EOL] assertEquals(date, result); [EOL] }
public void testPlusWeeks_PositiveWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusWeeks(3); [EOL] LocalDate expected = date.plusDays(3 * 7); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusWeeks_NegativeWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusWeeks(-2); [EOL] LocalDate expected = date.minusDays(2 * 7); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(0); [EOL] assertEquals(date, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusDays(10), result); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(-10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusDays(-10), result); [EOL] }
public void testMinusMonths_ZeroMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusMonths(0); [EOL] assertEquals(date, result); [EOL] }
public void testMinusMonths_NegativeMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusMonths(-1); [EOL] assertNotEquals(date, result); [EOL] assertTrue(result.isBefore(date)); [EOL] }
public void testMinusMonths_PositiveMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusMonths(1); [EOL] assertNotEquals(date, result); [EOL] assertTrue(result.isAfter(date)); [EOL] }
public static PeriodFormatter getDefault() { [EOL] return wordBased(Locale.ENGLISH); [EOL] }
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = null; [EOL] int minDaysInFirstWeek = 4; [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 4; [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] int minDaysInFirstWeek = 4; [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 0; [EOL] try { [EOL] EthiopicChronology.getInstance(zone, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEthiopicChronologyConstructor() { [EOL] Chronology base = ...; // You need to provide a valid Chronology instance [EOL] Object param = ...; // You need to provide a valid parameter, if required [EOL] int minDaysInFirstWeek = 4; // Example value [EOL] EthiopicChronology ethiopicChronology = new EthiopicChronology(base, param, minDaysInFirstWeek); [EOL] assertNotNull(ethiopicChronology); [EOL] }
protected void assemble(Fields fields) { [EOL] if (getBase() == null) { [EOL] super.assemble(fields); [EOL] fields.year = new SkipDateTimeField(this, fields.year); [EOL] fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL] fields.era = ERA_FIELD; [EOL] fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL] fields.months = fields.monthOfYear.getDurationField(); [EOL] } [EOL] }
public void testGetDurationField() { [EOL] DurationField field = new Time().getDurationField(); [EOL] assertNotNull(field); [EOL] assertTrue(field instanceof UnsupportedDurationField); [EOL] assertEquals(DurationFieldType.eras(), field.getType()); [EOL] }
public void testStandard_Initialized() { [EOL] PeriodType type = PeriodType.standard(); [EOL] assertNotNull(type); [EOL] assertEquals("Standard", type.getName()); [EOL] assertTrue(type.isSupported(DurationFieldType.years())); [EOL] assertTrue(type.isSupported(DurationFieldType.months())); [EOL] assertTrue(type.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(type.isSupported(DurationFieldType.days())); [EOL] assertTrue(type.isSupported(DurationFieldType.hours())); [EOL] assertTrue(type.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(type.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(type.isSupported(DurationFieldType.millis())); [EOL] }
public void testStandard_Singleton() { [EOL] PeriodType type1 = PeriodType.standard(); [EOL] PeriodType type2 = PeriodType.standard(); [EOL] assertSame(type1, type2); [EOL] }
public void testYearMonthDayTime_WhenTypeIsNull() { [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYMDTime", null); [EOL] PeriodType result = PeriodType.yearMonthDayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("YearMonthDayTime", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.months())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.days())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testYearMonthDayTime_WhenTypeIsNotNull() { [EOL] PeriodType initialType = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYMDTime", initialType); [EOL] PeriodType result = PeriodType.yearMonthDayTime(); [EOL] assertSame(initialType, result); [EOL] }
public void testTime_WhenCTimeIsNull() { [EOL] Time.cTime = null; // Set cTime to null to simulate the condition [EOL] PeriodType result = Time.time(); [EOL] assertNotNull(result); [EOL] assertEquals("Time", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] assertEquals(4, result.size()); [EOL] }
public void testTime_WhenCTimeIsNotNull() { [EOL] PeriodType preDefinedType = new PeriodType("Predefined", new DurationFieldType[] {}, new int[] {}); [EOL] Time.cTime = preDefinedType; // Set cTime to a non-null value to simulate the condition [EOL] PeriodType result = Time.time(); [EOL] assertSame(preDefinedType, result); [EOL] }
public void testSeconds_InitiallyNull() { [EOL] PeriodType type = PeriodType.seconds(); [EOL] assertNotNull(type); [EOL] assertEquals("Seconds", type.getName()); [EOL] assertTrue(type.isSupported(DurationFieldType.seconds())); [EOL] assertFalse(type.isSupported(DurationFieldType.minutes())); [EOL] } [EOL] public void testSeconds_AlreadyInstantiated() { [EOL] PeriodType type1 = PeriodType.seconds(); [EOL] PeriodType type2 = PeriodType.seconds(); [EOL] assertSame(type1, type2); [EOL] }
public void testMillis_initialCall() { [EOL] PeriodType type = PeriodType.millis(); [EOL] assertNotNull(type); [EOL] assertEquals("Millis", type.getName()); [EOL] assertTrue(Arrays.asList(type.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testMillis_subsequentCall() { [EOL] PeriodType type1 = PeriodType.millis(); [EOL] PeriodType type2 = PeriodType.millis(); [EOL] assertSame(type1, type2); [EOL] }
public void testForFields_NullArray_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFields_EmptyArray_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(new DurationFieldType[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFields_ArrayWithNull_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(new DurationFieldType[]{null}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not contain null", e.getMessage()); [EOL] } [EOL] }
public void testForFields_ValidArray_ReturnsPeriodType() { [EOL] DurationFieldType[] types = new DurationFieldType[]{DurationFieldType.years()}; [EOL] PeriodType result = PeriodType.forFields(types); [EOL] assertNotNull(result); [EOL] }
public void testForFields_ValidArrayWithUnsupportedFields_ThrowsIllegalArgumentException() { [EOL] DurationFieldType[] types = new DurationFieldType[]{DurationFieldType.years(), new MockDurationFieldType("unsupported")}; [EOL] try { [EOL] PeriodType.forFields(types); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("PeriodType does not support fields")); [EOL] } [EOL] }
public void testForFields_ValidArrayWithCachedType_ReturnsCachedPeriodType() { [EOL] DurationFieldType[] types = new DurationFieldType[]{DurationFieldType.years()}; [EOL] PeriodType.forFields(types); // Call once to cache the PeriodType [EOL] PeriodType result = PeriodType.forFields(types); // Call again to retrieve from cache [EOL] assertNotNull(result); [EOL] }
public void testPeriodTypeConstructorWithValidArguments() { [EOL] String name = "testPeriodType"; [EOL] DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months() }; [EOL] int[] indices = new int[] { 0, 1 }; [EOL] PeriodType periodType = new PeriodType(name, types, indices); [EOL] assertNotNull(periodType); [EOL] assertEquals(name, periodType.getName()); [EOL] assertArrayEquals(types, periodType.getFieldTypes()); [EOL] assertArrayEquals(indices, periodType.getIndices()); [EOL] }
public String getName() { [EOL] return iName; [EOL] }
public void testGetFieldType_ValidIndex() { [EOL] DurationFieldType[] types = new DurationFieldType[] {DurationFieldType.seconds(), DurationFieldType.minutes()}; [EOL] PeriodType periodType = new PeriodType(types); [EOL] assertEquals(DurationFieldType.seconds(), periodType.getFieldType(0)); [EOL] assertEquals(DurationFieldType.minutes(), periodType.getFieldType(1)); [EOL] }
public void testGetFieldType_InvalidIndex() { [EOL] DurationFieldType[] types = new DurationFieldType[] {DurationFieldType.seconds(), DurationFieldType.minutes()}; [EOL] PeriodType periodType = new PeriodType(types); [EOL] try { [EOL] periodType.getFieldType(-1); [EOL] fail("Should have thrown IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] periodType.getFieldType(2); [EOL] fail("Should have thrown IndexOutOfBoundsException for index greater than types length"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testToString() { [EOL] PeriodType periodType = new PeriodType("TestPeriodType"); [EOL] String result = periodType.toString(); [EOL] assertEquals("PeriodType[TestPeriodType]", result); [EOL] }
public void testGetIndexedField_ValidIndex() { [EOL] ReadablePeriod mockPeriod = Mockito.mock(ReadablePeriod.class); [EOL] int[] indices = {1, 2, 3}; [EOL] int index = 1; [EOL] int expectedValue = 5; [EOL] Mockito.when(mockPeriod.getValue(indices[index])).thenReturn(expectedValue); [EOL] int result = getIndexedField(mockPeriod, index); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetIndexedField_IndexOutOfBounds() { [EOL] ReadablePeriod mockPeriod = Mockito.mock(ReadablePeriod.class); [EOL] int[] indices = {1, 2, 3}; [EOL] int index = 3; // Assuming the length of iIndices is 3 [EOL] try { [EOL] getIndexedField(mockPeriod, index); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetIndexedField_NegativeRealIndex() { [EOL] ReadablePeriod mockPeriod = Mockito.mock(ReadablePeriod.class); [EOL] int[] indices = {-1, 2, 3}; [EOL] int index = 0; [EOL] int result = getIndexedField(mockPeriod, index); [EOL] assertEquals(0, result); [EOL] }
public void testSetIndexedField_SupportedIndex() { [EOL] ReadablePeriod period = null; // Assuming period is not used in the method [EOL] int index = 0; // Assuming this is a valid index for the test [EOL] int[] values = new int[1]; // Assuming array size of 1 for simplicity [EOL] int newValue = 10; // Arbitrary new value [EOL] boolean result = setIndexedField(period, index, values, newValue); [EOL] assert result : "The method should return true"; [EOL] assert values[0] == newValue : "The value at index 0 should be updated to the new value"; [EOL] } [EOL] public void testSetIndexedField_UnsupportedIndex() { [EOL] ReadablePeriod period = null; // Assuming period is not used in the method [EOL] int index = 0; // Assuming this is the index that corresponds to -1 in iIndices [EOL] int[] values = new int[1]; // Assuming array size of 1 for simplicity [EOL] int newValue = 10; // Arbitrary new value [EOL] try { [EOL] setIndexedField(period, index, values, newValue); [EOL] assert false : "An UnsupportedOperationException should have been thrown"; [EOL] } catch (UnsupportedOperationException e) { [EOL] assert e.getMessage().equals("Field is not supported") : "Exception message should indicate the field is not supported"; [EOL] } [EOL] }
public void testWithMonthsRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType result = type.withMonthsRemoved(); [EOL] assertNotNull(result); [EOL] assertEquals("NoMonths", result.getName()); [EOL] assertFalse(result.hasField(DurationFieldType.months())); [EOL] }
public void testWithWeeksRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType result = type.withWeeksRemoved(); [EOL] assertFalse(result.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertTrue(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testWithDaysRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType noDays = type.withDaysRemoved(); [EOL] assertFalse(noDays.isSupported(DurationFieldType.days())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.years())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.months())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.hours())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(noDays.isSupported(DurationFieldType.millis())); [EOL] }
public void testWithHoursRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType noHours = type.withHoursRemoved(); [EOL] assertFalse(noHours.isSupported(DurationFieldType.hours())); [EOL] assertTrue(noHours.isSupported(DurationFieldType.minutes())); [EOL] }

public void testWithSecondsRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType result = type.withSecondsRemoved(); [EOL] assertFalse(result.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(result.isSupported(DurationFieldType.minutes())); [EOL] }
public void testWithFieldRemoved_FieldIndexNotPresent() { [EOL] PeriodType pt = new PeriodType("testType", new DurationFieldType[]{}, new int[]{-1, -1, -1, -1, -1, -1, -1, -1}); [EOL] PeriodType result = pt.withFieldRemoved(0, "Removed"); [EOL] assertSame("Should be the same object as field index is not present", pt, result); [EOL] }
public void testWithFieldRemoved_FieldIndexPresent() { [EOL] PeriodType pt = new PeriodType("testType", new DurationFieldType[]{DurationFieldType.years(), DurationFieldType.months()}, new int[]{0, 1, -1, -1, -1, -1, -1, -1}); [EOL] PeriodType result = pt.withFieldRemoved(0, "Removed"); [EOL] assertNotNull("Should not be the same object as field index is present", result); [EOL] assertEquals("New type name should append 'Removed'", "testTypeRemoved", result.getName()); [EOL] assertEquals("Size should be reduced by 1", 1, result.size()); [EOL] assertEquals("Remaining field should be months", DurationFieldType.months(), result.getFieldType(0)); [EOL] }
public void testWithFieldRemoved_RemoveMiddleField() { [EOL] PeriodType pt = new PeriodType("testType", new DurationFieldType[]{DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days()}, new int[]{0, 1, 2, -1, -1, -1, -1, -1}); [EOL] PeriodType result = pt.withFieldRemoved(1, "Removed"); [EOL] assertNotNull("Should not be the same object as field index is present", result); [EOL] assertEquals("New type name should append 'Removed'", "testTypeRemoved", result.getName()); [EOL] assertEquals("Size should be reduced by 1", 2, result.size()); [EOL] assertEquals("First field should be years", DurationFieldType.years(), result.getFieldType(0)); [EOL] assertEquals("Second field should be days", DurationFieldType.days(), result.getFieldType(1)); [EOL] }
public void testEquals_SameObject() { [EOL] PeriodType periodType = new PeriodType(); [EOL] assertTrue(periodType.equals(periodType)); [EOL] }
public void testEquals_DifferentClass() { [EOL] PeriodType periodType = new PeriodType(); [EOL] Object obj = new Object(); [EOL] assertFalse(periodType.equals(obj)); [EOL] }
public void testEquals_Null() { [EOL] PeriodType periodType = new PeriodType(); [EOL] Object obj = null; [EOL] assertFalse(periodType.equals(obj)); [EOL] }
public void testEquals_DifferentPeriodType() { [EOL] PeriodType periodType1 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] PeriodType periodType2 = new PeriodType(new String[]{"seconds", "minutes"}); [EOL] assertFalse(periodType1.equals(periodType2)); [EOL] }
public void testEquals_SamePeriodType() { [EOL] PeriodType periodType1 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] PeriodType periodType2 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] assertTrue(periodType1.equals(periodType2)); [EOL] }
public void testHashCode_emptyTypesArray() { [EOL] TimeType[] types = new TimeType[0]; [EOL] Time time = new Time(types); [EOL] int expectedHash = 0; [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashCode_singleElementTypesArray() { [EOL] TimeType[] types = new TimeType[]{new TimeType(1)}; [EOL] Time time = new Time(types); [EOL] int expectedHash = new TimeType(1).hashCode(); [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashCode_multipleElementsTypesArray() { [EOL] TimeType[] types = new TimeType[]{new TimeType(1), new TimeType(2), new TimeType(3)}; [EOL] Time time = new Time(types); [EOL] int expectedHash = new TimeType(1).hashCode() + new TimeType(2).hashCode() + new TimeType(3).hashCode(); [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testGetInstantChronologyWithNullInstant() { [EOL] Chronology result = Time.getInstantChronology(null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetInstantChronologyWithNonNullInstantAndNullChronology() { [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] when(mockInstant.getChronology()).thenReturn(null); [EOL] Chronology result = Time.getInstantChronology(mockInstant); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetInstantChronologyWithNonNullInstantAndNonNullChronology() { [EOL] Chronology expectedChronology = mock(Chronology.class); [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] when(mockInstant.getChronology()).thenReturn(expectedChronology); [EOL] Chronology result = Time.getInstantChronology(mockInstant); [EOL] assertSame(expectedChronology, result); [EOL] }
public void testGetChronology_NullChronology() { [EOL] Chronology result = Time.getChronology(null); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetChronology_NonNullChronology() { [EOL] Chronology inputChronology = BuddhistChronology.getInstance(); [EOL] Chronology result = Time.getChronology(inputChronology); [EOL] assertSame(inputChronology, result); [EOL] }
public void testGetPeriodTypeWithNull() { [EOL] PeriodType result = ClassName.getPeriodType(null); [EOL] assertNotNull(result); [EOL] assertEquals(PeriodType.standard(), result); [EOL] } [EOL] public void testGetPeriodTypeWithNonNull() { [EOL] PeriodType inputType = PeriodType.years(); [EOL] PeriodType result = ClassName.getPeriodType(inputType); [EOL] assertNotNull(result); [EOL] assertSame(inputType, result); [EOL] }
public void testGetDurationMillisWithNullDuration() { [EOL] long result = Time.getDurationMillis(null); [EOL] assertEquals(0L, result); [EOL] }
public void testGetDurationMillisWithNonNullDuration() { [EOL] ReadableDuration duration = new StubDuration(1234L); [EOL] long result = Time.getDurationMillis(duration); [EOL] assertEquals(1234L, result); [EOL] }
public void testIsContiguous_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] Time.isContiguous(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsContiguous_EmptyPartial_ReturnsTrue() { [EOL] ReadablePartial emptyPartial = new Partial(); [EOL] assertTrue(Time.isContiguous(emptyPartial)); [EOL] }
public void testIsContiguous_NonContiguousPartial_ReturnsFalse() { [EOL] ReadablePartial nonContiguousPartial = new Partial( [EOL] new DateTimeFieldType[] { [EOL] DateTimeFieldType.dayOfMonth(), [EOL] DateTimeFieldType.hourOfDay() [EOL] }, [EOL] new int[] {1, 12} [EOL] ); [EOL] assertFalse(Time.isContiguous(nonContiguousPartial)); [EOL] }
public void testIsContiguous_ContiguousPartial_ReturnsTrue() { [EOL] ReadablePartial contiguousPartial = new Partial( [EOL] new DateTimeFieldType[] { [EOL] DateTimeFieldType.year(), [EOL] DateTimeFieldType.monthOfYear(), [EOL] DateTimeFieldType.dayOfMonth() [EOL] }, [EOL] new int[] {2023, 4, 15} [EOL] ); [EOL] assertTrue(Time.isContiguous(contiguousPartial)); [EOL] }
public void testGetDateFormatSymbolsWithExistingLocale() { [EOL] Locale locale = Locale.US; [EOL] DateFormatSymbols symbols = time.getDateFormatSymbols(locale); [EOL] assertNotNull(symbols); [EOL] assertEquals(symbols, DateFormatSymbols.getInstance(locale)); [EOL] }
public void testGetDateFormatSymbolsWithNonExistingLocale() { [EOL] Locale locale = new Locale("xx", "XX"); [EOL] DateFormatSymbols symbols = time.getDateFormatSymbols(locale); [EOL] assertNotNull(symbols); [EOL] assertEquals(symbols.getLocale(), locale); [EOL] }
public void testBaseIntervalWithNullPeriod() { [EOL] ReadableInstant end = new Instant(); [EOL] BaseInterval interval = new BaseInterval(null, end); [EOL] assertEquals(end.getMillis(), interval.getEndMillis()); [EOL] assertEquals(end.getMillis(), interval.getStartMillis()); [EOL] }
public void testBaseIntervalWithNonNullPeriod() { [EOL] ReadableInstant end = new Instant(); [EOL] ReadablePeriod period = new Period(1, 1, 1, 1); [EOL] BaseInterval interval = new BaseInterval(period, end); [EOL] Chronology chrono = DateTimeUtils.getInstantChronology(end); [EOL] long expectedStartMillis = chrono.add(period, end.getMillis(), -1); [EOL] assertEquals(end.getMillis(), interval.getEndMillis()); [EOL] assertEquals(expectedStartMillis, interval.getStartMillis()); [EOL] }
public long getStartMillis() { [EOL] return iStartMillis; [EOL] }
public void testGetEndMillis() { [EOL] Time time = new Time(); [EOL] long expected = 123456789L; // Set this to the expected value of iEndMillis [EOL] time.iEndMillis = expected; // Assuming there's a way to set iEndMillis, otherwise, this needs to be set through the constructor or another method [EOL] long actual = time.getEndMillis(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetDefaultWithNonNullZone() { [EOL] DateTimeZone testZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone.setDefault(testZone); [EOL] assertEquals(DateTimeZone.getDefault(), testZone); [EOL] }
public void testSetDefaultWithNullZone() { [EOL] try { [EOL] DateTimeZone.setDefault(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetDefaultWithSecurityManager() { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] DateTimeZone testZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone.setDefault(testZone); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException ex) { [EOL] } [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); [EOL] } [EOL] }
public void testForID_NullId() { [EOL] DateTimeZone result = DateTimeZone.forID(null); [EOL] DateTimeZone expected = DateTimeZone.getDefault(); [EOL] assertEquals(expected, result); [EOL] }
public void testForID_UTCId() { [EOL] DateTimeZone result = DateTimeZone.forID("UTC"); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForID_ValidId() { [EOL] String validId = "Europe/London"; // Assuming this is a valid ID for the test [EOL] DateTimeZone result = DateTimeZone.forID(validId); [EOL] assertNotNull(result); [EOL] }
public void testForID_InvalidId() { [EOL] String invalidId = "Invalid/Zone"; [EOL] try { [EOL] DateTimeZone.forID(invalidId); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForID_ValidOffsetId_ZeroOffset() { [EOL] String zeroOffsetId = "+00:00"; [EOL] DateTimeZone result = DateTimeZone.forID(zeroOffsetId); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForID_ValidOffsetId_NonZeroOffset() { [EOL] String nonZeroOffsetId = "+01:00"; // Assuming this is a valid offset [EOL] DateTimeZone result = DateTimeZone.forID(nonZeroOffsetId); [EOL] assertNotNull(result); [EOL] assertNotEquals(DateTimeZone.UTC, result); [EOL] }
public void testForOffsetHours_ValidHour() { [EOL] int hoursOffset = 5; [EOL] DateTimeZone result = DateTimeZone.forOffsetHours(hoursOffset); [EOL] assertEquals("UTC+05:00", result.getID()); [EOL] }
public void testForOffsetHours_NegativeHour() { [EOL] int hoursOffset = -5; [EOL] DateTimeZone result = DateTimeZone.forOffsetHours(hoursOffset); [EOL] assertEquals("UTC-05:00", result.getID()); [EOL] }
public void testForOffsetHours_ZeroHour() { [EOL] int hoursOffset = 0; [EOL] DateTimeZone result = DateTimeZone.forOffsetHours(hoursOffset); [EOL] assertEquals("UTC", result.getID()); [EOL] }
public void testForOffsetHoursMinutes_UTC() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(0, 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForOffsetHoursMinutes_HoursOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(-24, 0); [EOL] fail("Should have thrown IllegalArgumentException for hours out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] Time.forOffsetHoursMinutes(24, 0); [EOL] fail("Should have thrown IllegalArgumentException for hours out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForOffsetHoursMinutes_MinutesOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, -60); [EOL] fail("Should have thrown IllegalArgumentException for minutes out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, 60); [EOL] fail("Should have thrown IllegalArgumentException for minutes out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForOffsetHoursMinutes_PositiveHoursNegativeMinutes() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, -1); [EOL] fail("Should have thrown IllegalArgumentException for positive hours with negative minutes"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForOffsetHoursMinutes_ValidOffset() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(1, 30); [EOL] assertNotNull(result); [EOL] }
public void testForOffsetHoursMinutes_OffsetTooLarge() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(Integer.MAX_VALUE / 60, 59); [EOL] fail("Should have thrown IllegalArgumentException for offset too large"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForTimeZoneWithNullZone() { [EOL] DateTimeZone result = DateTimeZone.forTimeZone(null); [EOL] assertNotNull(result); [EOL] }
public void testForTimeZoneWithUTC() { [EOL] TimeZone zone = TimeZone.getTimeZone("UTC"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertSame(DateTimeZone.UTC, result); [EOL] }
public void testForTimeZoneWithKnownID() { [EOL] TimeZone zone = TimeZone.getTimeZone("Europe/London"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] }
public void testForTimeZoneWithUnknownID() { [EOL] TimeZone zone = TimeZone.getTimeZone("Unknown/Zone"); [EOL] try { [EOL] DateTimeZone.forTimeZone(zone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForTimeZoneWithGMTPlusOffset() { [EOL] TimeZone zone = TimeZone.getTimeZone("GMT+0100"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] }
public void testForTimeZoneWithGMTMinusOffset() { [EOL] TimeZone zone = TimeZone.getTimeZone("GMT-0100"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] }
public void testFixedOffsetZoneWithZeroOffset() { [EOL] DateTimeZone result = ClassName.fixedOffsetZone("UTC", 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheMiss() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; // 1 hour in milliseconds [EOL] DateTimeZone result = ClassName.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals(offset, result.getOffset(null)); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheHit() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; // 1 hour in milliseconds [EOL] DateTimeZone cachedZone = new FixedDateTimeZone(id, null, offset, offset); [EOL] ClassName.iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(cachedZone)); [EOL] DateTimeZone result = ClassName.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertSame(cachedZone, result); [EOL] }
public void testGetConvertedIdWithNullMapAndKnownId() { [EOL] String result = Time.getConvertedId("GMT"); [EOL] assertEquals("UTC", result); [EOL] }
public void testGetConvertedIdWithNullMapAndUnknownId() { [EOL] String result = Time.getConvertedId("UNKNOWN"); [EOL] assertNull(result); [EOL] }
public void testGetConvertedIdWithInitializedMapAndKnownId() { [EOL] Time.getConvertedId("GMT"); [EOL] String result = Time.getConvertedId("CET"); [EOL] assertEquals("CET", result); [EOL] }
public void testGetConvertedIdWithInitializedMapAndUnknownId() { [EOL] Time.getConvertedId("GMT"); [EOL] String result = Time.getConvertedId("UNKNOWN"); [EOL] assertNull(result); [EOL] }
private static int parseOffset(String str) { [EOL] Chronology chrono = new BaseChronology() { [EOL] private static final long serialVersionUID = -3128740902654445468L; [EOL] public DateTimeZone getZone() { [EOL] return null; [EOL] } [EOL] public Chronology withUTC() { [EOL] return this; [EOL] } [EOL] public Chronology withZone(DateTimeZone zone) { [EOL] return this; [EOL] } [EOL] public String toString() { [EOL] return getClass().getName(); [EOL] } [EOL] }; [EOL] return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); [EOL] }
public void testPrintOffsetPositive() { [EOL] int offset = 3600000; // 1 hour in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:00", result); [EOL] }
public void testPrintOffsetNegative() { [EOL] int offset = -3600000; // -1 hour in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:00", result); [EOL] }
public void testPrintOffsetPositiveWithMinutes() { [EOL] int offset = 3660000; // 1 hour and 1 minute in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01", result); [EOL] }
public void testPrintOffsetNegativeWithMinutes() { [EOL] int offset = -3660000; // -1 hour and 1 minute in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01", result); [EOL] }
public void testPrintOffsetPositiveWithSeconds() { [EOL] int offset = 3661000; // 1 hour, 1 minute, and 1 second in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01:01", result); [EOL] }
public void testPrintOffsetNegativeWithSeconds() { [EOL] int offset = -3661000; // -1 hour, 1 minute, and 1 second in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01:01", result); [EOL] }
public void testPrintOffsetPositiveWithMillis() { [EOL] int offset = 3661001; // 1 hour, 1 minute, 1 second, and 1 millisecond [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01:01.001", result); [EOL] }
public void testPrintOffsetNegativeWithMillis() { [EOL] int offset = -3661001; // -1 hour, 1 minute, 1 second, and 1 millisecond [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01:01.001", result); [EOL] }
public void testOffsetFormatter_WhenCalledMultipleTimes_ShouldReturnSameInstance() { [EOL] DateTimeFormatter firstCallFormatter = offsetFormatter(); [EOL] DateTimeFormatter secondCallFormatter = offsetFormatter(); [EOL] assertSame(firstCallFormatter, secondCallFormatter); [EOL] }
public void testIsLocalDateTimeGap_WithFixedTimeZone_ShouldReturnFalse() { [EOL] DateTimeZone fixedTimeZone = DateTimeZone.forOffsetHours(1); // Assuming isFixed() returns true for fixed time zones [EOL] LocalDateTime localDateTime = new LocalDateTime(); [EOL] boolean result = fixedTimeZone.isLocalDateTimeGap(localDateTime); [EOL] assertFalse(result); [EOL] }
public void testIsLocalDateTimeGap_WithNonFixedTimeZoneAndNoGap_ShouldReturnFalse() { [EOL] DateTimeZone nonFixedTimeZone = DateTimeZone.forID("Europe/London"); // Assuming isFixed() returns false for non-fixed time zones [EOL] LocalDateTime localDateTime = new LocalDateTime(2023, 3, 25, 1, 0); // Before the gap [EOL] boolean result = nonFixedTimeZone.isLocalDateTimeGap(localDateTime); [EOL] assertFalse(result); [EOL] }
public void testIsLocalDateTimeGap_WithNonFixedTimeZoneAndGap_ShouldReturnTrue() { [EOL] DateTimeZone nonFixedTimeZone = DateTimeZone.forID("Europe/London"); // Assuming isFixed() returns false for non-fixed time zones [EOL] LocalDateTime localDateTime = new LocalDateTime(2023, 3, 26, 1, 0); // During the gap [EOL] boolean result = nonFixedTimeZone.isLocalDateTimeGap(localDateTime); [EOL] assertTrue(result); [EOL] }
public void testAdjustOffsetWithOffsetBeforeLessThanOrEqualToOffsetAfter() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 2 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long result = time.adjustOffset(instant, true); [EOL] assertEquals(instant, result); [EOL] }
public void testAdjustOffsetWithInstantBeforeOverlapStart() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long result = time.adjustOffset(instant, true); [EOL] assertEquals(instant, result); [EOL] }
public void testAdjustOffsetWithInstantAtOrAfterOverlapEnd() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant - 10; [EOL] } [EOL] }; [EOL] long result = time.adjustOffset(instant, true); [EOL] assertEquals(instant, result); [EOL] }
public void testAdjustOffsetWithInstantAfterOverlapStartAndEarlier() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant; [EOL] } [EOL] }; [EOL] long result = time.adjustOffset(instant, false); [EOL] assertEquals(instant - 3, result); [EOL] }
public void testAdjustOffsetWithInstantAfterOverlapStartAndLater() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant; [EOL] } [EOL] }; [EOL] long result = time.adjustOffset(instant, true); [EOL] assertEquals(instant + 3, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Time time = new Time(mockChronology); [EOL] long result = time.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull() { [EOL] Time time = new Time(null); [EOL] long result = time.getDateTimeMillis(2020, 1, 1, 0); [EOL] long expected = time.getDateMidnightMillis(2020, 1, 1) + 0; [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_InvalidMillisOfDay() { [EOL] Time time = new Time(null); [EOL] try { [EOL] time.getDateTimeMillis(2020, 1, 1, DateTimeConstants.MILLIS_PER_DAY); [EOL] fail("IllegalArgumentException expected for millisOfDay out of bounds"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_BaseChronology() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBase.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] setBase(mockBase); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2020, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_ValidValues() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] long result = getDateTimeMillis(2020, 1, 1, 12, 0, 0, 0); [EOL] long expected = getDateMidnightMillis(2020, 1, 1) + 12 * DateTimeConstants.MILLIS_PER_HOUR; [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_HourOfDayLowerBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, -1, 0, 0, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_HourOfDayUpperBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 24, 0, 0, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MinuteOfHourLowerBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, -1, 0, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MinuteOfHourUpperBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, 60, 0, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_SecondOfMinuteLowerBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, 0, -1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_SecondOfMinuteUpperBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, 0, 60, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MillisOfSecondLowerBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, 0, 0, -1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MillisOfSecondUpperBound() { [EOL] setBase(null); [EOL] try { [EOL] getDateTimeMillis(2020, 1, 1, 0, 0, 0, 1000); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetYearMonthMillis_January() { [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long actualMillis = getYearMonthMillis(2021, 1); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] } [EOL] public void testGetYearMonthMillis_February() { [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long actualMillis = getYearMonthMillis(2021, 2); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] } [EOL] public void testGetYearMonthMillis_December() { [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long actualMillis = getYearMonthMillis(2021, 12); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearWithNegativeInstant() { [EOL] long instant = -1L; // Some negative instant [EOL] int expectedYear = -1970; // Expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAtEpoch() { [EOL] long instant = 0L; // Instant at the epoch [EOL] int expectedYear = 1970; // Expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantJustBeforeLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 1) - 1; // Just before a leap year [EOL] int expectedYear = 1973; // Expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAtLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 1); // Start of a leap year [EOL] int expectedYear = 1974; // Expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAfterLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (366L + 365L * 3 + 1); // After a leap year [EOL] int expectedYear = 1975; // Expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetDayOfYear() { [EOL] long instant = 1234567890L; // Example timestamp [EOL] int expectedYear = 2023; // Expected year for the given timestamp [EOL] int expectedDayOfYear = 100; // Expected day of the year for the given timestamp and year [EOL] Time time = mock(Time.class); // Assuming Time is the class that contains getDayOfYear [EOL] when(time.getYear(instant)).thenReturn(expectedYear); [EOL] when(time.getDayOfYear(instant, expectedYear)).thenReturn(expectedDayOfYear); [EOL] int actualDayOfYear = time.getDayOfYear(instant); [EOL] assertEquals(expectedDayOfYear, actualDayOfYear); [EOL] }
public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL] super(); [EOL] if (start == null || end == null) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL] } [EOL] if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL] type = checkPeriodType(type); [EOL] long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL] long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL] Chronology chrono = start.getChronology(); [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] iType = type; [EOL] iValues = chrono.get(this, startMillis, endMillis); [EOL] } else { [EOL] if (start.size() != end.size()) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] for (int i = 0, isize = start.size(); i < isize; i++) { [EOL] if (start.getFieldType(i) != end.getFieldType(i)) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] } [EOL] if (DateTimeUtils.isContiguous(start) == false) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL] } [EOL] iType = checkPeriodType(type); [EOL] Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL] iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) { [EOL] super(); [EOL] type = checkPeriodType(type); [EOL] long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL] long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL] long endMillis = FieldUtils.safeAdd(startMillis, durationMillis); [EOL] Chronology chrono = DateTimeUtils.getInstantChronology(startInstant); [EOL] iType = type; [EOL] iValues = chrono.get(this, startMillis, endMillis); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected void addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }];
protected void testBasePeriodWithLongDuration() { [EOL] long duration = 123456L; [EOL] BasePeriod period = new BasePeriod(duration); [EOL] assertNotNull(period.getPeriodType()); [EOL] assertEquals(PeriodType.standard(), period.getPeriodType()); [EOL] int[] values = period.getValues(); [EOL] assertNotNull(values); [EOL] assertEquals(8, values.length); [EOL] for (int i = 0; i < 4; i++) { [EOL] assertEquals(0, values[i]); [EOL] } [EOL] assertEquals(0, values[4]); // hours [EOL] assertEquals(0, values[5]); // minutes [EOL] assertEquals(0, values[6]); // seconds [EOL] assertEquals(0, values[7]); // millis [EOL] }

protected BasePeriod(long duration, PeriodType type, Chronology chrono) { [EOL] super(); [EOL] type = checkPeriodType(type); [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] iType = type; [EOL] iValues = chrono.get(this, duration); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }];
protected BasePeriod(int[] values, PeriodType type) { [EOL] super(); [EOL] iType = type; [EOL] iValues = values; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
protected PeriodType checkPeriodType(PeriodType type) { [EOL] return DateTimeUtils.getPeriodType(type); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] } [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] } [EOL] }];
public PeriodType getPeriodType() { [EOL] return iType; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public int getValueTestWithValidIndex() { [EOL] int[] values = new int[] {1, 2, 3, 4, 5, 6, 7, 8}; [EOL] BasePeriod period = new BasePeriod(values, null); [EOL] int index = 3; // Assuming index is within bounds [EOL] int expectedValue = 4; [EOL] int actualValue = period.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public int getValueTestWithInvalidIndex() { [EOL] int[] values = new int[] {1, 2, 3, 4, 5, 6, 7, 8}; [EOL] BasePeriod period = new BasePeriod(values, null); [EOL] int index = 10; // Assuming index is out of bounds [EOL] try { [EOL] period.getValue(index); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
protected void setPeriod(ReadablePeriod period) { [EOL] if (period == null) { [EOL] setValues(new int[size()]); [EOL] } else { [EOL] setPeriodInternal(period); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void addField(DurationFieldType field, int value) { [EOL] addFieldInto(iValues, field, value); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void addFieldInto(int[] values, DurationFieldType field, int value) { [EOL] int index = indexOf(field); [EOL] if (index == -1) { [EOL] if (value != 0 || field == null) { [EOL] throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL] } [EOL] } else { [EOL] values[index] = FieldUtils.safeAdd(values[index], value); [EOL] } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
protected void setValue(int index, int value) { [EOL] iValues[index] = value; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
public void testISODateTimeFormatSubclassCreation() { [EOL] SubclassOfISODateTimeFormat instance = new SubclassOfISODateTimeFormat(); [EOL] assertNotNull(instance); [EOL] }
public void testForFieldsWithNullFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(null, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithEmptyFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(Collections.emptyList(), true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithMonthOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekOfWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfMonth() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfWeek() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithUnsupportedOperationException() { [EOL] Set<DateTimeFieldType> fields = new HashSet<DateTimeFieldType>() { [EOL] @Override [EOL] public boolean retainAll(Collection<?> c) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithNoValidFormat() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.era()); [EOL] try { [EOL] DateTimeFormatter.forFields(fields, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("No valid format for fields")); [EOL] } [EOL] }
public void testDateByMonthWithYearMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearMonth() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithYearDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithMonthOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithDayOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByOrdinalWithYearAndDayOfYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByOrdinalWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByOrdinalWithDayOfYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByOrdinalWithNeitherYearNorDayOfYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearAndWeekOfWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearWeekOfWeekYearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = true; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekOfWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekOfWeekYearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testTimeWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("HH", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourAndMinute() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("HH:mm", bld.toFormatter().toString()); [EOL] }
public void testTimeWithAllFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] fields.add(DateTimeFieldType.millisOfSecond()); [EOL] time(bld, fields, true, false, false, true); [EOL] assertEquals("THH:mm:ss.SSS", bld.toFormatter().toString()); [EOL] }
public void testTimeWithStrictISOAndReducedPrecision() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] time(bld, fields, false, true, true, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOAndDatePresent() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] try { [EOL] time(bld, fields, false, true, false, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOWithoutHour() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] try { [EOL] time(bld, fields, false, true, false, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public static DateTimeFormatter timeParser() { [EOL] return Constants.tp; [EOL] }
public void testLocalDateOptionalTimeParser() { [EOL] DateTimeFormatter result = ClassName.localDateOptionalTimeParser(); [EOL] assertNotNull(result); [EOL] }
public void testBasicTTime() { [EOL] DateTimeFormatter result = ClassName.basicTTime(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.btt, result); [EOL] }
public void testBasicWeekDateTime() { [EOL] DateTimeFormatter result = Time.basicWeekDateTime(); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthDay() { [EOL] DateTimeFormatter formatter = ClassName.yearMonthDay(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", "yyyy-MM-dd", formatter.toString()); [EOL] }
public void testWeekyear() { [EOL] DateTimeFormatter formatter = Time.weekyear(); [EOL] assertNotNull(formatter); [EOL] }
public void testWeekyearWeekDay() { [EOL] DateTimeFormatter formatter = Time.weekyearWeekDay(); [EOL] assertNotNull(formatter); [EOL] assertEquals("wwd", formatter.toString()); [EOL] }
public void testDateHourMinuteSecondMillis() { [EOL] DateTimeFormatter formatter = ClassName.dateHourMinuteSecondMillis(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", Constants.dhmsl.toPattern(), formatter.toPattern()); [EOL] }
public void testDateHourMinuteSecondFraction() { [EOL] DateTimeFormatter formatter = ClassName.dateHourMinuteSecondFraction(); [EOL] assertNotNull(formatter); [EOL] }
public void testMinutesZero() { [EOL] Minutes result = Time.minutes(0); [EOL] assertSame(Minutes.ZERO, result); [EOL] }
public void testMinutesOne() { [EOL] Minutes result = Time.minutes(1); [EOL] assertSame(Minutes.ONE, result); [EOL] }
public void testMinutesTwo() { [EOL] Minutes result = Time.minutes(2); [EOL] assertSame(Minutes.TWO, result); [EOL] }
public void testMinutesThree() { [EOL] Minutes result = Time.minutes(3); [EOL] assertSame(Minutes.THREE, result); [EOL] }
public void testMinutesMaxValue() { [EOL] Minutes result = Time.minutes(Integer.MAX_VALUE); [EOL] assertSame(Minutes.MAX_VALUE, result); [EOL] }
public void testMinutesMinValue() { [EOL] Minutes result = Time.minutes(Integer.MIN_VALUE); [EOL] assertSame(Minutes.MIN_VALUE, result); [EOL] }
public void testMinutesOther() { [EOL] int anyOtherValue = 4; // This can be any value not covered by the switch cases [EOL] Minutes result = Time.minutes(anyOtherValue); [EOL] assertNotNull(result); [EOL] assertEquals(anyOtherValue, result.getMinutes()); [EOL] }
public void testMinutesBetween_SameChronologyLocalTimes() { [EOL] LocalTime start = new LocalTime(10, 0); [EOL] LocalTime end = new LocalTime(10, 30); [EOL] Minutes result = Time.minutesBetween(start, end); [EOL] assertEquals(30, result.getMinutes()); [EOL] }
public void testMinutesBetween_DifferentChronologyLocalTimes() { [EOL] LocalTime start = new LocalTime(10, 0, DateTimeZone.forID("Europe/London")); [EOL] LocalTime end = new LocalTime(11, 0, DateTimeZone.forID("Asia/Kolkata")); [EOL] Minutes result = Time.minutesBetween(start, end); [EOL] assertEquals(330, result.getMinutes()); [EOL] }
public void testMinutesBetween_NonLocalTime() { [EOL] LocalDate start = new LocalDate(2023, 1, 1); [EOL] LocalDate end = new LocalDate(2023, 1, 2); [EOL] Minutes result = Time.minutesBetween(start, end); [EOL] assertEquals(24 * 60, result.getMinutes()); [EOL] }
public void testParseMinutes_NullInput() { [EOL] Minutes result = Time.parseMinutes(null); [EOL] assertEquals(Minutes.ZERO, result); [EOL] }
public void testParseMinutes_ValidInput() { [EOL] Minutes result = Time.parseMinutes("PT10M"); [EOL] assertEquals(Minutes.minutes(10), result); [EOL] }
public void testParseMinutes_InvalidInput() { [EOL] try { [EOL] Time.parseMinutes("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldType_ReturnsMinutes() { [EOL] DurationFieldType fieldType = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.minutes(), fieldType); [EOL] }
public void testToStandardWeeks_exactWeeks() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_WEEK * 2); [EOL] Weeks weeks = minutes.toStandardWeeks(); [EOL] assertEquals(2, weeks.getWeeks()); [EOL] } [EOL] public void testToStandardWeeks_lessThanAWeek() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_WEEK - 1); [EOL] Weeks weeks = minutes.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] } [EOL] public void testToStandardWeeks_moreThanAWeek() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_WEEK + 1); [EOL] Weeks weeks = minutes.toStandardWeeks(); [EOL] assertEquals(1, weeks.getWeeks()); [EOL] } [EOL] public void testToStandardWeeks_negativeMinutes() { [EOL] Minutes minutes = Minutes.minutes(-1); [EOL] Weeks weeks = minutes.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] } [EOL] public void testToStandardWeeks_zeroMinutes() { [EOL] Minutes minutes = Minutes.minutes(0); [EOL] Weeks weeks = minutes.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] }
public void testMinusWithNull() { [EOL] Minutes originalMinutes = new Minutes(5); [EOL] Minutes result = originalMinutes.minus(null); [EOL] assertEquals(5, result.getValue()); [EOL] }
public void testMinusWithNonNull() { [EOL] Minutes originalMinutes = new Minutes(5); [EOL] Minutes toSubtract = new Minutes(3); [EOL] Minutes result = originalMinutes.minus(toSubtract); [EOL] assertEquals(2, result.getValue()); [EOL] }
protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; [EOL] ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; [EOL] }]
public static boolean verbose() { [EOL] return cVerbose.get(); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] } [EOL] };
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = null; [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] int minDaysInFirstWeek = 0; [EOL] try { [EOL] GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBaseDateTimeWithInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] BaseDateTime dateTime = new BaseDateTime(instant, zone); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testBaseDateTimeWithInstantAndNullZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] BaseDateTime dateTime = new BaseDateTime(instant, null); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(DateTimeZone.getDefault(), dateTime.getZone()); [EOL] }
public int getStandardOffsetTest() { [EOL] DateTimeZone zone = DateTimeZone.forOffsetHours(3); [EOL] long instant = System.currentTimeMillis(); [EOL] int expected = zone.getStandardOffset(instant); [EOL] int actual = zone.getStandardOffset(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long nextTransition(long instant) { [EOL] return instant; [EOL] }
public long previousTransitionTest() { [EOL] long instant = 1000L; [EOL] long result = previousTransition(instant); [EOL] assert result == instant; [EOL] }
public void testGetMinimumValueOverall() { [EOL] Time time = new Time(); [EOL] int minValue = time.getMinimumValueOverall(); [EOL] assertEquals("Minimum value should match expected", expectedMinimumValue, minValue); [EOL] }
public int testGetMinimumValue() { [EOL] YourConcreteClass instance = new YourConcreteClass(); [EOL] int expected = /* some expected minimum value based on the field */; [EOL] int actual = instance.getMinimumValue(); [EOL] assert(expected == actual); [EOL] }
public void testGetMaximumValueOverall() { [EOL] Time time = new Time(); [EOL] int expected = Integer.MAX_VALUE; // Assuming getField().getMaximumValue() returns Integer.MAX_VALUE [EOL] int actual = time.getMaximumValueOverall(); [EOL] assertEquals(expected, actual); [EOL] }
public int getMaximumValueTest() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int expectedValue = testDateTime.getChronology().dayOfMonth().getMaximumValue(testDateTime.getMillis()); [EOL] int actualValue = testDateTime.getMaximumValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public int hashCode() { [EOL] return get() * 17 + getFieldType().hashCode() + getChronology().hashCode(); [EOL] }
public void testGetName() { [EOL] TimeType mockType = mock(TimeType.class); [EOL] when(mockType.getName()).thenReturn("MockedName"); [EOL] Time time = new Time(mockType); [EOL] String result = time.getName(); [EOL] assertEquals("MockedName", result); [EOL] }
public void testGetRangeDurationField_ReturnsCorrectField() { [EOL] MyClass myClassInstance = new MyClass(expectedRangeField); [EOL] DurationField result = myClassInstance.getRangeDurationField(); [EOL] assertEquals(expectedRangeField, result); [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = SOME_EXPECTED_VALUE; // Replace with the expected value [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_InvalidMonth() { [EOL] int year = 2021; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidDay() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 32; // Invalid day [EOL] int millisOfDay = 12345; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidMillis() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = -1; // Invalid millisOfDay [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_ValidInput() { [EOL] long instant = 0L; // Use a fixed instant for the test [EOL] int hourOfDay = 10; // Use a fixed hour of day [EOL] int minuteOfHour = 30; // Use a fixed minute of hour [EOL] int secondOfMinute = 45; // Use a fixed second of minute [EOL] int millisOfSecond = 123; // Use a fixed millisecond of second [EOL] long expected = SOME_EXPECTED_VALUE; // Replace with the expected value [EOL] long actual = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateTimeMillis_WithOffset() { [EOL] long instant = 0L; // Use a fixed instant for the test [EOL] int hourOfDay = 10; // Use a fixed hour of day [EOL] int minuteOfHour = 30; // Use a fixed minute of hour [EOL] int secondOfMinute = 45; // Use a fixed second of minute [EOL] int millisOfSecond = 123; // Use a fixed millisecond of second [EOL] long offset = SOME_OFFSET_VALUE; // Replace with a non-zero offset value [EOL] long expected = SOME_EXPECTED_VALUE_WITH_OFFSET; // Replace with the expected value with offset [EOL] long actual = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, actual); [EOL] }
public void testLocalToUTC_withNoOffsetChange() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] long localInstant = System.currentTimeMillis(); [EOL] when(mockZone.getOffsetFromLocal(localInstant)).thenReturn(0); [EOL] when(mockZone.getOffset(localInstant)).thenReturn(0); [EOL] long result = localToUTC(localInstant); [EOL] assertEquals(localInstant, result); [EOL] }
public void testLocalToUTC_withOffsetChange() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] long localInstant = System.currentTimeMillis(); [EOL] int offset = 1000; [EOL] when(mockZone.getOffsetFromLocal(localInstant)).thenReturn(offset); [EOL] when(mockZone.getOffset(localInstant - offset)).thenReturn(offset + 1000); // Different offset to trigger exception [EOL] try { [EOL] localToUTC(localInstant); [EOL] fail("Expected IllegalInstantException"); [EOL] } catch (IllegalInstantException e) { [EOL] } [EOL] }
public void testToString_BaseChronologyAndZoneNotNull() { [EOL] ZonedChronology zonedChronology = new ZonedChronology(BaseChronology, DateTimeZone.UTC); [EOL] String result = zonedChronology.toString(); [EOL] assertEquals("ZonedChronology[BaseChronology, UTC]", result); [EOL] }
public void testAdd_WithPositiveValue() { [EOL] long instant = 0L; // Replace with appropriate test value [EOL] int value = 5; // Replace with a positive value to test addition [EOL] long expected = instant + value; // Replace with the expected result after addition [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithNegativeValue() { [EOL] long instant = 0L; // Replace with appropriate test value [EOL] int value = -5; // Replace with a negative value to test addition [EOL] long expected = instant + value; // Replace with the expected result after addition [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithZeroValue() { [EOL] long instant = 0L; // Replace with appropriate test value [EOL] int value = 0; // Replace with zero to test no change [EOL] long expected = instant; // The expected result should be the same as the input instant [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithOffset() { [EOL] long instant = 0L; // Replace with appropriate test value [EOL] int value = 5; // Replace with a positive value to test addition [EOL] int offset = getOffsetToAdd(instant); // Stub or mock this method if necessary [EOL] long expected = instant + offset + value - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant + offset + value)); // Calculate the expected result considering the offset [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithPositiveValue() { [EOL] long instant = 0L; // Assuming 0L is a valid instant [EOL] long value = 5L; // A positive value to add [EOL] long expected = instant + value; // Replace with actual expected value [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithNegativeValue() { [EOL] long instant = 0L; // Assuming 0L is a valid instant [EOL] long value = -5L; // A negative value to subtract [EOL] long expected = instant + value; // Replace with actual expected value [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithZeroValue() { [EOL] long instant = 0L; // Assuming 0L is a valid instant [EOL] long value = 0L; // Adding zero should result in the same instant [EOL] long expected = instant; // The expected value is the same as the instant [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithOffsetChange() { [EOL] long instant = 0L; // Assuming 0L is a valid instant [EOL] long value = 5L; // A positive value to add [EOL] long offsetBefore = getOffsetToAdd(instant); [EOL] long offsetAfter = getOffsetToAdd(instant + offsetBefore + value); [EOL] long expected = instant + value - (iTimeField ? offsetBefore : offsetAfter); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetOffsetFromLocalToSubtract_NoOverflow() { [EOL] long instant = 0L; // Use a value that won't cause overflow when subtracted [EOL] int expectedOffset = 0; // Replace with the expected offset for the given instant [EOL] int actualOffset = getOffsetFromLocalToSubtract(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testGetOffsetFromLocalToSubtract_Overflow() { [EOL] long instant = Long.MAX_VALUE; // Use a value that will cause overflow when subtracted [EOL] try { [EOL] getOffsetFromLocalToSubtract(instant); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public String getAsTextTestValidInput() { [EOL] int fieldValue = 10; // Example value, adjust as needed [EOL] Locale locale = Locale.ENGLISH; // Example locale, adjust as needed [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockFieldType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.getAsText(fieldValue, locale)).thenReturn("ExpectedText"); [EOL] String result = mockFieldType.getAsText(fieldValue, locale); [EOL] assertEquals("ExpectedText", result); [EOL] }
public void testGetAsShortTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] Time time = new Time(field); [EOL] String result = time.getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsShortTextWithInvalidFieldValue() { [EOL] int fieldValue = Integer.MAX_VALUE; [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] Time time = new Time(field); [EOL] try { [EOL] time.getAsShortText(fieldValue, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] int fieldValue = 5; [EOL] Locale locale = null; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] Time time = new Time(field); [EOL] String result = time.getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testAdd_WithTimeField() { [EOL] iTimeField = true; [EOL] long instant = 0L; [EOL] long value = 5L; [EOL] int offset = 10; // Example offset value [EOL] long expected = 15L; // Expected result after adding value and adjusting for offset [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithoutTimeField() { [EOL] iTimeField = false; [EOL] long instant = 0L; [EOL] long value = 5L; [EOL] long localInstant = 100L; // Example local instant value [EOL] long expected = 105L; // Expected result after adding value [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMinimumValue() { [EOL] int minValue = time.getMinimumValue(); [EOL] int expectedMinValue = /* some expected minimum value based on the context */; [EOL] assertEquals(expectedMinValue, minValue); [EOL] }
public void testGetMinimumValue_WithInstant() { [EOL] long instant = SOME_INSTANT_VALUE; // Replace with an actual instant value [EOL] int expectedValue = EXPECTED_MINIMUM_VALUE; // Replace with the expected minimum value for the given instant [EOL] int actualValue = time.getMinimumValue(instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMinimumValue_WithInstantAtZoneBoundary() { [EOL] long instantAtBoundary = SOME_INSTANT_AT_ZONE_BOUNDARY; // Replace with an instant value at a DST boundary or similar [EOL] int expectedValueAtBoundary = EXPECTED_MINIMUM_VALUE_AT_BOUNDARY; // Replace with the expected minimum value at the boundary [EOL] int actualValueAtBoundary = time.getMinimumValue(instantAtBoundary); [EOL] assertEquals(expectedValueAtBoundary, actualValueAtBoundary); [EOL] }
public void testGetRangeDurationField() { [EOL] MyChronology chronology = new MyChronology(); [EOL] DurationField field = chronology.getRangeDurationField(); [EOL] assertNotNull(field); [EOL] assertEquals(chronology.weeks(), field); [EOL] }
public void testGetMinimumValue() { [EOL] Time time = new Time(); [EOL] int minValue = time.getMinimumValue(); [EOL] assertEquals(DateTimeConstants.MONDAY, minValue); [EOL] }
public void testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int maxValue = time.getMaximumValue(); [EOL] assertEquals(DateTimeConstants.SUNDAY, maxValue); [EOL] }
public void testGetMaximumShortTextLengthWithNullLocale() { [EOL] try { [EOL] int result = getMaximumShortTextLength(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetMaximumShortTextLengthWithUSLocale() { [EOL] Locale locale = Locale.US; [EOL] int result = getMaximumShortTextLength(locale); [EOL] assertTrue("The result should be a positive integer", result > 0); [EOL] }
public void testGetMaximumShortTextLengthWithFrenchLocale() { [EOL] Locale locale = Locale.FRENCH; [EOL] int result = getMaximumShortTextLength(locale); [EOL] assertTrue("The result should be a positive integer", result > 0); [EOL] }
public void testCreateMessage_ValueNotSupported() { [EOL] String result = createMessage("field", 10, null, null, null); [EOL] assertEquals("Value 10 for field is not supported", result); [EOL] }
public void testCreateMessage_ValueExceedsUpperBound() { [EOL] String result = createMessage("field", 10, null, 5, null); [EOL] assertEquals("Value 10 for field must not be larger than 5", result); [EOL] }
public void testCreateMessage_ValueBelowLowerBound() { [EOL] String result = createMessage("field", 1, 5, null, null); [EOL] assertEquals("Value 1 for field must not be smaller than 5", result); [EOL] }
public void testCreateMessage_ValueInRange() { [EOL] String result = createMessage("field", 5, 1, 10, null); [EOL] assertEquals("Value 5 for field must be in the range [1,10]", result); [EOL] }
public void testCreateMessage_ValueInRangeWithExplanation() { [EOL] String result = createMessage("field", 5, 1, 10, "Please check the value"); [EOL] assertEquals("Value 5 for field must be in the range [1,10]: Please check the value", result); [EOL] }
public void testIllegalFieldValueExceptionWithFieldTypeAndNumberValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Integer value = 5; [EOL] String explain = "Value must be in the range"; [EOL] IllegalFieldValueException exception = new IllegalFieldValueException(fieldType, value, explain); [EOL] assertEquals(fieldType, exception.getDateTimeFieldType()); [EOL] assertEquals(value, exception.getNumberValue()); [EOL] assertEquals("Value must be in the range", exception.getMessage()); [EOL] assertNull(exception.getDurationFieldType()); [EOL] assertNull(exception.getStringValue()); [EOL] assertNull(exception.getLowerBound()); [EOL] assertNull(exception.getUpperBound()); [EOL] }
public void testIllegalFieldValueExceptionWithNullFieldType() { [EOL] Number value = 5; [EOL] String explain = "Field type is null"; [EOL] try { [EOL] new IllegalFieldValueException(null, value, explain); [EOL] fail("Should have thrown IllegalArgumentException because fieldType is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalTime.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The date must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNonNullDate() { [EOL] Date date = new Date(117, 5, 10, 14, 30, 25); // June 10, 2017, 14:30:25 [EOL] date.setTime(date.getTime() + 50); // Add 50 milliseconds [EOL] LocalTime localTime = LocalTime.fromDateFields(date); [EOL] assertEquals(14, localTime.getHourOfDay()); [EOL] assertEquals(30, localTime.getMinuteOfHour()); [EOL] assertEquals(25, localTime.getSecondOfMinute()); [EOL] assertEquals(50, localTime.getMillisOfSecond()); [EOL] }
public void testLocalTimeWithInstant() { [EOL] Object instant = Instant.now(); [EOL] LocalTime localTime = new LocalTime(instant); [EOL] assertNotNull(localTime); [EOL] }
public void testLocalTimeWithNullInstant() { [EOL] Object instant = null; [EOL] try { [EOL] LocalTime localTime = new LocalTime(instant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalTimeWithInvalidInstantType() { [EOL] Object instant = new Object(); [EOL] try { [EOL] LocalTime localTime = new LocalTime(instant); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testLocalTimeWithInstantAndZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalTime localTime = new LocalTime(instant, zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(DateTimeZone.UTC, localTime.getChronology().getZone()); [EOL] }
public void testLocalTimeWithPartialConverterAndZone() { [EOL] PartialConverter converter = new TimeOfDay(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] LocalTime localTime = new LocalTime(converter, zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(DateTimeZone.forID("Europe/London"), localTime.getChronology().getZone()); [EOL] }
public void testLocalTimeWithNullInstantAndUTCZone() { [EOL] Object instant = null; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] try { [EOL] new LocalTime(instant, zone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalTimeWithInstantAndNullZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = null; [EOL] LocalTime localTime = new LocalTime(instant, zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(DateTimeZone.getDefault(), localTime.getChronology().getZone()); [EOL] }
public void testLocalTimeWithNullInstantAndChronology() { [EOL] try { [EOL] new LocalTime(null, null); [EOL] fail("Should have thrown IllegalArgumentException for null instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testLocalTimeWithValidInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] LocalTime localTime = new LocalTime(instant, null); [EOL] assertNotNull("LocalTime should not be null", localTime); [EOL] } [EOL] public void testLocalTimeWithValidInstantAndChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalTime localTime = new LocalTime(instant, chronology); [EOL] assertNotNull("LocalTime should not be null", localTime); [EOL] assertEquals("Chronology should match", chronology.withUTC(), localTime.getChronology()); [EOL] } [EOL] public void testLocalTimeWithPartialConverterAndNullChronology() { [EOL] PartialConverter partialConverter = new TimeOfDay(); [EOL] LocalTime localTime = new LocalTime(partialConverter, null); [EOL] assertNotNull("LocalTime should not be null", localTime); [EOL] } [EOL] public void testLocalTimeWithPartialConverterAndChronology() { [EOL] PartialConverter partialConverter = new TimeOfDay(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalTime localTime = new LocalTime(partialConverter, chronology); [EOL] assertNotNull("LocalTime should not be null", localTime); [EOL] assertEquals("Chronology should match", chronology.withUTC(), localTime.getChronology()); [EOL] }
public int size() { [EOL] return 4; [EOL] }
public void testGetFieldHourOfDay() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(HOUR_OF_DAY, chrono); [EOL] assertEquals("HourOfDay field type", chrono.hourOfDay().getType(), field.getType()); [EOL] }
public void testGetFieldMinuteOfHour() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MINUTE_OF_HOUR, chrono); [EOL] assertEquals("MinuteOfHour field type", chrono.minuteOfHour().getType(), field.getType()); [EOL] }
public void testGetFieldSecondOfMinute() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(SECOND_OF_MINUTE, chrono); [EOL] assertEquals("SecondOfMinute field type", chrono.secondOfMinute().getType(), field.getType()); [EOL] }
public void testGetFieldMillisOfSecond() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MILLIS_OF_SECOND, chrono); [EOL] assertEquals("MillisOfSecond field type", chrono.millisOfSecond().getType(), field.getType()); [EOL] }
public void testGetFieldInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.centuries(); [EOL] boolean result = instance.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.minutes(); [EOL] boolean result = instance.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithBoundaryType() { [EOL] DurationFieldType boundaryType = DurationFieldType.days(); [EOL] boolean result = instance.isSupported(boundaryType); [EOL] assertTrue(result); [EOL] }
public void testEquals_SameReference() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] assertTrue(time.equals(time)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] Object obj = new Object(); [EOL] assertFalse(time.equals(obj)); [EOL] }
public void testEquals_EqualLocalTime() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(10, 0, 0); [EOL] assertTrue(time1.equals(time2)); [EOL] }
public void testEquals_NonEqualLocalTime_Chronology() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0, GregorianChronology.getInstance()); [EOL] LocalTime time2 = new LocalTime(10, 0, 0, BuddhistChronology.getInstance()); [EOL] assertFalse(time1.equals(time2)); [EOL] }
public void testEquals_NonEqualLocalTime_Millis() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(11, 0, 0); [EOL] assertFalse(time1.equals(time2)); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] time.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] time.withFieldAdded(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] LocalTime result = time.withFieldAdded(fieldType, 0); [EOL] assertEquals(time, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] int amount = 30; [EOL] LocalTime result = time.withFieldAdded(fieldType, amount); [EOL] assertNotSame(time, result); [EOL] assertEquals(time.plusMinutes(amount), result); [EOL] }
public void testPlusMinutes_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusMinutes(0); [EOL] assertEquals(time, result); [EOL] }
public void testPlusMinutes_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusMinutes(15); [EOL] assertNotEquals(time, result); [EOL] assertEquals(15, Duration.between(time, result).toMinutes()); [EOL] }
public void testPlusMinutes_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusMinutes(-15); [EOL] assertNotEquals(time, result); [EOL] assertEquals(-15, Duration.between(result, time).toMinutes()); [EOL] }
public void testPlusSeconds_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusSeconds(0); [EOL] assertEquals(time, result); [EOL] }
public void testPlusSeconds_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusSeconds(3600); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.plusHours(1), result); [EOL] }
public void testPlusSeconds_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusSeconds(-3600); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.minusHours(1), result); [EOL] }
public void testMinusMinutes_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusMinutes(0); [EOL] assertEquals(time, result); [EOL] }
public void testMinusMinutes_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime expected = time.minusMinutes(-30); [EOL] LocalTime result = time.minusMinutes(30).minusMinutes(-60); [EOL] assertEquals(expected, result); [EOL] }
public void testMinusMinutes_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime expected = time.minusMinutes(30); [EOL] long instant = time.getChronology().minutes().subtract(time.getLocalMillis(), 30); [EOL] LocalTime result = time.withLocalMillis(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testMinusSeconds_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusSeconds(0); [EOL] assertEquals(time, result); [EOL] }
public void testMinusSeconds_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] int secondsToSubtract = 1; [EOL] LocalTime result = time.minusSeconds(secondsToSubtract); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.getChronology().seconds().subtract(time.getLocalMillis(), secondsToSubtract), result.getLocalMillis()); [EOL] }
public void testMinusSeconds_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] int secondsToSubtract = -1; [EOL] LocalTime result = time.minusSeconds(secondsToSubtract); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.getChronology().seconds().subtract(time.getLocalMillis(), secondsToSubtract), result.getLocalMillis()); [EOL] }
public void testSet_ValueWithinBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue + 1; // Assuming iMinValue is a valid minimum value for the field [EOL] if (value == iSkip) { // Adjust value if it's equal to iSkip [EOL] value++; [EOL] } [EOL] long expected = super.set(millis, value); // Assuming super.set() works correctly [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueAtSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip; // Assuming iSkip is a special value that should be skipped [EOL] try { [EOL] set(millis, value); [EOL] fail("Expected IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testSet_ValueBelowSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip - 1; // Value just below iSkip [EOL] long expected = super.set(millis, value + 1); // Value is incremented before setting [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueAboveSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip + 1; // Value just above iSkip [EOL] long expected = super.set(millis, value); // No special handling for values above iSkip [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testWeeks() { [EOL] DurationFieldType type = DurationFieldType.weeks(); [EOL] assertNotNull(type); [EOL] assertEquals("weeks", type.getName()); [EOL] }
public void testIsSupportedWithSupportedChronology() { [EOL] Chronology supportedChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(supportedChronology.isSupported()).thenReturn(true); [EOL] boolean result = isSupported(supportedChronology); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithUnsupportedChronology() { [EOL] Chronology unsupportedChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(unsupportedChronology.isSupported()).thenReturn(false); [EOL] boolean result = isSupported(unsupportedChronology); [EOL] assertFalse(result); [EOL] }
public String testToStringReturnsCorrectName() { [EOL] Time time = new Time("TestName"); [EOL] String result = time.toString(); [EOL] assert result.equals("TestName"); [EOL] }
public void testEquals_Reflexive() { [EOL] StandardDurationFieldType fieldType = StandardDurationFieldType.seconds(); [EOL] assertTrue(fieldType.equals(fieldType)); [EOL] }
public void testEquals_SameOrdinal() { [EOL] StandardDurationFieldType fieldType1 = StandardDurationFieldType.seconds(); [EOL] StandardDurationFieldType fieldType2 = StandardDurationFieldType.seconds(); [EOL] assertTrue(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_DifferentOrdinal() { [EOL] StandardDurationFieldType fieldType1 = StandardDurationFieldType.seconds(); [EOL] StandardDurationFieldType fieldType2 = StandardDurationFieldType.minutes(); [EOL] assertFalse(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_Null() { [EOL] StandardDurationFieldType fieldType = StandardDurationFieldType.seconds(); [EOL] assertFalse(fieldType.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] StandardDurationFieldType fieldType = StandardDurationFieldType.seconds(); [EOL] Object obj = new Object(); [EOL] assertFalse(fieldType.equals(obj)); [EOL] }
public void testGetFieldWithEras() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.eras()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.ERAS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithCenturies() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.centuries()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.CENTURIES); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithWeekyears() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.weekyears()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.WEEKYEARS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithYears() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.years()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.YEARS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithMonths() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.months()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.MONTHS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithWeeks() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.weeks()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.WEEKS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithDays() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.days()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.DAYS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithHalfdays() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.halfdays()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.HALFDAYS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithHours() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.hours()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.HOURS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithMinutes() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.minutes()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.MINUTES); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithSeconds() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.seconds()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.SECONDS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithMillis() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.millis()).thenReturn(new DurationField()); [EOL] MyClass instance = new MyClass(MyEnum.MILLIS); [EOL] DurationField result = instance.getField(mockChronology); [EOL] assertNotNull(result); [EOL] }
public void testGetFieldWithInvalidOrdinal() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] MyClass instance = new MyClass(null); // Assuming null will lead to default case [EOL] try { [EOL] instance.getField(mockChronology); [EOL] fail("Expected an InternalError to be thrown"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testReadResolveForEras() { [EOL] MyClass instance = new MyClass(MyClass.ERAS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.ERAS_TYPE, result); [EOL] }
public void testReadResolveForCenturies() { [EOL] MyClass instance = new MyClass(MyClass.CENTURIES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.CENTURIES_TYPE, result); [EOL] }
public void testReadResolveForWeekyears() { [EOL] MyClass instance = new MyClass(MyClass.WEEKYEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKYEARS_TYPE, result); [EOL] }
public void testReadResolveForYears() { [EOL] MyClass instance = new MyClass(MyClass.YEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.YEARS_TYPE, result); [EOL] }
public void testReadResolveForMonths() { [EOL] MyClass instance = new MyClass(MyClass.MONTHS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MONTHS_TYPE, result); [EOL] }
public void testReadResolveForWeeks() { [EOL] MyClass instance = new MyClass(MyClass.WEEKS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKS_TYPE, result); [EOL] }
public void testReadResolveForDays() { [EOL] MyClass instance = new MyClass(MyClass.DAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.DAYS_TYPE, result); [EOL] }
public void testReadResolveForHalfdays() { [EOL] MyClass instance = new MyClass(MyClass.HALFDAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HALFDAYS_TYPE, result); [EOL] }
public void testReadResolveForHours() { [EOL] MyClass instance = new MyClass(MyClass.HOURS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HOURS_TYPE, result); [EOL] }
public void testReadResolveForMinutes() { [EOL] MyClass instance = new MyClass(MyClass.MINUTES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MINUTES_TYPE, result); [EOL] }
public void testReadResolveForSeconds() { [EOL] MyClass instance = new MyClass(MyClass.SECONDS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.SECONDS_TYPE, result); [EOL] }
public void testReadResolveForMillis() { [EOL] MyClass instance = new MyClass(MyClass.MILLIS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MILLIS_TYPE, result); [EOL] }
public void testReadResolveForDefault() { [EOL] MyClass instance = new MyClass(-1); // Assuming -1 is not a valid iOrdinal [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public void testGetUnitMillis() { [EOL] Time time = new Time(); [EOL] long unitMillis = time.getUnitMillis(); [EOL] assertEquals(0, unitMillis); [EOL] }
public void testNow() { [EOL] MutableDateTime dateTime = MutableDateTime.now(); [EOL] assertNotNull(dateTime); [EOL] long now = System.currentTimeMillis(); [EOL] long dateTimeMillis = dateTime.getMillis(); [EOL] assertTrue(Math.abs(dateTimeMillis - now) < 1000); // Assuming the test runs within 1000ms [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] MutableDateTime dateTime = Time.now(zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Zone must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testMutableDateTimeWithNullInstantAndNullZone() { [EOL] MutableDateTime dateTime = new MutableDateTime((Object) null, (DateTimeZone) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(DateTimeZone.getDefault(), dateTime.getZone()); [EOL] }
public void testMutableDateTimeWithNonNullInstantAndNullZone() { [EOL] Instant instant = new Instant(); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, (DateTimeZone) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(DateTimeZone.getDefault(), dateTime.getZone()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithNullInstantAndNonNullZone() { [EOL] DateTimeZone fixedZone = DateTimeZone.forID("Europe/Paris"); [EOL] MutableDateTime dateTime = new MutableDateTime((Object) null, fixedZone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(fixedZone, dateTime.getZone()); [EOL] }
public void testMutableDateTimeWithNonNullInstantAndNonNullZone() { [EOL] Instant instant = new Instant(); [EOL] DateTimeZone fixedZone = DateTimeZone.forID("Europe/Paris"); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, fixedZone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(fixedZone, dateTime.getZone()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public void testSetWithNullType() { [EOL] try { [EOL] dateTime.set(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetWithValidTypeAndValue() { [EOL] DateTimeFieldType type = DateTimeFieldType.hourOfDay(); [EOL] int value = 10; [EOL] long originalMillis = dateTime.getMillis(); [EOL] long expectedMillis = type.getField(dateTime.getChronology()).set(originalMillis, value); [EOL] dateTime.set(type, value); [EOL] assertEquals(expectedMillis, dateTime.getMillis()); [EOL] }
public void testAddWithNullTypeThrowsException() { [EOL] try { [EOL] time.add(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAddWithZeroAmountDoesNotAlterTime() { [EOL] long initialMillis = time.getMillis(); [EOL] time.add(DurationFieldType.seconds(), 0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddWithNonZeroAmountAltersTime() { [EOL] long initialMillis = time.getMillis(); [EOL] time.add(DurationFieldType.seconds(), 1); [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void testSetWeekyear_ValidValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int originalYear = dateTime.getYear(); [EOL] int newWeekyear = originalYear + 1; [EOL] dateTime.setWeekyear(newWeekyear); [EOL] assertEquals(newWeekyear, dateTime.getWeekyear()); [EOL] }
public void testSetWeekyear_SameValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int originalWeekyear = dateTime.getWeekyear(); [EOL] dateTime.setWeekyear(originalWeekyear); [EOL] assertEquals(originalWeekyear, dateTime.getWeekyear()); [EOL] }
public void testSetDayOfMonth_ValidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfMonth = 15; // Assuming 15 is a valid day for the current month [EOL] dateTime.setDayOfMonth(dayOfMonth); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] }
public void testSetDayOfMonth_InvalidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfMonth = 32; // Assuming 32 is an invalid day for any month [EOL] try { [EOL] dateTime.setDayOfMonth(dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetMinuteOfDay_ValidValue() { [EOL] Time time = new Time(); [EOL] int minuteOfDay = 123; [EOL] time.setMinuteOfDay(minuteOfDay); [EOL] assertEquals(minuteOfDay, time.getChronology().minuteOfDay().get(time.getMillis())); [EOL] }
public void testSetMinuteOfDay_MinValue() { [EOL] Time time = new Time(); [EOL] int minuteOfDay = 0; [EOL] time.setMinuteOfDay(minuteOfDay); [EOL] assertEquals(minuteOfDay, time.getChronology().minuteOfDay().get(time.getMillis())); [EOL] }
public void testSetMinuteOfDay_MaxValue() { [EOL] Time time = new Time(); [EOL] int minuteOfDay = 1439; [EOL] time.setMinuteOfDay(minuteOfDay); [EOL] assertEquals(minuteOfDay, time.getChronology().minuteOfDay().get(time.getMillis())); [EOL] }
public void testSetMillisOfDay_ValidValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int millisOfDay = 12345; [EOL] dateTime.setMillisOfDay(millisOfDay); [EOL] assertEquals(millisOfDay, dateTime.getMillisOfDay()); [EOL] }
public void testSetMillisOfDay_InvalidValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] try { [EOL] dateTime.setMillisOfDay(-1); [EOL] fail("Should have thrown IllegalArgumentException for negative millisOfDay"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] dateTime.setMillisOfDay(86400000); [EOL] fail("Should have thrown IllegalArgumentException for millisOfDay >= 86400000"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetMillisOfSecond_ValidValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int initialMillis = dateTime.getMillisOfSecond(); [EOL] int newMillis = (initialMillis + 500) % 1000; // Ensure newMillis is different [EOL] dateTime.setMillisOfSecond(newMillis); [EOL] assertEquals(newMillis, dateTime.getMillisOfSecond()); [EOL] }
public void testSetMillisOfSecond_EdgeCaseMinimum() { [EOL] DateTime dateTime = new DateTime(); [EOL] dateTime.setMillisOfSecond(0); [EOL] assertEquals(0, dateTime.getMillisOfSecond()); [EOL] }
public void testSetMillisOfSecond_EdgeCaseMaximum() { [EOL] DateTime dateTime = new DateTime(); [EOL] dateTime.setMillisOfSecond(999); [EOL] assertEquals(999, dateTime.getMillisOfSecond()); [EOL] }
public void testSetDate_ValidDate() { [EOL] Time time = new Time(); [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] time.setDate(year, monthOfYear, dayOfMonth); [EOL] }
public void testSetDate_InvalidDate() { [EOL] Time time = new Time(); [EOL] int year = 2021; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 32; // Invalid day [EOL] try { [EOL] time.setDate(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an exception for invalid date"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetTime_ValidTime() { [EOL] Time time = new Time(); // Replace with actual constructor [EOL] int hour = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] time.setTime(hour, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] long expectedMillis = 0L; // This should be calculated based on the input values [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testSetTime_InvalidTime() { [EOL] Time time = new Time(); // Replace with actual constructor [EOL] int hour = 25; // Invalid hour [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] try { [EOL] time.setTime(hour, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown an exception for invalid hour"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testYearOfCentury() { [EOL] Time time = new Time(); // Assuming Time is the class where yearOfCentury method exists [EOL] Property result = time.yearOfCentury(); [EOL] assertNotNull("Property should not be null", result); [EOL] assertEquals("Year of century should match expected value", [EOL] time.getChronology().yearOfCentury().get(), [EOL] result.get()); [EOL] }
public void testDayOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfYear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfYear(), property.getField()); [EOL] assertEquals(dateTime.get(DateTimeFieldType.dayOfYear()), property.get()); [EOL] }
public void testMinuteOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.minuteOfDay(); [EOL] int expectedValue = dateTime.getChronology().minuteOfDay().get(dateTime.getMillis()); [EOL] assertEquals(expectedValue, property.get()); [EOL] }
public void testMinuteOfHour() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.minuteOfHour(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().minuteOfHour().get(), property.get()); [EOL] }
public void testSecondOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.secondOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().secondOfDay().get(), property.get()); [EOL] }
public void testMillisOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.millisOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().millisOfDay().get(), property.get()); [EOL] }
public void testCopy() { [EOL] MutableDateTime original = new MutableDateTime(); [EOL] MutableDateTime copied = original.copy(); [EOL] assertNotSame(original, copied); [EOL] assertEquals(original, copied); [EOL] }
public void testWriteObject() throws IOException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] YourClass instance = new YourClass(); [EOL] instance.writeObject(oos); [EOL] oos.close(); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] }
public void testReadObjectWithValidInput() throws IOException, ClassNotFoundException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] MutableDateTime expectedInstant = new MutableDateTime(); [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] oos.writeObject(expectedInstant); [EOL] oos.writeObject(expectedType); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] YourClass instance = new YourClass(); [EOL] instance.readObject(ois); // Assuming the method is accessible, if not use reflection [EOL] assertEquals(expectedInstant, instance.iInstant); [EOL] assertEquals(expectedType.getField(expectedInstant.getChronology()), instance.iField); [EOL] }
public void testAddWrapField_PositiveValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = 1; // Assuming the field is such that adding 1 doesn't exceed its maximum value [EOL] MutableDateTime updatedDateTime = dateTime.addWrapField(valueToAdd); [EOL] long updatedMillis = updatedDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] }
public void testAddWrapField_NegativeValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = -1; // Assuming the field is such that subtracting 1 doesn't exceed its minimum value [EOL] MutableDateTime updatedDateTime = dateTime.addWrapField(valueToAdd); [EOL] long updatedMillis = updatedDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] }
public void testAddWrapField_MaxValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = Integer.MAX_VALUE; [EOL] MutableDateTime updatedDateTime = dateTime.addWrapField(valueToAdd); [EOL] long updatedMillis = updatedDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] }
public void testAddWrapField_MinValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = Integer.MIN_VALUE; [EOL] MutableDateTime updatedDateTime = dateTime.addWrapField(valueToAdd); [EOL] long updatedMillis = updatedDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] }
public void testRoundCeiling() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] long originalMillis = mutableDateTime.getMillis(); [EOL] DateTimeField field = mutableDateTime.getField(); [EOL] long expectedMillis = field.roundCeiling(originalMillis); [EOL] MutableDateTime result = mutableDateTime.roundCeiling(); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] }
public void testRoundHalfFloor_AtStartOfFirstHalf() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 1, 15, 10, 20, 30, 0); // Assume this is the start of the first half [EOL] MutableDateTime rounded = dateTime.roundHalfFloor(); [EOL] assertEquals(new MutableDateTime(2023, 1, 15, 10, 20, 30, 0), rounded); [EOL] }
public void testRoundHalfFloor_AtEndOfFirstHalf() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 1, 15, 10, 29, 59, 999); // Assume this is the end of the first half [EOL] MutableDateTime rounded = dateTime.roundHalfFloor(); [EOL] assertEquals(new MutableDateTime(2023, 1, 15, 10, 20, 30, 0), rounded); [EOL] }
public void testRoundHalfFloor_AtStartOfSecondHalf() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 1, 15, 10, 30, 0, 0); // Assume this is the start of the second half [EOL] MutableDateTime rounded = dateTime.roundHalfFloor(); [EOL] assertEquals(new MutableDateTime(2023, 1, 15, 10, 30, 0, 0), rounded); [EOL] }
public void testRoundHalfFloor_AtEndOfSecondHalf() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 1, 15, 10, 59, 59, 999); // Assume this is the end of the second half [EOL] MutableDateTime rounded = dateTime.roundHalfFloor(); [EOL] assertEquals(new MutableDateTime(2023, 1, 15, 10, 30, 0, 0), rounded); [EOL] }
public void testHoursZero() { [EOL] Hours result = Time.hours(0); [EOL] assertSame(Hours.ZERO, result); [EOL] }
public void testHoursOne() { [EOL] Hours result = Time.hours(1); [EOL] assertSame(Hours.ONE, result); [EOL] }
public void testHoursTwo() { [EOL] Hours result = Time.hours(2); [EOL] assertSame(Hours.TWO, result); [EOL] }
public void testHoursThree() { [EOL] Hours result = Time.hours(3); [EOL] assertSame(Hours.THREE, result); [EOL] }
public void testHoursFour() { [EOL] Hours result = Time.hours(4); [EOL] assertSame(Hours.FOUR, result); [EOL] }
public void testHoursFive() { [EOL] Hours result = Time.hours(5); [EOL] assertSame(Hours.FIVE, result); [EOL] }
public void testHoursSix() { [EOL] Hours result = Time.hours(6); [EOL] assertSame(Hours.SIX, result); [EOL] }
public void testHoursSeven() { [EOL] Hours result = Time.hours(7); [EOL] assertSame(Hours.SEVEN, result); [EOL] }
public void testHoursEight() { [EOL] Hours result = Time.hours(8); [EOL] assertSame(Hours.EIGHT, result); [EOL] }
public void testHoursMaxValue() { [EOL] Hours result = Time.hours(Integer.MAX_VALUE); [EOL] assertSame(Hours.MAX_VALUE, result); [EOL] }
public void testHoursMinValue() { [EOL] Hours result = Time.hours(Integer.MIN_VALUE); [EOL] assertSame(Hours.MIN_VALUE, result); [EOL] }
public void testHoursDefault() { [EOL] int arbitraryHour = 9; [EOL] Hours result = Time.hours(arbitraryHour); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryHour, result.getValue()); [EOL] }
public void testHoursBetweenWithLocalTimes() { [EOL] LocalTime start = new LocalTime(10, 0); // 10:00 AM [EOL] LocalTime end = new LocalTime(13, 0); // 1:00 PM [EOL] Hours result = Time.hoursBetween(start, end); [EOL] assertEquals(3, result.getHours()); [EOL] }
public void testHoursBetweenWithDifferentPartials() { [EOL] LocalDate startDate = new LocalDate(2020, 1, 1); [EOL] LocalDate endDate = new LocalDate(2020, 1, 2); [EOL] Hours result = Time.hoursBetween(startDate, endDate); [EOL] assertEquals(24, result.getHours()); [EOL] }
public void testHoursConstructor() { [EOL] int expectedHours = 5; [EOL] Hours hoursObject = new Hours(expectedHours); [EOL] assertEquals(expectedHours, hoursObject.getHours()); [EOL] }
public PeriodType getPeriodType() { [EOL] return PeriodType.hours(); [EOL] }
public void testToStandardDays_PositiveHours() { [EOL] Hours hours = Hours.hours(48); // 2 days [EOL] Days expected = Days.days(2); [EOL] Days actual = hours.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToStandardDays_NegativeHours() { [EOL] Hours hours = Hours.hours(-36); // -1.5 days [EOL] Days expected = Days.days(-1); [EOL] Days actual = hours.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToStandardDays_ZeroHours() { [EOL] Hours hours = Hours.hours(0); [EOL] Days expected = Days.days(0); [EOL] Days actual = hours.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToStandardDays_LessThanADay() { [EOL] Hours hours = Hours.hours(23); // Less than a day [EOL] Days expected = Days.days(0); [EOL] Days actual = hours.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDuration_PositiveHours() { [EOL] Period period = new Period().withHours(5); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(5 * DateTimeConstants.MILLIS_PER_HOUR, duration.getMillis()); [EOL] }
public void testToStandardDuration_ZeroHours() { [EOL] Period period = new Period().withHours(0); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(0, duration.getMillis()); [EOL] }
public void testToStandardDuration_NegativeHours() { [EOL] Period period = new Period().withHours(-5); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(-5 * DateTimeConstants.MILLIS_PER_HOUR, duration.getMillis()); [EOL] }
public void testIsGreaterThanWithNullOther() { [EOL] Hours hours = new Hours(5); [EOL] boolean result = hours.isGreaterThan(null); [EOL] assert result == true; [EOL] } [EOL] public void testIsGreaterThanWithPositiveOtherLesser() { [EOL] Hours hours = new Hours(5); [EOL] Hours other = new Hours(3); [EOL] boolean result = hours.isGreaterThan(other); [EOL] assert result == true; [EOL] } [EOL] public void testIsGreaterThanWithPositiveOtherGreater() { [EOL] Hours hours = new Hours(2); [EOL] Hours other = new Hours(5); [EOL] boolean result = hours.isGreaterThan(other); [EOL] assert result == false; [EOL] } [EOL] public void testIsGreaterThanWithEqualOther() { [EOL] Hours hours = new Hours(5); [EOL] Hours other = new Hours(5); [EOL] boolean result = hours.isGreaterThan(other); [EOL] assert result == false; [EOL] }
public void testRemove_ConverterNotFound() { [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] ConverterSet result = set.remove(converterC, removed); [EOL] assertEquals("ConverterSet should not change", set, result); [EOL] assertNull("Removed converter should be null", removed[0]); [EOL] }
public void testRemove_ConverterFound() { [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] ConverterSet result = set.remove(converterA, removed); [EOL] assertNotSame("ConverterSet should be a new instance", set, result); [EOL] assertEquals("Removed converter should be converterA", converterA, removed[0]); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL] Converter[] converters = set.iConverters; [EOL] int length = converters.length; [EOL] Converter converter; [EOL] for (int i = length; --i >= 0; ) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] if (supportedType == type) { [EOL] return converter; [EOL] } [EOL] if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL] set = set.remove(i, null); [EOL] converters = set.iConverters; [EOL] length = converters.length; [EOL] } [EOL] } [EOL] if (type == null || length == 0) { [EOL] return null; [EOL] } [EOL] if (length == 1) { [EOL] return converters[0]; [EOL] } [EOL] for (int i = length; --i >= 0; ) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] for (int j = length; --j >= 0; ) { [EOL] if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL] set = set.remove(j, null); [EOL] converters = set.iConverters; [EOL] length = converters.length; [EOL] i = length - 1; [EOL] } [EOL] } [EOL] } [EOL] if (length == 1) { [EOL] return converters[0]; [EOL] } [EOL] StringBuilder msg = new StringBuilder(); [EOL] msg.append("Unable to find best converter for type \""); [EOL] msg.append(type.getName()); [EOL] msg.append("\" from remaining set: "); [EOL] for (int i = 0; i < length; i++) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] msg.append(converter.getClass().getName()); [EOL] msg.append('['); [EOL] msg.append(supportedType == null ? null : supportedType.getName()); [EOL] msg.append("], "); [EOL] } [EOL] throw new IllegalStateException(msg.toString()); [EOL] }
public void testToParser_WhenFormatterIsParser() { [EOL] DateTimeFormatterStub formatter = new DateTimeFormatterStub(true); [EOL] DateTimeParser expectedParser = formatter.getDateTimeParser(); [EOL] DateTimeParser actualParser = formatter.toParser(); [EOL] assertEquals(expectedParser, actualParser); [EOL] } [EOL] public void testToParser_WhenFormatterIsNotParser_ThrowsException() { [EOL] DateTimeFormatterStub formatter = new DateTimeFormatterStub(false); [EOL] try { [EOL] formatter.toParser(); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Parsing is not supported", e.getMessage()); [EOL] } [EOL] }
public boolean canBuildParser() { [EOL] return isParser(getFormatter()); [EOL] }
public void testAppendWithValidPrinterAndParser() { [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.append(printer, parser); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithNullPrinter() { [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(null, parser); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNullParser() { [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(printer, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckPrinterWithNull() { [EOL] try { [EOL] checkPrinter(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No printer supplied", e.getMessage()); [EOL] } [EOL] }
public void testCheckPrinterWithNonNull() { [EOL] DateTimePrinter printer = new SomeDateTimePrinterImplementation(); [EOL] checkPrinter(printer); // Should not throw an exception [EOL] }
public void testAppendText_WithNullFieldType_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendText(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendText_WithNonNullFieldType_ReturnsDateTimeFormatterBuilder() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfWeek(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendText(fieldType); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendTwoDigitWeekyearWithPivot() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitWeekyear(2000); [EOL] assertNotNull(result); [EOL] }
public void testAppendTwoDigitWeekyearWithPivotAndFalse() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitWeekyear(2000, false); [EOL] assertNotNull(result); [EOL] }
public void testAppendTwoDigitWeekyearWithPivot() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] int pivot = 2000; [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitWeekyear(pivot, true); [EOL] assertNotNull(result); [EOL] }
public void testAppendTwoDigitWeekyearWithoutPivot() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitWeekyear(0, false); [EOL] assertNotNull(result); [EOL] }
public void testAppendYearOfEra_MinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendYearOfEra(2, 4); [EOL] assertNotNull(result); [EOL] }
public void testAppendYearOfEra_SameMinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendYearOfEra(3, 3); [EOL] assertNotNull(result); [EOL] }
public void testParseInto_MatchAtPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "expectedValue"; [EOL] int position = 0; [EOL] int expected = "expectedValue".length(); [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(expected, result); [EOL] }
public void testParseInto_NoMatchAtPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "unexpected"; [EOL] int position = 0; [EOL] int expected = ~position; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(expected, result); [EOL] }
public void testParseInto_MatchNotAtStartPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "abcexpectedValue"; [EOL] int position = 3; [EOL] int expected = position + "expectedValue".length(); [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(expected, result); [EOL] }
public void testParseInto_NoMatchDueToPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "expectedValue"; [EOL] int position = 5; [EOL] int expected = ~position; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(expected, result); [EOL] }
public void testPrintTo_SupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenReturn(123); [EOL] printTo(buf, mockPartial, Locale.ENGLISH); [EOL] assertEquals("Expected padded integer", "00123", buf.toString()); [EOL] } [EOL] public void testPrintTo_UnsupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(false); [EOL] printTo(buf, mockPartial, Locale.ENGLISH); [EOL] assertEquals("Expected unknown string", "???", buf.toString()); [EOL] } [EOL] public void testPrintTo_ThrowsRuntimeException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenThrow(new RuntimeException()); [EOL] printTo(buf, mockPartial, Locale.ENGLISH); [EOL] assertEquals("Expected unknown string after exception", "???", buf.toString()); [EOL] }
public void testParseInto_LenientParseFalseAndLimitLessThanTwo() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_LenientParseFalseAndLimitTwoOrMore() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrueNoSignCharAndNonDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueHasSignCharAndNonDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueHasSignCharAndDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueHasSignCharAndTwoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueHasNegativeSignCharAndDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueHasNegativeSignCharAndTwoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] } [EOL] public void testParseInto_LenientParseTrueLengthNineOrMore() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "123456789"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 9, result); [EOL] }
public void testParseInto_NonLenientAndNonDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "ab"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_NonLenientAndDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_PivotYearNotNull() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] bucket.setPivotYear(new Integer(2000)); [EOL] String text = "99"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testTextFieldWithLongDateTimeFieldType() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] boolean isShort = false; [EOL] TextField textField = new TextField(fieldType, isShort); [EOL] assertNotNull(textField); [EOL] assertEquals(fieldType, textField.iFieldType); [EOL] assertFalse(textField.iShort); [EOL] }
public void testTextFieldWithShortDateTimeFieldType() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] boolean isShort = true; [EOL] TextField textField = new TextField(fieldType, isShort); [EOL] assertNotNull(textField); [EOL] assertEquals(fieldType, textField.iFieldType); [EOL] assertTrue(textField.iShort); [EOL] }
public int estimatePrintedLengthTestShortTrue() { [EOL] Time time = new Time(true); [EOL] int estimatedLength = time.estimatePrintedLength(); [EOL] assertEquals(6, estimatedLength); [EOL] }
public int estimatePrintedLengthTestShortFalse() { [EOL] Time time = new Time(false); [EOL] int estimatedLength = time.estimatePrintedLength(); [EOL] assertEquals(20, estimatedLength); [EOL] }
public void testPrintToWithValidInputs() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertFalse(buf.length() == 0); [EOL] }
public void testPrintToWithException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = null; // Assuming this will cause a RuntimeException [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertTrue(buf.indexOf("\ufffd") != -1); [EOL] }
public void testPrintToWithValidPartial() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = new LocalDate(2021, 10, 5); // Assuming LocalDate implements ReadablePartial [EOL] Locale locale = Locale.ENGLISH; [EOL] printTo(buf, partial, locale); [EOL] assertEquals("Expected formatted date", "2021-10-05", buf.toString()); [EOL] }
public void testPrintToWithException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = mock(ReadablePartial.class); // Using a mocking framework like Mockito [EOL] when(partial.get(anyInt())).thenThrow(new RuntimeException()); [EOL] Locale locale = Locale.ENGLISH; [EOL] printTo(buf, partial, locale); [EOL] assertEquals("Expected replacement character", "\ufffd", buf.toString()); [EOL] }
public void testPrintWithShortTrue() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Locale locale = Locale.ENGLISH; [EOL] MyTimeClass instance = new MyTimeClass(true); [EOL] String result = instance.print(instant, chrono, locale); [EOL] assertNotNull("Result should not be null", result); [EOL] assertFalse("Result should not be the full text", result.equals(chrono.hourOfDay().getAsText(instant, locale))); [EOL] }
public void testPrintWithShortFalse() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Locale locale = Locale.ENGLISH; [EOL] MyTimeClass instance = new MyTimeClass(false); [EOL] String result = instance.print(instant, chrono, locale); [EOL] assertNotNull("Result should not be null", result); [EOL] assertTrue("Result should be the full text", result.equals(chrono.hourOfDay().getAsText(instant, locale))); [EOL] }
public void testPrint_SupportedShort() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(iFieldType.getField(mockPartial.getChronology())).thenReturn(mockField); [EOL] when(mockField.getAsShortText(mockPartial, Locale.ENGLISH)).thenReturn("ShortText"); [EOL] iShort = true; [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("ShortText", result); [EOL] }
public void testPrint_SupportedLong() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(iFieldType.getField(mockPartial.getChronology())).thenReturn(mockField); [EOL] when(mockField.getAsText(mockPartial, Locale.ENGLISH)).thenReturn("LongText"); [EOL] iShort = false; [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("LongText", result); [EOL] }
public void testPrint_Unsupported() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(false); [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("\ufffd", result); [EOL] }
public void testParseInto_CacheMissAndMaxDifferenceGreaterThan32() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "SomeText"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_CacheMissAndLocaleSpecificValues() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, Locale.ENGLISH, null, null, 0); [EOL] String text = "BCE"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result > 0); [EOL] }
public void testParseInto_CacheHit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, Locale.ENGLISH, null, null, 0); [EOL] String text = "CE"; [EOL] int position = 0; [EOL] Set<String> validValues = new HashSet<>(); [EOL] validValues.add("CE"); [EOL] Map<DateTimeFieldType, Object[]> innerMap = new HashMap<>(); [EOL] innerMap.put(DateTimeFieldType.era(), new Object[] { validValues, Integer.valueOf(2) }); [EOL] cParseCache.put(Locale.ENGLISH, innerMap); [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_NoMatchFound() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, Locale.ENGLISH, null, null, 0); [EOL] String text = "XYZ"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException { [EOL] DateTimeField field = iFieldType.getField(chrono); [EOL] int minDigits = iMinDigits; [EOL] long fraction; [EOL] try { [EOL] fraction = field.remainder(instant); [EOL] } catch (RuntimeException e) { [EOL] if (buf != null) { [EOL] appendUnknownString(buf, minDigits); [EOL] } else { [EOL] printUnknownString(out, minDigits); [EOL] } [EOL] return; [EOL] } [EOL] if (fraction == 0) { [EOL] if (buf != null) { [EOL] while (--minDigits >= 0) { [EOL] buf.append('0'); [EOL] } [EOL] } else { [EOL] while (--minDigits >= 0) { [EOL] out.write('0'); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] String str; [EOL] long[] fractionData = getFractionData(fraction, field); [EOL] long scaled = fractionData[0]; [EOL] int maxDigits = (int) fractionData[1]; [EOL] if ((scaled & 0x7fffffff) == scaled) { [EOL] str = Integer.toString((int) scaled); [EOL] } else { [EOL] str = Long.toString(scaled); [EOL] } [EOL] int length = str.length(); [EOL] int digits = maxDigits; [EOL] while (length < digits) { [EOL] if (buf != null) { [EOL] buf.append('0'); [EOL] } else { [EOL] out.write('0'); [EOL] } [EOL] minDigits--; [EOL] digits--; [EOL] } [EOL] if (minDigits < digits) { [EOL] while (minDigits < digits) { [EOL] if (length <= 1 || str.charAt(length - 1) != '0') { [EOL] break; [EOL] } [EOL] digits--; [EOL] length--; [EOL] } [EOL] if (length < str.length()) { [EOL] if (buf != null) { [EOL] for (int i = 0; i < length; i++) { [EOL] buf.append(str.charAt(i)); [EOL] } [EOL] } else { [EOL] for (int i = 0; i < length; i++) { [EOL] out.write(str.charAt(i)); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] if (buf != null) { [EOL] buf.append(str); [EOL] } else { [EOL] out.write(str); [EOL] } [EOL] }
public void testGetFractionData_DefaultCase() { [EOL] DateTimeField field = createMockedDateTimeField(1L); // Assuming createMockedDateTimeField is a method that creates a mock of DateTimeField with specified unitMillis [EOL] long fraction = 1L; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Default case should set scalar to 1", 1L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case1() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 1; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 1 should set scalar to 10", 10L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case2() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 2; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 2 should set scalar to 100", 100L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case3() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 3; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 3 should set scalar to 1000", 1000L, result[1]); [EOL] }
public void testGetFractionData_Case4() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 4; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 4 should set scalar to 10000", 10000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case5() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 5; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 5 should set scalar to 100000", 100000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case6() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 6; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 6 should set scalar to 1000000", 1000000L, result[1]); [EOL] }
public void testGetFractionData_Case7() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 7; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 7 should set scalar to 10000000", 10000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case8() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 8; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 8 should set scalar to 100000000", 100000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case9() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 9; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 9 should set scalar to 1000000000", 1000000000L, result[1]); [EOL] }
public void testGetFractionData_Case10() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 10; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 10 should set scalar to 10000000000", 10000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case11() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 11; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 11 should set scalar to 100000000000", 100000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case12() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 12; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 12 should set scalar to 1000000000000", 1000000000000L, result[1]); [EOL] }
public void testGetFractionData_Case13() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 13; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 13 should set scalar to 10000000000000", 10000000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case14() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 14; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 14 should set scalar to 100000000000000", 100000000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case15() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 15; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 15 should set scalar to 1000000000000000", 1000000000000000L, result[1]); [EOL] }
public void testGetFractionData_Case16() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 16; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 16 should set scalar to 10000000000000000", 10000000000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case17() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 17; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 17 should set scalar to 100000000000000000", 100000000000000000L, result[1]); [EOL] } [EOL] public void testGetFractionData_Case18() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 18; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals("Case 18 should set scalar to 1000000000000000000", 1000000000000000000L, result[1]); [EOL] }
public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithPlusSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be unchanged", 0, result); [EOL] assertEquals("Expected offset to be zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithMinusSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be unchanged", 0, result); [EOL] assertEquals("Expected offset to be zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextEmptyAndLimitZero() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextMatches() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Z"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented by length of 'Z'", 1, result); [EOL] assertEquals("Expected offset to be zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_LimitLessThanOrEqualToOne() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_InvalidFirstCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_ValidNegativeOffset() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "-02:30"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented by length of offset", 5, result); [EOL] assertNotNull("Expected offset to be set", bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ValidPositiveOffset() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+02:30"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented by length of offset", 5, result); [EOL] assertNotNull("Expected offset to be set", bucket.getOffset()); [EOL] } [EOL] public void testParseInto_InvalidHour() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+24:00"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_InvalidMinute() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+02:60"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_InvalidSecond() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+02:30:60"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_InvalidMillisecond() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+02:30:30.1000"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated", ~position, result); [EOL] } [EOL] public void testParseInto_ValidFullOffset() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+02:30:30.123"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented by length of full offset", 12, result); [EOL] assertNotNull("Expected offset to be set", bucket.getOffset()); [EOL] }
public void testPrintToWithNullElements() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = new ReadablePartialMock(); // Assuming a mock that implements ReadablePartial [EOL] Locale locale = Locale.ENGLISH; [EOL] TimePrinter timePrinter = new TimePrinter(null); // Assuming constructor that sets iPrinters to null [EOL] try { [EOL] timePrinter.printTo(buf, partial, locale); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullElements() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = new ReadablePartialMock(); // Assuming a mock that implements ReadablePartial [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimePrinter[] printers = new DateTimePrinter[] { [EOL] new DateTimePrinterMock(), // Assuming a mock that implements DateTimePrinter [EOL] new DateTimePrinterMock() [EOL] }; [EOL] TimePrinter timePrinter = new TimePrinter(printers); // Assuming constructor that sets iPrinters [EOL] timePrinter.printTo(buf, partial, locale); [EOL] }
public void testPrintToWithDefaultLocale() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = new ReadablePartialMock(); // Assuming a mock that implements ReadablePartial [EOL] DateTimePrinter[] printers = new DateTimePrinter[] { [EOL] new DateTimePrinterMock(), // Assuming a mock that implements DateTimePrinter [EOL] new DateTimePrinterMock() [EOL] }; [EOL] TimePrinter timePrinter = new TimePrinter(printers); // Assuming constructor that sets iPrinters [EOL] timePrinter.printTo(buf, partial, null); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] DateTimeParser[] parsers = iParsers; [EOL] int length = parsers.length; [EOL] final Object originalState = bucket.saveState(); [EOL] boolean isOptional = false; [EOL] int bestValidPos = position; [EOL] Object bestValidState = null; [EOL] int bestInvalidPos = position; [EOL] for (int i = 0; i < length; i++) { [EOL] DateTimeParser parser = parsers[i]; [EOL] if (parser == null) { [EOL] if (bestValidPos <= position) { [EOL] return position; [EOL] } [EOL] isOptional = true; [EOL] break; [EOL] } [EOL] int parsePos = parser.parseInto(bucket, text, position); [EOL] if (parsePos >= position) { [EOL] if (parsePos > bestValidPos) { [EOL] if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL] return parsePos; [EOL] } [EOL] bestValidPos = parsePos; [EOL] bestValidState = bucket.saveState(); [EOL] } [EOL] } else { [EOL] if (parsePos < 0) { [EOL] parsePos = ~parsePos; [EOL] if (parsePos > bestInvalidPos) { [EOL] bestInvalidPos = parsePos; [EOL] } [EOL] } [EOL] } [EOL] bucket.restoreState(originalState); [EOL] } [EOL] if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL] if (bestValidState != null) { [EOL] bucket.restoreState(bestValidState); [EOL] } [EOL] return bestValidPos; [EOL] } [EOL] return ~bestInvalidPos; [EOL] }
public TimeOfDay(long instant) { [EOL] super(instant); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay(Object instant) { [EOL] super(instant, null, ISODateTimeFormat.timeParser()); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=Optional[3633353405803318660L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }];
public void testTimeOfDayWithHourMinuteSecondChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] int secondOfMinute = 10; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinute() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayWithHourMinuteChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinuteSecond() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] int secondOfMinute = 10; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillis() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] int secondOfMinute = 10; [EOL] int millisOfSecond = 200; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillisChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 15; [EOL] int secondOfMinute = 10; [EOL] int millisOfSecond = 200; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, timeOfDay.getMillisOfSecond()); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=Optional[3633353405803318660L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }]
public void testToDateTimeTodayWithDefaultZone() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] DateTime result = timeOfDay.toDateTimeToday(); [EOL] assertNotNull(result); [EOL] assertEquals(result.toLocalTime(), timeOfDay.toLocalTime()); [EOL] }
public void testToDateTimeTodayWithSpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] DateTime result = timeOfDay.toDateTimeToday(zone); [EOL] assertNotNull(result); [EOL] assertEquals(result.getZone(), zone); [EOL] assertEquals(result.toLocalTime(), timeOfDay.toLocalTime()); [EOL] }
public TimeOfDay withHourOfDay(int hour) { [EOL] int[] newValues = getValues(); [EOL] newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay() { } [EOL] public TimeOfDay(DateTimeZone zone) { } [EOL] public TimeOfDay(Chronology chronology) { } [EOL] public TimeOfDay(long instant) { } [EOL] public TimeOfDay(long instant, Chronology chronology) { } [EOL] public TimeOfDay(Object instant) { } [EOL] public TimeOfDay(Object instant, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { } [EOL] TimeOfDay(TimeOfDay partial, int[] values) { } [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) { } [EOL] Property(TimeOfDay partial, int fieldIndex) { } [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) { } [EOL] public static TimeOfDay fromDateFields(Date date) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public TimeOfDay plus(ReadablePeriod period) { } [EOL] public TimeOfDay plusHours(int hours) { } [EOL] public TimeOfDay plusMinutes(int minutes) { } [EOL] public TimeOfDay plusSeconds(int seconds) { } [EOL] public TimeOfDay plusMillis(int millis) { } [EOL] public TimeOfDay minus(ReadablePeriod period) { } [EOL] public TimeOfDay minusHours(int hours) { } [EOL] public TimeOfDay minusMinutes(int minutes) { } [EOL] public TimeOfDay minusSeconds(int seconds) { } [EOL] public TimeOfDay minusMillis(int millis) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalTime toLocalTime() { } [EOL] public DateTime toDateTimeToday() { } [EOL] public DateTime toDateTimeToday(DateTimeZone zone) { } [EOL] public int getHourOfDay() { } [EOL] public int getMinuteOfHour() { } [EOL] public int getSecondOfMinute() { } [EOL] public int getMillisOfSecond() { } [EOL] public TimeOfDay withHourOfDay(int hour) { } [EOL] public TimeOfDay withMinuteOfHour(int minute) { } [EOL] public TimeOfDay withSecondOfMinute(int second) { } [EOL] public TimeOfDay withMillisOfSecond(int millis) { } [EOL] public Property hourOfDay() { } [EOL] public Property minuteOfHour() { } [EOL] public Property secondOfMinute() { } [EOL] public Property millisOfSecond() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public TimeOfDay getTimeOfDay() { } [EOL] public int get() { } [EOL] public TimeOfDay addToCopy(int valueToAdd) { } [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) { } [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public TimeOfDay setCopy(int value) { } [EOL] public TimeOfDay setCopy(String text, Locale locale) { } [EOL] public TimeOfDay setCopy(String text) { } [EOL] public TimeOfDay withMaximumValue() { } [EOL] public TimeOfDay withMinimumValue() { } [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay withMinuteOfHour(int minute) { [EOL] int[] newValues = getValues(); [EOL] newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay() { } [EOL] public TimeOfDay(DateTimeZone zone) { } [EOL] public TimeOfDay(Chronology chronology) { } [EOL] public TimeOfDay(long instant) { } [EOL] public TimeOfDay(long instant, Chronology chronology) { } [EOL] public TimeOfDay(Object instant) { } [EOL] public TimeOfDay(Object instant, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { } [EOL] TimeOfDay(TimeOfDay partial, int[] values) { } [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) { } [EOL] Property(TimeOfDay partial, int fieldIndex) { } [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) { } [EOL] public static TimeOfDay fromDateFields(Date date) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public TimeOfDay plus(ReadablePeriod period) { } [EOL] public TimeOfDay plusHours(int hours) { } [EOL] public TimeOfDay plusMinutes(int minutes) { } [EOL] public TimeOfDay plusSeconds(int seconds) { } [EOL] public TimeOfDay plusMillis(int millis) { } [EOL] public TimeOfDay minus(ReadablePeriod period) { } [EOL] public TimeOfDay minusHours(int hours) { } [EOL] public TimeOfDay minusMinutes(int minutes) { } [EOL] public TimeOfDay minusSeconds(int seconds) { } [EOL] public TimeOfDay minusMillis(int millis) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalTime toLocalTime() { } [EOL] public DateTime toDateTimeToday() { } [EOL] public DateTime toDateTimeToday(DateTimeZone zone) { } [EOL] public int getHourOfDay() { } [EOL] public int getMinuteOfHour() { } [EOL] public int getSecondOfMinute() { } [EOL] public int getMillisOfSecond() { } [EOL] public TimeOfDay withHourOfDay(int hour) { } [EOL] public TimeOfDay withMinuteOfHour(int minute) { } [EOL] public TimeOfDay withSecondOfMinute(int second) { } [EOL] public TimeOfDay withMillisOfSecond(int millis) { } [EOL] public Property hourOfDay() { } [EOL] public Property minuteOfHour() { } [EOL] public Property secondOfMinute() { } [EOL] public Property millisOfSecond() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public TimeOfDay getTimeOfDay() { } [EOL] public int get() { } [EOL] public TimeOfDay addToCopy(int valueToAdd) { } [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) { } [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public TimeOfDay setCopy(int value) { } [EOL] public TimeOfDay setCopy(String text, Locale locale) { } [EOL] public TimeOfDay setCopy(String text) { } [EOL] public TimeOfDay withMaximumValue() { } [EOL] public TimeOfDay withMinimumValue() { } [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay withSecondOfMinute(int second) { [EOL] int[] newValues = getValues(); [EOL] newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay() {} [EOL] public TimeOfDay(DateTimeZone zone) {} [EOL] public TimeOfDay(Chronology chronology) {} [EOL] public TimeOfDay(long instant) {} [EOL] public TimeOfDay(long instant, Chronology chronology) {} [EOL] public TimeOfDay(Object instant) {} [EOL] public TimeOfDay(Object instant, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {} [EOL] TimeOfDay(TimeOfDay partial, int[] values) {} [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) {} [EOL] Property(TimeOfDay partial, int fieldIndex) {} [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) {} [EOL] public static TimeOfDay fromDateFields(Date date) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public TimeOfDay plus(ReadablePeriod period) {} [EOL] public TimeOfDay plusHours(int hours) {} [EOL] public TimeOfDay plusMinutes(int minutes) {} [EOL] public TimeOfDay plusSeconds(int seconds) {} [EOL] public TimeOfDay plusMillis(int millis) {} [EOL] public TimeOfDay minus(ReadablePeriod period) {} [EOL] public TimeOfDay minusHours(int hours) {} [EOL] public TimeOfDay minusMinutes(int minutes) {} [EOL] public TimeOfDay minusSeconds(int seconds) {} [EOL] public TimeOfDay minusMillis(int millis) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public LocalTime toLocalTime() {} [EOL] public DateTime toDateTimeToday() {} [EOL] public DateTime toDateTimeToday(DateTimeZone zone) {} [EOL] public int getHourOfDay() {} [EOL] public int getMinuteOfHour() {} [EOL] public int getSecondOfMinute() {} [EOL] public int getMillisOfSecond() {} [EOL] public TimeOfDay withHourOfDay(int hour) {} [EOL] public TimeOfDay withMinuteOfHour(int minute) {} [EOL] public TimeOfDay withSecondOfMinute(int second) {} [EOL] public TimeOfDay withMillisOfSecond(int millis) {} [EOL] public Property hourOfDay() {} [EOL] public Property minuteOfHour() {} [EOL] public Property secondOfMinute() {} [EOL] public Property millisOfSecond() {} [EOL] public String toString() {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public TimeOfDay getTimeOfDay() {} [EOL] public int get() {} [EOL] public TimeOfDay addToCopy(int valueToAdd) {} [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) {} [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public TimeOfDay setCopy(int value) {} [EOL] public TimeOfDay setCopy(String text, Locale locale) {} [EOL] public TimeOfDay setCopy(String text) {} [EOL] public TimeOfDay withMaximumValue() {} [EOL] public TimeOfDay withMinimumValue() {} [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testWithMillisOfSecond_ValidValue() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 0); [EOL] TimeOfDay updatedTime = time.withMillisOfSecond(500); [EOL] assertEquals(500, updatedTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfSecond_SameValue() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 500); [EOL] TimeOfDay updatedTime = time.withMillisOfSecond(500); [EOL] assertEquals(time, updatedTime); [EOL] }
public void testWithMillisOfSecond_OutOfRange() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 0); [EOL] try { [EOL] time.withMillisOfSecond(1000); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public Property millisOfSecond() { [EOL] return new Property(this, MILLIS_OF_SECOND); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay getTimeOfDay() { [EOL] return iTimeOfDay; [EOL] }
public int get() { [EOL] return iTimeOfDay.getValue(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=3633353405803318660L; DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addToCopy(int valueToAdd) { [EOL] int[] newValues = iTimeOfDay.getValues(); [EOL] newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL] return new TimeOfDay(iTimeOfDay, newValues); [EOL] } [EOL] public TimeOfDay() {} [EOL] public TimeOfDay(DateTimeZone zone) {} [EOL] public TimeOfDay(Chronology chronology) {} [EOL] public TimeOfDay(long instant) {} [EOL] public TimeOfDay(long instant, Chronology chronology) {} [EOL] public TimeOfDay(Object instant) {} [EOL] public TimeOfDay(Object instant, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {} [EOL] TimeOfDay(TimeOfDay partial, int[] values) {} [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) {} [EOL] Property(TimeOfDay partial, int fieldIndex) {} [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) {} [EOL] public static TimeOfDay fromDateFields(Date date) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public TimeOfDay plus(ReadablePeriod period) {} [EOL] public TimeOfDay plusHours(int hours) {} [EOL] public TimeOfDay plusMinutes(int minutes) {} [EOL] public TimeOfDay plusSeconds(int seconds) {} [EOL] public TimeOfDay plusMillis(int millis) {} [EOL] public TimeOfDay minus(ReadablePeriod period) {} [EOL] public TimeOfDay minusHours(int hours) {} [EOL] public TimeOfDay minusMinutes(int minutes) {} [EOL] public TimeOfDay minusSeconds(int seconds) {} [EOL] public TimeOfDay minusMillis(int millis) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public LocalTime toLocalTime() {} [EOL] public DateTime toDateTimeToday() {} [EOL] public DateTime toDateTimeToday(DateTimeZone zone) {} [EOL] public int getHourOfDay() {} [EOL] public int getMinuteOfHour() {} [EOL] public int getSecondOfMinute() {} [EOL] public int getMillisOfSecond() {} [EOL] public TimeOfDay withHourOfDay(int hour) {} [EOL] public TimeOfDay withMinuteOfHour(int minute) {} [EOL] public TimeOfDay withSecondOfMinute(int second) {} [EOL] public TimeOfDay withMillisOfSecond(int millis) {} [EOL] public Property hourOfDay() {} [EOL] public Property minuteOfHour() {} [EOL] public Property secondOfMinute() {} [EOL] public Property millisOfSecond() {} [EOL] public String toString() {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public TimeOfDay getTimeOfDay() {} [EOL] public int get() {} [EOL] public TimeOfDay addToCopy(int valueToAdd) {} [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) {} [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public TimeOfDay setCopy(int value) {} [EOL] public TimeOfDay setCopy(String text, Locale locale) {} [EOL] public TimeOfDay setCopy(String text) {} [EOL] public TimeOfDay withMaximumValue() {} [EOL] public TimeOfDay withMinimumValue() {} [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testAbstractIntervalSubclassInstantiation() { [EOL] ConcreteInterval interval = new ConcreteInterval(); [EOL] assertNotNull(interval); [EOL] }
public void testCheckInterval_ValidInterval() { [EOL] long start = 1000; [EOL] long end = 2000; [EOL] checkInterval(start, end); [EOL] }
public void testCheckInterval_InvalidInterval() { [EOL] long start = 2000; [EOL] long end = 1000; [EOL] try { [EOL] checkInterval(start, end); [EOL] fail("Expected IllegalArgumentException for end < start"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The end instant must be greater or equal to the start", e.getMessage()); [EOL] } [EOL] }
public void testCheckInterval_EqualStartAndEnd() { [EOL] long start = 1000; [EOL] long end = 1000; [EOL] checkInterval(start, end); [EOL] }
public void testIsBeforeWithNullInterval() { [EOL] DateTime dateTime = new DateTime(); [EOL] assertTrue(dateTime.isBefore(null)); [EOL] }
public void testIsBeforeWithNonNullIntervalBefore() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadableInterval interval = new Interval(dateTime.plusHours(1), dateTime.plusHours(2)); [EOL] assertTrue(dateTime.isBefore(interval)); [EOL] }
public void testIsBeforeWithNonNullIntervalAfter() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadableInterval interval = new Interval(dateTime.minusHours(2), dateTime.minusHours(1)); [EOL] assertFalse(dateTime.isBefore(interval)); [EOL] }
public long toDurationMillis() { [EOL] return FieldUtils.safeAdd(getEndMillis(), -getStartMillis()); [EOL] }
public void testToDurationWithZeroMillis() { [EOL] Time time = new Time(0); // Assuming Time is the class that contains toDuration method [EOL] Duration result = time.toDuration(); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testToDurationWithNonZeroMillis() { [EOL] Time time = new Time(12345); // Assuming Time is the class that contains toDuration method [EOL] Duration result = time.toDuration(); [EOL] assertNotNull(result); [EOL] assertEquals(12345, result.getMillis()); [EOL] }
public void testToPeriod() { [EOL] DateTime start = new DateTime(2021, 1, 1, 0, 0, 0); [EOL] DateTime end = new DateTime(2021, 12, 31, 23, 59, 59); [EOL] Interval interval = new Interval(start, end); [EOL] Period result = interval.toPeriod(); [EOL] assertNotNull(result); [EOL] assertEquals(start.getMillis(), result.getStartMillis()); [EOL] assertEquals(end.getMillis(), result.getEndMillis()); [EOL] assertEquals(interval.getChronology(), result.getChronology()); [EOL] }
public void testEquals_SameObject() { [EOL] ReadableInterval interval = createInterval(); [EOL] assertTrue(interval.equals(interval)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadableInterval interval = createInterval(); [EOL] assertFalse(interval.equals(null)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadableInterval interval = createInterval(); [EOL] assertFalse(interval.equals(new Object())); [EOL] } [EOL] public void testEquals_EqualIntervals() { [EOL] ReadableInterval interval1 = createInterval(); [EOL] ReadableInterval interval2 = createInterval(); [EOL] assertTrue(interval1.equals(interval2)); [EOL] } [EOL] public void testEquals_DifferentStartMillis() { [EOL] ReadableInterval interval1 = createInterval(); [EOL] ReadableInterval interval2 = createIntervalWithDifferentStart(); [EOL] assertFalse(interval1.equals(interval2)); [EOL] } [EOL] public void testEquals_DifferentEndMillis() { [EOL] ReadableInterval interval1 = createInterval(); [EOL] ReadableInterval interval2 = createIntervalWithDifferentEnd(); [EOL] assertFalse(interval1.equals(interval2)); [EOL] } [EOL] public void testEquals_DifferentChronology() { [EOL] ReadableInterval interval1 = createInterval(); [EOL] ReadableInterval interval2 = createIntervalWithDifferentChronology(); [EOL] assertFalse(interval1.equals(interval2)); [EOL] }
public void testHashCode() { [EOL] long startMillis = 123456789L; [EOL] long endMillis = 987654321L; [EOL] Chronology chronology = ISOChronology.getInstance(); // Assuming ISOChronology as an example [EOL] TimePeriod period = new TimePeriod(startMillis, endMillis, chronology); [EOL] int expectedHashCode = 97; [EOL] expectedHashCode = 31 * expectedHashCode + ((int) (startMillis ^ (startMillis >>> 32))); [EOL] expectedHashCode = 31 * expectedHashCode + ((int) (endMillis ^ (endMillis >>> 32))); [EOL] expectedHashCode = 31 * expectedHashCode + chronology.hashCode(); [EOL] int actualHashCode = period.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testAbstractPeriodConstructor() { [EOL] class TestableAbstractPeriod extends AbstractPeriod { [EOL] TestableAbstractPeriod() { [EOL] super(); [EOL] } [EOL] } [EOL] TestableAbstractPeriod testInstance = new TestableAbstractPeriod(); [EOL] assertNotNull("Constructor should create an instance", testInstance); [EOL] }
public int testSize() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] int size = timePeriod.size(); [EOL] assert size == 3 : "Size should be equal to the number of period types"; [EOL] }
public DurationFieldType getFieldType(int index) { [EOL] return getPeriodType().getFieldType(index); [EOL] }
public void testIsSupported_withSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.seconds(); [EOL] PeriodType mockPeriodType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockPeriodType.isSupported(Mockito.eq(supportedType))).thenReturn(true); [EOL] TimePeriod timePeriod = new TimePeriod(mockPeriodType); [EOL] boolean result = timePeriod.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_withUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.centuries(); [EOL] PeriodType mockPeriodType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockPeriodType.isSupported(Mockito.eq(unsupportedType))).thenReturn(false); [EOL] TimePeriod timePeriod = new TimePeriod(mockPeriodType); [EOL] boolean result = timePeriod.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testMutablePeriodWithValidDurationAndType() { [EOL] long duration = 1000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, type); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationFrom(new Instant(0)).getMillis()); [EOL] assertEquals(type, mutablePeriod.getPeriodType()); [EOL] }
public void testMutablePeriodWithNegativeDuration() { [EOL] long duration = -1000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, type); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationFrom(new Instant(0)).getMillis()); [EOL] assertEquals(type, mutablePeriod.getPeriodType()); [EOL] }
public void testMutablePeriodWithNullType() { [EOL] long duration = 1000L; [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, null); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationFrom(new Instant(0)).getMillis()); [EOL] assertNull(mutablePeriod.getPeriodType()); [EOL] }
public void testMutablePeriodWithValidDurationAndTypeAndChronology() { [EOL] long duration = 123456L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, type, chronology); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationMillis()); [EOL] assertEquals(type, mutablePeriod.getPeriodType()); [EOL] assertEquals(chronology, mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithNullType() { [EOL] long duration = 123456L; [EOL] PeriodType type = null; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, type, chronology); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationMillis()); [EOL] assertNull(mutablePeriod.getPeriodType()); [EOL] assertEquals(chronology, mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithNullChronology() { [EOL] long duration = 123456L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chronology = null; [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, type, chronology); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationMillis()); [EOL] assertEquals(type, mutablePeriod.getPeriodType()); [EOL] assertNull(mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithValidChronology() { [EOL] long startInstant = 0L; [EOL] long endInstant = 10000L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(chrono, period.getChronology()); [EOL] }
public void testMutablePeriodWithNullChronology() { [EOL] long startInstant = 0L; [EOL] long endInstant = 10000L; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, null); [EOL] assertNotNull(period); [EOL] assertEquals(ISOChronology.getInstanceUTC(), period.getChronology()); [EOL] }
public void testMutablePeriod_withStartInstantAndEndInstant() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] DateTime end = new DateTime(2020, 12, 31, 23, 59, 59); [EOL] MutablePeriod period = new MutablePeriod(start, end); [EOL] assertNotNull(period); [EOL] assertEquals(start, period.getStart()); [EOL] assertEquals(end, period.getEnd()); [EOL] }
public void testMutablePeriod_withStartInstantAndEndInstantSameTime() { [EOL] DateTime sameTime = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] MutablePeriod period = new MutablePeriod(sameTime, sameTime); [EOL] assertNotNull(period); [EOL] assertEquals(sameTime, period.getStart()); [EOL] assertEquals(sameTime, period.getEnd()); [EOL] }
public void testMutablePeriod_withStartInstantAndEndInstantNull() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] MutablePeriod period = new MutablePeriod(start, null); [EOL] assertNotNull(period); [EOL] assertEquals(start, period.getStart()); [EOL] assertNull(period.getEnd()); [EOL] }
public void testMutablePeriod_withStartInstantNullAndEndInstant() { [EOL] DateTime end = new DateTime(2020, 12, 31, 23, 59, 59); [EOL] MutablePeriod period = new MutablePeriod(null, end); [EOL] assertNotNull(period); [EOL] assertNull(period.getStart()); [EOL] assertEquals(end, period.getEnd()); [EOL] }
public void testMutablePeriod_WithInstantAndDurationAndType() { [EOL] DateTime startInstant = new DateTime(2020, 1, 1, 0, 0, 0, 0); [EOL] Duration duration = new Duration(1000L); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, duration, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(0, period.getYears()); [EOL] assertEquals(0, period.getMonths()); [EOL] assertEquals(0, period.getWeeks()); [EOL] assertEquals(0, period.getDays()); [EOL] assertEquals(0, period.getHours()); [EOL] assertEquals(0, period.getMinutes()); [EOL] assertEquals(1, period.getSeconds()); [EOL] assertEquals(0, period.getMillis()); [EOL] }
public void testMutablePeriod_WithInstantAndDurationAndNullType() { [EOL] DateTime startInstant = new DateTime(2020, 1, 1, 0, 0, 0, 0); [EOL] Duration duration = new Duration(1000L); [EOL] MutablePeriod period = new MutablePeriod(startInstant, duration, null); [EOL] assertNotNull(period); [EOL] assertEquals(PeriodType.standard(), period.getPeriodType()); [EOL] assertEquals(0, period.getYears()); [EOL] assertEquals(0, period.getMonths()); [EOL] assertEquals(0, period.getWeeks()); [EOL] assertEquals(0, period.getDays()); [EOL] assertEquals(0, period.getHours()); [EOL] assertEquals(0, period.getMinutes()); [EOL] assertEquals(1, period.getSeconds()); [EOL] assertEquals(0, period.getMillis()); [EOL] }
public void testMutablePeriodWithNull() { [EOL] try { [EOL] MutablePeriod mp = new MutablePeriod(null); [EOL] assertNotNull("MutablePeriod should not be null", mp); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception with null input: " + e.getMessage()); [EOL] } [EOL] }
public void testMutablePeriodWithNullPeriod() { [EOL] try { [EOL] new MutablePeriod(null, PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutablePeriodWithValidPeriod() { [EOL] MutablePeriod mp = new MutablePeriod(new Period(), PeriodType.standard()); [EOL] assertNotNull(mp); [EOL] }
public void testSetPeriod() { [EOL] time.setPeriod(mockPeriod); [EOL] }
public void testSetPeriod_AllZeros() { [EOL] setPeriod(0, 0, 0, 0, 0, 0, 0, 0); [EOL] } [EOL] public void testSetPeriod_PositiveValues() { [EOL] setPeriod(1, 1, 1, 1, 1, 1, 1, 1); [EOL] } [EOL] public void testSetPeriod_NegativeValues() { [EOL] setPeriod(-1, -1, -1, -1, -1, -1, -1, -1); [EOL] } [EOL] public void testSetPeriod_MaxValues() { [EOL] setPeriod(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL] } [EOL] public void testSetPeriod_MinValues() { [EOL] setPeriod(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE); [EOL] }
public void testSetPeriodWithSameStartAndEnd() { [EOL] TimePeriod period = new TimePeriod(); [EOL] ReadableInstant instant = new DateTime(); [EOL] period.setPeriod(instant, instant); [EOL] assertEquals(0, period.getPeriod()); [EOL] }
public void testSetPeriodWithDifferentStartAndEnd() { [EOL] TimePeriod period = new TimePeriod(); [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime().plusHours(1); [EOL] period.setPeriod(start, end); [EOL] long expectedMillis = end.getMillis() - start.getMillis(); [EOL] assertEquals(expectedMillis, period.getPeriod()); [EOL] }
public void addDaysTestWithPositiveDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] int daysToAdd = 5; [EOL] DateTime expected = dateTime.plusDays(daysToAdd); [EOL] dateTime.addDays(daysToAdd); [EOL] assertEquals(expected, dateTime); [EOL] }
public void addDaysTestWithNegativeDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] int daysToSubtract = -5; [EOL] DateTime expected = dateTime.minusDays(Math.abs(daysToSubtract)); [EOL] dateTime.addDays(daysToSubtract); [EOL] assertEquals(expected, dateTime); [EOL] }
public void addDaysTestWithZeroDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] int daysToAdd = 0; [EOL] DateTime expected = dateTime.plusDays(daysToAdd); [EOL] dateTime.addDays(daysToAdd); [EOL] assertEquals(expected, dateTime); [EOL] }
public void addMinutes_addPositiveMinutes() { [EOL] Time time = new Time(); [EOL] time.addMinutes(30); [EOL] int updatedMinutes = time.getMinutes(); [EOL] assertEquals("Minutes should be increased by 30", 30, updatedMinutes); [EOL] }
public void addMinutes_addNegativeMinutes() { [EOL] Time time = new Time(); [EOL] time.addMinutes(-15); [EOL] int updatedMinutes = time.getMinutes(); [EOL] assertEquals("Minutes should be decreased by 15", -15, updatedMinutes); [EOL] }
public void addMinutes_addZeroMinutes() { [EOL] Time time = new Time(); [EOL] time.addMinutes(0); [EOL] int updatedMinutes = time.getMinutes(); [EOL] assertEquals("Minutes should remain unchanged", 0, updatedMinutes); [EOL] }
public void testPreciseDurationDateTimeField_WithPreciseUnit() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] when(mockUnit.isPrecise()).thenReturn(true); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] new PreciseDurationDateTimeField(mockType, mockUnit); [EOL] }
public void testPreciseDurationDateTimeField_WithImpreciseUnit() { [EOL] expectedException.expect(IllegalArgumentException.class); [EOL] expectedException.expectMessage("Unit duration field must be precise"); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] when(mockUnit.isPrecise()).thenReturn(false); [EOL] new PreciseDurationDateTimeField(mockType, mockUnit); [EOL] }
public void testPreciseDurationDateTimeField_WithUnitMillisLessThanOne() { [EOL] expectedException.expect(IllegalArgumentException.class); [EOL] expectedException.expectMessage("The unit milliseconds must be at least 1"); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] when(mockUnit.isPrecise()).thenReturn(true); [EOL] when(mockUnit.getUnitMillis()).thenReturn(0L); [EOL] new PreciseDurationDateTimeField(mockType, mockUnit); [EOL] }
public void testGetDifferenceAsLong_WhenMinuendIsLessThanSubtrahend() { [EOL] long minuendInstant = 100L; [EOL] long subtrahendInstant = 200L; [EOL] long expected = -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLong_WhenMinuendIsGreaterThanSubtrahend() { [EOL] long minuendInstant = 200L; [EOL] long subtrahendInstant = 100L; [EOL] long expected = iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLong_WhenMinuendEqualsSubtrahend() { [EOL] long minuendInstant = 100L; [EOL] long subtrahendInstant = 100L; [EOL] long expected = iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testDateTimeParserBucket_WithNonNullChronoAndLocale() { [EOL] long instantLocal = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] Locale locale = Locale.FRANCE; [EOL] Integer pivotYear = 2000; [EOL] int defaultYear = 2023; [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, locale, pivotYear, defaultYear); [EOL] assertNotNull(bucket.iZone); [EOL] assertEquals(chrono.withUTC(), bucket.iChrono); [EOL] assertEquals(locale, bucket.iLocale); [EOL] assertEquals(pivotYear, bucket.iPivotYear); [EOL] assertEquals(defaultYear, bucket.iDefaultYear); [EOL] }
public void testDateTimeParserBucket_WithNullChronoAndLocale() { [EOL] long instantLocal = 0L; [EOL] Chronology chrono = null; [EOL] Locale locale = null; [EOL] Integer pivotYear = 2000; [EOL] int defaultYear = 2023; [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, locale, pivotYear, defaultYear); [EOL] assertNotNull(bucket.iZone); [EOL] assertNotNull(bucket.iChrono); [EOL] assertEquals(Locale.getDefault(), bucket.iLocale); [EOL] assertEquals(pivotYear, bucket.iPivotYear); [EOL] assertEquals(defaultYear, bucket.iDefaultYear); [EOL] }
public void testDateTimeParserBucket_WithNullPivotYear() { [EOL] long instantLocal = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] Locale locale = Locale.FRANCE; [EOL] Integer pivotYear = null; [EOL] int defaultYear = 2023; [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, locale, pivotYear, defaultYear); [EOL] assertNotNull(bucket.iZone); [EOL] assertEquals(chrono.withUTC(), bucket.iChrono); [EOL] assertEquals(locale, bucket.iLocale); [EOL] assertNull(bucket.iPivotYear); [EOL] assertEquals(defaultYear, bucket.iDefaultYear); [EOL] }
public void testGetChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chrono = dateTime.getChronology(); [EOL] assertNotNull(chrono); [EOL] }
public void testGetZone() { [EOL] DateTimeZone expectedZone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(expectedZone); [EOL] DateTimeZone actualZone = dateTime.getZone(); [EOL] assertEquals(expectedZone, actualZone); [EOL] }
public void testGetOffsetInteger() { [EOL] Integer expected = 10; [EOL] Time time = new Time(expected); [EOL] Integer actual = time.getOffsetInteger(); [EOL] assertEquals("The getOffsetInteger method should return the correct offset value", expected, actual); [EOL] }
public void testSetOffsetWithNull() { [EOL] Time time = new Time(); [EOL] time.setOffset(null); [EOL] assertNull(time.getOffset()); [EOL] }
public void testSetOffsetWithNonNull() { [EOL] Time time = new Time(); [EOL] time.setOffset(5); [EOL] assertNotNull(time.getOffset()); [EOL] assertEquals(5, time.getOffset().intValue()); [EOL] }
public void saveFieldTestWithValidFieldAndValue() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] int value = 10; [EOL] saveField(mockField, value); [EOL] }
public void testSaveFieldWithValidFieldTypeAndValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int value = 10; [EOL] saveField(fieldType, value); [EOL] }
public void testSaveFieldWithNullFieldType() { [EOL] int value = 10; [EOL] try { [EOL] saveField(null, value); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSaveFieldWhenArrayIsFull() { [EOL] Time time = new Time(); [EOL] int initialCapacity = 10; // Assuming initial capacity of the array is 10 [EOL] for (int i = 0; i < initialCapacity; i++) { [EOL] time.saveField(new SavedField()); // Fill the array [EOL] } [EOL] SavedField newField = new SavedField(); [EOL] time.saveField(newField); // This should trigger array resizing [EOL] }
public void testSaveFieldWhenArrayIsNotFullAndNotShared() { [EOL] Time time = new Time(); [EOL] time.saveField(new SavedField()); // Add a single field [EOL] }
public void testSaveFieldWhenArrayIsShared() { [EOL] Time time = new Time(); [EOL] time.setSavedFieldsShared(true); [EOL] time.saveField(new SavedField()); // This should copy the array even if it's not full [EOL] }
public void testSaveState_InitialState() { [EOL] YourClass instance = new YourClass(); [EOL] Object result = instance.saveState(); [EOL] assertNotNull("Saved state should not be null", result); [EOL] assertTrue("Result should be instance of SavedState", result instanceof SavedState); [EOL] } [EOL] public void testSaveState_ExistingState() { [EOL] YourClass instance = new YourClass(); [EOL] Object firstCallResult = instance.saveState(); [EOL] Object secondCallResult = instance.saveState(); [EOL] assertSame("Subsequent calls should return the same saved state object", firstCallResult, secondCallResult); [EOL] }
public void testRestoreStateWithSavedStateAndSuccessfulRestore() { [EOL] Time time = new Time(); [EOL] Object savedState = new SavedState() { [EOL] public boolean restoreState(Time time) { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = time.restoreState(savedState); [EOL] assertTrue(result); [EOL] assertEquals(savedState, time.getSavedState()); [EOL] }
public void testRestoreStateWithSavedStateAndUnsuccessfulRestore() { [EOL] Time time = new Time(); [EOL] Object savedState = new SavedState() { [EOL] public boolean restoreState(Time time) { [EOL] return false; [EOL] } [EOL] }; [EOL] boolean result = time.restoreState(savedState); [EOL] assertFalse(result); [EOL] assertNotEquals(savedState, time.getSavedState()); [EOL] }
public void testRestoreStateWithNonSavedState() { [EOL] Time time = new Time(); [EOL] Object savedState = new Object(); [EOL] boolean result = time.restoreState(savedState); [EOL] assertFalse(result); [EOL] }
public long computeMillis(boolean resetFields, String text) { [EOL] SavedField[] savedFields = iSavedFields; [EOL] int count = iSavedFieldsCount; [EOL] if (iSavedFieldsShared) { [EOL] iSavedFields = savedFields = (SavedField[]) iSavedFields.clone(); [EOL] iSavedFieldsShared = false; [EOL] } [EOL] sort(savedFields, count); [EOL] if (count > 0) { [EOL] DurationField months = DurationFieldType.months().getField(iChrono); [EOL] DurationField days = DurationFieldType.days().getField(iChrono); [EOL] DurationField first = savedFields[0].iField.getDurationField(); [EOL] if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { [EOL] saveField(DateTimeFieldType.year(), iDefaultYear); [EOL] return computeMillis(resetFields, text); [EOL] } [EOL] } [EOL] long millis = iMillis; [EOL] try { [EOL] for (int i = 0; i < count; i++) { [EOL] millis = savedFields[i].set(millis, resetFields); [EOL] } [EOL] if (resetFields) { [EOL] for (int i = 0; i < count; i++) { [EOL] millis = savedFields[i].set(millis, i == (count - 1)); [EOL] } [EOL] } [EOL] } catch (IllegalFieldValueException e) { [EOL] if (text != null) { [EOL] e.prependMessage("Cannot parse \"" + text + '"'); [EOL] } [EOL] throw e; [EOL] } [EOL] if (iOffset != null) { [EOL] millis -= iOffset; [EOL] } else if (iZone != null) { [EOL] int offset = iZone.getOffsetFromLocal(millis); [EOL] millis -= offset; [EOL] if (offset != iZone.getOffset(millis)) { [EOL] String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; [EOL] if (text != null) { [EOL] message = "Cannot parse \"" + text + "\": " + message; [EOL] } [EOL] throw new IllegalInstantException(message); [EOL] } [EOL] } [EOL] return millis; [EOL] }
public void testSortWithHighGreaterThan10() { [EOL] SavedField[] array = new SavedField[20]; [EOL] for (int i = 0; i < array.length; i++) { [EOL] array[i] = new SavedField(); [EOL] array[i].setValue(20 - i); [EOL] } [EOL] Time.sort(array, 15); [EOL] for (int i = 0; i < 14; i++) { [EOL] assertTrue(array[i].compareTo(array[i + 1]) <= 0); [EOL] } [EOL] }
public void testSortWithHighNotGreaterThan10() { [EOL] SavedField[] array = new SavedField[10]; [EOL] for (int i = 0; i < array.length; i++) { [EOL] array[i] = new SavedField(); [EOL] array[i].setValue(10 - i); [EOL] } [EOL] Time.sort(array, 9); [EOL] for (int i = 0; i < 8; i++) { [EOL] assertTrue(array[i].compareTo(array[i + 1]) <= 0); [EOL] } [EOL] }
public void testSavedState() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] DateTimeParserBucket.SavedState state = bucket.new SavedState(); [EOL] assertEquals(bucket.iZone, state.iZone); [EOL] assertEquals(bucket.iOffset, state.iOffset); [EOL] assertEquals(bucket.iSavedFields, state.iSavedFields); [EOL] assertEquals(bucket.iSavedFieldsCount, state.iSavedFieldsCount); [EOL] }
public void testRestoreStateWithSameObject() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] boolean result = bucket.restoreState(bucket); [EOL] assertTrue(result); [EOL] assertEquals(bucket.iZone, bucket.iZone); [EOL] assertEquals(bucket.iOffset, bucket.iOffset); [EOL] assertEquals(bucket.iSavedFields, bucket.iSavedFields); [EOL] assertEquals(bucket.iSavedFieldsCount, bucket.iSavedFieldsCount); [EOL] }
public void testRestoreStateWithDifferentObject() { [EOL] DateTimeParserBucket bucket1 = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] DateTimeParserBucket bucket2 = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] boolean result = bucket1.restoreState(bucket2); [EOL] assertFalse(result); [EOL] }
public void testRestoreStateWithSharedFields() { [EOL] DateTimeParserBucket bucket1 = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] DateTimeParserBucket bucket2 = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] bucket1.iSavedFields = new Object[10]; [EOL] bucket1.iSavedFieldsCount = 5; [EOL] bucket2.iSavedFields = new Object[5]; [EOL] bucket2.iSavedFieldsCount = 3; [EOL] boolean result = bucket1.restoreState(bucket2); [EOL] assertTrue(result); [EOL] assertTrue(bucket2.iSavedFieldsShared); [EOL] assertEquals(bucket1.iSavedFieldsCount, bucket2.iSavedFieldsCount); [EOL] }
public void testSavedFieldWithNonNullFieldAndPositiveValue() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] int value = 10; [EOL] SavedField savedField = new SavedField(field, value); [EOL] assertNotNull(savedField.iField); [EOL] assertEquals(value, savedField.iValue); [EOL] assertNull(savedField.iText); [EOL] assertNull(savedField.iLocale); [EOL] }
public void testSavedFieldWithNullFieldAndNegativeValue() { [EOL] DateTimeField field = null; [EOL] int value = -10; [EOL] SavedField savedField = new SavedField(field, value); [EOL] assertNull(savedField.iField); [EOL] assertEquals(value, savedField.iValue); [EOL] assertNull(savedField.iText); [EOL] assertNull(savedField.iLocale); [EOL] }
public void testSetWithNullTextAndResetTrue() { [EOL] long initialMillis = System.currentTimeMillis(); [EOL] long expectedMillis = iField.roundFloor(iField.set(initialMillis, iValue)); [EOL] long actualMillis = set(initialMillis, true); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSetWithNullTextAndResetFalse() { [EOL] long initialMillis = System.currentTimeMillis(); [EOL] long expectedMillis = iField.set(initialMillis, iValue); [EOL] long actualMillis = set(initialMillis, false); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSetWithNonNullTextAndResetTrue() { [EOL] long initialMillis = System.currentTimeMillis(); [EOL] long expectedMillis = iField.roundFloor(iField.set(initialMillis, iText, iLocale)); [EOL] long actualMillis = set(initialMillis, true); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSetWithNonNullTextAndResetFalse() { [EOL] long initialMillis = System.currentTimeMillis(); [EOL] long expectedMillis = iField.set(initialMillis, iText, iLocale); [EOL] long actualMillis = set(initialMillis, false); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCompareTo_DifferentRangeDurationFields() { [EOL] SavedField field1 = createSavedFieldWithRangeDurationField(10); [EOL] SavedField field2 = createSavedFieldWithRangeDurationField(5); [EOL] int result = field1.compareTo(field2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_SameRangeDifferentDurationFields() { [EOL] SavedField field1 = createSavedFieldWithSameRangeDifferentDurationField(10); [EOL] SavedField field2 = createSavedFieldWithSameRangeDifferentDurationField(5); [EOL] int result = field1.compareTo(field2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_SameRangeSameDurationFields() { [EOL] SavedField field1 = createSavedFieldWithSameRangeSameDurationField(); [EOL] SavedField field2 = createSavedFieldWithSameRangeSameDurationField(); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareReverseBothFieldsNull() { [EOL] DurationField a = null; [EOL] DurationField b = null; [EOL] int result = compareReverse(a, b); [EOL] assertEquals(0, result); [EOL] }
public void testCompareReverseFirstFieldNull() { [EOL] DurationField a = null; [EOL] DurationField b = new MockDurationField(true); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareReverseSecondFieldNull() { [EOL] DurationField a = new MockDurationField(true); [EOL] DurationField b = null; [EOL] int result = compareReverse(a, b); [EOL] assertEquals(1, result); [EOL] }
public void testCompareReverseFirstFieldNotSupported() { [EOL] DurationField a = new MockDurationField(false); [EOL] DurationField b = new MockDurationField(true); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareReverseSecondFieldNotSupported() { [EOL] DurationField a = new MockDurationField(true); [EOL] DurationField b = new MockDurationField(false); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(1, result); [EOL] }
public void testCompareReverseBothFieldsSupported() { [EOL] DurationField a = new MockDurationField(true); [EOL] DurationField b = new MockDurationField(true); [EOL] when(a.compareTo(b)).thenReturn(1); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testRoundHalfCeiling() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = EXPECTED_RESULT; [EOL] long actual = roundHalfCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetOffset() { [EOL] Time time = new Time(5); // Assuming there is a constructor that sets the iOffset [EOL] int offset = time.getOffset(); [EOL] assertEquals(5, offset); [EOL] }
public void testBasicFixedMonthChronology() { [EOL] Chronology base = null; // Assuming Chronology is an interface or class that can be instantiated or mocked [EOL] Object param = new Object(); [EOL] int minDaysInFirstWeek = 1; [EOL] BasicFixedMonthChronology chronology = new BasicFixedMonthChronology(base, param, minDaysInFirstWeek); [EOL] assertNotNull(chronology); [EOL] }
public void testGetYearDifference_SameYear() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expected = 0; [EOL] long actual = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetYearDifference_OneYearApart() { [EOL] long minuendInstant = 1609459200000L; // 2021-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expected = 1; [EOL] long actual = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetYearDifference_OneYearApart_Reversed() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1609459200000L; // 2021-01-01T00:00:00Z [EOL] long expected = -1; [EOL] long actual = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetYearDifference_WithRemainderLess() { [EOL] long minuendInstant = 1609459200000L; // 2021-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577923200000L; // 2020-01-02T00:00:00Z [EOL] long expected = 0; [EOL] long actual = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetYearDifference_WithRemainderMore() { [EOL] long minuendInstant = 1609545600000L; // 2021-01-02T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expected = 1; [EOL] long actual = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public int getWeekOfWeekyearTest() { [EOL] long instant = /* some instant representing a specific time */; [EOL] int expectedWeek = /* the expected week of the year for the given instant */; [EOL] int actualWeek = iChronology.getWeekOfWeekyear(instant); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetRangeDurationField() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.weekyear(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DurationField field = fieldType.getDurationField(chronology); [EOL] DurationField rangeField = fieldType.getRangeDurationField(chronology); [EOL] assertEquals("Range duration field should be the same as weekyears from the chronology", field, rangeField); [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL] return value > 52 ? getMaximumValue(instant) : 52; [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagSet() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] long instant = 0L; [EOL] int hourOfDay = 12; [EOL] int minuteOfHour = 0; [EOL] int secondOfMinute = 0; [EOL] int millisOfSecond = 0; [EOL] Mockito.when(mockChronology.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(12345L); [EOL] this.iBase = mockChronology; [EOL] this.iBaseFlags = 1; [EOL] long result = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(12345L, result); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagNotSet() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] long instant = 0L; [EOL] int hourOfDay = 12; [EOL] int minuteOfHour = 0; [EOL] int secondOfMinute = 0; [EOL] int millisOfSecond = 0; [EOL] Mockito.when(mockChronology.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(12345L); [EOL] this.iBase = mockChronology; [EOL] this.iBaseFlags = 0; // Flag is not set [EOL] long result = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(12345L, result); [EOL] }
public void testGetDateTimeMillis_BaseNull() { [EOL] long instant = 0L; [EOL] int hourOfDay = 12; [EOL] int minuteOfHour = 0; [EOL] int secondOfMinute = 0; [EOL] int millisOfSecond = 0; [EOL] this.iBase = null; [EOL] long result = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(super.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond), result); [EOL] }
public void testMinutesField() { [EOL] Time time = new Time(); [EOL] DurationField minutesField = time.minutes(); [EOL] assertNotNull(minutesField); [EOL] }
public void testHours() { [EOL] DurationField expected = iHours; [EOL] DurationField actual = instance.hours(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardHours() { [EOL] Days days = Days.days(1); [EOL] Hours result = days.toStandardHours(); [EOL] assertEquals(24, result.getHours()); [EOL] }
public void testToStandardHoursWithZeroDays() { [EOL] Days days = Days.days(0); [EOL] Hours result = days.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHoursWithNegativeDays() { [EOL] Days days = Days.days(-1); [EOL] Hours result = days.toStandardHours(); [EOL] assertEquals(-24, result.getHours()); [EOL] }
public int getDays() { [EOL] return getValue(); [EOL] }
public void testPlus_withNull() { [EOL] Days originalDays = Days.of(5); [EOL] Days result = originalDays.plus(null); [EOL] assertEquals("Adding null should return the original Days object", originalDays, result); [EOL] }
public void testPlus_withNonNull() { [EOL] Days originalDays = Days.of(5); [EOL] Days daysToAdd = Days.of(3); [EOL] Days result = originalDays.plus(daysToAdd); [EOL] assertEquals("Adding non-null Days should return the correct result", Days.of(8), result); [EOL] }
public void testGetWithPositiveYear() { [EOL] long instant = /* some positive year instant */; [EOL] int expected = /* expected year */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithNegativeYear() { [EOL] long instant = /* some negative year instant */; [EOL] int expected = /* expected positive year */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithYearZero() { [EOL] long instant = /* instant representing year 0 */; [EOL] int expected = 1; // Year 0 should be converted to 1 [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testNow() { [EOL] MonthDay result = MonthDay.now(); [EOL] assertNotNull(result); [EOL] }
public void testNowWithDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay result = MonthDay.now(zone); [EOL] assertNotNull(result); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay result = MonthDay.now(chronology); [EOL] assertNotNull(result); [EOL] }
public void testParseString() { [EOL] String str = "--12-03"; [EOL] MonthDay result = MonthDay.parse(str); [EOL] assertEquals(12, result.getMonthOfYear()); [EOL] assertEquals(3, result.getDayOfMonth()); [EOL] }
public void testParseStringWithFormatter() { [EOL] String str = "--12-03"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("--MM-dd"); [EOL] MonthDay result = MonthDay.parse(str, formatter); [EOL] assertEquals(12, result.getMonthOfYear()); [EOL] assertEquals(3, result.getDayOfMonth()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.DECEMBER); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 3); [EOL] MonthDay result = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(12, result.getMonthOfYear()); [EOL] assertEquals(3, result.getDayOfMonth()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.DECEMBER, 3).getTime(); [EOL] MonthDay result = MonthDay.fromDateFields(date); [EOL] assertEquals(12, result.getMonthOfYear()); [EOL] assertEquals(3, result.getDayOfMonth()); [EOL] }
public void testConstructorWithMonthAndDay() { [EOL] int monthOfYear = 12; [EOL] int dayOfMonth = 3; [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] }
public void testConstructorWithMonthDayAndChronology() { [EOL] int monthOfYear = 12; [EOL] int dayOfMonth = 3; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testWithMonthOfYear() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int monthOfYear = 12; [EOL] MonthDay updatedMonthDay = monthDay.withMonthOfYear(monthOfYear); [EOL] assertEquals(monthOfYear, updatedMonthDay.getMonthOfYear()); [EOL] }
public void testWithDayOfMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int dayOfMonth = 3; [EOL] MonthDay updatedMonthDay = monthDay.withDayOfMonth(dayOfMonth); [EOL] assertEquals(dayOfMonth, updatedMonthDay.getDayOfMonth()); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] }
public void testMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new LocalDate(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new LocalDate(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertNotNull(monthDay); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] int monthOfYear = 1; [EOL] int dayOfMonth = 1; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] int monthOfYear = 1; [EOL] int dayOfMonth = 1; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayPartialConstructor() { [EOL] MonthDay partial = new MonthDay(); [EOL] int[] values = new int[] {1, 1}; [EOL] MonthDay monthDay = new MonthDay(partial, values); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayPartialChronoConstructor() { [EOL] MonthDay partial = new MonthDay(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(partial, chrono); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayPropertyConstructor() { [EOL] MonthDay partial = new MonthDay(); [EOL] int fieldIndex = 0; [EOL] MonthDay.Property property = new MonthDay.Property(partial, fieldIndex); [EOL] assertNotNull(property); [EOL] }
public void testMonthDayNow() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayNowZone() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayParseString() { [EOL] String str = "--01-01"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayParseStringFormatter() { [EOL] String str = "--01-01"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.monthDay(); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.JANUARY); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 1); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromDateFields() { [EOL] Date date = new Date(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, monthDay.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayWithPartialAndChronology() { [EOL] MonthDay partial = new MonthDay(5, 1); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] MonthDay result = new MonthDay(partial, chrono); [EOL] assertEquals(5, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(chrono, result.getChronology()); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay result = new MonthDay(); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay result = new MonthDay(zone); [EOL] assertEquals(zone, result.getChronology().getZone()); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(chronology); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay result = new MonthDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(instant, chronology); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] MonthDay result = new MonthDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(instant, chronology); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testGetFieldTypes() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] DateTimeFieldType[] fieldTypes = monthDay.getFieldTypes(); [EOL] assertNotNull("Field types should not be null", fieldTypes); [EOL] assertEquals("There should be 2 field types", 2, fieldTypes.length); [EOL] assertEquals("First field type should be monthOfYear", DateTimeFieldType.monthOfYear(), fieldTypes[0]); [EOL] assertEquals("Second field type should be dayOfMonth", DateTimeFieldType.dayOfMonth(), fieldTypes[1]); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] MonthDay original = new MonthDay(); [EOL] Chronology originalChrono = original.getChronology(); [EOL] MonthDay result = original.withChronologyRetainFields(originalChrono); [EOL] assertSame("Expected same instance when chronology is the same", original, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] MonthDay original = new MonthDay(); [EOL] Chronology newChrono = ISOChronology.getInstanceUTC(); [EOL] if (original.getChronology().equals(newChrono)) { [EOL] newChrono = BuddhistChronology.getInstance(); [EOL] } [EOL] MonthDay result = original.withChronologyRetainFields(newChrono); [EOL] assertNotSame("Expected different instance when chronology is different", original, result); [EOL] assertEquals("Expected different chronology", newChrono, result.getChronology()); [EOL] }
public void testWithFieldSameValue() { [EOL] MonthDay original = new MonthDay(5, 15); [EOL] MonthDay result = original.withField(DateTimeFieldType.dayOfMonth(), 15); [EOL] assertSame("Expected same instance when setting same value", original, result); [EOL] }
public void testWithFieldDifferentValue() { [EOL] MonthDay original = new MonthDay(5, 15); [EOL] MonthDay result = original.withField(DateTimeFieldType.dayOfMonth(), 20); [EOL] assertNotSame("Expected different instance when setting different value", original, result); [EOL] assertEquals("Expected day of month to be updated", 20, result.getDayOfMonth()); [EOL] }
public void testWithFieldUnsupportedType() { [EOL] MonthDay original = new MonthDay(5, 15); [EOL] try { [EOL] original.withField(DateTimeFieldType.hourOfDay(), 10); [EOL] fail("Expected exception when setting unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public MonthDay minusMonths(int months) { [EOL] return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } [EOL] public MonthDay() {} [EOL] public MonthDay(DateTimeZone zone) {} [EOL] public MonthDay(Chronology chronology) {} [EOL] public MonthDay(long instant) {} [EOL] public MonthDay(long instant, Chronology chronology) {} [EOL] public MonthDay(Object instant) {} [EOL] public MonthDay(Object instant, Chronology chronology) {} [EOL] public MonthDay(int monthOfYear, int dayOfMonth) {} [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {} [EOL] MonthDay(MonthDay partial, int[] values) {} [EOL] MonthDay(MonthDay partial, Chronology chrono) {} [EOL] Property(MonthDay partial, int fieldIndex) {} [EOL] public static MonthDay now() {} [EOL] public static MonthDay now(DateTimeZone zone) {} [EOL] public static MonthDay now(Chronology chronology) {} [EOL] public static MonthDay parse(String str) {} [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter) {} [EOL] public static MonthDay fromCalendarFields(Calendar calendar) {} [EOL] public static MonthDay fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public MonthDay plus(ReadablePeriod period) {} [EOL] public MonthDay plusMonths(int months) {} [EOL] public MonthDay plusDays(int days) {} [EOL] public MonthDay minus(ReadablePeriod period) {} [EOL] public MonthDay minusMonths(int months) {} [EOL] public MonthDay minusDays(int days) {} [EOL] public LocalDate toLocalDate(int year) {} [EOL] public int getMonthOfYear() {} [EOL] public int getDayOfMonth() {} [EOL] public MonthDay withMonthOfYear(int monthOfYear) {} [EOL] public MonthDay withDayOfMonth(int dayOfMonth) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property monthOfYear() {} [EOL] public Property dayOfMonth() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public MonthDay getMonthDay() {} [EOL] public int get() {} [EOL] public MonthDay addToCopy(int valueToAdd) {} [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public MonthDay setCopy(int value) {} [EOL] public MonthDay setCopy(String text, Locale locale) {} [EOL] public MonthDay setCopy(String text) {} [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testMinusDays_Normal() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay result = original.minusDays(1); [EOL] assertEquals(new MonthDay(4, 30), result); // Should be April 30th [EOL] } [EOL] public void testMinusDays_OverMonthBoundary() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay result = original.minusDays(2); [EOL] assertEquals(new MonthDay(4, 29), result); // Should be April 29th [EOL] } [EOL] public void testMinusDays_Negative() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay result = original.minusDays(-1); [EOL] assertEquals(new MonthDay(5, 2), result); // Should be May 2nd [EOL] } [EOL] public void testMinusDays_Zero() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay result = original.minusDays(0); [EOL] assertEquals(original, result); // Should be the same instance [EOL] }
public void testToStringWithNullPattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String result = monthDay.toString(null, Locale.getDefault()); [EOL] assertEquals(monthDay.toString(), result); [EOL] }
public void testToStringWithValidPatternAndLocale() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String result = monthDay.toString(pattern, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("\\d{2}-\\d{2}")); [EOL] }
public void testToStringWithInvalidPattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "invalid-pattern"; [EOL] Locale locale = Locale.US; [EOL] try { [EOL] monthDay.toString(pattern, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public MonthDay addToCopy(int valueToAdd) { [EOL] int[] newValues = iBase.getValues(); [EOL] newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL] return new MonthDay(iBase, newValues); [EOL] } [EOL] public MonthDay() {} [EOL] public MonthDay(DateTimeZone zone) {} [EOL] public MonthDay(Chronology chronology) {} [EOL] public MonthDay(long instant) {} [EOL] public MonthDay(long instant, Chronology chronology) {} [EOL] public MonthDay(Object instant) {} [EOL] public MonthDay(Object instant, Chronology chronology) {} [EOL] public MonthDay(int monthOfYear, int dayOfMonth) {} [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {} [EOL] MonthDay(MonthDay partial, int[] values) {} [EOL] MonthDay(MonthDay partial, Chronology chrono) {} [EOL] Property(MonthDay partial, int fieldIndex) {} [EOL] public static MonthDay now() {} [EOL] public static MonthDay now(DateTimeZone zone) {} [EOL] public static MonthDay now(Chronology chronology) {} [EOL] public static MonthDay parse(String str) {} [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter) {} [EOL] public static MonthDay fromCalendarFields(Calendar calendar) {} [EOL] public static MonthDay fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public MonthDay plus(ReadablePeriod period) {} [EOL] public MonthDay plusMonths(int months) {} [EOL] public MonthDay plusDays(int days) {} [EOL] public MonthDay minus(ReadablePeriod period) {} [EOL] public MonthDay minusMonths(int months) {} [EOL] public MonthDay minusDays(int days) {} [EOL] public LocalDate toLocalDate(int year) {} [EOL] public int getMonthOfYear() {} [EOL] public int getDayOfMonth() {} [EOL] public MonthDay withMonthOfYear(int monthOfYear) {} [EOL] public MonthDay withDayOfMonth(int dayOfMonth) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property monthOfYear() {} [EOL] public Property dayOfMonth() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public MonthDay getMonthDay() {} [EOL] public int get() {} [EOL] public MonthDay addToCopy(int valueToAdd) {} [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public MonthDay setCopy(int value) {} [EOL] public MonthDay setCopy(String text, Locale locale) {} [EOL] public MonthDay setCopy(String text) {} [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testSetCopyWithValidTextAndLocale() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Locale locale = Locale.ENGLISH; [EOL] String validText = "January 1"; [EOL] MonthDay updatedMonthDay = monthDay.setCopy(validText, locale); [EOL] assertNotNull(updatedMonthDay); [EOL] assertNotSame(monthDay, updatedMonthDay); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Locale locale = Locale.ENGLISH; [EOL] String invalidText = "Invalid"; [EOL] try { [EOL] monthDay.setCopy(invalidText, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String validText = "January 1"; [EOL] try { [EOL] monthDay.setCopy(validText, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetCopyWithString() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String text = "01-01"; [EOL] MonthDay result = monthDay.setCopy(text); [EOL] assertNotNull(result); [EOL] assertEquals(new MonthDay(1, 1), result); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(), monthDay); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(zone), monthDay); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(chronology), monthDay); [EOL] }
public void testMonthDayInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(instant), monthDay); [EOL] }
public void testMonthDayInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(instant, chronology), monthDay); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(instant), monthDay); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(instant, chronology), monthDay); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] int monthOfYear = 1; [EOL] int dayOfMonth = 1; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(monthOfYear, dayOfMonth), monthDay); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] int monthOfYear = 1; [EOL] int dayOfMonth = 1; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(new MonthDay(monthOfYear, dayOfMonth, chronology), monthDay); [EOL] }
public void testNow() { [EOL] MonthDay now = MonthDay.now(); [EOL] assertNotNull(now); [EOL] assertEquals(new MonthDay(), now); [EOL] }
public void testNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay now = MonthDay.now(zone); [EOL] assertNotNull(now); [EOL] assertEquals(new MonthDay(zone), now); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay now = MonthDay.now(chronology); [EOL] assertNotNull(now); [EOL] assertEquals(new MonthDay(chronology), now); [EOL] }
public void testParseString() { [EOL] String str = "--01-01"; [EOL] MonthDay parsed = MonthDay.parse(str); [EOL] assertNotNull(parsed); [EOL] assertEquals(new MonthDay(1, 1), parsed); [EOL] }
public void testParseStringFormatter() { [EOL] String str = "--01-01"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("--MM-dd"); [EOL] MonthDay parsed = MonthDay.parse(str, formatter); [EOL] assertNotNull(parsed); [EOL] assertEquals(new MonthDay(1, 1), parsed); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.JANUARY); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 1); [EOL] MonthDay fromCalendar = MonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(fromCalendar); [EOL] assertEquals(new MonthDay(1, 1), fromCalendar); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] MonthDay fromDate = MonthDay.fromDateFields(date); [EOL] assertNotNull(fromDate); [EOL] assertEquals(new MonthDay(date), fromDate); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDateTime.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNegativeTime() { [EOL] Date date = new Date(-1); [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] }
public void testFromDateFieldsWithPositiveTime() { [EOL] Date date = new Date(1); [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(1970, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(1, result.getMillisOfSecond()); [EOL] }
public void testLocalDateTimeWithInstantAndZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalDateTime localDateTime = new LocalDateTime(instant, zone); [EOL] assertNotNull(localDateTime); [EOL] assertEquals(zone, localDateTime.getChronology().getZone()); [EOL] }
public void testLocalDateTimeWithPartialAndZone() { [EOL] Partial partial = new LocalDate(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] LocalDateTime localDateTime = new LocalDateTime(partial, zone); [EOL] assertNotNull(localDateTime); [EOL] assertEquals(DateTimeZone.UTC, localDateTime.getChronology().getZone()); [EOL] }
public void testLocalDateTimeWithNullInstantAndZone() { [EOL] Object instant = null; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] try { [EOL] new LocalDateTime(instant, zone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateTimeWithInstantAndNullZone() { [EOL] Object instant = new Instant(); [EOL] DateTimeZone zone = null; [EOL] LocalDateTime localDateTime = new LocalDateTime(instant, zone); [EOL] assertNotNull(localDateTime); [EOL] assertEquals(DateTimeZone.UTC, localDateTime.getChronology().getZone()); [EOL] }
public void testLocalDateTimeWithNullInstantAndChronology() { [EOL] LocalDateTime result = new LocalDateTime(null, null); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstanceUTC(), result.getChronology()); [EOL] }
public void testLocalDateTimeWithValidInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] LocalDateTime result = new LocalDateTime(instant, null); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstanceUTC(), result.getChronology()); [EOL] }
public void testLocalDateTimeWithValidInstantAndChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] LocalDateTime result = new LocalDateTime(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology.withUTC(), result.getChronology()); [EOL] }
public void testLocalDateTimeWithValidParameters() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 15, 11, 30); [EOL] assertNotNull(dateTime); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(15, dateTime.getDayOfMonth()); [EOL] assertEquals(11, dateTime.getHourOfDay()); [EOL] assertEquals(30, dateTime.getMinuteOfHour()); [EOL] assertEquals(0, dateTime.getSecondOfMinute()); [EOL] assertEquals(0, dateTime.getMillisOfSecond()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), dateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithValidValues() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 14, 15, 9, 26); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(14, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(9, dateTime.getMinuteOfHour()); [EOL] assertEquals(26, dateTime.getSecondOfMinute()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), dateTime.getChronology()); [EOL] }
public void testGetValue_YEAR() { [EOL] int index = YEAR; // Assuming YEAR is a constant defined somewhere [EOL] int expectedValue = 2023; // Assuming this is the expected year value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_MONTH_OF_YEAR() { [EOL] int index = MONTH_OF_YEAR; // Assuming MONTH_OF_YEAR is a constant defined somewhere [EOL] int expectedValue = 4; // Assuming this is the expected month value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_DAY_OF_MONTH() { [EOL] int index = DAY_OF_MONTH; // Assuming DAY_OF_MONTH is a constant defined somewhere [EOL] int expectedValue = 15; // Assuming this is the expected day of month value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_MILLIS_OF_DAY() { [EOL] int index = MILLIS_OF_DAY; // Assuming MILLIS_OF_DAY is a constant defined somewhere [EOL] int expectedValue = 123456789; // Assuming this is the expected millis of day value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_InvalidIndex() { [EOL] int index = -1; // Assuming this is an invalid index [EOL] try { [EOL] getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Invalid index: " + index, e.getMessage()); [EOL] } [EOL] }
public void testGetWithNullType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testGetWithValidType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int year = testDateTime.get(DateTimeFieldType.year()); [EOL] assertEquals(testDateTime.getChronology().year().get(testDateTime.getLocalMillis()), year); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = isSupported(null); [EOL] assert !result; [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = // ... initialize with an unsupported type [EOL] boolean result = isSupported(unsupportedType); [EOL] assert !result; [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = // ... initialize with a supported type [EOL] boolean result = isSupported(supportedType); [EOL] assert result; [EOL] }
public void testToDateTimeWithNullZone() { [EOL] DateTime testDateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] DateTime result = testDateTime.toDateTime(null); [EOL] assertNotNull(result); [EOL] assertEquals(testDateTime.getChronology().withZone(DateTimeZone.UTC), result.getChronology()); [EOL] }
public void testToDateTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime testDateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] DateTime result = testDateTime.toDateTime(zone); [EOL] assertNotNull(result); [EOL] assertEquals(testDateTime.getChronology().withZone(zone), result.getChronology()); [EOL] }
public LocalDateTime plusTestWithNullPeriod() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plus(null); [EOL] assertEquals(dateTime, result); [EOL] }
public LocalDateTime plusTestWithNonNullPeriod() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] Period period = Period.ofDays(1); [EOL] LocalDateTime expected = dateTime.plusDays(1); [EOL] LocalDateTime result = dateTime.plus(period); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusDays(0); [EOL] assertSame(dateTime, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusDays(10); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.plusDays(10), result); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusDays(-10); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.plusDays(-10), result); [EOL] }
public void testMinusYears_ZeroYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusYears(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusYears_PositiveYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusYears(5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.getYear() - 5, result.getYear()); [EOL] }
public void testMinusYears_NegativeYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusYears(-5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.getYear() + 5, result.getYear()); [EOL] }
public void testMinusMinutes_Zero() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMinutes(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusMinutes_Negative() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMinutes(-30); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.plusMinutes(30), result); [EOL] }
public void testMinusMinutes_Positive() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMinutes(30); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.minusMinutes(30), result); [EOL] }
public int getEra() { [EOL] return getChronology().era().get(getLocalMillis()); [EOL] }
public void testGetCenturyOfEra() { [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] DateTimeField mockCenturyOfEraField = mock(DateTimeField.class); [EOL] when(mockChronology.centuryOfEra()).thenReturn(mockCenturyOfEraField); [EOL] when(mockCenturyOfEraField.get(anyLong())).thenReturn(21); [EOL] MyClass myClassInstance = new MyClass(mockChronology); [EOL] int result = myClassInstance.getCenturyOfEra(); [EOL] assertEquals(21, result); [EOL] }
public void testGetYearOfEra() { [EOL] DateTime dateTime = new DateTime(2023, 1, 1, 0, 0, 0, 0); [EOL] int yearOfEra = dateTime.getYearOfEra(); [EOL] assertEquals(2023, yearOfEra); [EOL] }
public int getYearOfCentury() { [EOL] return getChronology().yearOfCentury().get(getLocalMillis()); [EOL] }
public int getWeekyear() { [EOL] return getChronology().weekyear().get(getLocalMillis()); [EOL] }
public void testGetWeekOfWeekyear() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockWeekField = Mockito.mock(DateTimeField.class); [EOL] long testMillis = 1234567890L; [EOL] int expectedWeek = 10; [EOL] Mockito.when(mockChronology.weekOfWeekyear()).thenReturn(mockWeekField); [EOL] Mockito.when(mockWeekField.get(testMillis)).thenReturn(expectedWeek); [EOL] Time time = new Time(mockChronology, testMillis); [EOL] int actualWeek = time.getWeekOfWeekyear(); [EOL] assertEquals("The week of the weekyear should be the expected value", expectedWeek, actualWeek); [EOL] }
public int getDayOfYear() { [EOL] return getChronology().dayOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfWeek() { [EOL] return getChronology().dayOfWeek().get(getLocalMillis()); [EOL] }
public int getMillisOfDay() { [EOL] return getChronology().millisOfDay().get(getLocalMillis()); [EOL] }
public void testWithEra_ValidEra() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int validEra = DateTimeConstants.BCE; [EOL] LocalDateTime newDateTime = dateTime.withEra(validEra); [EOL] assertEquals(validEra, newDateTime.getEra()); [EOL] }
public void testWithEra_InvalidEra() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int invalidEra = -1; // Assuming -1 is not a valid era [EOL] try { [EOL] dateTime.withEra(invalidEra); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithCenturyOfEra_ValidCentury() { [EOL] LocalDateTime dateTime = new LocalDateTime(2000, 1, 1, 0, 0); [EOL] int validCentury = 21; [EOL] LocalDateTime updatedDateTime = dateTime.withCenturyOfEra(validCentury); [EOL] assertEquals(21, updatedDateTime.getCenturyOfEra()); [EOL] }
public void testWithCenturyOfEra_NegativeCentury() { [EOL] LocalDateTime dateTime = new LocalDateTime(2000, 1, 1, 0, 0); [EOL] int negativeCentury = -1; [EOL] try { [EOL] dateTime.withCenturyOfEra(negativeCentury); [EOL] fail("Should have thrown an exception for negative century"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithCenturyOfEra_ZeroCentury() { [EOL] LocalDateTime dateTime = new LocalDateTime(2000, 1, 1, 0, 0); [EOL] int zeroCentury = 0; [EOL] LocalDateTime updatedDateTime = dateTime.withCenturyOfEra(zeroCentury); [EOL] assertEquals(0, updatedDateTime.getCenturyOfEra()); [EOL] }
public void testWithYearOfEra_ValidYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int validYear = 2023; [EOL] LocalDateTime updatedDateTime = dateTime.withYearOfEra(validYear); [EOL] assertEquals(validYear, updatedDateTime.getYearOfEra()); [EOL] }
public void testWithYearOfEra_InvalidYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int invalidYear = -1; // Assuming the yearOfEra cannot be negative [EOL] try { [EOL] dateTime.withYearOfEra(invalidYear); [EOL] fail("Should have thrown an exception for invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYearOfCentury_ValidYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(2000, 1, 1, 0, 0); [EOL] int yearOfCentury = 50; [EOL] LocalDateTime updatedDateTime = dateTime.withYearOfCentury(yearOfCentury); [EOL] assertEquals(1950, updatedDateTime.getYear()); [EOL] }
public void testWithYearOfCentury_InvalidYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(2000, 1, 1, 0, 0); [EOL] int yearOfCentury = -1; [EOL] try { [EOL] dateTime.withYearOfCentury(yearOfCentury); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYear_ValidYear() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int validYear = 2023; [EOL] LocalDateTime updatedDateTime = dateTime.withYear(validYear); [EOL] assertEquals(validYear, updatedDateTime.getYear()); [EOL] }
public void testWithYear_InvalidYear() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int invalidYear = -1; // Assuming the year cannot be negative [EOL] try { [EOL] dateTime.withYear(invalidYear); [EOL] fail("Should have thrown an exception for invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekyear_ValidWeekyear() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int validWeekyear = 2023; [EOL] LocalDateTime updatedDateTime = dateTime.withWeekyear(validWeekyear); [EOL] assertEquals(validWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithWeekyear_NegativeWeekyear() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int negativeWeekyear = -1; [EOL] LocalDateTime updatedDateTime = dateTime.withWeekyear(negativeWeekyear); [EOL] assertEquals(negativeWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithWeekyear_ZeroWeekyear() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int zeroWeekyear = 0; [EOL] LocalDateTime updatedDateTime = dateTime.withWeekyear(zeroWeekyear); [EOL] assertEquals(zeroWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithMonthOfYear_ValidMonth() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withMonthOfYear(6); [EOL] assertEquals(6, updatedDateTime.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear_InvalidMonthLow() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] try { [EOL] dateTime.withMonthOfYear(0); [EOL] fail("Should have thrown an exception for month 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMonthOfYear_InvalidMonthHigh() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] try { [EOL] dateTime.withMonthOfYear(13); [EOL] fail("Should have thrown an exception for month 13"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekOfWeekyear_ValidWeek() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] int validWeek = 10; [EOL] LocalDateTime updatedDateTime = dateTime.withWeekOfWeekyear(validWeek); [EOL] assertEquals(validWeek, updatedDateTime.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_EdgeCaseStartOfYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] int firstWeek = 1; [EOL] LocalDateTime updatedDateTime = dateTime.withWeekOfWeekyear(firstWeek); [EOL] assertEquals(firstWeek, updatedDateTime.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_EdgeCaseEndOfYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 12, 31, 0, 0); [EOL] int lastWeek = dateTime.getChronology().weekOfWeekyear().getMaximumValue(); [EOL] LocalDateTime updatedDateTime = dateTime.withWeekOfWeekyear(lastWeek); [EOL] assertEquals(lastWeek, updatedDateTime.getWeekOfWeekyear()); [EOL] }
public void testWithDayOfYear_ValidDay() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); // January 1st, 2023 [EOL] int dayOfYear = 32; // February 1st, 2023 [EOL] LocalDateTime newDateTime = dateTime.withDayOfYear(dayOfYear); [EOL] assertEquals(new LocalDateTime(2023, 2, 1, 0, 0), newDateTime); [EOL] }
public void testWithDayOfYear_InvalidDayLow() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] try { [EOL] dateTime.withDayOfYear(0); [EOL] fail("Should have thrown an exception for dayOfYear being too low"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfYear_InvalidDayHigh() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 1, 1, 0, 0); [EOL] try { [EOL] dateTime.withDayOfYear(367); [EOL] fail("Should have thrown an exception for dayOfYear being too high"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_ValidDay() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int dayOfMonth = 15; // Assuming 15 is a valid day for the current month [EOL] LocalDateTime updatedDateTime = dateTime.withDayOfMonth(dayOfMonth); [EOL] assertEquals(dayOfMonth, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithDayOfMonth_InvalidDay() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int dayOfMonth = 32; // Assuming 32 is an invalid day for any month [EOL] try { [EOL] dateTime.withDayOfMonth(dayOfMonth); [EOL] fail("Should have thrown an exception for an invalid day of month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfWeek_ValidDay() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 5, 12, 0); // Arbitrary date [EOL] int dayOfWeek = 3; // Wednesday [EOL] LocalDateTime result = dateTime.withDayOfWeek(dayOfWeek); [EOL] assertEquals(3, result.getDayOfWeek()); [EOL] }
public void testWithDayOfWeek_InvalidDayLow() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 5, 12, 0); // Arbitrary date [EOL] try { [EOL] dateTime.withDayOfWeek(0); // Invalid day of week [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfWeek_InvalidDayHigh() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 5, 12, 0); // Arbitrary date [EOL] try { [EOL] dateTime.withDayOfWeek(8); // Invalid day of week [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithHourOfDay_ValidHour() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withHourOfDay(6); [EOL] assertEquals(6, updatedDateTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_MinHour() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withHourOfDay(0); [EOL] assertEquals(0, updatedDateTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_MaxHour() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withHourOfDay(23); [EOL] assertEquals(23, updatedDateTime.getHourOfDay()); [EOL] }
public void testWithMinuteOfHour_ValidMinute() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); // 12:00 PM on April 1, 2023 [EOL] int validMinute = 30; [EOL] LocalDateTime updatedDateTime = dateTime.withMinuteOfHour(validMinute); [EOL] assertEquals(30, updatedDateTime.getMinuteOfHour()); [EOL] }
public void testWithMinuteOfHour_MinuteTooLow() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); // 12:00 PM on April 1, 2023 [EOL] int invalidMinute = -1; [EOL] try { [EOL] dateTime.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown an exception for minute being too low"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMinuteOfHour_MinuteTooHigh() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0); // 12:00 PM on April 1, 2023 [EOL] int invalidMinute = 60; [EOL] try { [EOL] dateTime.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown an exception for minute being too high"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithSecondOfMinute_ValidSecond() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withSecondOfMinute(30); [EOL] assertEquals(30, updatedDateTime.getSecondOfMinute()); [EOL] } [EOL] public void testWithSecondOfMinute_EdgeCaseZero() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 59); [EOL] LocalDateTime updatedDateTime = dateTime.withSecondOfMinute(0); [EOL] assertEquals(0, updatedDateTime.getSecondOfMinute()); [EOL] } [EOL] public void testWithSecondOfMinute_EdgeCaseFiftyNine() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 0); [EOL] LocalDateTime updatedDateTime = dateTime.withSecondOfMinute(59); [EOL] assertEquals(59, updatedDateTime.getSecondOfMinute()); [EOL] } [EOL] public void testWithSecondOfMinute_InvalidSecondLow() { [EOL] try { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 0); [EOL] dateTime.withSecondOfMinute(-1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testWithSecondOfMinute_InvalidSecondHigh() { [EOL] try { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 0); [EOL] dateTime.withSecondOfMinute(60); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithMillisOfSecond_ValidMillis() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int validMillis = 123; [EOL] LocalDateTime updatedDateTime = dateTime.withMillisOfSecond(validMillis); [EOL] assertEquals(validMillis, updatedDateTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfSecond_MinMillis() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int minMillis = 0; [EOL] LocalDateTime updatedDateTime = dateTime.withMillisOfSecond(minMillis); [EOL] assertEquals(minMillis, updatedDateTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfSecond_MaxMillis() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int maxMillis = 999; [EOL] LocalDateTime updatedDateTime = dateTime.withMillisOfSecond(maxMillis); [EOL] assertEquals(maxMillis, updatedDateTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfDay_ValidMillis() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int validMillis = 12345; // Assuming this is a valid millisecond value within the day [EOL] LocalDateTime result = dateTime.withMillisOfDay(validMillis); [EOL] assertEquals(validMillis, result.get(ChronoField.MILLI_OF_DAY)); [EOL] }
public void testWithMillisOfDay_MinMillis() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int minMillis = 0; // Start of the day [EOL] LocalDateTime result = dateTime.withMillisOfDay(minMillis); [EOL] assertEquals(minMillis, result.get(ChronoField.MILLI_OF_DAY)); [EOL] }
public void testWithMillisOfDay_MaxMillis() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] int maxMillis = 86399999; // Assuming this is the last millisecond of the day [EOL] LocalDateTime result = dateTime.withMillisOfDay(maxMillis); [EOL] assertEquals(maxMillis, result.get(ChronoField.MILLI_OF_DAY)); [EOL] }
public void testHourOfDayProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.hourOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().hourOfDay(), property.getField()); [EOL] assertEquals(dateTime.getHourOfDay(), property.get()); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); [EOL] String result = time.toString(null, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] assertEquals(time.toString(), result); [EOL] }
public void testToStringWithValidPatternAndLocale() { [EOL] Time time = new Time(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = time.toString(pattern, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] String expected = manuallyFormatTime(time, pattern, Locale.ENGLISH); [EOL] assertEquals(expected, result); [EOL] }
public DateTimeField getField() { [EOL] return iField; [EOL] }
protected long getMillis() { [EOL] return iInstant.getLocalMillis(); [EOL] }
protected Chronology getChronology() { [EOL] return iInstant.getChronology(); [EOL] }
public void testSetCopy_ValidValue() { [EOL] LocalDateTime testInstant = LocalDateTime.now(); [EOL] int validValue = 5; // Assuming 5 is a valid value for the field [EOL] LocalDateTime updatedInstant = testInstant.setCopy(validValue); [EOL] assertNotEquals(testInstant, updatedInstant); [EOL] assertEquals(validValue, updatedInstant.get(testInstant.getChronology().getFieldType())); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] LocalDateTime testInstant = LocalDateTime.now(); [EOL] int invalidValue = Integer.MAX_VALUE; // Assuming this is an invalid value for the field [EOL] try { [EOL] testInstant.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public LocalDateTime withMaximumValue() { [EOL] return setCopy(getMaximumValue()); [EOL] }
public LocalDateTime withMinimumValue() { [EOL] return setCopy(getMinimumValue()); [EOL] }
public void testGetChronologyWithNonNullChronology() { [EOL] Object object = new GregorianCalendar(); [EOL] Chronology expectedChronology = ISOChronology.getInstance(); [EOL] Chronology actualChronology = getChronology(object, expectedChronology); [EOL] assertEquals(expectedChronology, actualChronology); [EOL] }
public void testGetChronologyWithNullChronologyAndValidCalendar() { [EOL] Calendar cal = new GregorianCalendar(); [EOL] cal.setTimeZone(TimeZone.getTimeZone("GMT")); [EOL] Object object = cal; [EOL] Chronology actualChronology = getChronology(object, null); [EOL] assertNotNull(actualChronology); [EOL] }
public void testGetChronologyWithNullChronologyAndInvalidTimeZone() { [EOL] Calendar cal = new GregorianCalendar() { [EOL] public TimeZone getTimeZone() { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] }; [EOL] Object object = cal; [EOL] Chronology actualChronology = getChronology(object, null); [EOL] assertNotNull(actualChronology); [EOL] }
public void testGetChronologyWithBuddhistCalendar() { [EOL] Object buddhistCalendar = new BuddhistCalendar(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(buddhistCalendar, zone); [EOL] assertTrue(result instanceof BuddhistChronology); [EOL] }
public void testGetChronologyWithGregorianCalendarMinCutover() { [EOL] GregorianCalendar gregorianCalendar = new GregorianCalendar(); [EOL] gregorianCalendar.setGregorianChange(new Date(Long.MIN_VALUE)); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(gregorianCalendar, zone); [EOL] assertTrue(result instanceof GregorianChronology); [EOL] }
public void testGetChronologyWithGregorianCalendarMaxCutover() { [EOL] GregorianCalendar gregorianCalendar = new GregorianCalendar(); [EOL] gregorianCalendar.setGregorianChange(new Date(Long.MAX_VALUE)); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(gregorianCalendar, zone); [EOL] assertTrue(result instanceof JulianChronology); [EOL] }
public void testGetChronologyWithGregorianCalendarNormalCutover() { [EOL] GregorianCalendar gregorianCalendar = new GregorianCalendar(); [EOL] gregorianCalendar.setGregorianChange(new Date(0)); // Assuming 0 is a valid cutover and not MIN or MAX [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(gregorianCalendar, zone); [EOL] assertTrue(result instanceof GJChronology); [EOL] }
public void testGetChronologyWithOtherObject() { [EOL] Object otherObject = new Object(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(otherObject, zone); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetInstantMillisWithNonNullChrono() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] long expectedMillis = calendar.getTime().getTime(); [EOL] long actualMillis = getInstantMillis(calendar, chrono); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetInstantMillisWithNullChrono() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] long expectedMillis = calendar.getTime().getTime(); [EOL] long actualMillis = getInstantMillis(calendar, null); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetWrappedField() { [EOL] DurationField field = new MockDurationField(); [EOL] DelegatedDurationField delegatedField = new DelegatedDurationField(field); [EOL] assertEquals(field, delegatedField.getWrappedField()); [EOL] }
public void testIsPrecise_True() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.isPrecise()).thenReturn(true); [EOL] when(mockFieldType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] DateTimeField dateTimeField = new DateTimeField(mockFieldType, null); [EOL] assertTrue(dateTimeField.isPrecise()); [EOL] }
public void testIsPrecise_False() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.isPrecise()).thenReturn(false); [EOL] when(mockFieldType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] DateTimeField dateTimeField = new DateTimeField(mockFieldType, null); [EOL] assertFalse(dateTimeField.isPrecise()); [EOL] }
public void testWithZone_SameZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, null, zone, null, 0); [EOL] DateTimeFormatter result = formatter.withZone(zone); [EOL] assertSame(formatter, result); [EOL] }
public void testWithZone_DifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, null, originalZone, null, 0); [EOL] DateTimeFormatter result = formatter.withZone(newZone); [EOL] assertNotNull(result); [EOL] assertNotSame(formatter, result); [EOL] assertEquals(newZone, result.getZone()); [EOL] }
public void testParseInto_NullInstant_ThrowsIllegalArgumentException() { [EOL] try { [EOL] parseInto(null, "2023-04-01T00:00:00Z", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testParseInto_ValidInstantAndText_ParsesCorrectly() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] assertEquals(expectedMillis, mockInstant.getMillis()); [EOL] assertEquals(expectedChronology, mockInstant.getChronology()); [EOL] assertEquals(expectedNewPosition, result); [EOL] }
public void testParseInto_WithOffsetParsed_UpdatesInstantWithParsedOffset() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00+02:00"; // Text with offset [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] assertEquals(expectedMillisWithOffset, mockInstant.getMillis()); [EOL] assertEquals(expectedChronologyWithOffset, mockInstant.getChronology()); [EOL] assertEquals(expectedNewPositionWithOffset, result); [EOL] }
public void testParseInto_WithZone_UpdatesInstantWithZone() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; // Text without explicit zone [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] assertEquals(expectedMillisWithZone, mockInstant.getMillis()); [EOL] assertEquals(expectedChronologyWithZone, mockInstant.getChronology()); [EOL] assertEquals(expectedNewPositionWithZone, result); [EOL] }
public void testParseLocalDateTime_ValidInput() { [EOL] String validInput = "2023-03-10T15:00:00"; // Assuming this is a valid input for the parser [EOL] LocalDateTime result = parseLocalDateTime(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(10, result.getDayOfMonth()); [EOL] assertEquals(15, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] }
public void testParseLocalDateTime_InvalidInput() { [EOL] String invalidInput = "invalid-date-time"; // Assuming this is an invalid input for the parser [EOL] try { [EOL] parseLocalDateTime(invalidInput); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Cannot parse \"invalid-date-time\": not a valid representation (error at index 0)", e.getMessage()); [EOL] } [EOL] }
public void testParseLocalDateTime_ValidInputWithOffset() { [EOL] String validInputWithOffset = "2023-03-10T15:00:00+02:00"; // Assuming this is a valid input with offset [EOL] LocalDateTime result = parseLocalDateTime(validInputWithOffset); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(10, result.getDayOfMonth()); [EOL] assertEquals(15, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] }
public void testParseLocalDateTime_ValidInputWithZone() { [EOL] String validInputWithZone = "2023-03-10T15:00:00Z"; // Assuming this is a valid input with UTC zone [EOL] LocalDateTime result = parseLocalDateTime(validInputWithZone); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(10, result.getDayOfMonth()); [EOL] assertEquals(15, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] }
public void testValidateWithValidValues() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] validValues = new int[]{5, 10, 15}; // Assuming these are within the valid range for the fields [EOL] validate(mockPartial, validValues); [EOL] } [EOL] public void testValidateWithMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAtMinimum = new int[]{0, 0, 0}; // Assuming 0 is the minimum value for all fields [EOL] try { [EOL] validate(mockPartial, valuesAtMinimum); [EOL] fail("Should have thrown IllegalFieldValueException for value below minimum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAtMaximum = new int[]{10, 20, 30}; // Assuming these are the maximum values for the fields [EOL] try { [EOL] validate(mockPartial, valuesAtMaximum); [EOL] fail("Should have thrown IllegalFieldValueException for value above maximum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithBelowMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesBelowMinimum = new int[]{-1, -1, -1}; // Assuming -1 is below the minimum value for all fields [EOL] try { [EOL] validate(mockPartial, valuesBelowMinimum); [EOL] fail("Should have thrown IllegalFieldValueException for value below minimum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithAboveMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAboveMaximum = new int[]{11, 21, 31}; // Assuming these values are above the maximum for the fields [EOL] try { [EOL] validate(mockPartial, valuesAboveMaximum); [EOL] fail("Should have thrown IllegalFieldValueException for value above maximum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithMinimumValueDynamic() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] dynamicValuesAtMinimum = new int[]{5, 5, 5}; // Assuming these are the dynamic minimum values for the fields [EOL] try { [EOL] validate(mockPartial, dynamicValuesAtMinimum); [EOL] fail("Should have thrown IllegalFieldValueException for dynamic value below minimum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithMaximumValueDynamic() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] dynamicValuesAtMaximum = new int[]{15, 25, 35}; // Assuming these are the dynamic maximum values for the fields [EOL] try { [EOL] validate(mockPartial, dynamicValuesAtMaximum); [EOL] fail("Should have thrown IllegalFieldValueException for dynamic value above maximum"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testGetWithEmptyPartial() { [EOL] ReadablePartial emptyPartial = new ReadablePartial() { [EOL] public int size() { [EOL] return 0; [EOL] } [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(int index) { [EOL] return null; [EOL] } [EOL] public int getValue(int index) { [EOL] return 0; [EOL] } [EOL] public Chronology getChronology() { [EOL] return null; [EOL] } [EOL] }; [EOL] long instant = 0L; [EOL] Time time = new Time(); [EOL] int[] result = time.get(emptyPartial, instant); [EOL] assertEquals(0, result.length); [EOL] }
public void testGetWithNonEmptyPartial() { [EOL] ReadablePartial nonEmptyPartial = new ReadablePartial() { [EOL] public int size() { [EOL] return 2; [EOL] } [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] if (index == 0) { [EOL] return DateTimeFieldType.hourOfDay(); [EOL] } else { [EOL] return DateTimeFieldType.minuteOfHour(); [EOL] } [EOL] } [EOL] public DateTimeField getField(int index, Chronology chrono) { [EOL] if (index == 0) { [EOL] return chrono.hourOfDay(); [EOL] } else { [EOL] return chrono.minuteOfHour(); [EOL] } [EOL] } [EOL] public int getValue(int index) { [EOL] return index * 10; [EOL] } [EOL] public Chronology getChronology() { [EOL] return ISOChronology.getInstanceUTC(); [EOL] } [EOL] }; [EOL] long instant = 0L; [EOL] Time time = new Time(); [EOL] int[] result = time.get(nonEmptyPartial, instant); [EOL] assertEquals(2, result.length); [EOL] assertNotNull(result[0]); [EOL] assertNotNull(result[1]); [EOL] }
public void testGetWithDifferentStartAndEndInstant() { [EOL] ReadablePeriod period = createPeriodWithSize(2); // Assuming createPeriodWithSize is a helper method [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] int[] result = get(period, startInstant, endInstant); [EOL] assertEquals(2, result.length); // Assuming the period size is 2 [EOL] } [EOL] public void testGetWithSameStartAndEndInstant() { [EOL] ReadablePeriod period = createPeriodWithSize(1); // Assuming createPeriodWithSize is a helper method [EOL] long startInstant = 1000L; [EOL] long endInstant = 1000L; [EOL] int[] result = get(period, startInstant, endInstant); [EOL] assertEquals(1, result.length); // Assuming the period size is 1 [EOL] assertEquals(0, result[0]); // When startInstant is equal to endInstant, the difference should be 0 [EOL] }
public void testGetType() { [EOL] DurationFieldType type = new Duration().getType(); [EOL] assertEquals(DurationFieldType.millis(), type); [EOL] }
public long getValueAsLong(long duration) { [EOL] return duration; [EOL] }
public void testGetDifferenceWithPositiveDifference() { [EOL] long minuendInstant = 10L; [EOL] long subtrahendInstant = 5L; [EOL] int expected = 5; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceWithNegativeDifference() { [EOL] long minuendInstant = 5L; [EOL] long subtrahendInstant = 10L; [EOL] int expected = -5; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceWithNoDifference() { [EOL] long minuendInstant = 5L; [EOL] long subtrahendInstant = 5L; [EOL] int expected = 0; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceWithMaxIntDifference() { [EOL] long minuendInstant = Integer.MAX_VALUE + 1L; [EOL] long subtrahendInstant = 1L; [EOL] int expected = Integer.MAX_VALUE; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceWithMinIntDifference() { [EOL] long minuendInstant = 1L; [EOL] long subtrahendInstant = Integer.MAX_VALUE + 1L; [EOL] int expected = Integer.MIN_VALUE; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testEquals_withMillisDurationFieldAndEqualMillis() { [EOL] MillisDurationField field1 = new MillisDurationField(1000); [EOL] MillisDurationField field2 = new MillisDurationField(1000); [EOL] boolean result = field1.equals(field2); [EOL] assertTrue(result); [EOL] }
public void testEquals_withMillisDurationFieldAndDifferentMillis() { [EOL] MillisDurationField field1 = new MillisDurationField(1000); [EOL] MillisDurationField field2 = new MillisDurationField(2000); [EOL] boolean result = field1.equals(field2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withNonMillisDurationField() { [EOL] MillisDurationField field = new MillisDurationField(1000); [EOL] Object obj = new Object(); [EOL] boolean result = field.equals(obj); [EOL] assertFalse(result); [EOL] }
private Object readResolve() { [EOL] return INSTANCE; [EOL] }
public void testMillisOfSecond() { [EOL] DateTimeFieldType type = ClassName.millisOfSecond(); [EOL] assertNotNull(type); [EOL] assertEquals(ClassName.MILLIS_OF_SECOND_TYPE, type); [EOL] }
public void testMillisOfDay() { [EOL] DateTimeFieldType type = ClassName.millisOfDay(); [EOL] assertNotNull(type); [EOL] assertEquals(ClassName.MILLIS_OF_DAY_TYPE, type); [EOL] }
public void testSecondOfMinute() { [EOL] DateTimeFieldType secondOfMinuteType = DateTimeFieldType.secondOfMinute(); [EOL] assertNotNull(secondOfMinuteType); [EOL] assertEquals("secondOfMinute", secondOfMinuteType.getName()); [EOL] }
public void testSecondOfDay() { [EOL] DateTimeFieldType secondOfDayType = DateTimeFieldType.secondOfDay(); [EOL] assertNotNull(secondOfDayType); [EOL] assertEquals("secondOfDay", secondOfDayType.getName()); [EOL] }
public void testMinuteOfHour() { [EOL] DateTimeFieldType type = ClassName.minuteOfHour(); [EOL] assertNotNull(type); [EOL] assertEquals(ClassName.MINUTE_OF_HOUR_TYPE, type); [EOL] }
public void testMinuteOfDay() { [EOL] DateTimeFieldType type = ClassName.minuteOfDay(); [EOL] assertNotNull(type); [EOL] assertEquals(ClassName.MINUTE_OF_DAY_TYPE, type); [EOL] }
public void testHourOfDay() { [EOL] DateTimeFieldType type = ClassName.hourOfDay(); [EOL] assertNotNull(type); [EOL] assertEquals("hourOfDay", type.getName()); [EOL] }
public void testClockhourOfDay() { [EOL] DateTimeFieldType type = DateTimeFieldType.clockhourOfDay(); [EOL] assertNotNull("ClockhourOfDay type should not be null", type); [EOL] assertEquals("Type should be equal to CLOCKHOUR_OF_DAY_TYPE", DateTimeFieldType.CLOCKHOUR_OF_DAY_TYPE, type); [EOL] }
public void testHourOfHalfday() { [EOL] DateTimeFieldType type = ClassName.hourOfHalfday(); [EOL] assertNotNull(type); [EOL] assertEquals(DateTimeFieldType.HOUR_OF_HALFDAY_TYPE, type); [EOL] }
public void testClockhourOfHalfday() { [EOL] DateTimeFieldType type = DateTimeFieldType.clockhourOfHalfday(); [EOL] assertNotNull(type); [EOL] assertEquals(DateTimeFieldType.CLOCKHOUR_OF_HALFDAY, type); [EOL] }
public void testHalfdayOfDay() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.halfdayOfDay(); [EOL] assertNotNull("The halfdayOfDay() method should not return null", fieldType); [EOL] assertEquals("The halfdayOfDay() method should return the HALFDAY_OF_DAY_TYPE", DateTimeFieldType.HALFDAY_OF_DAY_TYPE, fieldType); [EOL] }
public void testDayOfWeek() { [EOL] DateTimeFieldType type = ClassName.dayOfWeek(); [EOL] assertNotNull("DayOfWeek type should not be null", type); [EOL] assertEquals("Type should be equal to DAY_OF_WEEK_TYPE", ClassName.DAY_OF_WEEK_TYPE, type); [EOL] }
public void testDayOfMonth() { [EOL] DateTimeFieldType type = ClassName.dayOfMonth(); [EOL] assertNotNull("DayOfMonth type should not be null", type); [EOL] assertEquals("Type should be equal to DAY_OF_MONTH_TYPE", ClassName.DAY_OF_MONTH_TYPE, type); [EOL] }
public void testDayOfYear() { [EOL] DateTimeFieldType type = ClassName.dayOfYear(); [EOL] assertNotNull(type); [EOL] assertEquals(ClassName.DAY_OF_YEAR_TYPE, type); [EOL] }
public static DateTimeFieldType weekOfWeekyear() { [EOL] return WEEK_OF_WEEKYEAR_TYPE; [EOL] }
public void testWeekyear() { [EOL] DateTimeFieldType type = DateTimeFieldType.weekyear(); [EOL] assertNotNull("Weekyear type should not be null", type); [EOL] assertSame("Weekyear type should be the same as WEEKYEAR_TYPE", DateTimeFieldType.WEEKYEAR_TYPE, type); [EOL] }
public void testMonthOfYear() { [EOL] DateTimeFieldType type = ClassName.monthOfYear(); [EOL] assertNotNull("MonthOfYear should not be null", type); [EOL] assertEquals("Type should be equal to MONTH_OF_YEAR_TYPE", ClassName.MONTH_OF_YEAR_TYPE, type); [EOL] }
public void testYear() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] assertNotNull(fieldType); [EOL] assertEquals(DateTimeFieldType.YEAR_TYPE, fieldType); [EOL] }
public void testYearOfEra() { [EOL] DateTimeFieldType type = DateTimeFieldType.yearOfEra(); [EOL] assertNotNull(type); [EOL] assertEquals("yearOfEra", type.getName()); [EOL] }
public void testEraFieldType() { [EOL] DateTimeFieldType eraType = DateTimeFieldType.era(); [EOL] assertNotNull("Era field type should not be null", eraType); [EOL] assertEquals("Era field type should be ERA_TYPE", DateTimeFieldType.ERA_TYPE, eraType); [EOL] }
public void testEquals_Reflexive() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType.equals(fieldType)); [EOL] }
public void testEquals_SameOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_DifferentOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.monthOfYear(); [EOL] assertFalse(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_Null() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertFalse(fieldType.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] Object obj = new Object(); [EOL] assertFalse(fieldType.equals(obj)); [EOL] }
public void testHashCode_PositiveOrdinal() { [EOL] Time time = new Time(5); // Assuming Time is the class and iOrdinal is a field within it [EOL] int expectedHashCode = 1 << 5; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testHashCode_ZeroOrdinal() { [EOL] Time time = new Time(0); [EOL] int expectedHashCode = 1; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testHashCode_NegativeOrdinal() { [EOL] Time time = new Time(-3); [EOL] int expectedHashCode = 1 << -3; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testGetFieldWithEra() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, ERA); [EOL] assertEquals(chronology.era(), field); [EOL] } [EOL] public void testGetFieldWithYearOfEra() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, YEAR_OF_ERA); [EOL] assertEquals(chronology.yearOfEra(), field); [EOL] } [EOL] public void testGetFieldWithCenturyOfEra() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, CENTURY_OF_ERA); [EOL] assertEquals(chronology.centuryOfEra(), field); [EOL] } [EOL] public void testGetFieldWithYearOfCentury() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, YEAR_OF_CENTURY); [EOL] assertEquals(chronology.yearOfCentury(), field); [EOL] } [EOL] public void testGetFieldWithYear() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, YEAR); [EOL] assertEquals(chronology.year(), field); [EOL] } [EOL] public void testGetFieldWithDayOfYear() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, DAY_OF_YEAR); [EOL] assertEquals(chronology.dayOfYear(), field); [EOL] } [EOL] public void testGetFieldWithMonthOfYear() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, MONTH_OF_YEAR); [EOL] assertEquals(chronology.monthOfYear(), field); [EOL] } [EOL] public void testGetFieldWithDayOfMonth() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, DAY_OF_MONTH); [EOL] assertEquals(chronology.dayOfMonth(), field); [EOL] } [EOL] public void testGetFieldWithWeekyearOfCentury() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, WEEKYEAR_OF_CENTURY); [EOL] assertEquals(chronology.weekyearOfCentury(), field); [EOL] } [EOL] public void testGetFieldWithWeekyear() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, WEEKYEAR); [EOL] assertEquals(chronology.weekyear(), field); [EOL] } [EOL] public void testGetFieldWithWeekOfWeekyear() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, WEEK_OF_WEEKYEAR); [EOL] assertEquals(chronology.weekOfWeekyear(), field); [EOL] } [EOL] public void testGetFieldWithDayOfWeek() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, DAY_OF_WEEK); [EOL] assertEquals(chronology.dayOfWeek(), field); [EOL] } [EOL] public void testGetFieldWithHalfdayOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, HALFDAY_OF_DAY); [EOL] assertEquals(chronology.halfdayOfDay(), field); [EOL] } [EOL] public void testGetFieldWithHourOfHalfday() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, HOUR_OF_HALFDAY); [EOL] assertEquals(chronology.hourOfHalfday(), field); [EOL] } [EOL] public void testGetFieldWithClockhourOfHalfday() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, CLOCKHOUR_OF_HALFDAY); [EOL] assertEquals(chronology.clockhourOfHalfday(), field); [EOL] } [EOL] public void testGetFieldWithClockhourOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, CLOCKHOUR_OF_DAY); [EOL] assertEquals(chronology.clockhourOfDay(), field); [EOL] } [EOL] public void testGetFieldWithHourOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, HOUR_OF_DAY); [EOL] assertEquals(chronology.hourOfDay(), field); [EOL] } [EOL] public void testGetFieldWithMinuteOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, MINUTE_OF_DAY); [EOL] assertEquals(chronology.minuteOfDay(), field); [EOL] } [EOL] public void testGetFieldWithMinuteOfHour() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, MINUTE_OF_HOUR); [EOL] assertEquals(chronology.minuteOfHour(), field); [EOL] } [EOL] public void testGetFieldWithSecondOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, SECOND_OF_DAY); [EOL] assertEquals(chronology.secondOfDay(), field); [EOL] } [EOL] public void testGetFieldWithSecondOfMinute() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, SECOND_OF_MINUTE); [EOL] assertEquals(chronology.secondOfMinute(), field); [EOL] } [EOL] public void testGetFieldWithMillisOfDay() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, MILLIS_OF_DAY); [EOL] assertEquals(chronology.millisOfDay(), field); [EOL] } [EOL] public void testGetFieldWithMillisOfSecond() { [EOL] Chronology chronology = createMockChronology(); [EOL] DateTimeField field = getField(chronology, MILLIS_OF_SECOND); [EOL] assertEquals(chronology.millisOfSecond(), field); [EOL] } [EOL] public void testGetFieldWithInvalidOrdinal() { [EOL] Chronology chronology = createMockChronology(); [EOL] try { [EOL] getField(chronology, INVALID_ORDINAL); [EOL] fail("Should have thrown InternalError"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testReadResolveWithERA() { [EOL] this.iOrdinal = ERA; [EOL] Object result = this.readResolve(); [EOL] assertEquals(ERA_TYPE, result); [EOL] }
public void testReadResolveWithYEAR_OF_ERA() { [EOL] this.iOrdinal = YEAR_OF_ERA; [EOL] Object result = this.readResolve(); [EOL] assertEquals(YEAR_OF_ERA_TYPE, result); [EOL] }
public void testReadResolveWithCENTURY_OF_ERA() { [EOL] this.iOrdinal = CENTURY_OF_ERA; [EOL] Object result = this.readResolve(); [EOL] assertEquals(CENTURY_OF_ERA_TYPE, result); [EOL] }
public void testReadResolveWithYEAR_OF_CENTURY() { [EOL] this.iOrdinal = YEAR_OF_CENTURY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(YEAR_OF_CENTURY_TYPE, result); [EOL] }
public void testReadResolveWithYEAR() { [EOL] this.iOrdinal = YEAR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(YEAR_TYPE, result); [EOL] }
public void testReadResolveWithDAY_OF_YEAR() { [EOL] this.iOrdinal = DAY_OF_YEAR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(DAY_OF_YEAR_TYPE, result); [EOL] }
public void testReadResolveWithMONTH_OF_YEAR() { [EOL] this.iOrdinal = MONTH_OF_YEAR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(MONTH_OF_YEAR_TYPE, result); [EOL] }
public void testReadResolveWithDAY_OF_MONTH() { [EOL] this.iOrdinal = DAY_OF_MONTH; [EOL] Object result = this.readResolve(); [EOL] assertEquals(DAY_OF_MONTH_TYPE, result); [EOL] }
public void testReadResolveWithWEEKYEAR_OF_CENTURY() { [EOL] this.iOrdinal = WEEKYEAR_OF_CENTURY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(WEEKYEAR_OF_CENTURY_TYPE, result); [EOL] }
public void testReadResolveWithWEEKYEAR() { [EOL] this.iOrdinal = WEEKYEAR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(WEEKYEAR_TYPE, result); [EOL] }
public void testReadResolveWithWEEK_OF_WEEKYEAR() { [EOL] this.iOrdinal = WEEK_OF_WEEKYEAR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(WEEK_OF_WEEKYEAR_TYPE, result); [EOL] }
public void testReadResolveWithDAY_OF_WEEK() { [EOL] this.iOrdinal = DAY_OF_WEEK; [EOL] Object result = this.readResolve(); [EOL] assertEquals(DAY_OF_WEEK_TYPE, result); [EOL] }
public void testReadResolveWithHALFDAY_OF_DAY() { [EOL] this.iOrdinal = HALFDAY_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(HALFDAY_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithHOUR_OF_HALFDAY() { [EOL] this.iOrdinal = HOUR_OF_HALFDAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(HOUR_OF_HALFDAY_TYPE, result); [EOL] }
public void testReadResolveWithCLOCKHOUR_OF_HALFDAY() { [EOL] this.iOrdinal = CLOCKHOUR_OF_HALFDAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_HALFDAY_TYPE, result); [EOL] }
public void testReadResolveWithCLOCKHOUR_OF_DAY() { [EOL] this.iOrdinal = CLOCKHOUR_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithHOUR_OF_DAY() { [EOL] this.iOrdinal = HOUR_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(HOUR_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithMINUTE_OF_DAY() { [EOL] this.iOrdinal = MINUTE_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(MINUTE_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithMINUTE_OF_HOUR() { [EOL] this.iOrdinal = MINUTE_OF_HOUR; [EOL] Object result = this.readResolve(); [EOL] assertEquals(MINUTE_OF_HOUR_TYPE, result); [EOL] }
public void testReadResolveWithSECOND_OF_DAY() { [EOL] this.iOrdinal = SECOND_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(SECOND_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithSECOND_OF_MINUTE() { [EOL] this.iOrdinal = SECOND_OF_MINUTE; [EOL] Object result = this.readResolve(); [EOL] assertEquals(SECOND_OF_MINUTE_TYPE, result); [EOL] }
public void testReadResolveWithMILLIS_OF_DAY() { [EOL] this.iOrdinal = MILLIS_OF_DAY; [EOL] Object result = this.readResolve(); [EOL] assertEquals(MILLIS_OF_DAY_TYPE, result); [EOL] }
public void testReadResolveWithMILLIS_OF_SECOND() { [EOL] this.iOrdinal = MILLIS_OF_SECOND; [EOL] Object result = this.readResolve(); [EOL] assertEquals(MILLIS_OF_SECOND_TYPE, result); [EOL] }
public void testReadResolveWithInvalidOrdinal() { [EOL] this.iOrdinal = INVALID_ORDINAL; // Assuming INVALID_ORDINAL is a value not covered by the switch cases [EOL] Object result = this.readResolve(); [EOL] assertSame(this, result); [EOL] }
public void testToDuration_WithPositiveMillis() { [EOL] Time time = new Time(12345); [EOL] Duration result = time.toDuration(); [EOL] assertEquals(12345, result.getMillis()); [EOL] }
public void testToDuration_WithZeroMillis() { [EOL] Time time = new Time(0); [EOL] Duration result = time.toDuration(); [EOL] assertEquals(0, result.getMillis()); [EOL] }
public void testToDuration_WithNegativeMillis() { [EOL] Time time = new Time(-12345); [EOL] Duration result = time.toDuration(); [EOL] assertEquals(-12345, result.getMillis()); [EOL] }
public void testToString_PositiveMillisWithoutFraction() { [EOL] long millis = 5000; [EOL] String result = toString(); [EOL] assertEquals("PT5S", result); [EOL] } [EOL] public void testToString_PositiveMillisWithFraction() { [EOL] long millis = 5432; [EOL] String result = toString(); [EOL] assertEquals("PT5.432S", result); [EOL] } [EOL] public void testToString_NegativeMillisWithoutFraction() { [EOL] long millis = -5000; [EOL] String result = toString(); [EOL] assertEquals("PT-5S", result); [EOL] } [EOL] public void testToString_NegativeMillisWithFraction() { [EOL] long millis = -5432; [EOL] String result = toString(); [EOL] assertEquals("PT-5.432S", result); [EOL] } [EOL] public void testToString_ZeroMillis() { [EOL] long millis = 0; [EOL] String result = toString(); [EOL] assertEquals("PT0S", result); [EOL] }
public long getDurationMillisTestWithReadableInterval() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.toDurationMillis()).thenReturn(12345L); [EOL] long duration = getDurationMillis(interval); [EOL] assertEquals(12345L, duration); [EOL] }
public long getDurationMillisTestWithNull() { [EOL] try { [EOL] getDurationMillis(null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGJLocaleSymbolsWithNonEnglishLocale() { [EOL] Locale nonEnglishLocale = new Locale("fr", "FR"); [EOL] GJLocaleSymbols symbols = new GJLocaleSymbols(nonEnglishLocale); [EOL] assertNotNull(symbols.iLocale.get()); [EOL] assertNotEquals("en", symbols.iLocale.get().getLanguage()); [EOL] assertNotNull(symbols.iEras); [EOL] assertNotNull(symbols.iDaysOfWeek); [EOL] assertNotNull(symbols.iShortDaysOfWeek); [EOL] assertNotNull(symbols.iMonths); [EOL] assertNotNull(symbols.iShortMonths); [EOL] assertNotNull(symbols.iHalfday); [EOL] assertTrue(symbols.iParseEras.size() > 0); [EOL] assertTrue(symbols.iParseDaysOfWeek.size() > 0); [EOL] assertTrue(symbols.iParseMonths.size() > 0); [EOL] assertTrue(symbols.iMaxEraLength > 0); [EOL] assertTrue(symbols.iMaxDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxShortDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxMonthLength > 0); [EOL] assertTrue(symbols.iMaxShortMonthLength > 0); [EOL] assertTrue(symbols.iMaxHalfdayLength > 0); [EOL] }
public void testGJLocaleSymbolsWithEnglishLocale() { [EOL] Locale englishLocale = new Locale("en", "US"); [EOL] GJLocaleSymbols symbols = new GJLocaleSymbols(englishLocale); [EOL] assertNotNull(symbols.iLocale.get()); [EOL] assertEquals("en", symbols.iLocale.get().getLanguage()); [EOL] assertNotNull(symbols.iEras); [EOL] assertNotNull(symbols.iDaysOfWeek); [EOL] assertNotNull(symbols.iShortDaysOfWeek); [EOL] assertNotNull(symbols.iMonths); [EOL] assertNotNull(symbols.iShortMonths); [EOL] assertNotNull(symbols.iHalfday); [EOL] assertTrue(symbols.iParseEras.size() > 0); [EOL] assertTrue(symbols.iParseEras.containsKey("BCE")); [EOL] assertTrue(symbols.iParseEras.containsKey("CE")); [EOL] assertTrue(symbols.iParseDaysOfWeek.size() > 0); [EOL] assertTrue(symbols.iParseMonths.size() > 0); [EOL] assertTrue(symbols.iMaxEraLength > 0); [EOL] assertTrue(symbols.iMaxDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxShortDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxMonthLength > 0); [EOL] assertTrue(symbols.iMaxShortMonthLength > 0); [EOL] assertTrue(symbols.iMaxHalfdayLength > 0); [EOL] }
public void testEquals_sameObject() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] boolean result = instant1.equals(instant1); [EOL] assertTrue(result); [EOL] }
public void testEquals_differentObjectSameInstant() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] ReadableInstant instant2 = new DateTime(instant1.getMillis()); [EOL] boolean result = instant1.equals(instant2); [EOL] assertTrue(result); [EOL] }
public void testEquals_differentObjectDifferentInstant() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] ReadableInstant instant2 = new DateTime(instant1.getMillis() + 1); [EOL] boolean result = instant1.equals(instant2); [EOL] assertFalse(result); [EOL] }
public void testEquals_null() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] boolean result = instant1.equals(null); [EOL] assertFalse(result); [EOL] }
public void testEquals_nonReadableInstant() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] Object nonInstant = new Object(); [EOL] boolean result = instant1.equals(nonInstant); [EOL] assertFalse(result); [EOL] }
public void testHashCode() { [EOL] long millis = 123456789L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Time time = new Time(millis, chronology); [EOL] int expectedHashCode = (int) (millis ^ (millis >>> 32)) + chronology.hashCode(); [EOL] int actualHashCode = time.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testToStringWithNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] String result = testDateTime.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals(testDateTime.toString(), result); [EOL] }
public void testToStringWithNonNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] String result = testDateTime.toString(formatter); [EOL] assertNotNull(result); [EOL] assertEquals(formatter.print(testDateTime), result); [EOL] }
public void testGetRangeDurationField_WithNonNullField() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] MyClass myClass = new MyClass(mockField); [EOL] DurationField result = myClass.getRangeDurationField(); [EOL] assertSame(mockField, result); [EOL] }
public void testGetRangeDurationField_WithNullField() { [EOL] MyClass myClass = new MyClass(null); [EOL] DurationField expectedField = DurationFieldType.seconds().getField(null); [EOL] DurationField result = myClass.getRangeDurationField(); [EOL] assertSame(expectedField, result); [EOL] }
public void testParseWithValidString() { [EOL] String validIntervalStr = "2020-01-01T00:00:00.000/2020-01-02T00:00:00.000"; [EOL] MutableInterval result = MutableInterval.parse(validIntervalStr); [EOL] assertNotNull(result); [EOL] assertEquals(new MutableInterval(validIntervalStr), result); [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidIntervalStr = "InvalidIntervalString"; [EOL] try { [EOL] MutableInterval.parse(invalidIntervalStr); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithNull() { [EOL] try { [EOL] MutableInterval.parse(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMutableInterval_WithPeriodAndEnd() { [EOL] ReadablePeriod period = new Period(1, 1, 1, 1); [EOL] ReadableInstant end = new DateTime(2023, 4, 10, 12, 0); [EOL] MutableInterval mutableInterval = new MutableInterval(period, end); [EOL] assertNotNull(mutableInterval); [EOL] assertEquals(new DateTime(2023, 4, 10, 12, 0).minus(period), mutableInterval.getStart()); [EOL] assertEquals(new DateTime(2023, 4, 10, 12, 0), mutableInterval.getEnd()); [EOL] }
public void testMutableInterval_WithNullPeriod() { [EOL] ReadableInstant end = new DateTime(2023, 4, 10, 12, 0); [EOL] try { [EOL] new MutableInterval(null, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutableInterval_WithNullEnd() { [EOL] ReadablePeriod period = new Period(1, 1, 1, 1); [EOL] try { [EOL] new MutableInterval(period, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetInterval_NullInterval_ThrowsIllegalArgumentException() { [EOL] try { [EOL] setInterval(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Interval must not be null", e.getMessage()); [EOL] } [EOL] }
public void testSetInterval_ValidInterval_SetsInterval() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] setInterval(interval); [EOL] assertEquals(interval.getStartMillis(), getStartMillis()); [EOL] assertEquals(interval.getEndMillis(), getEndMillis()); [EOL] assertEquals(interval.getChronology(), getChronology()); [EOL] }
public void testSetStartWithNull() { [EOL] try { [EOL] Interval interval = new Interval(0, 10); [EOL] interval.setStart(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetStartWithValidInstant() { [EOL] Interval interval = new Interval(0, 10); [EOL] ReadableInstant start = new Instant(5); [EOL] interval.setStart(start); [EOL] assertEquals(5, interval.getStartMillis()); [EOL] assertEquals(10, interval.getEndMillis()); [EOL] }
public void testSetEndMillis_ValidEndInstant() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 2000L; [EOL] Interval interval = new Interval(startMillis, startMillis + 1, ISOChronology.getInstanceUTC()); [EOL] interval.setEndMillis(endMillis); [EOL] assertEquals("End millis should be set to 2000L", endMillis, interval.getEndMillis()); [EOL] }
public void testSetEndMillis_SameEndInstant() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 1000L; [EOL] Interval interval = new Interval(startMillis, startMillis + 1, ISOChronology.getInstanceUTC()); [EOL] interval.setEndMillis(endMillis); [EOL] assertEquals("End millis should be set to 1000L", endMillis, interval.getEndMillis()); [EOL] }
public void setDurationAfterStart_WithNullDuration_ShouldThrowException() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] ReadableDuration nullDuration = null; [EOL] assertThrows(IllegalArgumentException.class, () -> testPeriod.setDurationAfterStart(nullDuration)); [EOL] }
public void setDurationAfterStart_WithValidDuration_ShouldSetEndMillisAccordingly() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] testPeriod.setStartMillis(0); [EOL] ReadableDuration validDuration = new ReadableDuration() { [EOL] @Override [EOL] public long getMillis() { [EOL] return 1000; // 1 second [EOL] } [EOL] }; [EOL] testPeriod.setDurationAfterStart(validDuration); [EOL] assertEquals(1000, testPeriod.getEndMillis()); [EOL] }
public void testDateMidnight_DefaultConstructor() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] assertNotNull(dateMidnight); [EOL] }
public void testWithChronology_SameChronology() { [EOL] DateMidnight original = new DateMidnight(); [EOL] Chronology chronology = original.getChronology(); [EOL] DateMidnight result = original.withChronology(chronology); [EOL] assertSame("Should be the same object as the chronology is the same", original, result); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] DateMidnight original = new DateMidnight(); [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); [EOL] if (original.getChronology().equals(newChronology)) { [EOL] newChronology = GregorianChronology.getInstanceUTC(); [EOL] } [EOL] DateMidnight result = original.withChronology(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", original, result); [EOL] assertEquals("The chronology should be the new one", newChronology, result.getChronology()); [EOL] }
public void testWithField_NullFieldType() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] try { [EOL] dateMidnight.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withField(fieldType, value); [EOL] assertNotNull(updatedDateMidnight); [EOL] assertEquals(value, updatedDateMidnight.getDayOfMonth()); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] try { [EOL] dateMidnight.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("Should be the same object", dateMidnight, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("Should not be the same object", dateMidnight, result); [EOL] assertTrue("The result should have a different millis value", dateMidnight.getMillis() != result.getMillis()); [EOL] }
public void testPlusWeeks_ZeroWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.plusWeeks(0); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testPlusWeeks_PositiveWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.plusWeeks(1); [EOL] assertNotSame(dateMidnight, result); [EOL] assertEquals(dateMidnight.plusWeeks(1).getMillis(), result.getMillis()); [EOL] }
public void testPlusWeeks_NegativeWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.plusWeeks(-1); [EOL] assertNotSame(dateMidnight, result); [EOL] assertEquals(dateMidnight.plusWeeks(-1).getMillis(), result.getMillis()); [EOL] }
public void testMinus_withNullDuration() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minus(null); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testMinus_withValidDuration() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadableDuration duration = new Duration(24 * 60 * 60 * 1000); // 1 day [EOL] DateMidnight result = dateMidnight.minus(duration); [EOL] DateMidnight expected = dateMidnight.minusDays(1); [EOL] assertEquals(expected, result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1); [EOL] DateMidnight result = dateMidnight.minus(null); [EOL] assertEquals(new DateMidnight(2023, 4, 1), result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1); [EOL] Period period = new Period(0, 1, 0, 0); // 1 month [EOL] DateMidnight result = dateMidnight.minus(period); [EOL] assertEquals(new DateMidnight(2023, 3, 1), result); [EOL] }
protected BasePartial(long instant) { [EOL] this(instant, null); [EOL] }
public void testBasePartialWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] BasePartial partial = new BasePartial(instant, null); [EOL] assertNotNull(partial.iChronology); [EOL] assertTrue(partial.iChronology == ISOChronology.getInstanceUTC()); [EOL] assertNotNull(partial.iValues); [EOL] assertEquals(4, partial.iValues.length); // Assuming the chronology returns an array of size 4 [EOL] }
public void testBasePartialWithNonNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] BasePartial partial = new BasePartial(instant, chronology); [EOL] assertNotNull(partial.iChronology); [EOL] assertTrue(partial.iChronology == chronology.withUTC()); [EOL] assertNotNull(partial.iValues); [EOL] assertEquals(4, partial.iValues.length); // Assuming the chronology returns an array of size 4 [EOL] }
public void testBasePartialWithNullChronology() { [EOL] int[] values = new int[] {2023, 4, 14}; [EOL] BasePartial partial = new BasePartial(values, null); [EOL] assertNotNull(partial); [EOL] assertEquals(ISOChronology.getInstanceUTC(), partial.getChronology()); [EOL] }
public void testBasePartialWithNonNullChronology() { [EOL] int[] values = new int[] {2023, 4, 14}; [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] BasePartial partial = new BasePartial(values, chronology); [EOL] assertNotNull(partial); [EOL] assertEquals(chronology.withUTC(), partial.getChronology()); [EOL] }
public int testGetValue_ValidIndex() { [EOL] Time time = new Time(new int[]{10, 20, 30}); [EOL] int value = time.getValue(1); [EOL] assert value == 20; [EOL] } [EOL] public int testGetValue_InvalidIndex() { [EOL] Time time = new Time(new int[]{10, 20, 30}); [EOL] try { [EOL] time.getValue(3); [EOL] assert false : "Expected an exception to be thrown"; [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assert true; [EOL] } [EOL] }
public void testSetValue_ValidIndex() { [EOL] int index = 1; // A valid index [EOL] int value = 10; // A valid value [EOL] int[] iValues = new int[] {1, 2, 3}; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.set(Mockito.any(), Mockito.eq(index), Mockito.any(int[].class), Mockito.eq(value))).thenReturn(new int[] {1, 10, 3}); [EOL] setValue(index, value); [EOL] assertEquals("Value at index should be updated", 10, iValues[index]); [EOL] }
public void testSetValue_InvalidIndex() { [EOL] int index = -1; // An invalid index [EOL] int value = 10; // A valid value [EOL] int[] iValues = new int[] {1, 2, 3}; [EOL] try { [EOL] setValue(index, value); [EOL] fail("Should have thrown an exception for invalid index"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
protected void setValues(int[] values) { [EOL] getChronology().validate(this, values); [EOL] System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] }
