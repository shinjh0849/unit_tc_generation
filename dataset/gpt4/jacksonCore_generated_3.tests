public void testCharsToNameCanonicalizerConstructor() { [EOL] CharsToNameCanonicalizer ctnCanonicalizer = new CharsToNameCanonicalizer(); [EOL] assertTrue(ctnCanonicalizer._canonicalize); [EOL] assertTrue(ctnCanonicalizer._intern); [EOL] assertTrue(ctnCanonicalizer._dirty); [EOL] assertEquals(0, ctnCanonicalizer._hashSeed); [EOL] assertEquals(0, ctnCanonicalizer._longestCollisionList); [EOL] assertNotNull(ctnCanonicalizer._symbols); [EOL] assertEquals(CharsToNameCanonicalizer.DEFAULT_TABLE_SIZE, ctnCanonicalizer._symbols.length); [EOL] }
public void testInitTables() { [EOL] initTables(8); // Test with initial size of 8 [EOL] assertEquals(8, _symbols.length); // Assert the symbols array is initialized with the given size [EOL] assertEquals(4, _buckets.length); // Assert the buckets array is half the size of the initial size [EOL] assertEquals(7, _indexMask); // Assert the index mask is initial size - 1 [EOL] assertEquals(0, _size); // Assert the size is initialized to 0 [EOL] assertEquals(0, _longestCollisionList); // Assert the longest collision list is initialized to 0 [EOL] assertTrue(_sizeThreshold > 0); // Assert the size threshold is calculated and greater than 0 [EOL] }
public int bucketCountTest() { [EOL] String[] symbols = new String[]{"symbol1", "symbol2", "symbol3"}; [EOL] MyClassUnderTest myObject = new MyClassUnderTest(symbols); [EOL] int result = myObject.bucketCount(); [EOL] assert result == symbols.length; [EOL] }
public void testCollisionCountEmpty() { [EOL] CustomHashMap map = new CustomHashMap(); [EOL] int count = map.collisionCount(); [EOL] assertEquals(0, count); [EOL] } [EOL] public void testCollisionCountNonEmptyNoCollision() { [EOL] CustomHashMap map = new CustomHashMap(); [EOL] map.put("key1", "value1"); // Assuming this method exists and adds to _buckets without collision [EOL] int count = map.collisionCount(); [EOL] assertEquals(0, count); // Assuming no collision occurred [EOL] } [EOL] public void testCollisionCountWithCollisions() { [EOL] CustomHashMap map = new CustomHashMap(); [EOL] map.put("key1", "value1"); // Assuming this method exists and adds to _buckets with a collision [EOL] map.put("key2", "value2"); // Another entry that collides with "key1" [EOL] int count = map.collisionCount(); [EOL] assertTrue(count > 0); // There should be at least one collision [EOL] }
public void testMaxCollisionLength() { [EOL] JacksonCore jacksonCore = new JacksonCore(); [EOL] jacksonCore.setLongestCollisionList(10); [EOL] int result = jacksonCore.maxCollisionLength(); [EOL] assert result == 10 : "Expected max collision length to be 10"; [EOL] }
public void testFindSymbolWithEmptyInput() { [EOL] char[] buffer = new char[0]; [EOL] String result = instance.findSymbol(buffer, 0, 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testFindSymbolWithoutCanonicalization() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] String result = instance.findSymbol(buffer, 0, 3, 0); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithExistingSymbol() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] int index = instance._hashToIndex(h); [EOL] instance._symbols[index] = "abc"; [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithCollisionAndBucketSearch() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] int index = instance._hashToIndex(h); [EOL] instance._symbols[index] = "xyz"; // Different symbol to cause collision [EOL] instance._buckets[index >> 1] = instance.new Bucket("abc", null); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithDirtyAndRehash() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithIntern() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertNotNull(result); [EOL] assertSame(result, InternCache.instance.intern(result)); [EOL] }
public void testFindSymbolWithLongCollisionChain() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertNotNull(result); [EOL] }
public void testCalcHashEmptyBuffer() { [EOL] char[] buffer = new char[0]; [EOL] int start = 0; [EOL] int len = 0; [EOL] int expectedHash = 1; // Assuming _hashSeed is initialized to a value that results in 1 for an empty buffer [EOL] int actualHash = calcHash(buffer, start, len); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashSingleCharacter() { [EOL] char[] buffer = new char[]{'a'}; [EOL] int start = 0; [EOL] int len = 1; [EOL] int expectedHash = (int) 'a'; // Assuming _hashSeed and HASH_MULT are such that this is the expected result [EOL] if (expectedHash == 0) { [EOL] expectedHash = 1; [EOL] } [EOL] int actualHash = calcHash(buffer, start, len); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashMultipleCharacters() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] int expectedHash = 1; // Replace with the actual expected hash value based on _hashSeed and HASH_MULT [EOL] for (int i = 0; i < len; ++i) { [EOL] expectedHash = (expectedHash * HASH_MULT) + (int) buffer[i]; [EOL] } [EOL] if (expectedHash == 0) { [EOL] expectedHash = 1; [EOL] } [EOL] int actualHash = calcHash(buffer, start, len); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithZeroHash() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] int hashSeedThatResultsInZero = // Calculate a seed that would result in a hash of 0 [EOL] _hashSeed = hashSeedThatResultsInZero; [EOL] int expectedHash = 1; // As per the method, if hash is 0, it should return 1 [EOL] int actualHash = calcHash(buffer, start, len); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithEmptyString() { [EOL] String key = ""; [EOL] int result = calcHash(key); [EOL] assert result == 1; [EOL] } [EOL] public void testCalcHashWithNonEmptyString() { [EOL] String key = "test"; [EOL] int result = calcHash(key); [EOL] assert result != 1; [EOL] } [EOL] public void testCalcHashWithSingleCharacter() { [EOL] String key = "a"; [EOL] int result = calcHash(key); [EOL] assert result != 1; [EOL] } [EOL] public void testCalcHashWithZeroHash() { [EOL] String key = "someStringThatResultsInZeroHash"; [EOL] int result = calcHash(key); [EOL] assert result == 1; [EOL] }
public void testRehashSizeExceedsMax() { [EOL] int initialSize = MAX_TABLE_SIZE / 2 + 1; [EOL] _symbols = new String[initialSize]; [EOL] _buckets = new Bucket[initialSize]; [EOL] _size = initialSize; [EOL] rehash(); [EOL] assertEquals(0, _size); [EOL] assertTrue(_dirty); [EOL] for (String symbol : _symbols) { [EOL] assertNull(symbol); [EOL] } [EOL] for (Bucket bucket : _buckets) { [EOL] assertNull(bucket); [EOL] } [EOL] }
public void testRehashNormal() { [EOL] int initialSize = 16; // Assuming this is less than MAX_TABLE_SIZE / 2 [EOL] _symbols = new String[initialSize]; [EOL] _buckets = new Bucket[initialSize / 2]; [EOL] _size = 10; // Assuming some arbitrary number of symbols already added [EOL] for (int i = 0; i < _size; i++) { [EOL] _symbols[i] = "sym" + i; [EOL] if (i % 2 == 0) { // Add buckets for even indices [EOL] _buckets[i / 2] = new Bucket("bucket" + i, null); [EOL] } [EOL] } [EOL] rehash(); [EOL] int newSize = initialSize * 2; [EOL] assertEquals(newSize, _symbols.length); [EOL] assertEquals(newSize / 2, _buckets.length); [EOL] assertNotNull(_symbols); [EOL] assertNotNull(_buckets); [EOL] }
public void testRehashWithCollisions() { [EOL] int initialSize = 16; // Assuming this is less than MAX_TABLE_SIZE / 2 [EOL] _symbols = new String[initialSize]; [EOL] _buckets = new Bucket[initialSize / 2]; [EOL] _size = 10; // Assuming some arbitrary number of symbols already added [EOL] for (int i = 0; i < _size; i++) { [EOL] _symbols[i] = "sym" + (i % (initialSize / 4)); // This will create collisions [EOL] if (i % 2 == 0) { // Add buckets for even indices [EOL] _buckets[i / 2] = new Bucket("bucket" + (i % (initialSize / 4)), null); [EOL] } [EOL] } [EOL] rehash(); [EOL] int newSize = initialSize * 2; [EOL] assertEquals(newSize, _symbols.length); [EOL] assertEquals(newSize / 2, _buckets.length); [EOL] assertNotNull(_symbols); [EOL] assertNotNull(_buckets); [EOL] }
public void testGetSymbol() { [EOL] String expectedSymbol = "testSymbol"; [EOL] MyClass obj = new MyClass(expectedSymbol); [EOL] String actualSymbol = obj.getSymbol(); [EOL] assertEquals(expectedSymbol, actualSymbol); [EOL] }
public Bucket getNext() { [EOL] return _next; [EOL] }
public void testFindWithMatchingSymbol() { [EOL] char[] buf = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] YourClass instance = new YourClass("abc", null); // Replace YourClass with the actual class name [EOL] String result = instance.find(buf, start, len); [EOL] assertEquals("abc", result); [EOL] }
public void testFindWithNoMatchingSymbol() { [EOL] char[] buf = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] YourClass instance = new YourClass("xyz", null); // Replace YourClass with the actual class name [EOL] String result = instance.find(buf, start, len); [EOL] assertNull(result); [EOL] }
public void testFindWithPartialMatch() { [EOL] char[] buf = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 2; [EOL] YourClass instance = new YourClass("ab", null); // Replace YourClass with the actual class name [EOL] String result = instance.find(buf, start, len); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchInNextBucket() { [EOL] char[] buf = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] Bucket nextBucket = new Bucket("abc", null); // Replace Bucket with the actual class name [EOL] YourClass instance = new YourClass("xyz", nextBucket); // Replace YourClass with the actual class name [EOL] String result = instance.find(buf, start, len); [EOL] assertEquals("abc", result); [EOL] }
public void testGetCurrentLocationAtStart() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("test"); [EOL] JsonLocation location = parser.getCurrentLocation(); [EOL] assertEquals(0, location.getByteOffset()); [EOL] assertEquals(1, location.getColumnNr()); [EOL] assertEquals(1, location.getLineNr()); [EOL] }
public void testGetCurrentLocationAfterReadingChars() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("test"); [EOL] parser.nextToken(); // Advance the parser to cover the line increment logic [EOL] JsonLocation location = parser.getCurrentLocation(); [EOL] assertEquals(4, location.getByteOffset()); [EOL] assertEquals(5, location.getColumnNr()); [EOL] assertEquals(1, location.getLineNr()); [EOL] }
public void testReleaseBuffersWithNonNullNameCopyBuffer() throws IOException { [EOL] _textBuffer = new TextBuffer(mockAllocator); [EOL] _nameCopyBuffer = new char[10]; // assuming this is a non-null value [EOL] _ioContext = mock(IOContext.class); [EOL] _releaseBuffers(); [EOL] assertNull(_nameCopyBuffer); [EOL] verify(_ioContext).releaseNameCopyBuffer(any(char[].class)); [EOL] }
public void testReleaseBuffersWithNullNameCopyBuffer() throws IOException { [EOL] _textBuffer = new TextBuffer(mockAllocator); [EOL] _nameCopyBuffer = null; // explicitly setting to null [EOL] _ioContext = mock(IOContext.class); [EOL] _releaseBuffers(); [EOL] assertNull(_nameCopyBuffer); [EOL] verify(_ioContext, never()).releaseNameCopyBuffer(any(char[].class)); [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsUnknown() throws IOException, JsonParseException { [EOL] setupNumberType(NR_UNKNOWN, JsonToken.VALUE_NUMBER_INT, NR_INT); [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.INT, result); [EOL] }
public void testGetNumberTypeWhenValueIsLong() throws IOException, JsonParseException { [EOL] setupNumberType(NR_UNKNOWN, JsonToken.VALUE_NUMBER_INT, NR_LONG); [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.LONG, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigInteger() throws IOException, JsonParseException { [EOL] setupNumberType(NR_UNKNOWN, JsonToken.VALUE_NUMBER_INT, 0); [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_INTEGER, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigDecimal() throws IOException, JsonParseException { [EOL] setupNumberType(NR_BIGDECIMAL, null, NR_BIGDECIMAL); [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_DECIMAL, result); [EOL] }
public void testGetNumberTypeWhenValueIsDouble() throws IOException, JsonParseException { [EOL] setupNumberType(0, null, 0); [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.DOUBLE, result); [EOL] }
public void testGetIntValueWithNrIntValid() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_INT); [EOL] setNumberInt(42); // example integer value [EOL] int result = getIntValue(); [EOL] assertEquals(42, result); [EOL] } [EOL] public void testGetIntValueWithNrUnknown() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_UNKNOWN); [EOL] mockParseNumericValue(NR_INT, 42); // example integer value after parsing [EOL] int result = getIntValue(); [EOL] assertEquals(42, result); [EOL] } [EOL] public void testGetIntValueWithNrIntInvalid() throws IOException, JsonParseException { [EOL] setNumTypesValid(0); // No valid types [EOL] mockConvertNumberToInt(42); // example integer value after conversion [EOL] int result = getIntValue(); [EOL] assertEquals(42, result); [EOL] }

public void testParseNumericValueInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9'}, 0, 9); [EOL] _intLength = 9; [EOL] _numberNegative = false; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(123456789, _numberInt); [EOL] }
public void testParseNumericValueNegativeInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'-', '1', '2', '3', '4', '5', '6', '7', '8', '9'}, 1, 9); [EOL] _intLength = 9; [EOL] _numberNegative = true; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(-123456789, _numberInt); [EOL] }
public void testParseNumericValueLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8'}, 0, 18); [EOL] _intLength = 18; [EOL] _numberNegative = false; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] assertEquals(123456789012345678L, _numberLong); [EOL] }
public void testParseNumericValueNegativeLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'-', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8'}, 1, 18); [EOL] _intLength = 18; [EOL] _numberNegative = true; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] assertEquals(-123456789012345678L, _numberLong); [EOL] }
public void testParseNumericValueBoundaryInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 10); [EOL] _intLength = 10; [EOL] _numberNegative = false; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(2147483647, _numberInt); [EOL] }
public void testParseNumericValueNegativeBoundaryInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 1, 10); [EOL] _intLength = 10; [EOL] _numberNegative = true; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(-2147483648, _numberInt); [EOL] }
public void testParseNumericValueFloat() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] _parseNumericValue(0); [EOL] }
public void testParseNumericValueInvalidToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; [EOL] try { [EOL] _parseNumericValue(0); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSizeWithTableInfoNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] TableInfo tableInfoMock = mock(TableInfo.class); [EOL] AtomicInteger countHolder = new AtomicInteger(5); [EOL] when(tableInfoMock.get()).thenReturn(countHolder); [EOL] instance._tableInfo = tableInfoMock; // Assuming _tableInfo can be accessed or set via a method if private [EOL] int result = instance.size(); [EOL] assertEquals(5, result); [EOL] }
public void testSizeWithTableInfoNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance._tableInfo = null; [EOL] instance._count = 3; // Assuming _count can be accessed or set via a method if private [EOL] int result = instance.size(); [EOL] assertEquals(3, result); [EOL] }
public void testBucketCount() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] JsonToken token = parser.nextToken(); // Move to START_OBJECT [EOL] parser.close(); [EOL] JsonFactory jf = new JsonFactory(); [EOL] JsonParser jp = jf.createParser("{}"); [EOL] JsonToken jt = jp.nextToken(); // Move to START_OBJECT [EOL] jp.close(); [EOL] int bucketCount = jp.bucketCount(); [EOL] assertTrue(bucketCount > 0); [EOL] }
public int collisionCount() { [EOL] return _collCount; [EOL] }
public void testAddNameWithIntern() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0}; [EOL] int qlen = 1; [EOL] boolean intern = true; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testAddNameWithoutIntern() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0, 1}; [EOL] int qlen = 2; [EOL] boolean intern = false; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testAddNameWithMultipleQuads() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0, 1, 2}; [EOL] int qlen = 3; [EOL] boolean intern = false; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testCalcHashWithLessThanThreeElements() { [EOL] int[] quads = {1, 2}; // qlen is 2, which is less than 3 [EOL] try { [EOL] calcHash(quads, quads.length); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCalcHashWithExactlyThreeElements() { [EOL] int[] quads = {1, 2, 3}; // qlen is 3 [EOL] int hash = calcHash(quads, quads.length); [EOL] int expectedHash = ((1 ^ _hashSeed) + ((1 ^ _hashSeed) >>> 9)) * MULT; [EOL] expectedHash += quads[1]; [EOL] expectedHash *= MULT2; [EOL] expectedHash += (expectedHash >>> 15); [EOL] expectedHash ^= quads[2]; [EOL] expectedHash += (expectedHash >>> 17); [EOL] assertEquals(expectedHash, hash); [EOL] }
public void testCalcHashWithMoreThanThreeElements() { [EOL] int[] quads = {1, 2, 3, 4}; // qlen is 4 [EOL] int hash = calcHash(quads, quads.length); [EOL] int expectedHash = ((1 ^ _hashSeed) + ((1 ^ _hashSeed) >>> 9)) * MULT; [EOL] expectedHash += quads[1]; [EOL] expectedHash *= MULT2; [EOL] expectedHash += (expectedHash >>> 15); [EOL] expectedHash ^= quads[2]; [EOL] expectedHash += (expectedHash >>> 17); [EOL] expectedHash = (expectedHash * MULT3) ^ quads[3]; [EOL] expectedHash += (expectedHash >>> 3); [EOL] expectedHash ^= (expectedHash << 7); [EOL] expectedHash += (expectedHash >>> 15); [EOL] expectedHash ^= (expectedHash << 9); [EOL] assertEquals(expectedHash, hash); [EOL] }
public void testCalcQuadsEmptyArray() { [EOL] byte[] wordBytes = new byte[0]; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(0, result.length); [EOL] }
public void testCalcQuadsSingleByte() { [EOL] byte[] wordBytes = new byte[]{0x01}; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(1, result.length); [EOL] assertEquals(0x01, result[0]); [EOL] }
public void testCalcQuadsThreeBytes() { [EOL] byte[] wordBytes = new byte[]{0x01, 0x02, 0x03}; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(1, result.length); [EOL] assertEquals(0x010203, result[0]); [EOL] }
public void testCalcQuadsFourBytes() { [EOL] byte[] wordBytes = new byte[]{0x01, 0x02, 0x03, 0x04}; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(1, result.length); [EOL] assertEquals(0x01020304, result[0]); [EOL] }
public void testCalcQuadsFiveBytes() { [EOL] byte[] wordBytes = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05}; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(2, result.length); [EOL] assertEquals(0x01020304, result[0]); [EOL] assertEquals(0x05000000, result[1]); [EOL] }
public void testCalcQuadsMultipleOfFour() { [EOL] byte[] wordBytes = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}; [EOL] int[] result = YourClass.calcQuads(wordBytes); [EOL] assertEquals(2, result.length); [EOL] assertEquals(0x01020304, result[0]); [EOL] assertEquals(0x05060708, result[1]); [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL] if (_mainHashShared) { [EOL] unshareMain(); [EOL] } [EOL] if (_needRehash) { [EOL] rehash(); [EOL] } [EOL] ++_count; [EOL] int ix = (hash & _mainHashMask); [EOL] if (_mainNames[ix] == null) { [EOL] _mainHash[ix] = (hash << 8); [EOL] if (_mainNamesShared) { [EOL] unshareNames(); [EOL] } [EOL] _mainNames[ix] = symbol; [EOL] } else { [EOL] if (_collListShared) { [EOL] unshareCollision(); [EOL] } [EOL] ++_collCount; [EOL] int entryValue = _mainHash[ix]; [EOL] int bucket = entryValue & 0xFF; [EOL] if (bucket == 0) { [EOL] if (_collEnd <= LAST_VALID_BUCKET) { [EOL] bucket = _collEnd; [EOL] ++_collEnd; [EOL] if (bucket >= _collList.length) { [EOL] expandCollision(); [EOL] } [EOL] } else { [EOL] bucket = findBestBucket(); [EOL] } [EOL] _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL] } else { [EOL] --bucket; [EOL] } [EOL] Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL] _collList[bucket] = newB; [EOL] _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL] if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL] reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL] } [EOL] } [EOL] { [EOL] int hashSize = _mainHash.length; [EOL] if (_count > (hashSize >> 1)) { [EOL] int hashQuarter = (hashSize >> 2); [EOL] if (_count > (hashSize - hashQuarter)) { [EOL] _needRehash = true; [EOL] } else if (_collCount >= hashQuarter) { [EOL] _needRehash = true; [EOL] } [EOL] } [EOL] } [EOL] }
private void rehash() { [EOL] _needRehash = false; [EOL] _mainNamesShared = false; [EOL] int[] oldMainHash = _mainHash; [EOL] int len = oldMainHash.length; [EOL] int newLen = len + len; [EOL] if (newLen > MAX_TABLE_SIZE) { [EOL] nukeSymbols(); [EOL] return; [EOL] } [EOL] _mainHash = new int[newLen]; [EOL] _mainHashMask = (newLen - 1); [EOL] Name[] oldNames = _mainNames; [EOL] _mainNames = new Name[newLen]; [EOL] int symbolsSeen = 0; [EOL] for (int i = 0; i < len; ++i) { [EOL] Name symbol = oldNames[i]; [EOL] if (symbol != null) { [EOL] ++symbolsSeen; [EOL] int hash = symbol.hashCode(); [EOL] int ix = (hash & _mainHashMask); [EOL] _mainNames[ix] = symbol; [EOL] _mainHash[ix] = hash << 8; [EOL] } [EOL] } [EOL] int oldEnd = _collEnd; [EOL] if (oldEnd == 0) { [EOL] _longestCollisionList = 0; [EOL] return; [EOL] } [EOL] _collCount = 0; [EOL] _collEnd = 0; [EOL] _collListShared = false; [EOL] int maxColl = 0; [EOL] Bucket[] oldBuckets = _collList; [EOL] _collList = new Bucket[oldBuckets.length]; [EOL] for (int i = 0; i < oldEnd; ++i) { [EOL] for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL] ++symbolsSeen; [EOL] Name symbol = curr._name; [EOL] int hash = symbol.hashCode(); [EOL] int ix = (hash & _mainHashMask); [EOL] int val = _mainHash[ix]; [EOL] if (_mainNames[ix] == null) { [EOL] _mainHash[ix] = (hash << 8); [EOL] _mainNames[ix] = symbol; [EOL] } else { [EOL] ++_collCount; [EOL] int bucket = val & 0xFF; [EOL] if (bucket == 0) { [EOL] if (_collEnd <= LAST_VALID_BUCKET) { [EOL] bucket = _collEnd; [EOL] ++_collEnd; [EOL] if (bucket >= _collList.length) { [EOL] expandCollision(); [EOL] } [EOL] } else { [EOL] bucket = findBestBucket(); [EOL] } [EOL] _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL] } else { [EOL] --bucket; [EOL] } [EOL] Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL] _collList[bucket] = newB; [EOL] maxColl = Math.max(maxColl, newB.length()); [EOL] } [EOL] } [EOL] } [EOL] _longestCollisionList = maxColl; [EOL] if (symbolsSeen != _count) { [EOL] throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL] } [EOL] }
public void testFindBestBucketWithEmptyBuckets() { [EOL] initializeBuckets(0); // Assuming this method initializes _collList with empty buckets [EOL] int bestBucket = findBestBucket(); [EOL] assertEquals(-1, bestBucket); [EOL] } [EOL] public void testFindBestBucketWithOneItemInOneBucket() { [EOL] initializeBuckets(1); // Assuming this method initializes _collList with one bucket having one item [EOL] int bestBucket = findBestBucket(); [EOL] assertEquals(0, bestBucket); [EOL] } [EOL] public void testFindBestBucketWithMultipleItemsInOneBucket() { [EOL] initializeBuckets(5); // Assuming this method initializes _collList with one bucket having multiple items [EOL] int bestBucket = findBestBucket(); [EOL] assertEquals(0, bestBucket); [EOL] } [EOL] public void testFindBestBucketWithMultipleBuckets() { [EOL] initializeBuckets(new int[]{3, 1, 2}); // Assuming this method initializes _collList with varying number of items in each bucket [EOL] int bestBucket = findBestBucket(); [EOL] assertEquals(1, bestBucket); [EOL] } [EOL] public void testFindBestBucketWithMultipleBucketsAndOneEmpty() { [EOL] initializeBuckets(new int[]{3, 0, 2}); // Assuming this method initializes _collList with varying number of items and one empty bucket [EOL] int bestBucket = findBestBucket(); [EOL] assertEquals(1, bestBucket); [EOL] }
public void testExpandCollision_WithNonNullCollList() { [EOL] Bucket[] initialCollList = new Bucket[4]; [EOL] for (int i = 0; i < initialCollList.length; i++) { [EOL] initialCollList[i] = new Bucket(); [EOL] } [EOL] JacksonCore jacksonCore = new JacksonCore(); [EOL] jacksonCore._collList = initialCollList; [EOL] int expectedSize = initialCollList.length * 2; [EOL] jacksonCore.expandCollision(); [EOL] assertNotNull(jacksonCore._collList); [EOL] assertEquals(expectedSize, jacksonCore._collList.length); [EOL] }
public void testExpandCollision_WithEmptyCollList() { [EOL] Bucket[] initialCollList = new Bucket[0]; [EOL] JacksonCore jacksonCore = new JacksonCore(); [EOL] jacksonCore._collList = initialCollList; [EOL] int expectedSize = initialCollList.length * 2; [EOL] jacksonCore.expandCollision(); [EOL] assertNotNull(jacksonCore._collList); [EOL] assertEquals(expectedSize, jacksonCore._collList.length); [EOL] }
public void testConstructNameWithOneQuad() { [EOL] int hash = 1; [EOL] String name = "test"; [EOL] int[] quads = {0}; [EOL] int qlen = 1; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name1); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] }
public void testConstructNameWithTwoQuads() { [EOL] int hash = 2; [EOL] String name = "test"; [EOL] int[] quads = {0, 1}; [EOL] int qlen = 2; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name2); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] }
public void testConstructNameWithThreeQuads() { [EOL] int hash = 3; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2}; [EOL] int qlen = 3; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name3); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] assertEquals(quads[2], result.getQuad(2)); [EOL] }
public void testConstructNameWithMoreThanThreeQuads() { [EOL] int hash = 4; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2, 3}; [EOL] int qlen = 4; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof NameN); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] for (int i = 0; i < qlen; i++) { [EOL] assertEquals(quads[i], result.getQuad(i)); [EOL] } [EOL] }
public void testByteBufferTypeWithPositiveSize() { [EOL] int size = 10; [EOL] ByteBufferType byteBufferType = new ByteBufferType(size); [EOL] assertEquals(size, byteBufferType.size); [EOL] }
public void testByteBufferTypeWithZeroSize() { [EOL] int size = 0; [EOL] ByteBufferType byteBufferType = new ByteBufferType(size); [EOL] assertEquals(size, byteBufferType.size); [EOL] }
public void testByteBufferTypeWithNegativeSize() { [EOL] int size = -10; [EOL] ByteBufferType byteBufferType = new ByteBufferType(size); [EOL] assertEquals(size, byteBufferType.size); [EOL] }
public void testCharBufferTypeWithZeroSize() { [EOL] CharBufferType cbt = new CharBufferType(0); [EOL] assertEquals(0, cbt.size); [EOL] }
public void testCharBufferTypeWithPositiveSize() { [EOL] CharBufferType cbt = new CharBufferType(10); [EOL] assertEquals(10, cbt.size); [EOL] }
public void testCharBufferTypeWithNegativeSize() { [EOL] CharBufferType cbt = new CharBufferType(-5); [EOL] assertEquals(-5, cbt.size); [EOL] }
It appears that the provided input text is for a constructor `BufferRecycler()` that does not contain any executable code. Since constructors are not typically directly tested unless they contain logic, and this constructor appears to be empty, there is no meaningful unit test that can be generated to cover lines of code within the constructor itself. [EOL] However, if the `BufferRecycler` class contains methods that use the state initialized by the constructor, you would write tests for those methods instead. If you provide the code for such methods, I can help generate meaningful unit test cases for them. Otherwise, for an empty constructor, no test cases are necessary or possible to achieve line coverage, as there are no lines of executable code to cover.
public void testOutputIntNegativeMinValue() { [EOL] char[] buffer = new char[11]; [EOL] int offset = 0; [EOL] int result = outputInt(Integer.MIN_VALUE, buffer, offset); [EOL] assertEquals(11, result); [EOL] assertEquals("-2147483648", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntNegativeOneDigit() { [EOL] char[] buffer = new char[2]; [EOL] int offset = 0; [EOL] int result = outputInt(-1, buffer, offset); [EOL] assertEquals(2, result); [EOL] assertEquals("-1", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveOneDigit() { [EOL] char[] buffer = new char[1]; [EOL] int offset = 0; [EOL] int result = outputInt(5, buffer, offset); [EOL] assertEquals(1, result); [EOL] assertEquals("5", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveThreeDigits() { [EOL] char[] buffer = new char[3]; [EOL] int offset = 0; [EOL] int result = outputInt(123, buffer, offset); [EOL] assertEquals(3, result); [EOL] assertEquals("123", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveSixDigits() { [EOL] char[] buffer = new char[6]; [EOL] int offset = 0; [EOL] int result = outputInt(123456, buffer, offset); [EOL] assertEquals(6, result); [EOL] assertEquals("123456", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveNineDigits() { [EOL] char[] buffer = new char[9]; [EOL] int offset = 0; [EOL] int result = outputInt(123456789, buffer, offset); [EOL] assertEquals(9, result); [EOL] assertEquals("123456789", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveTenDigits() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 0; [EOL] int result = outputInt(1000000000, buffer, offset); [EOL] assertEquals(10, result); [EOL] assertEquals("1000000000", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveElevenDigits() { [EOL] char[] buffer = new char[11]; [EOL] int offset = 0; [EOL] int result = outputInt(2000000000, buffer, offset); [EOL] assertEquals(11, result); [EOL] assertEquals("2000000000", new String(buffer, 0, result)); [EOL] }

public void testOutputIntWithNegativeMinValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(Integer.MIN_VALUE, buffer, 0); [EOL] assertEquals(11, offset); // "-2147483648".length() == 11 [EOL] } [EOL] public void testOutputIntWithNegativeValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(-1, buffer, 0); [EOL] assertEquals(2, offset); // "-1".length() == 2 [EOL] assertEquals('-', buffer[0]); [EOL] assertEquals('1', buffer[1]); [EOL] } [EOL] public void testOutputIntWithSingleDigit() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(5, buffer, 0); [EOL] assertEquals(1, offset); // "5".length() == 1 [EOL] assertEquals('5', buffer[0]); [EOL] } [EOL] public void testOutputIntWithThreeDigits() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(123, buffer, 0); [EOL] assertEquals(3, offset); // "123".length() == 3 [EOL] } [EOL] public void testOutputIntWithSixDigits() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(123456, buffer, 0); [EOL] assertEquals(6, offset); // "123456".length() == 6 [EOL] } [EOL] public void testOutputIntWithNineDigits() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(123456789, buffer, 0); [EOL] assertEquals(9, offset); // "123456789".length() == 9 [EOL] } [EOL] public void testOutputIntWithMoreThanNineDigits() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(Integer.MAX_VALUE, buffer, 0); [EOL] assertEquals(10, offset); // "2147483647".length() == 10 [EOL] }
public void testOutputIntWithBillionValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(BILLION, buffer, 0); [EOL] assertEquals(10, offset); // "1000000000".length() == 10 [EOL] assertEquals('1', buffer[0]); [EOL] } [EOL] public void testOutputIntWithTwoBillionValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = outputInt(2 * BILLION, buffer, 0); [EOL] assertEquals(10, offset); // "2000000000".length() == 10 [EOL] assertEquals('2', buffer[0]); [EOL] }
public static int outputLong(long value, char[] buffer, int offset) { [EOL] if (value < 0L) { [EOL] if (value > MIN_INT_AS_LONG) { [EOL] return outputInt((int) value, buffer, offset); [EOL] } [EOL] if (value == Long.MIN_VALUE) { [EOL] int len = SMALLEST_LONG.length(); [EOL] SMALLEST_LONG.getChars(0, len, buffer, offset); [EOL] return (offset + len); [EOL] } [EOL] buffer[offset++] = '-'; [EOL] value = -value; [EOL] } else { [EOL] if (value <= MAX_INT_AS_LONG) { [EOL] return outputInt((int) value, buffer, offset); [EOL] } [EOL] } [EOL] int origOffset = offset; [EOL] offset += calcLongStrLength(value); [EOL] int ptr = offset; [EOL] while (value > MAX_INT_AS_LONG) { [EOL] ptr -= 3; [EOL] long newValue = value / THOUSAND_L; [EOL] int triplet = (int) (value - newValue * THOUSAND_L); [EOL] outputFullTriplet(triplet, buffer, ptr); [EOL] value = newValue; [EOL] } [EOL] int ivalue = (int) value; [EOL] while (ivalue >= 1000) { [EOL] ptr -= 3; [EOL] int newValue = ivalue / 1000; [EOL] int triplet = ivalue - (newValue * 1000); [EOL] outputFullTriplet(triplet, buffer, ptr); [EOL] ivalue = newValue; [EOL] } [EOL] outputLeadingTriplet(ivalue, buffer, origOffset); [EOL] return offset; [EOL] } [EOL] public static int outputInt(int value, char[] buffer, int offset); [EOL] public static int outputInt(int value, byte[] buffer, int offset); [EOL] public static int outputLong(long value, char[] buffer, int offset); [EOL] public static int outputLong(long value, byte[] buffer, int offset); [EOL] public static String toString(int value); [EOL] public static String toString(long value); [EOL] public static String toString(double value); [EOL] private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); [EOL] private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); [EOL] private static int outputFullTriplet(int triplet, char[] buffer, int offset); [EOL] private static int outputFullTriplet(int triplet, byte[] buffer, int offset); [EOL] private static int calcLongStrLength(long posValue); [EOL] char NULL_CHAR=Optional[(char) 0]; [EOL] int MILLION=Optional[1000000]; [EOL] int BILLION=Optional[1000000000]; [EOL] long TEN_BILLION_L=Optional[10000000000L]; [EOL] long THOUSAND_L=Optional[1000L]; [EOL] long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; [EOL] long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; [EOL] String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; [EOL] char[] LEADING_TRIPLETS=Optional[new char[4000]]; [EOL] char[] FULL_TRIPLETS=Optional[new char[4000]]; [EOL] byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; [EOL] String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; [EOL] String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }];
private static int outputLeadingTriplet(int triplet, char[] buffer, int offset) { [EOL] int digitOffset = (triplet << 2); [EOL] char c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = c; [EOL] } [EOL] c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = c; [EOL] } [EOL] buffer[offset++] = LEADING_TRIPLETS[digitOffset]; [EOL] return offset; [EOL] } [EOL] public static int outputInt(int value, char[] buffer, int offset); [EOL] public static int outputInt(int value, byte[] buffer, int offset); [EOL] public static int outputLong(long value, char[] buffer, int offset); [EOL] public static int outputLong(long value, byte[] buffer, int offset); [EOL] public static String toString(int value); [EOL] public static String toString(long value); [EOL] public static String toString(double value); [EOL] private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); [EOL] private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); [EOL] private static int outputFullTriplet(int triplet, char[] buffer, int offset); [EOL] private static int outputFullTriplet(int triplet, byte[] buffer, int offset); [EOL] private static int calcLongStrLength(long posValue); [EOL] char NULL_CHAR=(char) 0; [EOL] int MILLION=1000000; [EOL] int BILLION=1000000000; [EOL] long TEN_BILLION_L=10000000000L; [EOL] long THOUSAND_L=1000L; [EOL] long MIN_INT_AS_LONG=(long) Integer.MIN_VALUE; [EOL] long MAX_INT_AS_LONG=(long) Integer.MAX_VALUE; [EOL] String SMALLEST_LONG=String.valueOf(Long.MIN_VALUE); [EOL] char[] LEADING_TRIPLETS=new char[4000]; [EOL] char[] FULL_TRIPLETS=new char[4000]; [EOL] byte[] FULL_TRIPLETS_B=new byte[4000]; [EOL] String[] sSmallIntStrs=new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }; [EOL] String[] sSmallIntStrs2=new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" };
private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset) { [EOL] int digitOffset = (triplet << 2); [EOL] char c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = (byte) c; [EOL] } [EOL] c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = (byte) c; [EOL] } [EOL] buffer[offset++] = (byte) LEADING_TRIPLETS[digitOffset]; [EOL] return offset; [EOL] }
public void testOutputFullTripletWithValidTriplet() { [EOL] char[] buffer = new char[5]; [EOL] int offset = 1; [EOL] int triplet = 123; [EOL] int expectedOffset = 4; [EOL] int resultOffset = outputFullTriplet(triplet, buffer, offset); [EOL] assertEquals(expectedOffset, resultOffset); [EOL] assertEquals('1', buffer[1]); [EOL] assertEquals('2', buffer[2]); [EOL] assertEquals('3', buffer[3]); [EOL] }
public void testOutputFullTripletWithMaxTriplet() { [EOL] char[] buffer = new char[5]; [EOL] int offset = 1; [EOL] int triplet = 999; [EOL] int expectedOffset = 4; [EOL] int resultOffset = outputFullTriplet(triplet, buffer, offset); [EOL] assertEquals(expectedOffset, resultOffset); [EOL] assertEquals('9', buffer[1]); [EOL] assertEquals('9', buffer[2]); [EOL] assertEquals('9', buffer[3]); [EOL] }
public void testOutputFullTripletWithMinTriplet() { [EOL] char[] buffer = new char[5]; [EOL] int offset = 1; [EOL] int triplet = 0; [EOL] int expectedOffset = 4; [EOL] int resultOffset = outputFullTriplet(triplet, buffer, offset); [EOL] assertEquals(expectedOffset, resultOffset); [EOL] assertEquals('0', buffer[1]); [EOL] assertEquals('0', buffer[2]); [EOL] assertEquals('0', buffer[3]); [EOL] }
public void testVersion() { [EOL] MyClass instance = new MyClass(); [EOL] Version result = instance.version(); [EOL] assertNotNull(result); [EOL] assertEquals(MyClass.VERSION, result); [EOL] }
public void testUTF8StreamJsonParser() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 0; [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ObjectCodec codec = null; [EOL] BytesToNameCanonicalizer sym = BytesToNameCanonicalizer.createRoot(); [EOL] byte[] inputBuffer = new byte[10]; [EOL] int start = 0; [EOL] int end = inputBuffer.length; [EOL] boolean bufferRecyclable = true; [EOL] UTF8StreamJsonParser parser = new UTF8StreamJsonParser(ctxt, features, in, codec, sym, inputBuffer, start, end, bufferRecyclable); [EOL] assertNotNull(parser); [EOL] }
public void testCloseInputWithManagedResource() throws IOException { [EOL] JsonParser jp = createParserWithManagedResource(); [EOL] jp.close(); [EOL] assertTrue("InputStream should be closed", isStreamClosed(jp)); [EOL] } [EOL] public void testCloseInputWithAutoCloseSourceEnabled() throws IOException { [EOL] JsonParser jp = createParserWithAutoCloseSourceEnabled(); [EOL] jp.close(); [EOL] assertTrue("InputStream should be closed", isStreamClosed(jp)); [EOL] } [EOL] public void testCloseInputWithNoManagedResourceAndAutoCloseSourceDisabled() throws IOException { [EOL] JsonParser jp = createParserWithNoManagedResourceAndAutoCloseSourceDisabled(); [EOL] jp.close(); [EOL] assertFalse("InputStream should not be closed", isStreamClosed(jp)); [EOL] }

public void testReleaseBuffersWithBufferRecyclable() throws IOException { [EOL] _bufferRecyclable = true; [EOL] _inputBuffer = new byte[10]; [EOL] _releaseBuffers(); [EOL] assertNull(_inputBuffer); [EOL] } [EOL] public void testReleaseBuffersWithBufferNotRecyclable() throws IOException { [EOL] _bufferRecyclable = false; [EOL] _inputBuffer = new byte[10]; [EOL] _releaseBuffers(); [EOL] assertNotNull(_inputBuffer); [EOL] } [EOL] public void testReleaseBuffersWithNullInputBuffer() throws IOException { [EOL] _bufferRecyclable = true; [EOL] _inputBuffer = null; [EOL] _releaseBuffers(); [EOL] assertNull(_inputBuffer); [EOL] }
public void testGetTextWithValueStringAndTokenIncomplete() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = true; [EOL] String result = getText(); [EOL] assertFalse(_tokenIncomplete); [EOL] assertNotNull(result); [EOL] assertEquals(_textBuffer.contentsAsString(), result); [EOL] }
public void testGetTextWithValueStringAndTokenComplete() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = false; [EOL] String result = getText(); [EOL] assertNotNull(result); [EOL] assertEquals(_textBuffer.contentsAsString(), result); [EOL] }
public void testGetTextWithNonValueStringToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; // Assuming NOT_AVAILABLE is a valid JsonToken other than VALUE_STRING [EOL] String result = getText(); [EOL] assertNotNull(result); [EOL] assertEquals(_getText2(_currToken), result); [EOL] }
public void testGetTextCharactersWithFieldNameAndNameNotCopied() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nameCopied = false; [EOL] _parsingContext = mock(ParsingContext.class); [EOL] when(_parsingContext.getCurrentName()).thenReturn("testName"); [EOL] _ioContext = mock(IOContext.class); [EOL] when(_ioContext.allocNameCopyBuffer(anyInt())).thenReturn(new char[8]); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals("testName", new String(result).trim()); [EOL] assertTrue(_nameCopied); [EOL] }
public void testGetTextCharactersWithFieldNameAndNameCopied() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nameCopied = true; [EOL] _nameCopyBuffer = "testName".toCharArray(); [EOL] char[] result = getTextCharacters(); [EOL] assertSame(_nameCopyBuffer, result); [EOL] }
public void testGetTextCharactersWithValueStringIncomplete() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = true; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[0]); [EOL] char[] result = getTextCharacters(); [EOL] assertFalse(_tokenIncomplete); [EOL] assertNotNull(result); [EOL] }
public void testGetTextCharactersWithValueStringComplete() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = false; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[0]); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] }
public void testGetTextCharactersWithValueNumberInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[0]); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] }
public void testGetTextCharactersWithValueNumberFloat() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[0]); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] }
public void testGetTextCharactersWithDefaultCase() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertArrayEquals(_currToken.asCharArray(), result); [EOL] }
public void testGetTextCharactersWithNullCurrentToken() throws IOException, JsonParseException { [EOL] _currToken = null; [EOL] char[] result = getTextCharacters(); [EOL] assertNull(result); [EOL] }
public void testGetTextLengthWithFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME); [EOL] parser.getParsingContext().setCurrentName("fieldName"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("fieldName".length(), length); [EOL] }
public void testGetTextLengthWithValueStringTokenIncomplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] parser.setTokenIncomplete(true); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(expectedStringLengthAfterFinishing, length); [EOL] }
public void testGetTextLengthWithValueStringTokenComplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] parser.setTokenIncomplete(false); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(expectedStringLength, length); [EOL] }
public void testGetTextLengthWithValueNumberIntToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_INT); [EOL] parser.getTextBuffer().setText("12345"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(5, length); [EOL] }
public void testGetTextLengthWithValueNumberFloatToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT); [EOL] parser.getTextBuffer().setText("123.45"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(6, length); [EOL] }
public void testGetTextLengthWithOtherToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_TRUE); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("true".length(), length); [EOL] }
public void testGetTextLengthWithNullToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(null); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(0, length); [EOL] }
public void testGetTextOffsetWithFieldName() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.FIELD_NAME); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testGetTextOffsetWithValueStringIncomplete() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, true); [EOL] int offset = jp.getTextOffset(); [EOL] assertFalse(jp.isTokenIncomplete()); [EOL] assertEquals(10, offset); [EOL] }
public void testGetTextOffsetWithValueStringComplete() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, false); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(10, offset); [EOL] }
public void testGetTextOffsetWithValueNumberInt() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_INT); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(10, offset); [EOL] }
public void testGetTextOffsetWithValueNumberFloat() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(10, offset); [EOL] }
public void testGetTextOffsetWithNoCurrentToken() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithNoCurrentToken(); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testNextTokenWithFieldName() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(_nextAfterName(), result); [EOL] }
public void testNextTokenWithIncompleteToken() throws IOException, JsonParseException { [EOL] _tokenIncomplete = true; [EOL] JsonToken result = nextToken(); [EOL] assertFalse(_tokenIncomplete); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] int i = _skipWSOrEnd(); [EOL] when(i).thenReturn(-1); [EOL] JsonToken result = nextToken(); [EOL] assertNull(result); [EOL] }
public void testNextTokenWithRBracket() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; [EOL] when(_parsingContext.inArray()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_ARRAY, result); [EOL] }
public void testNextTokenWithRCurly() throws IOException, JsonParseException { [EOL] int i = INT_RCURLY; [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] }
public void testNextTokenExpectComma() throws IOException, JsonParseException { [EOL] when(_parsingContext.expectComma()).thenReturn(true); [EOL] int i = INT_COMMA; [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenNotInObject() throws IOException, JsonParseException { [EOL] when(_parsingContext.inObject()).thenReturn(false); [EOL] int i = _skipWS(); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(_nextTokenNotInObject(i), result); [EOL] }
public void testNextTokenWithColon() throws IOException, JsonParseException { [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] int i = INT_COLON; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithValueString() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = nextToken(); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithStartArray() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_ARRAY, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithStartObject() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithTrue() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_TRUE, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithFalse() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_FALSE, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithNull() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_NULL, _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithNumber() throws IOException, JsonParseException { [EOL] int i = INT_0; // Can be any number from INT_0 to INT_9 [EOL] JsonToken result = nextToken(); [EOL] assertEquals(parseNumberText(i), _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNKNOWN; // Some value that triggers the default case [EOL] JsonToken result = nextToken(); [EOL] assertEquals(_handleUnexpectedValue(i), _nextToken); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenNotInObjectWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testNextTokenNotInObjectWithLBracket() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenNotInObjectWithLCurly() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenNotInObjectWithRBracket() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNextTokenNotInObjectWithRCurly() throws IOException, JsonParseException { [EOL] int i = INT_RCURLY; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNextTokenNotInObjectWithTrue() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenNotInObjectWithFalse() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenNotInObjectWithNull() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenNotInObjectWithNumber() throws IOException, JsonParseException { [EOL] int[] numbers = new int[]{INT_MINUS, INT_0, INT_1, INT_2, INT_3, INT_4, INT_5, INT_6, INT_7, INT_8, INT_9}; [EOL] for (int i : numbers) { [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(result); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNKNOWN; // Assuming INT_UNKNOWN is a constant for an unexpected value [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(result); [EOL] }
public void testNextAfterNameWithStartArray() { [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] JsonToken result = _nextAfterName(); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] assertFalse(_nameCopied); [EOL] }
public void testNextAfterNameWithStartObject() { [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] JsonToken result = _nextAfterName(); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] assertFalse(_nameCopied); [EOL] }
public void testNextAfterNameWithOtherToken() { [EOL] _nextToken = JsonToken.VALUE_STRING; // Any token other than START_ARRAY or START_OBJECT [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] JsonToken result = _nextAfterName(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertFalse(_nameCopied); [EOL] }
public void testClose() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator.close(); [EOL] }
public void testCloseWithSymbolsRelease() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator.close(); [EOL] }
public void testNextFieldNameWithFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithToken(JsonToken.FIELD_NAME); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertEquals(JsonToken.FIELD_NAME, parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithIncompleteToken() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithIncompleteToken(); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithEndArrayToken() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithToken(JsonToken.END_ARRAY); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertEquals(JsonToken.END_ARRAY, parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithEndObjectToken() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithToken(JsonToken.END_OBJECT); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertEquals(JsonToken.END_OBJECT, parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithComma() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserExpectingComma(); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
public void testNextFieldNameNotInObject() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserNotInObject(); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithQuoteAndMatchingName() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithQuoteAndMatchingName(); [EOL] SerializableString str = createSerializableStringMatchingName(); [EOL] assertTrue(parser.nextFieldName(str)); [EOL] assertEquals(JsonToken.FIELD_NAME, parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithQuoteAndNonMatchingName() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithQuoteAndNonMatchingName(); [EOL] SerializableString str = createSerializableStringNonMatchingName(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
public void testNextFieldNameWithIsNextTokenNameMaybe() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithIsNextTokenNameMaybe(); [EOL] SerializableString str = createSerializableString(); [EOL] assertFalse(parser.nextFieldName(str)); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
public void testIsNextTokenNameMaybeWithFieldNameMatch() throws IOException, JsonParseException { [EOL] int i = INT_f; // Assuming INT_f is a constant representing the character 'f' [EOL] SerializableString str = new SerializableString("false"); // Assuming SerializableString is a class with a constructor taking a String [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertTrue(match); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithFieldNameMismatch() throws IOException, JsonParseException { [EOL] int i = INT_t; // Assuming INT_t is a constant representing the character 't' [EOL] SerializableString str = new SerializableString("true"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertFalse(match); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithColonMissing() throws IOException, JsonParseException { [EOL] int i = INT_n; // Assuming INT_n is a constant representing the character 'n' [EOL] SerializableString str = new SerializableString("null"); [EOL] try { [EOL] _isNextTokenNameMaybe(i, str); [EOL] fail("Expected JsonParseException for missing colon"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testIsNextTokenNameMaybeWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; // Assuming INT_QUOTE is a constant representing the character '"' [EOL] SerializableString str = new SerializableString("aFieldName"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithStartArray() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; // Assuming INT_LBRACKET is a constant representing the character '[' [EOL] SerializableString str = new SerializableString("anArray"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertEquals(JsonToken.START_ARRAY, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithStartObject() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; // Assuming INT_LCURLY is a constant representing the character '{' [EOL] SerializableString str = new SerializableString("anObject"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertEquals(JsonToken.START_OBJECT, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithUnexpectedChar() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; // Assuming INT_RBRACKET is a constant representing the character ']' [EOL] SerializableString str = new SerializableString("]"); [EOL] try { [EOL] _isNextTokenNameMaybe(i, str); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testIsNextTokenNameMaybeWithTrueToken() throws IOException, JsonParseException { [EOL] int i = INT_t; // Assuming INT_t is a constant representing the character 't' [EOL] SerializableString str = new SerializableString("true"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertEquals(JsonToken.VALUE_TRUE, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithFalseToken() throws IOException, JsonParseException { [EOL] int i = INT_f; // Assuming INT_f is a constant representing the character 'f' [EOL] SerializableString str = new SerializableString("false"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertEquals(JsonToken.VALUE_FALSE, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithNullToken() throws IOException, JsonParseException { [EOL] int i = INT_n; // Assuming INT_n is a constant representing the character 'n' [EOL] SerializableString str = new SerializableString("null"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertEquals(JsonToken.VALUE_NULL, _nextToken); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithNumber() throws IOException, JsonParseException { [EOL] int i = INT_1; // Assuming INT_1 is a constant representing the character '1' [EOL] SerializableString str = new SerializableString("1"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] } [EOL] public void testIsNextTokenNameMaybeWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_ASTERISK; // Assuming INT_ASTERISK is a constant representing an unexpected character, e.g., '*' [EOL] SerializableString str = new SerializableString("*"); [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] }
public void testParseNumberTextNegative() throws IOException, JsonParseException { [EOL] int c = INT_MINUS; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextNonDigit() throws IOException, JsonParseException { [EOL] int c = INT_MINUS + 1; // Any non-digit character [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextLeadingZero() throws IOException, JsonParseException { [EOL] int c = INT_0; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextDigitSequence() throws IOException, JsonParseException { [EOL] int c = '1'; // Assuming '1' is within the range of INT_0 and INT_9 [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextEndWithNonDigit() throws IOException, JsonParseException { [EOL] int c = '2'; // Assuming '2' is within the range of INT_0 and INT_9 [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextWithDot() throws IOException, JsonParseException { [EOL] int c = '.'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextWithExponentE() throws IOException, JsonParseException { [EOL] int c = 'e'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextWithExponentEUpperCase() throws IOException, JsonParseException { [EOL] int c = 'E'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL] if (i != INT_QUOTE) { [EOL] return _handleUnusualFieldName(i); [EOL] } [EOL] if ((_inputPtr + 9) > _inputEnd) { [EOL] return slowParseFieldName(); [EOL] } [EOL] final byte[] input = _inputBuffer; [EOL] final int[] codes = sInputCodesLatin1; [EOL] int q = input[_inputPtr++] & 0xFF; [EOL] if (codes[q] == 0) { [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] _quad1 = q; [EOL] return parseMediumFieldName(i, codes); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 4); [EOL] } [EOL] return parseFieldName(q, i, 4); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 3); [EOL] } [EOL] return parseFieldName(q, i, 3); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 2); [EOL] } [EOL] return parseFieldName(q, i, 2); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 1); [EOL] } [EOL] return parseFieldName(q, i, 1); [EOL] } [EOL] if (q == INT_QUOTE) { [EOL] return BytesToNameCanonicalizer.getEmptyName(); [EOL] } [EOL] return parseFieldName(0, q, 0); [EOL] }
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 1); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 1); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 2); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 2); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 3); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 3); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 4); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 4); [EOL] } [EOL] _quadBuffer[0] = _quad1; [EOL] _quadBuffer[1] = q2; [EOL] return parseLongFieldName(i); [EOL] }
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL] final int[] codes = sInputCodesLatin1; [EOL] int qlen = 2; [EOL] while (true) { [EOL] if ((_inputEnd - _inputPtr) < 4) { [EOL] return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL] } [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 1); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 2); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 3); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 4); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL] } [EOL] if (qlen >= _quadBuffer.length) { [EOL] _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL] } [EOL] _quadBuffer[qlen++] = q; [EOL] q = i; [EOL] } [EOL] }
protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { [EOL] final int[] codes = sInputCodesLatin1; [EOL] while (true) { [EOL] if (codes[ch] != 0) { [EOL] if (ch == INT_QUOTE) { [EOL] break; [EOL] } [EOL] if (ch != INT_BACKSLASH) { [EOL] _throwUnquotedSpace(ch, "name"); [EOL] } else { [EOL] ch = _decodeEscaped(); [EOL] } [EOL] if (ch > 127) { [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] if (ch < 0x800) { [EOL] currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL] ++currQuadBytes; [EOL] } else { [EOL] currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL] ++currQuadBytes; [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL] ++currQuadBytes; [EOL] } [EOL] ch = 0x80 | (ch & 0x3f); [EOL] } [EOL] } [EOL] if (currQuadBytes < 4) { [EOL] ++currQuadBytes; [EOL] currQuad = (currQuad << 8) | ch; [EOL] } else { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = ch; [EOL] currQuadBytes = 1; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] } [EOL] if (currQuadBytes > 0) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] } [EOL] Name name = _symbols.findName(quads, qlen); [EOL] if (name == null) { [EOL] name = addName(quads, qlen, currQuadBytes); [EOL] } [EOL] return name; [EOL] }
public void testFindNameWithExistingName() { [EOL] int q1 = SOME_VALID_Q1; [EOL] int lastQuadBytes = SOME_VALID_LAST_QUAD_BYTES; [EOL] Name expectedName = new Name("expectedName", q1, lastQuadBytes); [EOL] _symbols.addName(expectedName); [EOL] Name result = findName(q1, lastQuadBytes); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithNonExistingName() { [EOL] int q1 = SOME_VALID_Q1; [EOL] int lastQuadBytes = SOME_VALID_LAST_QUAD_BYTES; [EOL] _symbols.addName(null); [EOL] Name result = findName(q1, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(q1, result.getQuad(0)); [EOL] assertEquals(lastQuadBytes, result.getLastQuad()); [EOL] }
public void testFindNameWithExistingName() { [EOL] int q1 = 1; [EOL] int q2 = 2; [EOL] int lastQuadBytes = 4; [EOL] Name testName = new Name("test", q1, q2); // Assuming Name is a valid class and has this constructor [EOL] _symbols.addName(testName); // Assuming _symbols is an instance of a class that has the addName method [EOL] Name result = findName(q1, q2, lastQuadBytes); [EOL] assertEquals(testName, result); [EOL] }
public void testFindNameWithNonExistingName() { [EOL] int q1 = 1; [EOL] int q2 = 2; [EOL] int lastQuadBytes = 4; [EOL] Name result = findName(q1, q2, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.getQuadLength()); // Assuming Name class has getQuadLength method that returns the number of quads [EOL] assertEquals(q1, result.getQuad(0)); // Assuming Name class has getQuad method that returns the quad value at the index [EOL] assertEquals(q2, result.getQuad(1)); [EOL] }
public void testFindNameWithExistingName() { [EOL] int[] quads = new int[] {1, 2, 3}; [EOL] int qlen = 3; [EOL] int lastQuad = 4; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = mock(Name.class); [EOL] when(_symbols.findName(quads, qlen + 1)).thenReturn(expectedName); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithNewName() { [EOL] int[] quads = new int[] {1, 2, 3}; [EOL] int qlen = 3; [EOL] int lastQuad = 4; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = mock(Name.class); [EOL] when(_symbols.findName(quads, qlen + 1)).thenReturn(null); [EOL] when(addName(quads, qlen + 1, lastQuadBytes)).thenReturn(expectedName); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithArrayExpansion() { [EOL] int[] quads = new int[] {1, 2}; [EOL] int qlen = 2; [EOL] int lastQuad = 3; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = mock(Name.class); [EOL] when(_symbols.findName(any(int[].class), eq(qlen + 1))).thenReturn(expectedName); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertEquals(expectedName, result); [EOL] assertTrue(quads.length > 2); // Check if array was expanded [EOL] }
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL] int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL] int lastQuad; [EOL] if (lastQuadBytes < 4) { [EOL] lastQuad = quads[qlen - 1]; [EOL] quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL] } else { [EOL] lastQuad = 0; [EOL] } [EOL] char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int cix = 0; [EOL] for (int ix = 0; ix < byteLen; ) { [EOL] int ch = quads[ix >> 2]; [EOL] int byteIx = (ix & 3); [EOL] ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL] ++ix; [EOL] if (ch > 127) { [EOL] int needed; [EOL] if ((ch & 0xE0) == 0xC0) { [EOL] ch &= 0x1F; [EOL] needed = 1; [EOL] } else if ((ch & 0xF0) == 0xE0) { [EOL] ch &= 0x0F; [EOL] needed = 2; [EOL] } else if ((ch & 0xF8) == 0xF0) { [EOL] ch &= 0x07; [EOL] needed = 3; [EOL] } else { [EOL] _reportInvalidInitial(ch); [EOL] needed = ch = 1; [EOL] } [EOL] if ((ix + needed) > byteLen) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] int ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 1) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 2) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2 & 0xFF); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] } [EOL] } [EOL] if (needed > 2) { [EOL] ch -= 0x10000; [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL] ch = 0xDC00 | (ch & 0x03FF); [EOL] } [EOL] } [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) ch; [EOL] } [EOL] String baseName = new String(cbuf, 0, cix); [EOL] if (lastQuadBytes < 4) { [EOL] quads[qlen - 1] = lastQuad; [EOL] } [EOL] return _symbols.addName(baseName, quads, qlen); [EOL] }
public void testFinishStringWithPtrAtInputEnd() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] _finishString(); [EOL] }
public void testFinishStringWithPtrBeforeInputEnd() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _finishString(); [EOL] }
public void testFinishStringWithCodeNonZero() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) INT_QUOTE; // Assuming INT_QUOTE is defined and is the quote character [EOL] sInputCodesUtf8[INT_QUOTE] = 1; // Non-zero value to trigger the if condition [EOL] _finishString(); [EOL] }
public void testFinishStringWithCodeZero() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = 'a'; // 'a' is typically not a control character and would have a code of 0 [EOL] sInputCodesUtf8['a'] = 0; // Zero value to continue the while loop [EOL] _finishString(); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL] int c; [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] ascii_loop: while (true) { [EOL] int ptr = _inputPtr; [EOL] if (ptr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] ptr = _inputPtr; [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL] while (ptr < max) { [EOL] c = (int) inputBuffer[ptr++] & 0xFF; [EOL] if (codes[c] != 0) { [EOL] _inputPtr = ptr; [EOL] break ascii_loop; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _inputPtr = ptr; [EOL] } [EOL] if (c == INT_QUOTE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] c = _decodeEscaped(); [EOL] break; [EOL] case 2: [EOL] c = _decodeUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] if ((_inputEnd - _inputPtr) >= 2) { [EOL] c = _decodeUtf8_3fast(c); [EOL] } else { [EOL] c = _decodeUtf8_3(c); [EOL] } [EOL] break; [EOL] case 4: [EOL] c = _decodeUtf8_4(c); [EOL] outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] c = 0xDC00 | (c & 0x3FF); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } else { [EOL] _reportInvalidChar(c); [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL] _tokenIncomplete = false; [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] int c; [EOL] ascii_loop: while (true) { [EOL] int ptr = _inputPtr; [EOL] int max = _inputEnd; [EOL] if (ptr >= max) { [EOL] loadMoreGuaranteed(); [EOL] ptr = _inputPtr; [EOL] max = _inputEnd; [EOL] } [EOL] while (ptr < max) { [EOL] c = (int) inputBuffer[ptr++] & 0xFF; [EOL] if (codes[c] != 0) { [EOL] _inputPtr = ptr; [EOL] break ascii_loop; [EOL] } [EOL] } [EOL] _inputPtr = ptr; [EOL] } [EOL] if (c == INT_QUOTE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] _decodeEscaped(); [EOL] break; [EOL] case 2: [EOL] _skipUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] _skipUtf8_3(c); [EOL] break; [EOL] case 4: [EOL] _skipUtf8_4(c); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } else { [EOL] _reportInvalidChar(c); [EOL] } [EOL] } [EOL] } [EOL] }
public void testHandleUnexpectedValueWithSingleQuote() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueWithN() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithNWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('N'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithI() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithIWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('I'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserAtBufferEnd(); [EOL] try { [EOL] parser._handleUnexpectedValue('+'); [EOL] fail("Expected JsonParseException for invalid EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusNotAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserNotAtBufferEnd(); [EOL] JsonToken result = parser._handleUnexpectedValue('+'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('a'); [EOL] fail("Expected JsonParseException for invalid token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('%'); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMatchTokenWithExactMatch() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length(); [EOL] _inputBuffer = matchStr.toCharArray(); [EOL] _matchToken(matchStr, i); [EOL] assertEquals(_inputPtr, matchStr.length()); [EOL] }
public void testMatchTokenWithPartialMatch() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; // Simulate partial buffer load [EOL] _inputBuffer = new char[]{'t', 'o', 'k', 'e', 'n', 'X'}; [EOL] try { [EOL] _matchToken(matchStr, i); [EOL] fail("Should have thrown JsonParseException due to invalid token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMatchTokenWithInvalidCharAfter() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length() + 1; [EOL] _inputBuffer = new char[]{'t', 'o', 'k', 'e', 'n', '1'}; [EOL] try { [EOL] _matchToken(matchStr, i); [EOL] fail("Should have thrown JsonParseException due to invalid character after token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMatchTokenWithEndOfInput() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length(); [EOL] _inputBuffer = matchStr.toCharArray(); [EOL] _matchToken(matchStr, i); [EOL] assertEquals(_inputPtr, matchStr.length()); [EOL] _inputPtr = _inputEnd; [EOL] _matchToken(matchStr, i); // Should return without exception [EOL] }
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL] _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] }
public void testReportInvalidTokenWithEmptyMatchedPartAndNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithInput(""); // Assuming createParserWithInput is a helper method [EOL] try { [EOL] parser._reportInvalidToken("", "valid JSON value"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testReportInvalidTokenWithNonEmptyMatchedPartAndNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithInput("invalidToken"); // Assuming createParserWithInput is a helper method [EOL] try { [EOL] parser._reportInvalidToken("invalid", "valid JSON value"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testReportInvalidTokenWithNonIdentifierChar() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithInput("invalid@Token"); // Assuming createParserWithInput is a helper method [EOL] try { [EOL] parser._reportInvalidToken("invalid", "valid JSON value"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testReportInvalidTokenWithValidIdentifierPart() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithInput("valid123"); // Assuming createParserWithInput is a helper method [EOL] try { [EOL] parser._reportInvalidToken("valid", "valid JSON value"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'a'}; // 'a' is a non-space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWS(); [EOL] assertEquals('a', result); // Assert that the non-space character is returned [EOL] }
public void testSkipWSWithSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'/'}; // '/' to trigger _skipComment() [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\n'}; // '\n' to trigger _skipLF() [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\r'}; // '\r' to trigger _skipCR() [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\t'}; // '\t' is a tab character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWS(); [EOL] assertEquals('\t', result); // Assert that the tab character is returned [EOL] }
public void testSkipWSWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{(byte) 0x01}; // An invalid space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to invalid space character"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{}; // Empty buffer to simulate end of input [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // 'a' is a non-space character [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('a', result); // Assert that the non-space character is returned [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '/'; // '/' is INT_SLASH [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) ' '; // ' ' is INT_SPACE [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assert that the end is reached and -1 is returned [EOL] }
public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\n'; // '\n' is INT_LF [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\r'; // '\r' is INT_CR [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\t'; // '\t' is INT_TAB [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assert that the end is reached and -1 is returned [EOL] }
public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 0x01; // Invalid space character [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Should have thrown JsonParseException due to invalid space"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndAtEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; // Set _inputPtr to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assert that the end is reached and -1 is returned [EOL] }
public void testDecodeCharForErrorWith2ByteChar() throws IOException, JsonParseException { [EOL] int firstByte = 0xC2; // 0xC2 is the start of a 2-byte UTF-8 character [EOL] int secondByte = 0xA9; // 0xA9 should be a valid second byte following 0xC2 [EOL] YourClass instance = new YourClass() { [EOL] int count = 0; [EOL] @Override [EOL] protected int nextByte() { [EOL] count++; [EOL] if (count == 1) return secondByte; [EOL] return 0; [EOL] } [EOL] @Override [EOL] protected void _reportInvalidInitial(int c) throws JsonParseException { [EOL] throw new JsonParseException("Invalid initial byte: " + c, JsonLocation.NA); [EOL] } [EOL] @Override [EOL] protected void _reportInvalidOther(int d) throws JsonParseException { [EOL] throw new JsonParseException("Invalid other byte: " + d, JsonLocation.NA); [EOL] } [EOL] }; [EOL] int result = instance._decodeCharForError(firstByte); [EOL] assertEquals(0x00A9, result); [EOL] }
public void testDecodeCharForErrorWithInvalidInitial() throws IOException, JsonParseException { [EOL] int firstByte = 0x80; // 0x80 is not a valid initial byte for UTF-8 [EOL] YourClass instance = new YourClass() { [EOL] @Override [EOL] protected void _reportInvalidInitial(int c) throws JsonParseException { [EOL] throw new JsonParseException("Invalid initial byte: " + c, JsonLocation.NA); [EOL] } [EOL] @Override [EOL] protected void _reportInvalidOther(int d) throws JsonParseException { [EOL] throw new AssertionError("Should not call _reportInvalidOther"); [EOL] } [EOL] }; [EOL] try { [EOL] instance._decodeCharForError(firstByte); [EOL] fail("Should have thrown JsonParseException for invalid initial byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeCharForErrorWithInvalidOther() throws IOException, JsonParseException { [EOL] int firstByte = 0xC2; // 0xC2 is the start of a 2-byte UTF-8 character [EOL] int invalidSecondByte = 0x01; // 0x01 is not a valid second byte following 0xC2 [EOL] YourClass instance = new YourClass() { [EOL] int count = 0; [EOL] @Override [EOL] protected int nextByte() { [EOL] count++; [EOL] if (count == 1) return invalidSecondByte; [EOL] return 0; [EOL] } [EOL] @Override [EOL] protected void _reportInvalidInitial(int c) throws JsonParseException { [EOL] throw new AssertionError("Should not call _reportInvalidInitial"); [EOL] } [EOL] @Override [EOL] protected void _reportInvalidOther(int d) throws JsonParseException { [EOL] throw new JsonParseException("Invalid other byte: " + d, JsonLocation.NA); [EOL] } [EOL] }; [EOL] try { [EOL] instance._decodeCharForError(firstByte); [EOL] fail("Should have thrown JsonParseException for invalid other byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_4WithValidInput() throws IOException, JsonParseException { [EOL] byte[] inputBuffer = new byte[]{(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x80}; [EOL] int inputPtr = 0; [EOL] int inputEnd = inputBuffer.length; [EOL] _inputBuffer = inputBuffer; [EOL] _inputPtr = inputPtr; [EOL] _inputEnd = inputEnd; [EOL] int result = _decodeUtf8_4(0xF0); [EOL] int expected = 0x10000; // This is the Unicode code point for the input sequence [EOL] assertEquals(expected, result); [EOL] }
public void testDecodeUtf8_4WithInvalidSecondByte() throws IOException, JsonParseException { [EOL] byte[] inputBuffer = new byte[]{(byte) 0xF0, (byte) 0xFF, (byte) 0x80, (byte) 0x80}; [EOL] int inputPtr = 0; [EOL] int inputEnd = inputBuffer.length; [EOL] _inputBuffer = inputBuffer; [EOL] _inputPtr = inputPtr; [EOL] _inputEnd = inputEnd; [EOL] try { [EOL] _decodeUtf8_4(0xF0); [EOL] fail("Should have thrown JsonParseException due to invalid second byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_4WithInvalidThirdByte() throws IOException, JsonParseException { [EOL] byte[] inputBuffer = new byte[]{(byte) 0xF0, (byte) 0x90, (byte) 0xFF, (byte) 0x80}; [EOL] int inputPtr = 0; [EOL] int inputEnd = inputBuffer.length; [EOL] _inputBuffer = inputBuffer; [EOL] _inputPtr = inputPtr; [EOL] _inputEnd = inputEnd; [EOL] try { [EOL] _decodeUtf8_4(0xF0); [EOL] fail("Should have thrown JsonParseException due to invalid third byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_4WithInvalidFourthByte() throws IOException, JsonParseException { [EOL] byte[] inputBuffer = new byte[]{(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0xFF}; [EOL] int inputPtr = 0; [EOL] int inputEnd = inputBuffer.length; [EOL] _inputBuffer = inputBuffer; [EOL] _inputPtr = inputPtr; [EOL] _inputEnd = inputEnd; [EOL] try { [EOL] _decodeUtf8_4(0xF0); [EOL] fail("Should have thrown JsonParseException due to invalid fourth byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipUtf8_4WithSufficientDataAndValidContinuationBytes() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new byte[] {(byte) 0xF0, (byte) 0x80, (byte) 0x80, (byte) 0x80}; [EOL] _skipUtf8_4(0xF0); [EOL] assertEquals("Input pointer should have advanced by 4", 4, _inputPtr); [EOL] }
public void testSkipUtf8_4WithInsufficientDataThrowsException() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new byte[] {(byte) 0xF0}; [EOL] try { [EOL] _skipUtf8_4(0xF0); [EOL] fail("Should have thrown IOException due to insufficient data"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSkipUtf8_4WithInvalidContinuationByteThrowsException() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new byte[] {(byte) 0xF0, (byte) 0x50, (byte) 0x80, (byte) 0x80}; // 0x50 is not a valid continuation byte [EOL] try { [EOL] _skipUtf8_4(0xF0); [EOL] fail("Should have thrown JsonParseException due to invalid continuation byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected void _skipLF() throws IOException { [EOL] ++_currInputRow; [EOL] _currInputRowStart = _inputPtr; [EOL] }
public void testVersionConstructorWithNonNullValues() { [EOL] int major = 1; [EOL] int minor = 2; [EOL] int patchLevel = 3; [EOL] String snapshotInfo = "SNAPSHOT"; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version version = new Version(major, minor, patchLevel, snapshotInfo, groupId, artifactId); [EOL] assertEquals(major, version.getMajorVersion()); [EOL] assertEquals(minor, version.getMinorVersion()); [EOL] assertEquals(patchLevel, version.getPatchLevel()); [EOL] assertEquals(snapshotInfo, version.getSnapshotInfo()); [EOL] assertEquals(groupId, version.getGroupId()); [EOL] assertEquals(artifactId, version.getArtifactId()); [EOL] }
public void testVersionConstructorWithNullGroupIdAndArtifactId() { [EOL] int major = 1; [EOL] int minor = 2; [EOL] int patchLevel = 3; [EOL] String snapshotInfo = "SNAPSHOT"; [EOL] String groupId = null; [EOL] String artifactId = null; [EOL] Version version = new Version(major, minor, patchLevel, snapshotInfo, groupId, artifactId); [EOL] assertEquals(major, version.getMajorVersion()); [EOL] assertEquals(minor, version.getMinorVersion()); [EOL] assertEquals(patchLevel, version.getPatchLevel()); [EOL] assertEquals(snapshotInfo, version.getSnapshotInfo()); [EOL] assertEquals("", version.getGroupId()); [EOL] assertEquals("", version.getArtifactId()); [EOL] }
public void testEquals_Reflexive() { [EOL] Version version = new Version(1, 0, 0, "artifact", "group"); [EOL] assertTrue(version.equals(version)); [EOL] }
public void testEquals_Null() { [EOL] Version version = new Version(1, 0, 0, "artifact", "group"); [EOL] assertFalse(version.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Version version = new Version(1, 0, 0, "artifact", "group"); [EOL] Object other = new Object(); [EOL] assertFalse(version.equals(other)); [EOL] }
public void testEquals_EqualObjects() { [EOL] Version version1 = new Version(1, 0, 0, "artifact", "group"); [EOL] Version version2 = new Version(1, 0, 0, "artifact", "group"); [EOL] assertTrue(version1.equals(version2)); [EOL] }
public void testEquals_DifferentMajorVersion() { [EOL] Version version1 = new Version(1, 0, 0, "artifact", "group"); [EOL] Version version2 = new Version(2, 0, 0, "artifact", "group"); [EOL] assertFalse(version1.equals(version2)); [EOL] }
public void testEquals_DifferentMinorVersion() { [EOL] Version version1 = new Version(1, 0, 0, "artifact", "group"); [EOL] Version version2 = new Version(1, 1, 0, "artifact", "group"); [EOL] assertFalse(version1.equals(version2)); [EOL] }
public void testEquals_DifferentPatchLevel() { [EOL] Version version1 = new Version(1, 0, 0, "artifact", "group"); [EOL] Version version2 = new Version(1, 0, 1, "artifact", "group"); [EOL] assertFalse(version1.equals(version2)); [EOL] }
public void testEquals_DifferentArtifactId() { [EOL] Version version1 = new Version(1, 0, 0, "artifact1", "group"); [EOL] Version version2 = new Version(1, 0, 0, "artifact2", "group"); [EOL] assertFalse(version1.equals(version2)); [EOL] }
public void testEquals_DifferentGroupId() { [EOL] Version version1 = new Version(1, 0, 0, "artifact", "group1"); [EOL] Version version2 = new Version(1, 0, 0, "artifact", "group2"); [EOL] assertFalse(version1.equals(version2)); [EOL] }
public void testAppendChar() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] writer.append('a'); [EOL] assertEquals("a", writer.toString()); [EOL] }
public void testAppendCharAndReturnSelf() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] Writer returnedWriter = writer.append('b'); [EOL] assertSame(writer, returnedWriter); [EOL] assertEquals("b", writer.toString()); [EOL] }
public void testWriteWithLenLessThanTwoAndLenEqualsOne() throws IOException { [EOL] char[] cbuf = new char[]{'a'}; [EOL] int off = 0; [EOL] int len = 1; [EOL] write(cbuf, off, len); [EOL] } [EOL] public void testWriteWithLenLessThanTwoAndLenNotOne() throws IOException { [EOL] char[] cbuf = new char[]{'a', 'b'}; [EOL] int off = 0; [EOL] int len = 0; [EOL] write(cbuf, off, len); [EOL] }
public void testWriteWithSurrogate() throws IOException { [EOL] char[] cbuf = new char[]{(char) 0xD800, 'b'}; [EOL] int off = 0; [EOL] int len = 2; [EOL] _surrogate = 1; // Assuming _surrogate is accessible and modifiable [EOL] write(cbuf, off, len); [EOL] }
public void testWriteAsciiCharacters() throws IOException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int off = 0; [EOL] int len = 3; [EOL] write(cbuf, off, len); [EOL] }
public void testWriteNonAsciiCharacters() throws IOException { [EOL] char[] cbuf = new char[]{(char) 0x80, (char) 0x81}; [EOL] int off = 0; [EOL] int len = 2; [EOL] write(cbuf, off, len); [EOL] }
public void testWriteSurrogatePair() throws IOException { [EOL] char[] cbuf = new char[]{(char) 0xD800, (char) 0xDC00}; [EOL] int off = 0; [EOL] int len = 2; [EOL] write(cbuf, off, len); [EOL] }
public void testWriteIllegalSurrogate() throws IOException { [EOL] char[] cbuf = new char[]{(char) 0xDC00}; [EOL] int off = 0; [EOL] int len = 1; [EOL] write(cbuf, off, len); [EOL] }
public void testWriteEndOfBuffer() throws IOException { [EOL] char[] cbuf = new char[1024]; [EOL] Arrays.fill(cbuf, 'a'); [EOL] int off = 0; [EOL] int len = cbuf.length; [EOL] _outBufferEnd = 10; // Assuming _outBufferEnd is accessible and modifiable [EOL] write(cbuf, off, len); [EOL] }
public void testWriteWithNullString() throws IOException { [EOL] try { [EOL] write(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWriteWithEmptyString() throws IOException { [EOL] write(""); [EOL] }
public void testWriteWithNonEmptyString() throws IOException { [EOL] String testStr = "Test String"; [EOL] write(testStr); [EOL] }
public void testWriteWithLenLessThanTwoAndLenEqualsZero() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("a", 0, 0); [EOL] } [EOL] public void testWriteWithLenLessThanTwoAndLenEqualsOne() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("b", 0, 1); [EOL] }
public void testWriteWithSurrogate() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.setSurrogate(someSurrogateValue); // Method to set _surrogate [EOL] instance.write("cd", 0, 2); [EOL] }
public void testWriteAsciiCharacters() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("normal", 0, 6); [EOL] }
public void testWriteNonAsciiCharacters() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("", 0, 1); [EOL] }
public void testWriteCharactersOutsideBmp() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("", 0, 2); [EOL] }
public void testWriteWithIllegalSurrogate() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write(String.valueOf((char) 0xD800), 0, 1); [EOL] }
public void testWriteWithEndOfBuffer() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] instance.write("longstring", 0, 10); [EOL] }
public void testGetSourceReferenceWithNonNullSourceRef() { [EOL] JsonLocation location = new JsonLocation(new Object(), 1L, 1, 1); [EOL] assertEquals(new Object(), location.getSourceReference()); [EOL] }
public void testGetSourceReferenceWithNullSourceRef() { [EOL] JsonLocation location = new JsonLocation(null, 1L, 1, 1); [EOL] assertNull(location.getSourceReference()); [EOL] }
public void testReleaseWriteEncodingBufferWithNonNullBuffer() { [EOL] byte[] nonNullBuffer = new byte[10]; [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(bufferRecycler); [EOL] generator.releaseWriteEncodingBuffer(nonNullBuffer); [EOL] assertNull(generator._writeEncodingBuffer); [EOL] assertTrue(bufferRecycler.isReleased(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, nonNullBuffer)); [EOL] }
public void testReleaseWriteEncodingBufferWithNullBuffer() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(bufferRecycler); [EOL] generator.releaseWriteEncodingBuffer(null); [EOL] assertNull(generator._writeEncodingBuffer); [EOL] assertFalse(bufferRecycler.isReleased(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, null)); [EOL] }
public void testReleaseNameCopyBufferWithNonNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] char[] testBuffer = new char[10]; [EOL] factory._nameCopyBuffer = testBuffer; [EOL] factory._bufferRecycler = new BufferRecycler(); [EOL] factory.releaseNameCopyBuffer(testBuffer); [EOL] assertNull(factory._nameCopyBuffer); [EOL] }
public void testReleaseNameCopyBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._nameCopyBuffer = null; [EOL] factory._bufferRecycler = new BufferRecycler(); [EOL] factory.releaseNameCopyBuffer(null); [EOL] assertNull(factory._nameCopyBuffer); [EOL] }
public void testNameNValidInput() { [EOL] String name = "validName"; [EOL] int hash = 123; [EOL] int[] quads = new int[]{0, 1, 2, 3}; [EOL] int quadLen = 4; [EOL] NameN nameN = new NameN(name, hash, quads, quadLen); [EOL] assertEquals(name, nameN.getName()); [EOL] assertEquals(hash, nameN.hashCode()); [EOL] assertArrayEquals(quads, nameN.getQuads()); [EOL] assertEquals(quadLen, nameN.getQuadLen()); [EOL] }
public void testNameNInvalidQuadLen() { [EOL] String name = "invalidName"; [EOL] int hash = 456; [EOL] int[] quads = new int[]{0, 1}; [EOL] int quadLen = 2; [EOL] try { [EOL] new NameN(name, hash, quads, quadLen); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Qlen must >= 3", e.getMessage()); [EOL] } [EOL] }
public void testCollectDefaults() { [EOL] int result = YourClass.collectDefaults(); [EOL] int expected = 0; [EOL] for (YourClass.Feature f : YourClass.Feature.values()) { [EOL] if (f.enabledByDefault()) { [EOL] expected |= f.getMask(); [EOL] } [EOL] } [EOL] assertEquals(expected, result); [EOL] }
public void testFeatureConstructorWithTrue() { [EOL] Feature feature = new Feature(true); [EOL] assertTrue(feature._defaultState); [EOL] }
public void testFeatureConstructorWithFalse() { [EOL] Feature feature = new Feature(false); [EOL] assertFalse(feature._defaultState); [EOL] }
public void testEnabledByDefaultTrue() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testEnabledByDefaultFalse() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return false; [EOL] } [EOL] }; [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testGetMaskForFirstValue() { [EOL] SomeEnum firstValue = SomeEnum.values()[0]; [EOL] int expectedMask = 1; // Assuming ordinal of first value is 0 [EOL] assertEquals(expectedMask, firstValue.getMask()); [EOL] }
public void testGetMaskForSecondValue() { [EOL] SomeEnum secondValue = SomeEnum.values()[1]; [EOL] int expectedMask = 2; // Assuming ordinal of second value is 1 [EOL] assertEquals(expectedMask, secondValue.getMask()); [EOL] }
public void testGetMaskForThirdValue() { [EOL] SomeEnum thirdValue = SomeEnum.values()[2]; [EOL] int expectedMask = 4; // Assuming ordinal of third value is 2 [EOL] assertEquals(expectedMask, thirdValue.getMask()); [EOL] }
public void testNextFieldNameMatch() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFieldName("expectedFieldName"); [EOL] SerializableString str = new SerializableStringImpl("expectedFieldName"); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertTrue(result); [EOL] }
public void testNextFieldNameNoMatch() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFieldName("expectedFieldName"); [EOL] SerializableString str = new SerializableStringImpl("unexpectedFieldName"); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] }
public void testNextFieldNameNotAFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNonFieldNameToken(); [EOL] SerializableString str = new SerializableStringImpl("irrelevantFieldName"); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] }
public void testGetBooleanValueTrue() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean result = parser.getBooleanValue(); [EOL] assertTrue(result); [EOL] }
public void testGetBooleanValueFalse() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] boolean result = parser.getBooleanValue(); [EOL] assertFalse(result); [EOL] }
public void testGetBooleanValueException() throws IOException, JsonParseException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Assuming VALUE_STRING is not a boolean type [EOL] try { [EOL] parser.getBooleanValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Current token (VALUE_STRING) not of boolean type", e.getMessage()); [EOL] } [EOL] }
protected JsonParseException _constructError(String msg) { [EOL] return new JsonParseException(msg, getCurrentLocation()); [EOL] }
public void testSetRootValueSeparatorWithNonNull() { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] SerializableString separator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return ","; [EOL] } [EOL] }; [EOL] JsonGenerator result = generator.setRootValueSeparator(separator); [EOL] assertNotNull(result); [EOL] assertSame(generator, result); [EOL] }
public void testSetRootValueSeparatorWithNull() { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] JsonGenerator result = generator.setRootValueSeparator(null); [EOL] assertNotNull(result); [EOL] assertSame(generator, result); [EOL] }
public void testSizeWithInputStartGreaterThanOrEqualToZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance._inputStart = 1; // any non-negative number [EOL] instance._inputLen = 10; // example length [EOL] int result = instance.size(); [EOL] assert result == 10; // Replace with actual assertion library syntax [EOL] }
public void testSizeWithResultArrayNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance._resultArray = new char[]{'a', 'b', 'c'}; // example array [EOL] int result = instance.size(); [EOL] assert result == 3; // Replace with actual assertion library syntax [EOL] }
public void testSizeWithResultStringNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance._resultString = "abc"; // example string [EOL] int result = instance.size(); [EOL] assert result == 3; // Replace with actual assertion library syntax [EOL] }
public void testSizeWithSegmentSizeAndCurrentSize() { [EOL] YourClass instance = new YourClass(); [EOL] instance._inputStart = -1; // example negative number [EOL] instance._segmentSize = 5; // example segment size [EOL] instance._currentSize = 3; // example current size [EOL] int result = instance.size(); [EOL] assert result == 8; // Replace with actual assertion library syntax [EOL] }
public void testGetCurrentSegmentWithInputStartGreaterThanOrEqualToZero() { [EOL] char[] result = getCurrentSegment(); [EOL] assertNotNull(result); [EOL] }
public void testGetCurrentSegmentWithCurrentSegmentNull() { [EOL] char[] result = getCurrentSegment(); [EOL] assertNotNull(result); [EOL] }
public void testGetCurrentSegmentWithCurrentSegmentFull() { [EOL] char[] result = getCurrentSegment(); [EOL] assertNotNull(result); [EOL] }
public void testUnshareWithNoNeedExtraAndEmptyCurrentSegment() { [EOL] int needExtra = 0; [EOL] initializeUnshareTestState(0, null, 0, 10); [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(0, _currentSize); [EOL] }
public void testUnshareWithNeedExtraAndNonEmptyCurrentSegment() { [EOL] int needExtra = 5; [EOL] initializeUnshareTestState(10, new char[10], 0, 10); [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertTrue(_currentSegment.length >= 15); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(10, _currentSize); [EOL] }
public void testUnshareWithNeedExtraAndSmallCurrentSegment() { [EOL] int needExtra = 5; [EOL] initializeUnshareTestState(10, new char[10], 0, 5); [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertTrue(_currentSegment.length >= 15); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(10, _currentSize); [EOL] }
public void testUnshareWithNeedExtraAndSufficientCurrentSegment() { [EOL] int needExtra = 5; [EOL] initializeUnshareTestState(10, new char[10], 0, 20); [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertEquals(20, _currentSegment.length); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(10, _currentSize); [EOL] }
public void testUseDefaultPrettyPrinter_WithNonNullPrettyPrinter() { [EOL] JsonGenerator generator = createGeneratorWithNonNullPrettyPrinter(); [EOL] JsonGenerator result = generator.useDefaultPrettyPrinter(); [EOL] assertSame("Expected the same generator instance when pretty printer is non-null", generator, result); [EOL] } [EOL] public void testUseDefaultPrettyPrinter_WithNullPrettyPrinter() { [EOL] JsonGenerator generator = createGeneratorWithNullPrettyPrinter(); [EOL] JsonGenerator result = generator.useDefaultPrettyPrinter(); [EOL] assertNotNull("Expected a non-null JsonGenerator instance", result); [EOL] assertNotSame("Expected a different generator instance when pretty printer is null", generator, result); [EOL] assertTrue("Expected result to have a DefaultPrettyPrinter", result.getPrettyPrinter() instanceof DefaultPrettyPrinter); [EOL] }
public void testWriteObjectWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this method to return a mock or a concrete JsonGenerator [EOL] gen.writeObject(null); [EOL] verify(gen).writeNull(); // Implement this method to verify that writeNull() was called [EOL] }
public void testWriteObjectWithNonNullValueUsingObjectCodec() throws IOException, JsonProcessingException { [EOL] ObjectCodec codec = mock(ObjectCodec.class); // Use a mocking framework like Mockito [EOL] JsonGenerator gen = createJsonGeneratorWithCodec(codec); // Implement this method to return a JsonGenerator with a non-null _objectCodec [EOL] Object value = new Object(); [EOL] gen.writeObject(value); [EOL] verify(codec).writeValue(gen, value); // Implement this method to verify that writeValue() was called with the correct arguments [EOL] }
public void testWriteObjectWithNonNullValueWithoutObjectCodec() throws IOException, JsonProcessingException { [EOL] JsonGenerator gen = createJsonGeneratorWithoutCodec(); // Implement this method to return a JsonGenerator with a null _objectCodec [EOL] Object value = new Object(); [EOL] gen.writeObject(value); [EOL] verify(gen).writeSimpleObject(value); // Implement this method to verify that _writeSimpleObject() was called with the correct arguments [EOL] }
public void testCopyCurrentEvent_NullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] try { [EOL] copyCurrentEvent(jp); [EOL] fail("Should have thrown JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testCopyCurrentEvent_StartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartObject(); [EOL] }
public void testCopyCurrentEvent_EndObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentEvent_StartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartArray(); [EOL] }
public void testCopyCurrentEvent_EndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentEvent_FieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeFieldName("fieldName"); [EOL] }
public void testCopyCurrentEvent_ValueStringWithTextCharacters() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(true); [EOL] when(jp.getTextCharacters()).thenReturn(new char[]{'t', 'e', 'x', 't'}); [EOL] when(jp.getTextOffset()).thenReturn(0); [EOL] when(jp.getTextLength()).thenReturn(4); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString(new char[]{'t', 'e', 'x', 't'}, 0, 4); [EOL] }
public void testCopyCurrentEvent_ValueStringWithoutTextCharacters() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(false); [EOL] when(jp.getText()).thenReturn("text"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString("text"); [EOL] }
public void testCopyCurrentEvent_ValueNumberInt_INT() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123); [EOL] }
public void testCopyCurrentEvent_ValueNumberInt_BIG_INTEGER() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] BigInteger bigInt = new BigInteger("12345678901234567890"); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInt); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(bigInt); [EOL] }
public void testCopyCurrentEvent_ValueNumberInt_LONG() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123L); [EOL] }
public void testCopyCurrentEvent_ValueNumberFloat_BIG_DECIMAL() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] BigDecimal bigDec = new BigDecimal("123.45"); [EOL] when(jp.getDecimalValue()).thenReturn(bigDec); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(bigDec); [EOL] }
public void testCopyCurrentEvent_ValueNumberFloat_FLOAT() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(123.45f); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.45f); [EOL] }
public void testCopyCurrentEvent_ValueNumberFloat_DOUBLE() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.45); [EOL] }
public void testCopyCurrentEvent_ValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(true); [EOL] }
public void testCopyCurrentEvent_ValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(false); [EOL] }
public void testCopyCurrentEvent_ValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNull(); [EOL] }
public void testCopyCurrentEvent_ValueEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object obj = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(obj); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeObject(obj); [EOL] }
public void testCopyCurrentEvent_InvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] copyCurrentEvent(jp); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
protected void _reportError(String msg) throws JsonGenerationException { [EOL] throw new JsonGenerationException(msg); [EOL] }
public void testWriteSimpleObjectWithNull() throws IOException { [EOL] _writeSimpleObject(null); [EOL] } [EOL] public void testWriteSimpleObjectWithString() throws IOException { [EOL] _writeSimpleObject("testString"); [EOL] } [EOL] public void testWriteSimpleObjectWithInteger() throws IOException { [EOL] _writeSimpleObject(Integer.valueOf(10)); [EOL] } [EOL] public void testWriteSimpleObjectWithLong() throws IOException { [EOL] _writeSimpleObject(Long.valueOf(10L)); [EOL] } [EOL] public void testWriteSimpleObjectWithDouble() throws IOException { [EOL] _writeSimpleObject(Double.valueOf(10.0)); [EOL] } [EOL] public void testWriteSimpleObjectWithFloat() throws IOException { [EOL] _writeSimpleObject(Float.valueOf(10.0f)); [EOL] } [EOL] public void testWriteSimpleObjectWithShort() throws IOException { [EOL] _writeSimpleObject(Short.valueOf((short) 10)); [EOL] } [EOL] public void testWriteSimpleObjectWithByte() throws IOException { [EOL] _writeSimpleObject(Byte.valueOf((byte) 10)); [EOL] } [EOL] public void testWriteSimpleObjectWithBigInteger() throws IOException { [EOL] _writeSimpleObject(new BigInteger("10")); [EOL] } [EOL] public void testWriteSimpleObjectWithBigDecimal() throws IOException { [EOL] _writeSimpleObject(new BigDecimal("10.0")); [EOL] } [EOL] public void testWriteSimpleObjectWithAtomicInteger() throws IOException { [EOL] _writeSimpleObject(new AtomicInteger(10)); [EOL] } [EOL] public void testWriteSimpleObjectWithAtomicLong() throws IOException { [EOL] _writeSimpleObject(new AtomicLong(10L)); [EOL] } [EOL] public void testWriteSimpleObjectWithByteArray() throws IOException { [EOL] _writeSimpleObject(new byte[]{1, 2, 3}); [EOL] } [EOL] public void testWriteSimpleObjectWithBoolean() throws IOException { [EOL] _writeSimpleObject(Boolean.TRUE); [EOL] } [EOL] public void testWriteSimpleObjectWithAtomicBoolean() throws IOException { [EOL] _writeSimpleObject(new AtomicBoolean(true)); [EOL] } [EOL] public void testWriteSimpleObjectWithUnsupportedType() { [EOL] try { [EOL] _writeSimpleObject(new Object()); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testResetWithValidParameters() { [EOL] TokenLocation tokenLocation = new TokenLocation(); [EOL] int type = 1; [EOL] int lineNr = 10; [EOL] int colNr = 20; [EOL] tokenLocation.reset(type, lineNr, colNr); [EOL] assertEquals(type, tokenLocation.getType()); [EOL] assertEquals(-1, tokenLocation.getIndex()); [EOL] assertEquals(lineNr, tokenLocation.getLineNr()); [EOL] assertEquals(colNr, tokenLocation.getColumnNr()); [EOL] assertNull(tokenLocation.getCurrentName()); [EOL] }
public void testCreateChildArrayContext_NewContext() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] int lineNr = 2; [EOL] int colNr = 3; [EOL] JsonReadContext childContext = parentContext.createChildArrayContext(lineNr, colNr); [EOL] assertNotNull(childContext); [EOL] assertSame(parentContext, childContext.getParent()); [EOL] assertEquals(JsonReadContext.TYPE_ARRAY, childContext.getType()); [EOL] assertEquals(lineNr, childContext.getLineNr()); [EOL] assertEquals(colNr, childContext.getColNr()); [EOL] }
public void testCreateChildArrayContext_ExistingContext() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] int lineNr = 2; [EOL] int colNr = 3; [EOL] JsonReadContext firstChildContext = parentContext.createChildArrayContext(lineNr, colNr); [EOL] int newLineNr = 4; [EOL] int newColNr = 5; [EOL] JsonReadContext secondChildContext = parentContext.createChildArrayContext(newLineNr, newColNr); [EOL] assertNotNull(secondChildContext); [EOL] assertSame(firstChildContext, secondChildContext); [EOL] assertEquals(JsonReadContext.TYPE_ARRAY, secondChildContext.getType()); [EOL] assertEquals(newLineNr, secondChildContext.getLineNr()); [EOL] assertEquals(newColNr, secondChildContext.getColNr()); [EOL] }
public void testCreateChildObjectContext_WithNoExistingChild() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] JsonReadContext childContext = parentContext.createChildObjectContext(2, 5); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonReadContext.TYPE_OBJECT, childContext.getType()); [EOL] assertEquals(2, childContext.getLineNr()); [EOL] assertEquals(5, childContext.getColNr()); [EOL] assertSame(parentContext, childContext.getParent()); [EOL] }
public void testCreateChildObjectContext_WithExistingChild() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] JsonReadContext existingChild = parentContext.createChildObjectContext(2, 5); [EOL] JsonReadContext reusedChild = parentContext.createChildObjectContext(3, 10); [EOL] assertNotNull(reusedChild); [EOL] assertEquals(JsonReadContext.TYPE_OBJECT, reusedChild.getType()); [EOL] assertEquals(3, reusedChild.getLineNr()); [EOL] assertEquals(10, reusedChild.getColNr()); [EOL] assertSame(parentContext, reusedChild.getParent()); [EOL] assertSame(existingChild, reusedChild); [EOL] }
public void testVersionForWithPackageVersion() { [EOL] Class<?> cls = MyClassWithPackageVersion.class; // Assume this class has a PACKAGE_VERSION field [EOL] Version result = JacksonCore.versionFor(cls); [EOL] assertNotNull(result); [EOL] assertEquals(new Version(1, 0, 0, null, null, null), result); [EOL] }
public void testVersionForWithoutPackageVersionAndVersionFileExists() { [EOL] Class<?> cls = MyClassWithoutPackageVersion.class; // Assume this class does not have a PACKAGE_VERSION field but has VERSION_FILE [EOL] Version result = JacksonCore.versionFor(cls); [EOL] assertNotNull(result); [EOL] assertEquals(new Version(1, 2, 3, "SNAPSHOT", "com.example", "my-module"), result); [EOL] }
public void testVersionForWithoutPackageVersionAndVersionFileMissing() { [EOL] Class<?> cls = MyClassWithoutPackageVersionAndFile.class; // Assume this class does not have a PACKAGE_VERSION field and missing VERSION_FILE [EOL] Version result = JacksonCore.versionFor(cls); [EOL] assertNotNull(result); [EOL] assertEquals(Version.unknownVersion(), result); [EOL] }
public void testVersionForIOExceptionOnCloseInputStream() { [EOL] Class<?> cls = MyClassWithIOExceptionOnClose.class; // Assume closing the InputStream of this class throws IOException [EOL] try { [EOL] JacksonCore.versionFor(cls); [EOL] fail("Expected RuntimeException due to IOException on closing InputStream"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVersionForUnsupportedEncodingException() { [EOL] Class<?> cls = MyClassWithUnsupportedEncoding.class; // Assume this class's VERSION_FILE has an unsupported encoding [EOL] Version result = JacksonCore.versionFor(cls); [EOL] assertNotNull(result); [EOL] assertEquals(Version.unknownVersion(), result); [EOL] }
public void testPackageVersionFor_WithValidClass() { [EOL] Class<?> cls = ValidVersionedClass.class; [EOL] Version result = JacksonCoreUtils.packageVersionFor(cls); [EOL] assertNotNull(result); [EOL] assertEquals(result.getMajorVersion(), 1); // Assuming ValidVersionedClass has a version 1.x [EOL] } [EOL] public void testPackageVersionFor_WithInvalidClass() { [EOL] Class<?> cls = InvalidVersionedClass.class; [EOL] try { [EOL] JacksonCoreUtils.packageVersionFor(cls); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testPackageVersionFor_WithNonVersionedClass() { [EOL] Class<?> cls = NonVersionedClass.class; [EOL] try { [EOL] JacksonCoreUtils.packageVersionFor(cls); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testPackageVersionFor_WithNullPackage() { [EOL] Class<?> cls = ClassWithoutPackage.class; [EOL] Version result = JacksonCoreUtils.packageVersionFor(cls); [EOL] assertNull(result); [EOL] } [EOL] public void testPackageVersionFor_WithExceptionInVersionClassInstantiation() { [EOL] Class<?> cls = VersionedClassWithExceptionInConstructor.class; [EOL] try { [EOL] JacksonCoreUtils.packageVersionFor(cls); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }

public void testMavenVersionForWithExistingPomProperties() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version version = JacksonCoreVersion.mavenVersionFor(classLoader, groupId, artifactId); [EOL] assertNotNull(version); [EOL] assertNotEquals(Version.unknownVersion(), version); [EOL] }
public void testMavenVersionForWithNonExistingPomProperties() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String groupId = "non.existing.group"; [EOL] String artifactId = "non-existing-artifact"; [EOL] Version version = JacksonCoreVersion.mavenVersionFor(classLoader, groupId, artifactId); [EOL] assertNotNull(version); [EOL] assertEquals(Version.unknownVersion(), version); [EOL] }
public void testMavenVersionForWithIOExceptionOnLoad() { [EOL] ClassLoader classLoader = new ClassLoader() { [EOL] @Override [EOL] public InputStream getResourceAsStream(String name) { [EOL] if ("META-INF/maven/com.fasterxml.jackson.core/jackson-core/pom.properties".equals(name)) { [EOL] return new InputStream() { [EOL] @Override [EOL] public int read() throws IOException { [EOL] throw new IOException("Test IOException"); [EOL] } [EOL] }; [EOL] } [EOL] return super.getResourceAsStream(name); [EOL] } [EOL] }; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version version = JacksonCoreVersion.mavenVersionFor(classLoader, groupId, artifactId); [EOL] assertNotNull(version); [EOL] assertEquals(Version.unknownVersion(), version); [EOL] }
public void testMavenVersionForWithIOExceptionOnClose() { [EOL] ClassLoader classLoader = new ClassLoader() { [EOL] @Override [EOL] public InputStream getResourceAsStream(String name) { [EOL] if ("META-INF/maven/com.fasterxml.jackson.core/jackson-core/pom.properties".equals(name)) { [EOL] return new InputStream() { [EOL] @Override [EOL] public int read() { [EOL] return -1; // end of stream [EOL] } [EOL] @Override [EOL] public void close() throws IOException { [EOL] throw new IOException("Test IOException on close"); [EOL] } [EOL] }; [EOL] } [EOL] return super.getResourceAsStream(name); [EOL] } [EOL] }; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version version = JacksonCoreVersion.mavenVersionFor(classLoader, groupId, artifactId); [EOL] assertNotNull(version); [EOL] assertNotEquals(Version.unknownVersion(), version); [EOL] }
public void testParseVersionWithNullInput() { [EOL] String versionStr = null; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNull(result); [EOL] }
public void testParseVersionWithEmptyString() { [EOL] String versionStr = ""; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNull(result); [EOL] }
public void testParseVersionWithValidInput() { [EOL] String versionStr = "2.10.3-SNAPSHOT"; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.getMajorVersion()); [EOL] assertEquals(10, result.getMinorVersion()); [EOL] assertEquals(3, result.getPatchLevel()); [EOL] assertEquals("SNAPSHOT", result.getSnapshotInfo()); [EOL] assertEquals(groupId, result.getGroupId()); [EOL] assertEquals(artifactId, result.getArtifactId()); [EOL] }
public void testParseVersionWithOnlyMajor() { [EOL] String versionStr = "3"; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.getMajorVersion()); [EOL] assertEquals(0, result.getMinorVersion()); [EOL] assertEquals(0, result.getPatchLevel()); [EOL] assertNull(result.getSnapshotInfo()); [EOL] }
public void testParseVersionWithMajorAndMinor() { [EOL] String versionStr = "3.1"; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.getMajorVersion()); [EOL] assertEquals(1, result.getMinorVersion()); [EOL] assertEquals(0, result.getPatchLevel()); [EOL] assertNull(result.getSnapshotInfo()); [EOL] }
public void testParseVersionWithMajorMinorAndPatch() { [EOL] String versionStr = "3.1.4"; [EOL] String groupId = "com.fasterxml.jackson.core"; [EOL] String artifactId = "jackson-core"; [EOL] Version result = Version.parseVersion(versionStr, groupId, artifactId); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.getMajorVersion()); [EOL] assertEquals(1, result.getMinorVersion()); [EOL] assertEquals(4, result.getPatchLevel()); [EOL] assertNull(result.getSnapshotInfo()); [EOL] }
public void testParseVersionPartWithAllDigits() { [EOL] int result = parseVersionPart("123"); [EOL] assertEquals(123, result); [EOL] }
public void testParseVersionPartWithLeadingZeros() { [EOL] int result = parseVersionPart("007"); [EOL] assertEquals(7, result); [EOL] }
public void testParseVersionPartWithNonDigitCharacters() { [EOL] int result = parseVersionPart("123abc"); [EOL] assertEquals(123, result); [EOL] }
public void testParseVersionPartWithEmptyString() { [EOL] int result = parseVersionPart(""); [EOL] assertEquals(0, result); [EOL] }
public void testParseVersionPartWithOnlyNonDigits() { [EOL] int result = parseVersionPart("abc"); [EOL] assertEquals(0, result); [EOL] }
public void testWriteFieldNameWithExpectedValueStatus() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContext(JsonWriteContext.STATUS_EXPECT_VALUE); [EOL] try { [EOL] generator.writeFieldName("fieldName"); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteFieldNameWithPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContextAndPrettyPrinter(JsonWriteContext.STATUS_OK_AFTER_COMMA); [EOL] generator.writeFieldName("fieldName"); [EOL] }
public void testWriteFieldNameAfterCommaWithoutPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContext(JsonWriteContext.STATUS_OK_AFTER_COMMA); [EOL] generator.writeFieldName("fieldName"); [EOL] }
public void testWriteFieldNameWithoutCommaAndPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContext(JsonWriteContext.STATUS_OK_AFTER_COLON); [EOL] generator.writeFieldName("fieldName"); [EOL] }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL] _verifyValueWrite("write text value"); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] if (len <= _outputMaxContiguous) { [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _writeStringSegment(text, offset, len); [EOL] } else { [EOL] _writeStringSegments(text, offset, len); [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void writeNumber_withSmallInt_writesNumber() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(false, 10); [EOL] generator.writeNumber(5); [EOL] verify(generator, times(1))._flushBuffer(); [EOL] verify(generator, never())._writeQuotedInt(anyInt()); [EOL] assertEquals(5, generator.getOutputBuffer()[generator.getOutputTail() - 1]); [EOL] }
public void writeNumber_withLargeInt_writesNumber() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(false, 1000); [EOL] generator.writeNumber(123456789); [EOL] verify(generator, never())._flushBuffer(); [EOL] verify(generator, never())._writeQuotedInt(anyInt()); [EOL] assertTrue(generator.getOutputTail() > 0); [EOL] }
public void writeNumber_withNumbersAsStrings_writesQuotedNumber() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(true, 10); [EOL] generator.writeNumber(5); [EOL] verify(generator, never())._flushBuffer(); [EOL] verify(generator, times(1))._writeQuotedInt(5); [EOL] }
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL] int status = _writeContext.writeValue(); [EOL] if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL] _reportError("Can not " + typeMsg + ", expecting field name"); [EOL] } [EOL] if (_cfgPrettyPrinter == null) { [EOL] byte b; [EOL] switch(status) { [EOL] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL] b = BYTE_COMMA; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL] b = BYTE_COLON; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL] if (_rootValueSeparator != null) { [EOL] byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL] if (raw.length > 0) { [EOL] _writeBytes(raw); [EOL] } [EOL] } [EOL] return; [EOL] case JsonWriteContext.STATUS_OK_AS_IS: [EOL] default: [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail] = b; [EOL] ++_outputTail; [EOL] return; [EOL] } [EOL] _verifyPrettyValueWrite(typeMsg, status); [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
@Override [EOL] public final void flush() throws IOException { [EOL] _flushBuffer(); [EOL] if (_outputStream != null) { [EOL] if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL] _outputStream.flush(); [EOL] } [EOL] } [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testGetTypeDescForTypeRoot() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_ROOT is a static field [EOL] assertEquals("ROOT", token.getTypeDesc()); [EOL] }
public void testGetTypeDescForTypeArray() { [EOL] JsonToken token = JsonToken.START_ARRAY; // Assuming JsonToken is the class and TYPE_ARRAY is a static field [EOL] assertEquals("ARRAY", token.getTypeDesc()); [EOL] }
public void testGetTypeDescForTypeObject() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_OBJECT is a static field [EOL] assertEquals("OBJECT", token.getTypeDesc()); [EOL] }
public void testGetTypeDescForUnknownType() { [EOL] JsonToken token = JsonToken.NOT_AVAILABLE; // Assuming JsonToken is the class and NOT_AVAILABLE is a static field for an undefined type [EOL] assertEquals("?", token.getTypeDesc()); [EOL] }
public void testByteSourceJsonBootstrapper() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ByteSourceJsonBootstrapper bootstrapper = new ByteSourceJsonBootstrapper(ctxt, in); [EOL] assertNotNull(bootstrapper); [EOL] assertEquals(0, bootstrapper._inputEnd); [EOL] assertEquals(0, bootstrapper._inputPtr); [EOL] assertEquals(0, bootstrapper._inputProcessed); [EOL] assertTrue(bootstrapper._bufferRecyclable); [EOL] assertNotNull(bootstrapper._inputBuffer); [EOL] }
public void testDetectEncodingWithNoBOMAndNotEnoughBytes() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {0, 0, 0}; // Less than 4 bytes [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF8, encoding); [EOL] } [EOL] public void testDetectEncodingWithUTF8BOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xEF, (byte)0xBB, (byte)0xBF, 0}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF8, encoding); [EOL] } [EOL] public void testDetectEncodingWithUTF32BEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {0, 0, (byte)0xFE, (byte)0xFF}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF32_BE, encoding); [EOL] } [EOL] public void testDetectEncodingWithUTF32LEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFF, (byte)0xFE, 0, 0}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF32_LE, encoding); [EOL] } [EOL] public void testDetectEncodingWithUTF16BEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFE, (byte)0xFF}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF16_BE, encoding); [EOL] } [EOL] public void testDetectEncodingWithUTF16LEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFF, (byte)0xFE}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF16_LE, encoding); [EOL] } [EOL] public void testDetectEncodingWithInvalidBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {1, 2, 3, 4}; // Not a valid BOM [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF8, encoding); [EOL] } [EOL] public void testDetectEncodingWithException() { [EOL] _inputBuffer = new byte[] {0, 0, 0, 0}; [EOL] _inputPtr = 0; [EOL] _bytesPerChar = 3; // Invalid value that should cause an exception [EOL] try { [EOL] JsonEncoding encoding = detectEncoding(); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Internal error", e.getMessage()); [EOL] } [EOL] }
public void testConstructReaderUTF32BE() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF32_BE); [EOL] when(_context.getEncoding().isBigEndian()).thenReturn(true); [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof UTF32Reader); [EOL] }
public void testConstructReaderUTF32LE() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF32_LE); [EOL] when(_context.getEncoding().isBigEndian()).thenReturn(false); [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof UTF32Reader); [EOL] }
public void testConstructReaderUTF16BE() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF16_BE); [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderUTF16LE() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF16_LE); [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderUTF8() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF8); [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderWithInputStreamNotNull() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF8); [EOL] _in = mock(InputStream.class); [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderWithInputStreamNull() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF8); [EOL] _in = null; [EOL] _inputBuffer = new byte[]{}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderWithInputStreamNotNullAndBufferNotEmpty() throws IOException { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(JsonEncoding.UTF8); [EOL] _in = mock(InputStream.class); [EOL] _inputBuffer = new byte[]{1, 2, 3}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] Reader reader = constructReader(); [EOL] assertTrue(reader instanceof InputStreamReader); [EOL] }
public void testConstructReaderInternalError() { [EOL] _context = mock(IOContext.class); [EOL] when(_context.getEncoding()).thenReturn(null); [EOL] Exception exception = assertThrows(RuntimeException.class, () -> { [EOL] Reader reader = constructReader(); [EOL] }); [EOL] assertEquals("Internal error", exception.getMessage()); [EOL] }
public void testConstructParserWithUTF8AndCanonicalize() throws IOException, JsonParseException { [EOL] int parserFeatures = 0; [EOL] ObjectCodec codec = null; [EOL] BytesToNameCanonicalizer rootByteSymbols = mock(BytesToNameCanonicalizer.class); [EOL] CharsToNameCanonicalizer rootCharSymbols = null; [EOL] boolean canonicalize = true; [EOL] boolean intern = false; [EOL] when(rootByteSymbols.makeChild(canonicalize, intern)).thenReturn(mock(BytesToNameCanonicalizer.class)); [EOL] JsonParser result = constructParser(parserFeatures, codec, rootByteSymbols, rootCharSymbols, canonicalize, intern); [EOL] assertTrue(result instanceof UTF8StreamJsonParser); [EOL] }
public void testConstructParserWithUTF8AndNotCanonicalize() throws IOException, JsonParseException { [EOL] int parserFeatures = 0; [EOL] ObjectCodec codec = null; [EOL] BytesToNameCanonicalizer rootByteSymbols = mock(BytesToNameCanonicalizer.class); [EOL] CharsToNameCanonicalizer rootCharSymbols = null; [EOL] boolean canonicalize = false; [EOL] boolean intern = false; [EOL] JsonParser result = constructParser(parserFeatures, codec, rootByteSymbols, rootCharSymbols, canonicalize, intern); [EOL] assertTrue(result instanceof ReaderBasedJsonParser); [EOL] }
public void testConstructParserWithNonUTF8() throws IOException, JsonParseException { [EOL] int parserFeatures = 0; [EOL] ObjectCodec codec = null; [EOL] BytesToNameCanonicalizer rootByteSymbols = null; [EOL] CharsToNameCanonicalizer rootCharSymbols = mock(CharsToNameCanonicalizer.class); [EOL] boolean canonicalize = true; [EOL] boolean intern = true; [EOL] when(rootCharSymbols.makeChild(canonicalize, intern)).thenReturn(mock(CharsToNameCanonicalizer.class)); [EOL] JsonParser result = constructParser(parserFeatures, codec, rootByteSymbols, rootCharSymbols, canonicalize, intern); [EOL] assertTrue(result instanceof ReaderBasedJsonParser); [EOL] }
public void testHandleBOMWith0x0000FEFF() throws IOException { [EOL] int quad = 0x0000FEFF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(4, _inputPtr); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xFFFE0000() throws IOException { [EOL] int quad = 0xFFFE0000; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertFalse(_bigEndian); [EOL] assertEquals(4, _inputPtr); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testHandleBOMWith0x0000FFFE() throws IOException { [EOL] int quad = 0x0000FFFE; [EOL] try { [EOL] handleBOM(quad); [EOL] fail("Should throw IOException for 0x0000FFFE"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testHandleBOMWith0xFEFF0000() throws IOException { [EOL] int quad = 0xFEFF0000; [EOL] try { [EOL] handleBOM(quad); [EOL] fail("Should throw IOException for 0xFEFF0000"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testHandleBOMWith0xFEFF() throws IOException { [EOL] int quad = 0x0000FEFF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(2, _inputPtr); [EOL] assertEquals(2, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xFFFE() throws IOException { [EOL] int quad = 0x0000FFFE; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertFalse(_bigEndian); [EOL] assertEquals(2, _inputPtr); [EOL] assertEquals(2, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xEFBBBF() throws IOException { [EOL] int quad = 0x00EFBBBF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(3, _inputPtr); [EOL] assertEquals(1, _bytesPerChar); [EOL] }
public void testHandleBOMWithInvalidQuad() throws IOException { [EOL] int quad = 0x12345678; [EOL] boolean result = handleBOM(quad); [EOL] assertFalse(result); [EOL] }
public void testCheckUTF32_BigEndian() throws IOException { [EOL] int quad = 0x00010000; // Big endian with only the highest byte non-zero [EOL] assertTrue(checkUTF32(quad)); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testCheckUTF32_LittleEndian() throws IOException { [EOL] int quad = 0x00000001; // Little endian with only the lowest byte non-zero [EOL] assertTrue(checkUTF32(quad)); [EOL] assertFalse(_bigEndian); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testCheckUTF32_WeirdUCS4_3412() throws IOException { [EOL] int quad = 0x00010000; // 3412 format with only the second highest byte non-zero [EOL] try { [EOL] checkUTF32(quad); [EOL] fail("Should have thrown IOException for 3412 format"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCheckUTF32_WeirdUCS4_2143() throws IOException { [EOL] int quad = 0x00000100; // 2143 format with only the second lowest byte non-zero [EOL] try { [EOL] checkUTF32(quad); [EOL] fail("Should have thrown IOException for 2143 format"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCheckUTF32_InvalidFormat() throws IOException { [EOL] int quad = 0x12345678; // No valid UTF-32 format [EOL] assertFalse(checkUTF32(quad)); [EOL] }
public void testCheckUTF16WithFirstByteNonZero() { [EOL] JacksonCoreTest obj = new JacksonCoreTest(); [EOL] boolean result = obj.checkUTF16(0xFF00); [EOL] assertTrue(result); [EOL] assertTrue(obj.isBigEndian()); [EOL] }
public void testCheckUTF16WithSecondByteNonZero() { [EOL] JacksonCoreTest obj = new JacksonCoreTest(); [EOL] boolean result = obj.checkUTF16(0x00FF); [EOL] assertTrue(result); [EOL] assertFalse(obj.isBigEndian()); [EOL] }
public void testCheckUTF16WithNoBytesZero() { [EOL] JacksonCoreTest obj = new JacksonCoreTest(); [EOL] boolean result = obj.checkUTF16(0xFFFF); [EOL] assertFalse(result); [EOL] }
public void testEnsureLoadedWithNullInput() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] _in = null; [EOL] boolean result = ensureLoaded(10); [EOL] assertFalse(result); [EOL] }
public void testEnsureLoadedWithSufficientBuffer() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 10; [EOL] _in = new ByteArrayInputStream(new byte[20]); [EOL] boolean result = ensureLoaded(5); [EOL] assertTrue(result); [EOL] }
public void testEnsureLoadedWithPartialReads() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] _in = new ByteArrayInputStream(new byte[20]) { [EOL] private int readCount = 0; [EOL] @Override [EOL] public int read(byte[] b, int off, int len) { [EOL] if (readCount < 2) { [EOL] readCount++; [EOL] return 4; // return less than minimum to force loop [EOL] } else { [EOL] return -1; // simulate end of stream [EOL] } [EOL] } [EOL] }; [EOL] boolean result = ensureLoaded(10); [EOL] assertFalse(result); [EOL] }
public void testEnsureLoadedWithExactReads() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] _in = new ByteArrayInputStream(new byte[10]); [EOL] boolean result = ensureLoaded(10); [EOL] assertTrue(result); [EOL] }
public void testDefaultPrettyPrinterConstructor() { [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] assertNotNull(prettyPrinter); [EOL] assertEquals(DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR, prettyPrinter.getRootValueSeparator()); [EOL] }
public void testDefaultPrettyPrinterWithNullRootSeparator() { [EOL] DefaultPrettyPrinter printer = new DefaultPrettyPrinter(null); [EOL] assertNull(printer.getRootSeparator()); [EOL] }
public void testDefaultPrettyPrinterWithNonNullRootSeparator() { [EOL] String rootSeparator = "\n"; [EOL] DefaultPrettyPrinter printer = new DefaultPrettyPrinter(rootSeparator); [EOL] assertNotNull(printer.getRootSeparator()); [EOL] assertEquals(new SerializedString(rootSeparator), printer.getRootSeparator()); [EOL] }
public void testDefaultPrettyPrinterWithNullRootSeparator() { [EOL] SerializableString rootSeparator = null; [EOL] DefaultPrettyPrinter printer = new DefaultPrettyPrinter(rootSeparator); [EOL] assertNull(printer._rootSeparator); [EOL] }
public void testDefaultPrettyPrinterWithNonNullRootSeparator() { [EOL] SerializableString rootSeparator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return ","; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return 1; [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] DefaultPrettyPrinter printer = new DefaultPrettyPrinter(rootSeparator); [EOL] assertEquals(rootSeparator, printer._rootSeparator); [EOL] }
public void testWriteRootValueSeparatorWithNonNullRootSeparator() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String rootSeparator = ","; [EOL] JsonWriteContext context = new JsonWriteContext(0, null, null); [EOL] context._rootSeparator = rootSeparator; [EOL] context.writeRootValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(rootSeparator); [EOL] }
public void testWriteRootValueSeparatorWithNullRootSeparator() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext context = new JsonWriteContext(0, null, null); [EOL] context._rootSeparator = null; [EOL] context.writeRootValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator, never()).writeRaw(anyString()); [EOL] }
public void testWriteStartObjectWithInlineIndenter() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._objectIndenter = new DefaultPrettyPrinter.FixedSpaceIndenter(); [EOL] prettyPrinter.writeStartObject(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('{'); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testWriteStartObjectWithNonInlineIndenter() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._objectIndenter = new DefaultIndenter("  ", "\n"); [EOL] prettyPrinter._nesting = 0; [EOL] prettyPrinter.writeStartObject(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('{'); [EOL] assertEquals(1, prettyPrinter._nesting); [EOL] }
public void testBeforeObjectEntriesWithProperNesting() throws IOException { [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter.NopIndenter indenter = new DefaultPrettyPrinter.NopIndenter(); [EOL] indenter.beforeObjectEntries(mockJsonGenerator); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 0); [EOL] }
public void testBeforeObjectEntriesWithIncreasedNesting() throws IOException { [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter.NopIndenter indenter = new DefaultPrettyPrinter.NopIndenter(); [EOL] indenter._nesting = 1; [EOL] indenter.beforeObjectEntries(mockJsonGenerator); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 1); [EOL] }
public void testWriteObjectFieldValueSeparatorWithSpaces() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriter writer = new JsonWriter(); [EOL] writer._spacesInObjectEntries = true; [EOL] writer.writeObjectFieldValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(" : "); [EOL] }
public void testWriteObjectFieldValueSeparatorWithoutSpaces() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriter writer = new JsonWriter(); [EOL] writer._spacesInObjectEntries = false; [EOL] writer.writeObjectFieldValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(':'); [EOL] }
public void testWriteObjectEntrySeparatorWithNoNesting() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._objectIndenter = mockIndenter; [EOL] prettyPrinter._nesting = 0; [EOL] prettyPrinter.writeObjectEntrySeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(','); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 0); [EOL] }
public void testWriteObjectEntrySeparatorWithNesting() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._objectIndenter = mockIndenter; [EOL] prettyPrinter._nesting = 1; [EOL] prettyPrinter.writeObjectEntrySeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(','); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 1); [EOL] }
public void testWriteEndObject_WithInlineIndenterAndNoEntries() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(true).when(indenter).isInline(); [EOL] indenter.writeEndObject(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw('}'); [EOL] verify(indenter, never()).writeIndentation(any(JsonGenerator.class), anyInt()); [EOL] }
public void testWriteEndObject_WithInlineIndenterAndEntries() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(true).when(indenter).isInline(); [EOL] indenter.writeEndObject(mockJsonGenerator, 1); [EOL] verify(mockJsonGenerator, never()).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw('}'); [EOL] verify(indenter).writeIndentation(mockJsonGenerator, 0); [EOL] }
public void testWriteEndObject_WithNonInlineIndenterAndNoEntries() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(false).when(indenter).isInline(); [EOL] indenter.writeEndObject(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw('}'); [EOL] verify(indenter, never()).writeIndentation(any(JsonGenerator.class), anyInt()); [EOL] verify(indenter).setNesting(anyInt()); [EOL] }
public void testWriteEndObject_WithNonInlineIndenterAndEntries() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(false).when(indenter).isInline(); [EOL] indenter.writeEndObject(mockJsonGenerator, 1); [EOL] verify(mockJsonGenerator, never()).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw('}'); [EOL] verify(indenter).writeIndentation(mockJsonGenerator, 0); [EOL] verify(indenter).setNesting(anyInt()); [EOL] }
public void testWriteStartArrayWithInlineIndenter() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._arrayIndenter = new DefaultPrettyPrinter.FixedSpaceIndenter(); [EOL] prettyPrinter.writeStartArray(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('['); [EOL] assertEquals(0, prettyPrinter._nesting); [EOL] }
public void testWriteStartArrayWithNonInlineIndenter() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._arrayIndenter = new DefaultPrettyPrinter.NopIndenter(); [EOL] prettyPrinter.writeStartArray(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('['); [EOL] assertEquals(1, prettyPrinter._nesting); [EOL] }
public void testBeforeArrayValuesWithProperIndenter() throws IOException { [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._arrayIndenter = mockIndenter; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] prettyPrinter._nesting = 1; [EOL] prettyPrinter.beforeArrayValues(mockJsonGenerator); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 1); [EOL] }
public void testBeforeArrayValuesWithNoOpIndenter() throws IOException { [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] prettyPrinter._arrayIndenter = DefaultPrettyPrinter.NopIndenter.instance; [EOL] prettyPrinter._nesting = 1; [EOL] prettyPrinter.beforeArrayValues(mockJsonGenerator); [EOL] verifyNoInteractions(mockJsonGenerator); [EOL] }
public void testWriteArrayValueSeparator() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultPrettyPrinter.Indenter mockIndenter = mock(DefaultPrettyPrinter.Indenter.class); [EOL] DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter(); [EOL] prettyPrinter._arrayIndenter = mockIndenter; [EOL] prettyPrinter._nesting = 1; // Assuming _nesting is a modifiable field [EOL] prettyPrinter.writeArrayValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(','); [EOL] verify(mockIndenter).writeIndentation(mockJsonGenerator, 1); [EOL] }
public void testWriteEndArrayWithInlineIndenterAndNonZeroNrOfValues() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(true).when(indenter).isInline(); [EOL] JsonWriteContext context = new JsonWriteContext(1, null, indenter); [EOL] context.writeEndArray(mockJsonGenerator, 5); [EOL] verify(indenter, never()).writeIndentation(any(JsonGenerator.class), anyInt()); [EOL] verify(mockJsonGenerator, never()).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw(']'); [EOL] }
public void testWriteEndArrayWithInlineIndenterAndZeroNrOfValues() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(true).when(indenter).isInline(); [EOL] JsonWriteContext context = new JsonWriteContext(1, null, indenter); [EOL] context.writeEndArray(mockJsonGenerator, 0); [EOL] verify(indenter, never()).writeIndentation(any(JsonGenerator.class), anyInt()); [EOL] verify(mockJsonGenerator).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw(']'); [EOL] }
public void testWriteEndArrayWithNonInlineIndenterAndNonZeroNrOfValues() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(false).when(indenter).isInline(); [EOL] JsonWriteContext context = new JsonWriteContext(1, null, indenter); [EOL] context.writeEndArray(mockJsonGenerator, 5); [EOL] verify(indenter).writeIndentation(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator, never()).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw(']'); [EOL] }
public void testWriteEndArrayWithNonInlineIndenterAndZeroNrOfValues() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] DefaultIndenter indenter = new DefaultIndenter("  ", 1); [EOL] indenter = spy(indenter); [EOL] doReturn(false).when(indenter).isInline(); [EOL] JsonWriteContext context = new JsonWriteContext(1, null, indenter); [EOL] context.writeEndArray(mockJsonGenerator, 0); [EOL] verify(indenter, never()).writeIndentation(any(JsonGenerator.class), anyInt()); [EOL] verify(mockJsonGenerator).writeRaw(' '); [EOL] verify(mockJsonGenerator).writeRaw(']'); [EOL] }
public void testWriteIndentation() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext testInstance = new JsonWriteContext(1, null, null); [EOL] testInstance.writeIndentation(mockJsonGenerator, 1); [EOL] verify(mockJsonGenerator).writeRaw(' '); [EOL] }
public void testIsInline() { [EOL] JsonGenerator gen = new MyJsonGenerator(); // Assuming MyJsonGenerator extends JsonGenerator [EOL] boolean result = gen.isInline(); [EOL] assertTrue(result); [EOL] }
public void testLf2SpacesIndenterConstructor() { [EOL] Lf2SpacesIndenter indenter = new Lf2SpacesIndenter(); [EOL] assertNotNull(indenter); [EOL] }
public void testLf2SpacesIndenterWithNull() { [EOL] Lf2SpacesIndenter indenter = new Lf2SpacesIndenter(null); [EOL] assertNull(indenter.getLf()); [EOL] }
public void testLf2SpacesIndenterWithEmptyString() { [EOL] Lf2SpacesIndenter indenter = new Lf2SpacesIndenter(""); [EOL] assertEquals("", indenter.getLf()); [EOL] }
public void testLf2SpacesIndenterWithNewLine() { [EOL] Lf2SpacesIndenter indenter = new Lf2SpacesIndenter("\n"); [EOL] assertEquals("\n", indenter.getLf()); [EOL] }
public void testIsInline() { [EOL] JsonGenerator gen = new MyJsonGenerator(); [EOL] boolean result = gen.isInline(); [EOL] assertFalse(result); [EOL] }
public void testWriteIndentationWithNegativeLevel() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] IndentationWriter writer = new IndentationWriter(); [EOL] writer.writeIndentation(mockJsonGenerator, -1); [EOL] verify(mockJsonGenerator).writeRaw(_lf); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testWriteIndentationWithZeroLevel() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] IndentationWriter writer = new IndentationWriter(); [EOL] writer.writeIndentation(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator).writeRaw(_lf); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testWriteIndentationWithLevelOne() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] IndentationWriter writer = new IndentationWriter(); [EOL] writer.writeIndentation(mockJsonGenerator, 1); [EOL] verify(mockJsonGenerator).writeRaw(_lf); [EOL] verify(mockJsonGenerator).writeRaw(SPACES, 0, 1); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testWriteIndentationWithLevelGreaterThanSpaceCount() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] IndentationWriter writer = new IndentationWriter(); [EOL] final int level = SPACE_COUNT + 1; [EOL] writer.writeIndentation(mockJsonGenerator, level); [EOL] verify(mockJsonGenerator).writeRaw(_lf); [EOL] verify(mockJsonGenerator, times(1)).writeRaw(SPACES, 0, SPACE_COUNT); [EOL] verify(mockJsonGenerator).writeRaw(SPACES, 0, level - SPACE_COUNT); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testGetJavaName() { [EOL] JsonProperty prop = new JsonProperty("testName"); [EOL] String javaName = prop.getJavaName(); [EOL] assertEquals("testName", javaName); [EOL] }
public void testIsBigEndianTrue() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.configure(JsonFactory.Feature.USE_BIG_ENDIAN_FOR_INT, true); [EOL] assertTrue(factory.isBigEndian()); [EOL] }
public void testIsBigEndianFalse() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.configure(JsonFactory.Feature.USE_BIG_ENDIAN_FOR_INT, false); [EOL] assertFalse(factory.isBigEndian()); [EOL] }
public void testGetPrettyPrinter() { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] PrettyPrinter pp = gen.getPrettyPrinter(); [EOL] assertNull(pp); [EOL] }
public void testSetAndGetPrettyPrinter() { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] PrettyPrinter pp = new DefaultPrettyPrinter(); [EOL] gen.setPrettyPrinter(pp); [EOL] assertSame(pp, gen.getPrettyPrinter()); [EOL] }
public void testWriteBooleanFieldTrue() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] gen.writeBooleanField("field", true); [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] assertOutput("{\"field\":true}"); [EOL] }
public void testWriteBooleanFieldFalse() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] gen.writeBooleanField("field", false); [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] assertOutput("{\"field\":false}"); [EOL] }
public void testWriteNullFieldWithValidFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); // You need to implement createJsonGenerator to instantiate your JsonGenerator [EOL] gen.writeStartObject(); // Assuming the generator needs to be in an object context [EOL] gen.writeNullField("fieldName"); [EOL] gen.writeEndObject(); [EOL] }
public void testWriteNullFieldWithNullFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); // You need to implement createJsonGenerator to instantiate your JsonGenerator [EOL] try { [EOL] gen.writeStartObject(); // Assuming the generator needs to be in an object context [EOL] gen.writeNullField(null); [EOL] fail("Should throw NullPointerException"); // Assuming writeFieldName does not accept null [EOL] } catch (NullPointerException e) { [EOL] } [EOL] gen.writeEndObject(); [EOL] }
public void testWriteNumberFieldWithValidFieldNameAndValue() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates a JsonGenerator instance [EOL] String fieldName = "testField"; [EOL] int value = 123; [EOL] generator.writeNumberField(fieldName, value); [EOL] String expectedOutput = "\"testField\":123"; [EOL] assertEquals(expectedOutput, generator.getOutput()); [EOL] }
public void testWriteNumberFieldWithNullFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] String fieldName = null; [EOL] int value = 123; [EOL] try { [EOL] generator.writeNumberField(fieldName, value); [EOL] fail("Expected JsonGenerationException was not thrown."); [EOL] } catch (JsonGenerationException e) { [EOL] String expectedMessage = "Field name cannot be null"; [EOL] assertEquals(expectedMessage, e.getMessage()); [EOL] } [EOL] }
public void testWriteNumberFieldWithEmptyFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] String fieldName = ""; [EOL] int value = 123; [EOL] generator.writeNumberField(fieldName, value); [EOL] String expectedOutput = "\":123"; [EOL] assertEquals(expectedOutput, generator.getOutput()); [EOL] }
public void testWriteNumberFieldWithValidFieldNameAndBigDecimal() throws IOException, JsonGenerationException { [EOL] String fieldName = "testField"; [EOL] BigDecimal value = new BigDecimal("123.456"); [EOL] JsonGenerator generator = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates a JsonGenerator instance [EOL] generator.writeNumberField(fieldName, value); [EOL] String output = getOutput(generator); [EOL] assertEquals("\"testField\":123.456", output); [EOL] }
public void testWriteNumberFieldWithNullFieldName() throws IOException, JsonGenerationException { [EOL] String fieldName = null; [EOL] BigDecimal value = new BigDecimal("123.456"); [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] assertThrows(NullPointerException.class, () -> { [EOL] generator.writeNumberField(fieldName, value); [EOL] }); [EOL] }
public void testWriteNumberFieldWithNullBigDecimal() throws IOException, JsonGenerationException { [EOL] String fieldName = "testField"; [EOL] BigDecimal value = null; [EOL] JsonGenerator generator = createJsonGenerator(); [EOL] generator.writeNumberField(fieldName, value); [EOL] String output = getOutput(generator); [EOL] assertEquals("\"testField\":null", output); [EOL] }
public void testWriteArrayFieldStart() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates an instance of JsonGenerator [EOL] gen.writeArrayFieldStart("myArray"); [EOL] String output = getOutput(gen); // Assuming getOutput() is a method that retrieves the generator's output [EOL] assertTrue(output.contains("\"myArray\": [")); [EOL] }

public void testWriteObjectFieldStart_ValidFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates an instance of JsonGenerator [EOL] gen.writeObjectFieldStart("myField"); [EOL] String expectedOutput = "{\"myField\":{"; [EOL] assertEquals(expectedOutput, gen.getOutput()); // Assuming getOutput() is a method that returns the current output as a string [EOL] }
public void testWriteObjectFieldStart_NullFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] try { [EOL] gen.writeObjectFieldStart(null); [EOL] fail("Expected JsonGenerationException was not thrown."); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testBase64VariantValidAlphabet() { [EOL] String name = "validName"; [EOL] String base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; [EOL] boolean usesPadding = true; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] Base64Variant variant = new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertEquals(usesPadding, variant.usesPadding()); [EOL] assertEquals(paddingChar, variant.getPaddingChar()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] for (int i = 0; i < base64Alphabet.length(); ++i) { [EOL] assertEquals(base64Alphabet.charAt(i), variant.encode(i)); [EOL] } [EOL] assertEquals(Base64Variant.BASE64_VALUE_PADDING, variant.decode(paddingChar)); [EOL] }
public void testBase64VariantInvalidAlphabetLength() { [EOL] String name = "invalidName"; [EOL] String base64Alphabet = "ABC"; // Invalid length [EOL] boolean usesPadding = true; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] try { [EOL] new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] fail("Should have thrown IllegalArgumentException due to invalid alphabet length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBase64VariantWithoutPadding() { [EOL] String name = "noPadding"; [EOL] String base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; [EOL] boolean usesPadding = false; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] Base64Variant variant = new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertEquals(usesPadding, variant.usesPadding()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] for (int i = 0; i < base64Alphabet.length(); ++i) { [EOL] assertEquals(base64Alphabet.charAt(i), variant.encode(i)); [EOL] } [EOL] try { [EOL] variant.decode(paddingChar); [EOL] fail("Should have thrown IllegalArgumentException because padding is not used"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetText2WithNullToken() { [EOL] String result = _getText2(null); [EOL] assertNull(result); [EOL] }
public void testGetText2WithFieldNameToken() { [EOL] JsonToken token = JsonToken.FIELD_NAME; [EOL] when(_parsingContext.getCurrentName()).thenReturn("fieldName"); [EOL] String result = _getText2(token); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetText2WithValueStringToken() { [EOL] JsonToken token = JsonToken.VALUE_STRING; [EOL] when(_textBuffer.contentsAsString()).thenReturn("stringValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetText2WithValueNumberIntToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_INT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("intValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("intValue", result); [EOL] }
public void testGetText2WithValueNumberFloatToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_FLOAT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("floatValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("floatValue", result); [EOL] }
public void testGetText2WithDefaultToken() { [EOL] JsonToken token = JsonToken.VALUE_TRUE; // Assuming VALUE_TRUE is a valid default case [EOL] String result = _getText2(token); [EOL] assertEquals("true", result); [EOL] }
public void testNextTokenWithFieldName() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] JsonToken result = nextToken(); [EOL] } [EOL] public void testNextTokenWithTokenIncomplete() throws IOException, JsonParseException { [EOL] _tokenIncomplete = true; [EOL] JsonToken result = nextToken(); [EOL] } [EOL] public void testNextTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(-1); [EOL] JsonToken result = nextToken(); [EOL] assertNull(result); [EOL] } [EOL] public void testNextTokenWithIntRBracket() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RBRACKET); [EOL] when(_parsingContext.inArray()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_ARRAY, result); [EOL] } [EOL] public void testNextTokenWithIntRBracketMismatch() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RBRACKET); [EOL] when(_parsingContext.inArray()).thenReturn(false); [EOL] } [EOL] public void testNextTokenWithIntRCurly() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RCURLY); [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] } [EOL] public void testNextTokenWithIntRCurlyMismatch() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RCURLY); [EOL] when(_parsingContext.inObject()).thenReturn(false); [EOL] } [EOL] public void testNextTokenExpectComma() throws IOException, JsonParseException { [EOL] when(_parsingContext.expectComma()).thenReturn(true); [EOL] when(_skipWSOrEnd()).thenReturn(INT_COMMA); [EOL] when(_skipWS()).thenReturn(INT_COLON); // Assuming INT_COLON is the next expected token [EOL] JsonToken result = nextToken(); [EOL] } [EOL] public void testNextTokenInObject() throws IOException, JsonParseException { [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] when(_skipWSOrEnd()).thenReturn(INT_COLON); // Assuming INT_COLON is the next expected token after field name [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] } [EOL] public void testNextTokenWithValue() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_QUOTE); // Assuming INT_QUOTE is the next expected token for a string value [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }

private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int outPtr = 0; [EOL] if (negative) { [EOL] outBuf[outPtr++] = '-'; [EOL] } [EOL] int intLen = 0; [EOL] char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL] if (c == '0') { [EOL] c = _verifyNoLeadingZeroes(); [EOL] } [EOL] boolean eof = false; [EOL] int_loop: while (c >= '0' && c <= '9') { [EOL] ++intLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] c = CHAR_NULL; [EOL] eof = true; [EOL] break int_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (intLen == 0) { [EOL] reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL] } [EOL] int fractLen = 0; [EOL] if (c == '.') { [EOL] outBuf[outPtr++] = c; [EOL] fract_loop: while (true) { [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break fract_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] if (c < INT_0 || c > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (c == 'e' || c == 'E') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] if (c == '-' || c == '+') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] } [EOL] exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL] ++expLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break exp_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] if (!eof) { [EOL] --_inputPtr; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] }
public void testParseFieldNameWithNonQuoteChar() throws IOException, JsonParseException { [EOL] final int NON_QUOTE_CHAR = 'a'; // Some character that is not a quote [EOL] String result = _parseFieldName(NON_QUOTE_CHAR); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharAtBufferEnd() throws IOException, JsonParseException { [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharBeforeBufferEnd() throws IOException, JsonParseException { [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithSpecialCharInBuffer() throws IOException, JsonParseException { [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldName2_EndOfInput() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 0; [EOL] int endChar = '}'; // Example end character [EOL] try { [EOL] _parseFieldName2(startPtr, hash, endChar); [EOL] fail("Should have thrown JsonParseException due to end of input"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseFieldName2_ValidEndChar() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 0; [EOL] int endChar = '}'; // Example end character [EOL] String result = _parseFieldName2(startPtr, hash, endChar); [EOL] assertNotNull("The result should not be null", result); [EOL] }
public void testParseFieldName2_EscapeChar() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 0; [EOL] int endChar = '}'; // Example end character [EOL] String result = _parseFieldName2(startPtr, hash, endChar); [EOL] assertNotNull("The result should not be null", result); [EOL] }
public void testParseFieldName2_InvalidChar() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 0; [EOL] int endChar = '}'; // Example end character [EOL] try { [EOL] _parseFieldName2(startPtr, hash, endChar); [EOL] fail("Should have thrown JsonParseException due to invalid character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected void _finishString2() throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.getCurrentSegment(); [EOL] int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL] while (true) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL] } [EOL] } [EOL] char c = _inputBuffer[_inputPtr++]; [EOL] int i = (int) c; [EOL] if (i <= INT_BACKSLASH) { [EOL] if (i == INT_BACKSLASH) { [EOL] c = _decodeEscaped(); [EOL] } else if (i <= INT_QUOTE) { [EOL] if (i == INT_QUOTE) { [EOL] break; [EOL] } [EOL] if (i < INT_SPACE) { [EOL] _throwUnquotedSpace(i, "string value"); [EOL] } [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
public void testSkipStringWithClosingQuote() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', 't', '"'}; [EOL] _skipString(); [EOL] assertEquals(6, _inputPtr); [EOL] }
public void testSkipStringWithoutClosingQuote() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', 't'}; [EOL] try { [EOL] _skipString(); [EOL] fail("Should throw JsonParseException due to missing closing quote"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipStringWithBackslash() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 7; [EOL] _inputBuffer = new char[]{'"', 't', '\\', 'n', 'e', 's', 't', '"'}; [EOL] _skipString(); [EOL] assertEquals(8, _inputPtr); [EOL] }
public void testSkipStringWithUnquotedSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', '\n'}; [EOL] try { [EOL] _skipString(); [EOL] fail("Should throw JsonParseException due to unquoted space"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'a'}; // 'a' is a non-space character [EOL] int result = _skipWS(); [EOL] assertEquals('a', result); [EOL] }
public void testSkipWSWithSlash() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'/'}; // '/' is INT_SLASH [EOL] _skipWS(); [EOL] }
public void testSkipWSWithSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{' '}; // ' ' is INT_SPACE [EOL] int result = _skipWS(); [EOL] assertEquals(' ', result); [EOL] }
public void testSkipWSWithLineFeed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\n'}; // '\n' is INT_LF [EOL] _skipWS(); [EOL] }
public void testSkipWSWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\r'}; // '\r' is INT_CR [EOL] _skipWS(); [EOL] }
public void testSkipWSWithTab() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\t'}; // '\t' is INT_TAB [EOL] int result = _skipWS(); [EOL] assertEquals('\t', result); [EOL] }
public void testSkipWSWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\b'}; // Assuming '\b' is an invalid space character [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to invalid space character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'a'}; // 'a' is a non-space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('a', result); [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', 'b'}; // '/' should trigger _skipComment [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('b', result); [EOL] }
public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\n'}; // '\n' should trigger _skipLF [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\r'}; // '\r' should trigger _skipCR [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\t'}; // '\t' is a tab character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{(char) 0x01}; // Non-valid whitespace character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndAtEndOfBuffer() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testDecodeEscapedInputPtrAtInputEndAndLoadMoreFails() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithBackspaceChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithTabChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithNewlineChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithFormFeedChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithCarriageReturnChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithQuoteSlashOrBackslashChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithUnrecognizedChar() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithUnicodeSequence() throws IOException { [EOL] } [EOL] public void testDecodeEscapedWithInvalidUnicodeSequence() throws IOException { [EOL] }
public void testJsonGenerationExceptionWithMessage() { [EOL] String message = "Test message"; [EOL] JsonGenerationException exception = new JsonGenerationException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] }
public void testNameInitialization() { [EOL] String expectedName = "testName"; [EOL] int expectedHashCode = 12345; [EOL] Name nameObj = new Name(expectedName, expectedHashCode); [EOL] assertEquals(expectedName, nameObj._name); [EOL] assertEquals(expectedHashCode, nameObj._hashCode); [EOL] }
public void testGetNameWhenNameIsNotNull() { [EOL] MyClass obj = new MyClass("TestName"); [EOL] String name = obj.getName(); [EOL] assertNotNull(name); [EOL] assertEquals("TestName", name); [EOL] }
public void testGetNameWhenNameIsNull() { [EOL] MyClass obj = new MyClass(null); [EOL] String name = obj.getName(); [EOL] assertNull(name); [EOL] }
public void testWriteEndArrayNotInArrayContext() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setWriteContextNotInArray(generator); [EOL] try { [EOL] generator.writeEndArray(); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndArrayWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setPrettyPrinter(generator); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(prettyPrinterInvoked(generator)); [EOL] } [EOL] public void testWriteEndArrayWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] assertNull(generator.getPrettyPrinter()); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(outputEndsWithCharacter(generator, ']')); [EOL] } [EOL] public void testWriteEndArrayFlushBuffer() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] assertNull(generator.getPrettyPrinter()); [EOL] enterArrayContext(generator); [EOL] fillOutputBuffer(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(bufferWasFlushed(generator)); [EOL] assertTrue(outputEndsWithCharacter(generator, ']')); [EOL] }
public void testWriteStartObjectWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl gen = createJsonGeneratorImplWithPrettyPrinter(); [EOL] gen.writeStartObject(); [EOL] assertTrue(gen.getPrettyPrinterInvoked()); [EOL] } [EOL] public void testWriteStartObjectWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl gen = createJsonGeneratorImpl(); [EOL] gen.writeStartObject(); [EOL] assertEquals('{', gen.getOutputBufferLastCharacter()); [EOL] assertNotNull(gen.getWriteContext()); [EOL] } [EOL] public void testWriteStartObjectWithFullBuffer() throws IOException { [EOL] JsonGeneratorImpl gen = createJsonGeneratorImplWithFullBuffer(); [EOL] gen.writeStartObject(); [EOL] assertTrue(gen.isBufferFlushed()); [EOL] assertEquals('{', gen.getOutputBufferLastCharacter()); [EOL] }

public void testWriteEndObject_NotInObjectContext() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] try { [EOL] generator.writeEndObject(); [EOL] fail("Should not pass, an exception is expected"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndObject_WithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImplWithPrettyPrinter(); [EOL] generator.writeStartObject(); // Set the context to object [EOL] generator.writeEndObject(); // Should not throw exception [EOL] } [EOL] public void testWriteEndObject_WithoutPrettyPrinter_BufferNotFull() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] generator.writeStartObject(); // Set the context to object [EOL] generator.writeEndObject(); // Should not throw exception [EOL] } [EOL] public void testWriteEndObject_WithoutPrettyPrinter_BufferFull() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImplWithFullBuffer(); [EOL] generator.writeStartObject(); // Set the context to object [EOL] generator._outputTail = generator._outputEnd; // Simulate full buffer [EOL] generator.writeEndObject(); // Should trigger _flushBuffer [EOL] }

public void testWriteFieldNameWithPrettyPrinterAndComma() throws IOException { [EOL] _cfgPrettyPrinter = mock(PrettyPrinter.class); [EOL] _writeFieldName("name", true); [EOL] verify(_cfgPrettyPrinter).writeFieldName("name"); [EOL] }
public void testWriteFieldNameWithBufferFlush() throws IOException { [EOL] _outputTail = _outputEnd; // Set output tail to trigger buffer flush [EOL] _writeFieldName("name", false); [EOL] assertTrue(/* condition to check if buffer was flushed */); [EOL] }
public void testWriteFieldNameWithCommaBefore() throws IOException { [EOL] _outputTail = 0; [EOL] _outputEnd = 10; // Ensure no buffer flush [EOL] _writeFieldName("name", true); [EOL] assertEquals(',', _outputBuffer[0]); [EOL] }
public void testWriteFieldNameWithoutQuoteFieldNames() throws IOException { [EOL] _outputTail = 0; [EOL] _outputEnd = 10; // Ensure no buffer flush [EOL] when(isEnabled(Feature.QUOTE_FIELD_NAMES)).thenReturn(false); [EOL] _writeFieldName("name", false); [EOL] assertEquals('n', _outputBuffer[0]); // Check the first character of the name [EOL] }
public void testWriteFieldNameWithQuoteFieldNames() throws IOException { [EOL] _outputTail = 0; [EOL] _outputEnd = 10; // Ensure no buffer flush [EOL] when(isEnabled(Feature.QUOTE_FIELD_NAMES)).thenReturn(true); [EOL] _writeFieldName("name", false); [EOL] assertEquals('"', _outputBuffer[0]); [EOL] assertEquals('n', _outputBuffer[1]); // Check the first character of the name [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); // Check the last character is quote [EOL] }
public void testWriteFieldNameWithBufferFlushAtEnd() throws IOException { [EOL] _outputTail = _outputEnd - 1; // Set output tail to trigger buffer flush after writing name [EOL] when(isEnabled(Feature.QUOTE_FIELD_NAMES)).thenReturn(true); [EOL] _writeFieldName("name", false); [EOL] assertTrue(/* condition to check if buffer was flushed at the end */); [EOL] }
public void testWritePPFieldNameWithCommaBeforeAndQuoteFieldNamesEnabled() throws IOException { [EOL] String name = "fieldName"; [EOL] boolean commaBefore = true; [EOL] initForWritePPFieldName(true); // Assuming this method initializes necessary objects and state [EOL] _writePPFieldName(name, commaBefore); [EOL] verifyObjectEntrySeparatorWritten(); [EOL] verifyFieldNameQuoted(name); [EOL] }
public void testWritePPFieldNameWithoutCommaBeforeAndQuoteFieldNamesEnabled() throws IOException { [EOL] String name = "fieldName"; [EOL] boolean commaBefore = false; [EOL] initForWritePPFieldName(true); // Assuming this method initializes necessary objects and state [EOL] _writePPFieldName(name, commaBefore); [EOL] verifyBeforeObjectEntriesCalled(); [EOL] verifyFieldNameQuoted(name); [EOL] }
public void testWritePPFieldNameWithCommaBeforeAndQuoteFieldNamesDisabled() throws IOException { [EOL] String name = "fieldName"; [EOL] boolean commaBefore = true; [EOL] initForWritePPFieldName(false); // Assuming this method initializes necessary objects and state [EOL] _writePPFieldName(name, commaBefore); [EOL] verifyObjectEntrySeparatorWritten(); [EOL] verifyFieldNameNotQuoted(name); [EOL] }
public void testWritePPFieldNameWithoutCommaBeforeAndQuoteFieldNamesDisabled() throws IOException { [EOL] String name = "fieldName"; [EOL] boolean commaBefore = false; [EOL] initForWritePPFieldName(false); // Assuming this method initializes necessary objects and state [EOL] _writePPFieldName(name, commaBefore); [EOL] verifyBeforeObjectEntriesCalled(); [EOL] verifyFieldNameNotQuoted(name); [EOL] }
public void testWriteStringWithSufficientBufferSpace() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] JsonGeneratorImpl gen = createJsonGeneratorWithMockedBuffer(); [EOL] gen.writeString(text, offset, len); [EOL] } [EOL] public void testWriteStringWithBufferFlushNeededAtStart() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] JsonGeneratorImpl gen = createJsonGeneratorWithMockedBuffer(); [EOL] forceBufferToBeFull(gen); [EOL] gen.writeString(text, offset, len); [EOL] } [EOL] public void testWriteStringWithBufferFlushNeededAtEnd() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] JsonGeneratorImpl gen = createJsonGeneratorWithMockedBuffer(); [EOL] forceBufferAlmostFull(gen); [EOL] gen.writeString(text, offset, len); [EOL] }
public void testWriteRawWithSerializableString() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] SerializableString serializableString = new SerializableStringImpl("test"); // You need to implement SerializableStringImpl or use a mock [EOL] generator.writeRaw(serializableString); [EOL] assertGeneratorOutputEquals("test"); // You need to implement this method to assert the output of the JsonGenerator [EOL] }
public void testWriteRawWithShortWrite() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = 5; // SHORT_WRITE is not defined, assuming it's greater than 5 [EOL] writeRaw(text, offset, len); [EOL] }
public void testWriteRawWithExactRoom() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = _outputEnd - _outputTail; // Assuming _outputEnd and _outputTail are accessible [EOL] writeRaw(text, offset, len); [EOL] }
public void testWriteRawWithInsufficientRoom() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = _outputEnd - _outputTail + 1; // Assuming _outputEnd and _outputTail are accessible [EOL] writeRaw(text, offset, len); [EOL] }
public void testWriteRawWithLongWrite() throws IOException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = 10; // Assuming SHORT_WRITE is less than 10 [EOL] writeRaw(text, offset, len); [EOL] }
public void testWriteNumberWithNumbersAsStringsTrue() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithConfigNumbersAsStrings(true); [EOL] short testValue = 123; [EOL] generator.writeNumber(testValue); [EOL] assertOutputIsQuotedShort(testValue); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceSufficient() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithConfigNumbersAsStrings(false); [EOL] short testValue = 123; [EOL] generator.writeNumber(testValue); [EOL] assertOutputIsUnquotedShort(testValue); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceInsufficient() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithConfigNumbersAsStrings(false); [EOL] short testValue = 123; [EOL] generator.writeNumber(testValue); [EOL] assertFlushBufferCalled(); [EOL] assertOutputIsUnquotedShort(testValue); [EOL] }
public void testWriteNumberWithNumbersAsStringsTrue() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithNumbersAsStringsConfig(true); [EOL] generator.writeNumber(123); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceSufficient() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithNumbersAsStringsConfig(false); [EOL] generator._outputTail = generator._outputEnd - 10; [EOL] generator.writeNumber(123); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceInsufficient() throws IOException { [EOL] JsonGenerator generator = createGeneratorWithNumbersAsStringsConfig(false); [EOL] generator._outputTail = generator._outputEnd - 5; [EOL] generator.writeNumber(123); [EOL] }
public void testWriteNumberWithNullValue() throws IOException { [EOL] JsonGenerator gen = createGenerator(); // You need to implement createGenerator [EOL] gen.writeNumber((BigInteger) null); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator gen = createGenerator(); // You need to implement createGenerator [EOL] gen.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] gen.writeNumber(new BigInteger("12345")); [EOL] }
public void testWriteNumberWithNumbersAsStringsDisabled() throws IOException { [EOL] JsonGenerator gen = createGenerator(); // You need to implement createGenerator [EOL] gen.disable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] gen.writeNumber(new BigInteger("12345")); [EOL] }
public void testWriteBooleanTrue() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); // Assuming createJsonGenerator() is a method that properly initializes a JsonGeneratorImpl instance [EOL] generator.writeBoolean(true); [EOL] assertEquals("true", generator.getOutput()); // Assuming getOutput() is a method that returns the current output as a String [EOL] }
public void testWriteBooleanFalse() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeBoolean(false); [EOL] assertEquals("false", generator.getOutput()); [EOL] }
public void testWriteBooleanRequiresFlush() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithLimitedBuffer(4); // Assuming createJsonGeneratorWithLimitedBuffer(int) initializes a JsonGeneratorImpl with a limited buffer size [EOL] generator.writeBoolean(true); [EOL] assertEquals("true", generator.getOutput()); [EOL] }
public void testWriteNull() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates an instance of the JsonGenerator [EOL] generator.writeNull(); [EOL] String output = getOutput(); // Assuming getOutput() is a method that retrieves the output of the generator [EOL] assertEquals("null", output); [EOL] }
public void testVerifyValueWriteExpectingFieldName() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assuming createGenerator() is a method that creates an instance of the generator [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up the context to expect a name [EOL] try { [EOL] generator._verifyValueWrite("start an array"); [EOL] fail("Should not allow writing a value when expecting a field name"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testVerifyValueWriteAfterComma() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up the context to be after a value which would be after a comma [EOL] generator._verifyValueWrite("start an array"); [EOL] assertEquals(',', generator._outputBuffer[generator._outputTail - 1]); // Check that a comma was written [EOL] }
public void testVerifyValueWriteAfterColon() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up the context to be after a value which would be after a colon [EOL] generator._verifyValueWrite("start an object"); [EOL] assertEquals(':', generator._outputBuffer[generator._outputTail - 1]); // Check that a colon was written [EOL] }
public void testVerifyValueWriteAfterSpaceWithRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._rootValueSeparator = new SerializedString(" "); // Set a space as the root value separator [EOL] generator._writeContext.writeValue(); // Set up the context to be after a space [EOL] generator._verifyValueWrite("start an object"); [EOL] assertTrue(new String(generator._outputBuffer, generator._outputTail - 1, 1).equals(" ")); [EOL] }
public void testVerifyValueWriteAfterSpaceWithoutRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._rootValueSeparator = null; // No root value separator [EOL] generator._writeContext.writeValue(); // Set up the context to be after a space [EOL] generator._verifyValueWrite("start an object"); [EOL] }
public void testVerifyValueWriteAsIs() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up the context to be as is [EOL] generator._verifyValueWrite("start an object"); [EOL] }
public void testVerifyValueWriteWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._cfgPrettyPrinter = mock(PrettyPrinter.class); // Assuming mock() is a method that creates a mock PrettyPrinter [EOL] generator._writeContext.writeValue(); // Set up the context to be as is [EOL] generator._verifyValueWrite("start an object"); [EOL] verify(generator._cfgPrettyPrinter).writeObjectFieldValueSeparator(generator); // Assuming verify() is a method from a mocking framework [EOL] }
public void testVerifyPrettyValueWriteAfterComma() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinter(); [EOL] generator._verifyPrettyValueWrite("typeMsg", JsonWriteContext.STATUS_OK_AFTER_COMMA); [EOL] Mockito.verify(generator._cfgPrettyPrinter).writeArrayValueSeparator(generator); [EOL] }
public void testVerifyPrettyValueWriteAfterColon() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinter(); [EOL] generator._verifyPrettyValueWrite("typeMsg", JsonWriteContext.STATUS_OK_AFTER_COLON); [EOL] Mockito.verify(generator._cfgPrettyPrinter).writeObjectFieldValueSeparator(generator); [EOL] }
public void testVerifyPrettyValueWriteAfterSpace() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinter(); [EOL] generator._verifyPrettyValueWrite("typeMsg", JsonWriteContext.STATUS_OK_AFTER_SPACE); [EOL] Mockito.verify(generator._cfgPrettyPrinter).writeRootValueSeparator(generator); [EOL] }
public void testVerifyPrettyValueWriteAsIsInArray() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinterAndWriteContext(true, false); [EOL] generator._verifyPrettyValueWrite("typeMsg", JsonWriteContext.STATUS_OK_AS_IS); [EOL] Mockito.verify(generator._cfgPrettyPrinter).beforeArrayValues(generator); [EOL] }
public void testVerifyPrettyValueWriteAsIsInObject() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinterAndWriteContext(false, true); [EOL] generator._verifyPrettyValueWrite("typeMsg", JsonWriteContext.STATUS_OK_AS_IS); [EOL] Mockito.verify(generator._cfgPrettyPrinter).beforeObjectEntries(generator); [EOL] }
public void testVerifyPrettyValueWriteDefault() { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedPrettyPrinter(); [EOL] assertThrows(JsonGenerationException.class, () -> { [EOL] generator._verifyPrettyValueWrite("typeMsg", -1); [EOL] }); [EOL] }
public void testFlushWithNonNullWriterAndFlushPassedToStreamEnabled() throws IOException { [EOL] _flushBuffer(); // Assuming this is a method that can be called without side effects for setup [EOL] enableFeature(Feature.FLUSH_PASSED_TO_STREAM); // Assuming this is a method to enable the feature [EOL] flush(); [EOL] verify(_writer).flush(); // Assuming a mock framework is used [EOL] }
public void testFlushWithNonNullWriterAndFlushPassedToStreamDisabled() throws IOException { [EOL] _flushBuffer(); // Assuming this is a method that can be called without side effects for setup [EOL] disableFeature(Feature.FLUSH_PASSED_TO_STREAM); // Assuming this is a method to disable the feature [EOL] flush(); [EOL] verify(_writer, never()).flush(); // Assuming a mock framework is used [EOL] }
public void testFlushWithNullWriter() throws IOException { [EOL] _flushBuffer(); // Assuming this is a method that can be called without side effects for setup [EOL] _writer = null; // Directly setting _writer to null [EOL] flush(); [EOL] }
public void testCloseWithAutoCloseJsonContentEnabledAndInArray() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentEnabled(); [EOL] gen.writeStartArray(); [EOL] gen.close(); [EOL] assertTrue("Expected writeEndArray to be called", wasEndArrayCalled()); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentEnabledAndInObject() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentEnabled(); [EOL] gen.writeStartObject(); [EOL] gen.close(); [EOL] assertTrue("Expected writeEndObject to be called", wasEndObjectCalled()); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentDisabled(); [EOL] gen.writeStartObject(); [EOL] gen.close(); [EOL] assertFalse("Expected writeEndObject not to be called", wasEndObjectCalled()); [EOL] } [EOL] public void testCloseWithAutoCloseTargetEnabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseTargetEnabled(); [EOL] gen.close(); [EOL] assertTrue("Expected writer to be closed", wasWriterClosed()); [EOL] } [EOL] public void testCloseWithAutoCloseTargetDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseTargetDisabled(); [EOL] gen.close(); [EOL] assertFalse("Expected writer not to be closed", wasWriterClosed()); [EOL] } [EOL] public void testCloseWithFlushPassedToStreamEnabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithFlushPassedToStreamEnabled(); [EOL] gen.close(); [EOL] assertTrue("Expected writer to be flushed", wasWriterFlushed()); [EOL] } [EOL] public void testCloseWithFlushPassedToStreamDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithFlushPassedToStreamDisabled(); [EOL] gen.close(); [EOL] assertFalse("Expected writer not to be flushed", wasWriterFlushed()); [EOL] }

public void testWriteStringWithLengthGreaterThanOutputEnd() throws IOException { [EOL] String text = "text longer than outputEnd"; [EOL] setupOutputEnd(text.length() - 1); [EOL] _writeString(text); [EOL] } [EOL] public void testWriteStringWithOutputTailPlusLengthGreaterThanOutputEnd() throws IOException { [EOL] String text = "text"; [EOL] setupOutputEnd(text.length()); [EOL] incrementOutputTail(text.length() + 1); [EOL] _writeString(text); [EOL] }
public void testWriteStringWithCharacterEscapes() throws IOException { [EOL] String text = "text"; [EOL] setupOutputEnd(text.length() * 2); [EOL] setupCharacterEscapes(); [EOL] _writeString(text); [EOL] }
public void testWriteStringWithMaximumNonEscapedChar() throws IOException { [EOL] String text = "text"; [EOL] setupOutputEnd(text.length() * 2); [EOL] setMaximumNonEscapedChar(127); [EOL] _writeString(text); [EOL] }
public void testWriteStringWithoutEscaping() throws IOException { [EOL] String text = "text"; [EOL] setupOutputEnd(text.length() * 2); [EOL] _writeString(text); [EOL] }
public void testWriteString2WithNoEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] _outputEscapes = new int[128]; // Assuming ASCII, no escaping by default [EOL] StringWriter _writer = new StringWriter(); [EOL] _writeString2(5); // len is equal to the length of _outputBuffer [EOL] assertEquals("abcde", _writer.toString()); [EOL] assertEquals(5, _outputTail); [EOL] }
public void testWriteString2WithEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', '<', 'd', 'e'}; [EOL] _outputEscapes = new int[128]; [EOL] _outputEscapes['<'] = 1; // Assuming '<' needs to be escaped [EOL] StringWriter _writer = new StringWriter(); [EOL] _writeString2(5); // len is equal to the length of _outputBuffer [EOL] assertTrue(_writer.toString().contains("ab")); // Check that 'a' and 'b' were written before escaping [EOL] assertTrue(_writer.toString().contains("<")); // Check that '<' was escaped [EOL] assertEquals(5, _outputTail); [EOL] }
public void testWriteString2WithBufferEndBoundary() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] _outputEscapes = new int[128]; // Assuming ASCII, no escaping by default [EOL] StringWriter _writer = new StringWriter(); [EOL] _writeString2(3); // len is less than the length of _outputBuffer [EOL] assertEquals("abc", _writer.toString()); [EOL] assertEquals(3, _outputTail); [EOL] }
public void testWriteStringWithCharacterEscapes() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', '\\', 'n'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = new CharacterEscapes(); // Assuming CharacterEscapes is a mockable class [EOL] _writeString(text, offset, len); [EOL] }
public void testWriteStringWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _maximumNonEscapedChar = 127; // Assuming this is the maximum non-escaped char value [EOL] _writeString(text, offset, len); [EOL] }
public void testWriteStringWithoutEscaping() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int offset = 0; [EOL] int len = 3; // Less than text.length to not trigger escaping [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; // Assuming this is the default escapes array [EOL] _outputBuffer = new char[10]; // Assuming this is the output buffer [EOL] _outputTail = 0; [EOL] _outputEnd = 10; [EOL] _writeString(text, offset, len); [EOL] }
public void testWriteStringEscapingRequired() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', '\\', 'n'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; [EOL] _outputEscapes['\\'] = 1; // Assuming this means '\\' needs to be escaped [EOL] _outputBuffer = new char[10]; [EOL] _outputTail = 0; [EOL] _outputEnd = 10; [EOL] _writeString(text, offset, len); [EOL] }
public void testWriteStringWithFlushBuffer() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; [EOL] _outputBuffer = new char[5]; // Smaller buffer to force flush [EOL] _outputTail = 0; [EOL] _outputEnd = 5; [EOL] _writeString(text, offset, len); [EOL] }
public void testWriteStringASCII_noEscapingNeeded() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int len = 10; [EOL] int maxNonEscaped = 127; // Assuming ASCII characters won't be escaped [EOL] _writeStringASCII(len, maxNonEscaped); [EOL] }
public void testWriteStringASCII_withEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', '<', '>', '&', 'g', 'h', 'i', 'j'}; [EOL] int len = 10; [EOL] int maxNonEscaped = 127; // Assuming '<', '>', '&' will be escaped [EOL] _writeStringASCII(len, maxNonEscaped); [EOL] }
public void testWriteStringASCII_withHighValueChars() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', (char) 200}; [EOL] int len = 10; [EOL] int maxNonEscaped = 127; // Assuming characters above 127 will be escaped [EOL] _writeStringASCII(len, maxNonEscaped); [EOL] }
public void testWriteStringCustomWithNoEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[10]; [EOL] _outputEscapes = new int[128]; [EOL] _maximumNonEscapedChar = 0; [EOL] _characterEscapes = null; [EOL] _writeStringCustom(5); [EOL] assertEquals(5, _outputTail); [EOL] }
public void testWriteStringCustomWithEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', '<', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] _outputEscapes = new int[128]; [EOL] _outputEscapes['<'] = 1; // Assuming '<' needs to be escaped [EOL] _maximumNonEscapedChar = 127; [EOL] _characterEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[0]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return null; [EOL] } [EOL] }; [EOL] _writeStringCustom(10); [EOL] assertTrue(_outputTail > 0); [EOL] }
public void testWriteStringCustomWithCustomEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] _outputEscapes = new int[128]; [EOL] _maximumNonEscapedChar = 127; [EOL] _characterEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[0]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] if (ch == 'd') { [EOL] return new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "\\u0064"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return 6; [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return new byte[0]; [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return new byte[0]; [EOL] } [EOL] }; [EOL] } [EOL] return null; [EOL] } [EOL] }; [EOL] _writeStringCustom(10); [EOL] assertTrue(_outputTail > 0); [EOL] }
public void testWriteNullWhenOutputTailPlusFourIsLessThanOutputEnd() throws IOException { [EOL] _outputTail = 1; [EOL] _outputEnd = 10; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] int expectedOutputTail = _outputTail + 4; [EOL] _writeNull(); [EOL] assertEquals('n', _outputBuffer[_outputTail]); [EOL] assertEquals('u', _outputBuffer[_outputTail + 1]); [EOL] assertEquals('l', _outputBuffer[_outputTail + 2]); [EOL] assertEquals('l', _outputBuffer[_outputTail + 3]); [EOL] assertEquals(expectedOutputTail, _outputTail); [EOL] }
public void testWriteNullWhenOutputTailPlusFourIsGreaterThanOrEqualToOutputEnd() throws IOException { [EOL] _outputTail = 1; [EOL] _outputEnd = 5; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] _outputTail = 0; [EOL] int expectedOutputTail = 4; [EOL] _writeNull(); [EOL] assertEquals('n', _outputBuffer[0]); [EOL] assertEquals('u', _outputBuffer[1]); [EOL] assertEquals('l', _outputBuffer[2]); [EOL] assertEquals('l', _outputBuffer[3]); [EOL] assertEquals(expectedOutputTail, _outputTail); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_outputTailSufficient() throws IOException { [EOL] char ch = 'a'; [EOL] int escCode = 1; // escCode >= 0 [EOL] _outputTail = 2; // _outputTail >= 2 [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals('\\', _outputBuffer[_outputHead]); [EOL] assertEquals((char) escCode, _outputBuffer[_outputHead + 1]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_outputTailNotSufficient() throws IOException { [EOL] char ch = 'a'; [EOL] int escCode = 1; // escCode >= 0 [EOL] _outputTail = 1; // _outputTail < 2 [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals((char) escCode, _entityBuffer[1]); [EOL] assertEquals("The writer should contain the escaped character", "\\" + (char) escCode, _writer.toString()); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotCustom_outputTailSufficient() throws IOException { [EOL] char ch = 0x1234; // ch > 0xFF [EOL] int escCode = -1; // escCode != CharacterEscapes.ESCAPE_CUSTOM and escCode < 0 [EOL] _outputTail = 6; // _outputTail >= 6 [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals('\\', _outputBuffer[_outputHead]); [EOL] assertEquals('u', _outputBuffer[_outputHead + 1]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotCustom_outputTailNotSufficient() throws IOException { [EOL] char ch = 0x34; // ch <= 0xFF [EOL] int escCode = -1; // escCode != CharacterEscapes.ESCAPE_CUSTOM and escCode < 0 [EOL] _outputTail = 5; // _outputTail < 6 [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals(HEX_CHARS[ch >> 4], _entityBuffer[6]); [EOL] assertEquals(HEX_CHARS[ch & 0xF], _entityBuffer[7]); [EOL] assertEquals("The writer should contain the unicode escape sequence", "\\u00" + HEX_CHARS[ch >> 4] + HEX_CHARS[ch & 0xF], _writer.toString()); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeCustom_currentEscapeNull() throws IOException { [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL] _outputTail = 10; // Sufficient space in _outputBuffer [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _currentEscape = null; [EOL] _characterEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[0]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "custom"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals("The output buffer should contain the custom escape", "custom", new String(_outputBuffer, _outputHead, "custom".length())); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeCustom_currentEscapeNotNull() throws IOException { [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL] _outputTail = 10; // Sufficient space in _outputBuffer [EOL] _outputBuffer = new char[10]; [EOL] _outputHead = 0; [EOL] _entityBuffer = null; [EOL] _writer = new StringWriter(); [EOL] _currentEscape = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "current"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] _prependOrWriteCharacterEscape(ch, escCode); [EOL] assertEquals("The output buffer should contain the current escape", "current", new String(_outputBuffer, _outputHead, "current".length())); [EOL] assertNull("The current escape should be reset to null", _currentEscape); [EOL] }
public void testAppendQuotedWithNoEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "normalText"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("normalText", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWith\"Quotes\""; [EOL] appendQuoted(sb, content); [EOL] assertEquals("textWith\\\"Quotes\\\"", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithSpecialCharacters() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWith\nNewLine"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("textWith\\nNewLine", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithUnicodeEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWithSpecialChar\u0001"; [EOL] appendQuoted(sb, content); [EOL] assertTrue(sb.toString().contains("\\u0001")); [EOL] }
public void testAppendQuotedWithAllEscapableCharacters() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "\"\\\b\f\n\r\t"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("\\\"\\\\\\b\\f\\n\\r\\t", sb.toString()); [EOL] }
public void testCopyHexChars() { [EOL] char[] hexCharsCopy = ClassName.copyHexChars(); [EOL] assertNotNull(hexCharsCopy); [EOL] assertNotSame(ClassName.HEX_CHARS, hexCharsCopy); [EOL] assertEquals(ClassName.HEX_CHARS.length, hexCharsCopy.length); [EOL] for (int i = 0; i < ClassName.HEX_CHARS.length; i++) { [EOL] assertEquals(ClassName.HEX_CHARS[i], hexCharsCopy[i]); [EOL] } [EOL] }
public void testCopyHexBytes() { [EOL] byte[] original = JacksonCore.copyHexBytes(); [EOL] byte[] copied = JacksonCore.copyHexBytes(); [EOL] assertNotSame(original, copied); [EOL] assertArrayEquals(original, copied); [EOL] }
public void testGetInstance_NewInstance() { [EOL] JsonStringEncoder enc1 = JsonStringEncoder.getInstance(); [EOL] assertNotNull(enc1); [EOL] }
public void testGetInstance_ExistingInstance() { [EOL] JsonStringEncoder enc1 = JsonStringEncoder.getInstance(); [EOL] JsonStringEncoder enc2 = JsonStringEncoder.getInstance(); [EOL] assertSame(enc1, enc2); [EOL] }
public void testAppendNumericEscape() { [EOL] char[] quoteBuffer = new char[6]; [EOL] int value = 0; // Test with value 0 [EOL] int result = _appendNumericEscape(value, quoteBuffer); [EOL] assertEquals(6, result); [EOL] assertEquals('u', quoteBuffer[1]); [EOL] assertEquals('0', quoteBuffer[4]); // HEX_CHARS[0] [EOL] assertEquals('0', quoteBuffer[5]); // HEX_CHARS[0] [EOL] }
public void testAppendNumericEscapeWithMaxValue() { [EOL] char[] quoteBuffer = new char[6]; [EOL] int value = 255; // Test with max single byte value [EOL] int result = _appendNumericEscape(value, quoteBuffer); [EOL] assertEquals(6, result); [EOL] assertEquals('u', quoteBuffer[1]); [EOL] assertEquals('f', quoteBuffer[4]); // HEX_CHARS[15] [EOL] assertEquals('f', quoteBuffer[5]); // HEX_CHARS[15] [EOL] }
protected final void _reportError(String msg) throws JsonParseException { [EOL] throw _constructError(msg); [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
public void testCreateChildArrayContext_WhenChildIsNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext childContext = parentContext.createChildArrayContext(); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonWriteContext.TYPE_ARRAY, childContext.type()); [EOL] }
public void testCreateChildArrayContext_WhenChildIsNotNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext existingChildContext = parentContext.createChildArrayContext(); [EOL] JsonWriteContext newChildContext = parentContext.createChildArrayContext(); [EOL] assertSame(existingChildContext, newChildContext); [EOL] assertEquals(JsonWriteContext.TYPE_ARRAY, newChildContext.type()); [EOL] }
public void testCreateChildObjectContext_WhenChildIsNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext childContext = parentContext.createChildObjectContext(); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonWriteContext.TYPE_OBJECT, childContext.type()); [EOL] }
public void testCreateChildObjectContext_WhenChildIsNotNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext childContext1 = parentContext.createChildObjectContext(); [EOL] JsonWriteContext childContext2 = parentContext.createChildObjectContext(); [EOL] assertNotNull(childContext2); [EOL] assertNotSame(childContext1, childContext2); [EOL] assertEquals(JsonWriteContext.TYPE_OBJECT, childContext2.type()); [EOL] }
public void testMergedStreamConstructor() { [EOL] IOContext context = new IOContext(new BufferRecycler(), new File("test"), false); [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4}); [EOL] byte[] buf = new byte[]{5, 6, 7, 8}; [EOL] int start = 1; [EOL] int end = 3; [EOL] MergedStream mergedStream = new MergedStream(context, in, buf, start, end); [EOL] assertNotNull(mergedStream); [EOL] assertEquals(context, mergedStream._context); [EOL] assertEquals(in, mergedStream._in); [EOL] assertArrayEquals(buf, mergedStream._buffer); [EOL] assertEquals(start, mergedStream._ptr); [EOL] assertEquals(end, mergedStream._end); [EOL] }
public void testAvailableWithNonNullBuffer() throws IOException { [EOL] JsonParser parser = createParserWithBuffer(); [EOL] int expectedAvailable = parser._end - parser._ptr; [EOL] int actualAvailable = parser.available(); [EOL] assertEquals(expectedAvailable, actualAvailable); [EOL] }
public void testAvailableWithNullBuffer() throws IOException { [EOL] JsonParser parser = createParserWithNullBuffer(); [EOL] int expectedAvailable = parser._in.available(); [EOL] int actualAvailable = parser.available(); [EOL] assertEquals(expectedAvailable, actualAvailable); [EOL] }
public void testClose() throws IOException { [EOL] JsonParser jp = createJsonParser(); [EOL] jp.close(); [EOL] assertTrue(jp.isClosed()); [EOL] }
public void testCloseWithException() throws IOException { [EOL] JsonParser jp = createJsonParser(); [EOL] doThrow(new IOException()).when(jp)._in.close(); [EOL] try { [EOL] jp.close(); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testMarkWithNullBuffer() throws IOException { [EOL] InputStream inputStreamMock = mock(InputStream.class); [EOL] JacksonCoreWrapper jacksonCoreWrapper = new JacksonCoreWrapper(inputStreamMock); [EOL] jacksonCoreWrapper.mark(100); [EOL] verify(inputStreamMock).mark(100); [EOL] }
public void testMarkWithNonNullBuffer() throws IOException { [EOL] InputStream inputStreamMock = mock(InputStream.class); [EOL] JacksonCoreWrapper jacksonCoreWrapper = new JacksonCoreWrapper(inputStreamMock); [EOL] jacksonCoreWrapper._buffer = new byte[10]; // Assuming there is a way to set _buffer. [EOL] jacksonCoreWrapper.mark(100); [EOL] verify(inputStreamMock, never()).mark(anyInt()); [EOL] }
public void testMarkSupportedWithNullBuffer() { [EOL] JacksonCoreInputStreamUnderTest._buffer = null; [EOL] JacksonCoreInputStreamUnderTest._in = new ByteArrayInputStream(new byte[]{}); [EOL] boolean result = JacksonCoreInputStreamUnderTest.markSupported(); [EOL] assert result == JacksonCoreInputStreamUnderTest._in.markSupported(); [EOL] }
public void testMarkSupportedWithNonNullBuffer() { [EOL] JacksonCoreInputStreamUnderTest._buffer = new byte[]{}; [EOL] JacksonCoreInputStreamUnderTest._in = new ByteArrayInputStream(new byte[]{}); [EOL] boolean result = JacksonCoreInputStreamUnderTest.markSupported(); [EOL] assert !result; [EOL] }
public void testReadWithBufferNotEmptyAndPtrLessThanEnd() throws IOException { [EOL] _buffer = new byte[]{(byte) 'a', (byte) 'b', (byte) 'c'}; [EOL] _ptr = 0; [EOL] _end = 3; [EOL] int result = read(); [EOL] assertEquals('a', result); [EOL] assertEquals(1, _ptr); [EOL] }
public void testReadWithBufferNotEmptyAndPtrAtEnd() throws IOException { [EOL] _buffer = new byte[]{(byte) 'a', (byte) 'b', (byte) 'c'}; [EOL] _ptr = 2; [EOL] _end = 3; [EOL] int result = read(); [EOL] assertEquals('c', result); [EOL] assertNull(_buffer); [EOL] }
public void testReadWithBufferEmpty() throws IOException { [EOL] _buffer = null; [EOL] InputStream mockInputStream = mock(InputStream.class); [EOL] when(mockInputStream.read()).thenReturn((int) 'd'); [EOL] _in = mockInputStream; [EOL] int result = read(); [EOL] assertEquals('d', result); [EOL] verify(mockInputStream).read(); [EOL] }
public void testReadWithNonNullBufferAndLenGreaterThanAvailable() throws IOException { [EOL] byte[] b = new byte[10]; [EOL] int off = 0; [EOL] int len = 5; [EOL] int avail = 3; [EOL] YourClass instance = new YourClass(); [EOL] instance._buffer = new byte[]{1, 2, 3, 4, 5}; [EOL] instance._ptr = 2; // Set pointer to simulate 3 bytes available [EOL] instance._end = 5; [EOL] int bytesRead = instance.read(b, off, len); [EOL] assertEquals(avail, bytesRead); // Should read only the available bytes [EOL] assertEquals(5, instance._ptr); // Pointer should move by 'avail' bytes [EOL] assertNull(instance._buffer); // Buffer should be freed [EOL] }
public void testReadWithNonNullBufferAndLenLessThanAvailable() throws IOException { [EOL] byte[] b = new byte[10]; [EOL] int off = 0; [EOL] int len = 2; [EOL] int avail = 5; [EOL] YourClass instance = new YourClass(); [EOL] instance._buffer = new byte[]{1, 2, 3, 4, 5}; [EOL] instance._ptr = 0; // Set pointer to simulate 5 bytes available [EOL] instance._end = 5; [EOL] int bytesRead = instance.read(b, off, len); [EOL] assertEquals(len, bytesRead); // Should read 'len' bytes [EOL] assertEquals(2, instance._ptr); // Pointer should move by 'len' bytes [EOL] assertNotNull(instance._buffer); // Buffer should not be freed [EOL] }
public void testReadWithNullBuffer() throws IOException { [EOL] byte[] b = new byte[10]; [EOL] int off = 0; [EOL] int len = 5; [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] YourClass instance = new YourClass(); [EOL] instance._buffer = null; [EOL] instance._in = in; [EOL] int bytesRead = instance.read(b, off, len); [EOL] assertEquals(len, bytesRead); // Should read 'len' bytes from _in [EOL] }
public void testSkipWithNonNullBufferAndNLessThanAmount() throws IOException { [EOL] long n = 5L; [EOL] long expected = n; [EOL] long actual = skip(n); [EOL] assertEquals(expected, actual); [EOL] assertEquals(initialPtrValue + n, _ptr); [EOL] }
public void testSkipWithNonNullBufferAndNGreaterThanAmount() throws IOException { [EOL] long n = 15L; [EOL] long expected = amount; // where amount is (_end - _ptr) before the skip [EOL] long actual = skip(n); [EOL] assertEquals(expected, actual); [EOL] assertNull(_buffer); [EOL] assertEquals(amount, count); [EOL] }
public void testSkipWithNullBuffer() throws IOException { [EOL] long n = 10L; [EOL] long expected = _in.skip(n); // Assuming _in is a mock and skip is stubbed to return a specific value [EOL] long actual = skip(n); [EOL] assertEquals(expected, actual); [EOL] }
public void testSkipWithNZero() throws IOException { [EOL] long n = 0L; [EOL] long expected = 0L; [EOL] long actual = skip(n); [EOL] assertEquals(expected, actual); [EOL] assertEquals(initialPtrValue, _ptr); [EOL] }
public void testFreeMergedBuffer_WithNonNullBufferAndContext() { [EOL] _buffer = new byte[10]; // Assuming _buffer is a class member [EOL] _context = mock(IOContext.class); // Assuming _context is a class member and IOContext can be mocked [EOL] freeMergedBuffer(); [EOL] assertNull(_buffer); [EOL] verify(_context).releaseReadIOBuffer(any(byte[].class)); [EOL] }
public void testFreeMergedBuffer_WithNullBuffer() { [EOL] _buffer = null; // Assuming _buffer is a class member [EOL] _context = mock(IOContext.class); // Assuming _context is a class member and IOContext can be mocked [EOL] freeMergedBuffer(); [EOL] assertNull(_buffer); [EOL] verify(_context, never()).releaseReadIOBuffer(any(byte[].class)); [EOL] }
public void testFreeMergedBuffer_WithNonNullBufferAndNullContext() { [EOL] _buffer = new byte[10]; // Assuming _buffer is a class member [EOL] _context = null; // Assuming _context is a class member [EOL] freeMergedBuffer(); [EOL] assertNull(_buffer); [EOL] }
public void testCloseWithNonNullInputStream() throws IOException { [EOL] InputStream mockInputStream = mock(InputStream.class); [EOL] JsonParser jp = new JsonParser(mockInputStream); [EOL] jp.close(); [EOL] verify(mockInputStream).close(); [EOL] }
public void testCloseWithNullInputStream() throws IOException { [EOL] JsonParser jp = new JsonParser(null); [EOL] jp.close(); [EOL] }
public void testFreeBuffersWithNonNullBuffer() { [EOL] IOContext context = new IOContext(new BufferRecycler(), new Object(), false); [EOL] byte[] buffer = new byte[10]; [EOL] JsonReadContext jsonReadContext = new JsonReadContext(context, null, 0, 0, 0); [EOL] jsonReadContext.setBuffer(buffer); [EOL] jsonReadContext.freeBuffers(); [EOL] assertNull(jsonReadContext._buffer); [EOL] assertTrue(context.isBufferRecycled()); [EOL] }
public void testFreeBuffersWithNullBuffer() { [EOL] IOContext context = new IOContext(new BufferRecycler(), new Object(), false); [EOL] JsonReadContext jsonReadContext = new JsonReadContext(context, null, 0, 0, 0); [EOL] jsonReadContext.freeBuffers(); [EOL] assertNull(jsonReadContext._buffer); [EOL] assertFalse(context.isBufferRecycled()); [EOL] }
public void testJsonFactoryConstructor() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertNull(factory.getCodec()); [EOL] }
public void testJsonFactoryWithNullObjectCodec() { [EOL] JsonFactory factory = new JsonFactory(null); [EOL] assertNull(factory._objectCodec); [EOL] }
public void testJsonFactoryWithNonNullObjectCodec() { [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] JsonFactory factory = new JsonFactory(codec); [EOL] assertSame(codec, factory._objectCodec); [EOL] }
public void testJsonFactoryCopyConstructor() { [EOL] JsonFactory src = new JsonFactory(); [EOL] ObjectCodec codec = null; // Assuming ObjectCodec is a class that can be instantiated or mocked [EOL] src.setCodec(codec); [EOL] src.configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, true); [EOL] src.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL] src.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, true); [EOL] CharacterEscapes charEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[128]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return null; [EOL] } [EOL] }; [EOL] src.setCharacterEscapes(charEscapes); [EOL] InputDecorator inputDecorator = new InputDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, InputStream in) throws IOException { [EOL] return in; [EOL] } [EOL] }; [EOL] src.setInputDecorator(inputDecorator); [EOL] OutputDecorator outputDecorator = new OutputDecorator() { [EOL] @Override [EOL] public OutputStream decorate(IOContext ctxt, OutputStream out) throws IOException { [EOL] return out; [EOL] } [EOL] }; [EOL] src.setOutputDecorator(outputDecorator); [EOL] SerializableString rootValueSeparator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return ","; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return 1; [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return new char[]{','}; [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return new byte[]{','}; [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return new byte[]{','}; [EOL] } [EOL] }; [EOL] src.setRootValueSeparator(rootValueSeparator); [EOL] JsonFactory copy = new JsonFactory(src, codec); [EOL] assertNull(copy.getCodec()); [EOL] assertEquals(src._factoryFeatures, copy._factoryFeatures); [EOL] assertEquals(src._parserFeatures, copy._parserFeatures); [EOL] assertEquals(src._generatorFeatures, copy._generatorFeatures); [EOL] assertEquals(src._characterEscapes, copy._characterEscapes); [EOL] assertEquals(src._inputDecorator, copy._inputDecorator); [EOL] assertEquals(src._outputDecorator, copy._outputDecorator); [EOL] assertEquals(src._rootValueSeparator, copy._rootValueSeparator); [EOL] }
protected Object readResolve() { [EOL] return new JsonFactory(this, _objectCodec); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.enable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] boolean result = factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] assert result; [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] boolean result = factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] assert !result; [EOL] }
public void testCreateParserWithNonNullContent() throws IOException, JsonParseException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] String content = "{\"key\":\"value\"}"; [EOL] JsonParser parser = factory.createParser(content); [EOL] assertNotNull(parser); [EOL] assertTrue(parser.nextToken() == JsonToken.START_OBJECT); [EOL] } [EOL] public void testCreateParserWithNullContent() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] String content = null; [EOL] try { [EOL] factory.createParser(content); [EOL] fail("Expected IOException was not thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] } [EOL] public void testCreateParserWithInputDecorator() throws IOException, JsonParseException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected Reader _inputDecorator(IOContext ctxt, Reader r) { [EOL] return new StringReader("{\"decorated\":\"true\"}"); [EOL] } [EOL] }; [EOL] String content = "{\"key\":\"value\"}"; [EOL] JsonParser parser = factory.createParser(content); [EOL] assertNotNull(parser); [EOL] assertTrue(parser.nextToken() == JsonToken.START_OBJECT); [EOL] assertTrue(parser.nextFieldName().equals("decorated")); [EOL] assertTrue(parser.nextTextValue().equals("true")); [EOL] }

public void testCreateGeneratorWithUTF8EncodingAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] }
public void testCreateGeneratorWithUTF8EncodingAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected OutputDecorator outputDecorator() { [EOL] return new OutputDecorator() { [EOL] @Override [EOL] public OutputStream decorate(IOContext ctxt, OutputStream out) throws IOException { [EOL] return new BufferedOutputStream(out); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] assertTrue(((OutputStreamWrapper) generator.getOutputTarget()).getWrappedStream() instanceof BufferedOutputStream); [EOL] }
public void testCreateGeneratorWithNonUTF8EncodingAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF16_BE); [EOL] assertNotNull(generator); [EOL] assertFalse(generator instanceof UTF8JsonGenerator); [EOL] }
public void testCreateGeneratorWithNonUTF8EncodingAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected OutputDecorator outputDecorator() { [EOL] return new OutputDecorator() { [EOL] @Override [EOL] public Writer decorate(IOContext ctxt, Writer w) throws IOException { [EOL] return new BufferedWriter(w); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF16_BE); [EOL] assertNotNull(generator); [EOL] assertFalse(generator instanceof UTF8JsonGenerator); [EOL] assertTrue(((WriterBasedJsonGenerator) generator).getOutputTarget() instanceof BufferedWriter); [EOL] }
public void testCreateGeneratorWithOutputStream() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] }

public void testCreateGeneratorWithNullOutputDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Writer writer = new StringWriter(); [EOL] JsonGenerator generator = factory.createGenerator(writer); [EOL] assertNotNull(generator); [EOL] }
public void testCreateGeneratorWithNonNullOutputDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setOutputDecorator(new OutputDecorator() { [EOL] @Override [EOL] public Writer decorate(IOContext ctxt, Writer writer) throws IOException { [EOL] return new BufferedWriter(writer); [EOL] } [EOL] }); [EOL] Writer writer = new StringWriter(); [EOL] JsonGenerator generator = factory.createGenerator(writer); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof WriterBasedJsonGenerator); [EOL] }
protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException { [EOL] return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec, _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES))); [EOL] }
public void testCreateGeneratorWithDefaultRootValueSeparator() throws IOException { [EOL] Writer out = new StringWriter(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] JsonGenerator gen = jsonFactory._createGenerator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(gen instanceof WriterBasedJsonGenerator); [EOL] assertEquals(JsonFactory.DEFAULT_ROOT_VALUE_SEPARATOR, ((WriterBasedJsonGenerator) gen).getRootValueSeparator()); [EOL] }
public void testCreateGeneratorWithCustomRootValueSeparator() throws IOException { [EOL] Writer out = new StringWriter(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] SerializableString customRootValueSeparator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "|"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return 1; [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return new char[]{'|'}; [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return new byte[]{'|'}; [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return new byte[]{'|'}; [EOL] } [EOL] }; [EOL] jsonFactory.setRootValueSeparator(customRootValueSeparator); [EOL] JsonGenerator gen = jsonFactory._createGenerator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(gen instanceof WriterBasedJsonGenerator); [EOL] assertEquals(customRootValueSeparator, ((WriterBasedJsonGenerator) gen).getRootValueSeparator()); [EOL] }
public void testCreateGeneratorWithCharacterEscapes() throws IOException { [EOL] Writer out = new StringWriter(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] CharacterEscapes customEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[128]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "escape"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return 6; [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return new char[]{'e', 's', 'c', 'a', 'p', 'e'}; [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return new byte[]{'e', 's', 'c', 'a', 'p', 'e'}; [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return new byte[]{'e', 's', 'c', 'a', 'p', 'e'}; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] jsonFactory.setCharacterEscapes(customEscapes); [EOL] JsonGenerator gen = jsonFactory._createGenerator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(gen instanceof WriterBasedJsonGenerator); [EOL] assertEquals(customEscapes, ((WriterBasedJsonGenerator) gen).getCharacterEscapes()); [EOL] }
public void testCreateUTF8GeneratorWithDefaultRootValueSeparator() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] JsonGenerator gen = jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(checkRootValueSeparatorIsDefault(gen)); [EOL] } [EOL] public void testCreateUTF8GeneratorWithNonDefaultRootValueSeparator() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] SerializableString nonDefaultRootValueSeparator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return ";"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] jsonFactory.setRootValueSeparator(nonDefaultRootValueSeparator); [EOL] JsonGenerator gen = jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(checkRootValueSeparatorIsNotDefault(gen, nonDefaultRootValueSeparator)); [EOL] } [EOL] public void testCreateUTF8GeneratorWithCharacterEscapes() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] CharacterEscapes customEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[128]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return null; [EOL] } [EOL] }; [EOL] jsonFactory.setCharacterEscapes(customEscapes); [EOL] UTF8JsonGenerator gen = (UTF8JsonGenerator) jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertEquals(customEscapes, gen.getCharacterEscapes()); [EOL] }
public void testCreateContextWithResourceManagedTrue() { [EOL] IOContext context = _createContext(new Object(), true); [EOL] assertNotNull(context); [EOL] assertTrue(context.isResourceManaged()); [EOL] }
public void testCreateContextWithResourceManagedFalse() { [EOL] IOContext context = _createContext(new Object(), false); [EOL] assertNotNull(context); [EOL] assertFalse(context.isResourceManaged()); [EOL] }
public void testGetBufferRecyclerWithNullReference() { [EOL] YourClass instance = new YourClass(); [EOL] instance._recyclerRef = new ThreadLocal<SoftReference<BufferRecycler>>(); [EOL] instance._recyclerRef.set(null); [EOL] BufferRecycler result = instance._getBufferRecycler(); [EOL] assertNotNull(result); [EOL] SoftReference<BufferRecycler> ref = instance._recyclerRef.get(); [EOL] assertNotNull(ref); [EOL] assertNotNull(ref.get()); [EOL] }
public void testGetBufferRecyclerWithNonNullReference() { [EOL] YourClass instance = new YourClass(); [EOL] BufferRecycler existingRecycler = new BufferRecycler(); [EOL] instance._recyclerRef = new ThreadLocal<SoftReference<BufferRecycler>>(); [EOL] instance._recyclerRef.set(new SoftReference<BufferRecycler>(existingRecycler)); [EOL] BufferRecycler result = instance._getBufferRecycler(); [EOL] assertSame(existingRecycler, result); [EOL] }
