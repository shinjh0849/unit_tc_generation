public int[] getValues() { [EOL]     int[] result = new int[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getValue(i); [EOL]     } [EOL]     return result; [EOL] }
public int[] getValues() { [EOL]     int[] result = new int[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getValue(i); [EOL]     } [EOL]     return result; [EOL] }
protected int indexOf(DurationFieldType type) { [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i).getDurationType() == type) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
protected int indexOfSupported(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
protected int indexOfSupported(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof ReadablePartial == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePartial other = (ReadablePartial) partial; [EOL]     if (size() != other.size()) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public int compareTo(ReadablePartial other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (size() != other.size()) { [EOL]         throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) != other.getFieldType(i)) { [EOL]             throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]         } [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) > other.getValue(i)) { [EOL]             return 1; [EOL]         } [EOL]         if (getValue(i) < other.getValue(i)) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(ReadablePartial other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (size() != other.size()) { [EOL]         throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) != other.getFieldType(i)) { [EOL]             throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]         } [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) > other.getValue(i)) { [EOL]             return 1; [EOL]         } [EOL]         if (getValue(i) < other.getValue(i)) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public static YearMonthDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new YearMonthDay(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static YearMonthDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new YearMonthDay(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology); [EOL]         newChronology.validate(newYearMonthDay, getValues()); [EOL]         return newYearMonthDay; [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology); [EOL]         newChronology.validate(newYearMonthDay, getValues()); [EOL]         return newYearMonthDay; [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay addToCopy(int valueToAdd) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay addToCopy(int valueToAdd) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected ReadablePartialConverter() { [EOL]     super(); [EOL] }
protected LongConverter() { [EOL]     super(); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard()); [EOL] }
public Period(ReadablePartial start, ReadablePartial end) { [EOL]     super(start, end, null); [EOL] }
public Period(ReadablePartial start, ReadablePartial end) { [EOL]     super(start, end, null); [EOL] }
public Period(ReadablePartial start, ReadablePartial end) { [EOL]     super(start, end, null); [EOL] }
public Period(ReadablePartial start, ReadablePartial end) { [EOL]     super(start, end, null); [EOL] }
public Period(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(start, end, type); [EOL] }
public Period(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(start, end, type); [EOL] }
public Period(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(start, end, type); [EOL] }
public Period(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(start, end, type); [EOL] }
public Period(ReadableDuration duration, ReadableInstant endInstant) { [EOL]     super(duration, endInstant, null); [EOL] }
public Period withField(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.setFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withField(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.setFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period minus(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE)); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period minus(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE)); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period multipliedBy(int scalar) { [EOL]     if (this == ZERO || scalar == 1) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         values[i] = FieldUtils.safeMultiply(values[i], scalar); [EOL]     } [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period negated() { [EOL]     return multipliedBy(-1); [EOL] }
public Period negated() { [EOL]     return multipliedBy(-1); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     checkYearsAndMonths("Hours"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     long hours = millis / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     hours = FieldUtils.safeAdd(hours, getHours()); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY)); [EOL]     hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK)); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (--month % 2 == 1) { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH; [EOL]     } else { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR; [EOL]     } [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (--month % 2 == 1) { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH; [EOL]     } else { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR; [EOL]     } [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public String toString() { [EOL]     StringBuffer sb = new StringBuffer(60); [EOL]     sb.append("GJChronology"); [EOL]     sb.append('['); [EOL]     sb.append(getZone().getID()); [EOL]     if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) { [EOL]         sb.append(",cutover="); [EOL]         DateTimeFormatter printer; [EOL]         if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) { [EOL]             printer = ISODateTimeFormat.date(); [EOL]         } else { [EOL]             printer = ISODateTimeFormat.dateTime(); [EOL]         } [EOL]         printer.withChronology(withUTC()).printTo(sb, iCutoverMillis); [EOL]     } [EOL]     if (getMinimumDaysInFirstWeek() != 4) { [EOL]         sb.append(",mdfw="); [EOL]         sb.append(getMinimumDaysInFirstWeek()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer sb = new StringBuffer(60); [EOL]     sb.append("GJChronology"); [EOL]     sb.append('['); [EOL]     sb.append(getZone().getID()); [EOL]     if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) { [EOL]         sb.append(",cutover="); [EOL]         DateTimeFormatter printer; [EOL]         if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) { [EOL]             printer = ISODateTimeFormat.date(); [EOL]         } else { [EOL]             printer = ISODateTimeFormat.dateTime(); [EOL]         } [EOL]         printer.withChronology(withUTC()).printTo(sb, iCutoverMillis); [EOL]     } [EOL]     if (getMinimumDaysInFirstWeek() != 4) { [EOL]         sb.append(",mdfw="); [EOL]         sb.append(getMinimumDaysInFirstWeek()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, text, locale); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, text, locale); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, text, locale); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, text, locale); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, text, locale); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, text, locale); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, text, locale); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, text, locale); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long add(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.add(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 if (iConvertByWeekyear) { [EOL]                     int wyear = iGregorianChronology.weekyear().get(instant); [EOL]                     if (wyear <= 0) { [EOL]                         instant = iGregorianChronology.weekyear().add(instant, -1); [EOL]                     } [EOL]                 } else { [EOL]                     int year = iGregorianChronology.year().get(instant); [EOL]                     if (year <= 0) { [EOL]                         instant = iGregorianChronology.year().add(instant, -1); [EOL]                     } [EOL]                 } [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.add(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant >= iCutover) { [EOL]         if (subtrahendInstant >= iCutover) { [EOL]             return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL]         } [EOL]         minuendInstant = gregorianToJulian(minuendInstant); [EOL]         return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL]     } else { [EOL]         if (subtrahendInstant < iCutover) { [EOL]             return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL]         } [EOL]         minuendInstant = julianToGregorian(minuendInstant); [EOL]         return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL]     } [EOL] }
public long add(long instant, int value) { [EOL]     return iField.add(instant, value); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return iField.getDifference(minuendInstant, subtrahendInstant); [EOL] }
protected AbstractConverter() { [EOL]     super(); [EOL] }
public String toString() { [EOL]     return "Converter[" + (getSupportedType() == null ? "null" : getSupportedType().getName()) + "]"; [EOL] }
public String toString() { [EOL]     return "Converter[" + (getSupportedType() == null ? "null" : getSupportedType().getName()) + "]"; [EOL] }
protected StringConverter() { [EOL]     super(); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { [EOL]     if (parser.getZone() != null) { [EOL]         chrono = chrono.withZone(parser.getZone()); [EOL]     } [EOL]     long millis = parser.withChronology(chrono).parseMillis((String) object); [EOL]     return chrono.get(fieldSource, millis); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { [EOL]     if (parser.getZone() != null) { [EOL]         chrono = chrono.withZone(parser.getZone()); [EOL]     } [EOL]     long millis = parser.withChronology(chrono).parseMillis((String) object); [EOL]     return chrono.get(fieldSource, millis); [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public Class<?> getSupportedType() { [EOL]     return String.class; [EOL] }
protected ReadablePeriodConverter() { [EOL]     super(); [EOL] }
public PeriodFormatter toFormatter() { [EOL]     PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser); [EOL]     iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone(); [EOL]     return formatter; [EOL] }
public void clear() { [EOL]     iMinPrintedDigits = 1; [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; [EOL]     iMaxParsedDigits = 10; [EOL]     iRejectSignedValues = false; [EOL]     iPrefix = null; [EOL]     if (iElementPairs == null) { [EOL]         iElementPairs = new ArrayList<Object>(); [EOL]     } else { [EOL]         iElementPairs.clear(); [EOL]     } [EOL]     iNotPrinter = false; [EOL]     iNotParser = false; [EOL]     iFieldFormatters = new FieldFormatter[10]; [EOL] }
public void clear() { [EOL]     iMinPrintedDigits = 1; [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; [EOL]     iMaxParsedDigits = 10; [EOL]     iRejectSignedValues = false; [EOL]     iPrefix = null; [EOL]     if (iElementPairs == null) { [EOL]         iElementPairs = new ArrayList<Object>(); [EOL]     } else { [EOL]         iElementPairs.clear(); [EOL]     } [EOL]     iNotPrinter = false; [EOL]     iNotParser = false; [EOL]     iFieldFormatters = new FieldFormatter[10]; [EOL] }
public PeriodFormatterBuilder appendPrefix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendPrefix(new SimpleAffix(text)); [EOL] }
public PeriodFormatterBuilder appendPrefix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendPrefix(new SimpleAffix(text)); [EOL] }
private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         prefix = new CompositeAffix(iPrefix, prefix); [EOL]     } [EOL]     iPrefix = prefix; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         prefix = new CompositeAffix(iPrefix, prefix); [EOL]     } [EOL]     iPrefix = prefix; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         prefix = new CompositeAffix(iPrefix, prefix); [EOL]     } [EOL]     iPrefix = prefix; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendHours() { [EOL]     appendField(HOURS); [EOL]     return this; [EOL] }
private void appendField(int type) { [EOL]     appendField(type, iMinPrintedDigits); [EOL] }
private void appendField(int type, int minPrinted) { [EOL]     FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting, iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null); [EOL]     append0(field, field); [EOL]     iFieldFormatters[type] = field; [EOL]     iPrefix = null; [EOL] }
public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) { [EOL]     if (singularText == null || pluralText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new PluralAffix(singularText, pluralText)); [EOL] }
public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) { [EOL]     if (singularText == null || pluralText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new PluralAffix(singularText, pluralText)); [EOL] }
public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) { [EOL]     if (singularText == null || pluralText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new PluralAffix(singularText, pluralText)); [EOL] }
private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     iNotPrinter |= (printer == null); [EOL]     iNotParser |= (parser == null); [EOL]     return this; [EOL] }
private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     iNotPrinter |= (printer == null); [EOL]     iNotParser |= (parser == null); [EOL]     return this; [EOL] }
private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     iNotPrinter |= (printer == null); [EOL]     iNotParser |= (parser == null); [EOL]     return this; [EOL] }
private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     iNotPrinter |= (printer == null); [EOL]     iNotParser |= (parser == null); [EOL]     return this; [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
SimpleAffix(String text) { [EOL]     iText = text; [EOL] }
SimpleAffix(String text) { [EOL]     iText = text; [EOL] }
SimpleAffix(String text) { [EOL]     iText = text; [EOL] }
public int calculatePrintedLength(int value) { [EOL]     return iText.length(); [EOL] }
public void printTo(StringBuffer buf, int value) { [EOL]     buf.append(iText); [EOL] }
public void printTo(StringBuffer buf, int value) { [EOL]     buf.append(iText); [EOL] }
PluralAffix(String singularText, String pluralText) { [EOL]     iSingularText = singularText; [EOL]     iPluralText = pluralText; [EOL] }
public int calculatePrintedLength(int value) { [EOL]     return (value == 1 ? iSingularText : iPluralText).length(); [EOL] }
public int calculatePrintedLength(int value) { [EOL]     return (value == 1 ? iSingularText : iPluralText).length(); [EOL] }
public void printTo(StringBuffer buf, int value) { [EOL]     buf.append(value == 1 ? iSingularText : iPluralText); [EOL] }
public void printTo(StringBuffer buf, int value) { [EOL]     buf.append(value == 1 ? iSingularText : iPluralText); [EOL] }
FieldFormatter(int minPrintedDigits, int printZeroSetting, int maxParsedDigits, boolean rejectSignedValues, int fieldType, FieldFormatter[] fieldFormatters, PeriodFieldAffix prefix, PeriodFieldAffix suffix) { [EOL]     iMinPrintedDigits = minPrintedDigits; [EOL]     iPrintZeroSetting = printZeroSetting; [EOL]     iMaxParsedDigits = maxParsedDigits; [EOL]     iRejectSignedValues = rejectSignedValues; [EOL]     iFieldType = fieldType; [EOL]     iFieldFormatters = fieldFormatters; [EOL]     iPrefix = prefix; [EOL]     iSuffix = suffix; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     if (stopAt <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     if (stopAt <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
boolean isZero(ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         if (period.getValue(i) != 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
boolean isZero(ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         if (period.getValue(i) != 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.size() <= 0) { [EOL]         iPrinters = null; [EOL]     } else { [EOL]         iPrinters = printerList.toArray(new PeriodPrinter[printerList.size()]); [EOL]     } [EOL]     if (parserList.size() <= 0) { [EOL]         iParsers = null; [EOL]     } else { [EOL]         iParsers = parserList.toArray(new PeriodParser[parserList.size()]); [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.size() <= 0) { [EOL]         iPrinters = null; [EOL]     } else { [EOL]         iPrinters = printerList.toArray(new PeriodPrinter[printerList.size()]); [EOL]     } [EOL]     if (parserList.size() <= 0) { [EOL]         iParsers = null; [EOL]     } else { [EOL]         iParsers = parserList.toArray(new PeriodParser[parserList.size()]); [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.size() <= 0) { [EOL]         iPrinters = null; [EOL]     } else { [EOL]         iPrinters = printerList.toArray(new PeriodPrinter[printerList.size()]); [EOL]     } [EOL]     if (parserList.size() <= 0) { [EOL]         iParsers = null; [EOL]     } else { [EOL]         iParsers = parserList.toArray(new PeriodParser[parserList.size()]); [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.size() <= 0) { [EOL]         iPrinters = null; [EOL]     } else { [EOL]         iPrinters = printerList.toArray(new PeriodPrinter[printerList.size()]); [EOL]     } [EOL]     if (parserList.size() <= 0) { [EOL]         iParsers = null; [EOL]     } else { [EOL]         iParsers = parserList.toArray(new PeriodParser[parserList.size()]); [EOL]     } [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     int sum = 0; [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     for (int i = printers.length; sum < stopAt && --i >= 0; ) { [EOL]         sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     int sum = 0; [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     for (int i = printers.length; --i >= 0; ) { [EOL]         sum += printers[i].calculatePrintedLength(period, locale); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     int sum = 0; [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     for (int i = printers.length; --i >= 0; ) { [EOL]         sum += printers[i].calculatePrintedLength(period, locale); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     int sum = 0; [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     for (int i = printers.length; --i >= 0; ) { [EOL]         sum += printers[i].calculatePrintedLength(period, locale); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(buf, period, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(buf, period, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(buf, period, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(buf, period, locale); [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public boolean isLenient() { [EOL]     return false; [EOL] }
public static DateTimeFormatter mediumTime() { [EOL]     return createFormatterForStyleIndex(NONE, MEDIUM); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
String getPattern(Locale locale) { [EOL]     DateFormat f = null; [EOL]     switch(iType) { [EOL]         case DATE: [EOL]             f = DateFormat.getDateInstance(iDateStyle, locale); [EOL]             break; [EOL]         case TIME: [EOL]             f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL]             break; [EOL]         case DATETIME: [EOL]             f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL]             break; [EOL]     } [EOL]     if (f instanceof SimpleDateFormat == false) { [EOL]         throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL]     } [EOL]     return ((SimpleDateFormat) f).toPattern(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static Duration standardHours(long hours) { [EOL]     if (hours == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR)); [EOL] }
public static Duration standardHours(long hours) { [EOL]     if (hours == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR)); [EOL] }
public static Duration standardHours(long hours) { [EOL]     if (hours == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR)); [EOL] }
public Duration(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant); [EOL] }
public Duration minus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), -1); [EOL] }
public Duration minus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), -1); [EOL] }
public Duration dividedBy(long divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeDivide(getMillis(), divisor)); [EOL] }
public Duration dividedBy(long divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeDivide(getMillis(), divisor)); [EOL] }
public static PeriodFormatter alternateExtendedWithWeeks() { [EOL]     if (cAlternateExtendedWihWeeks == null) { [EOL]         cAlternateExtendedWihWeeks = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator("-").minimumPrintedDigits(2).appendPrefix("W").appendWeeks().appendSeparator("-").appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendSeparator(":").appendMinutes().appendSeparator(":").appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternateExtendedWihWeeks; [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] }
public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (iRuleSets.size() > 0) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); [EOL]         lastRuleSet.setUpperLimit(year, ofYear); [EOL]     } [EOL]     iRuleSets.add(new RuleSet()); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (iRuleSets.size() > 0) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); [EOL]         lastRuleSet.setUpperLimit(year, ofYear); [EOL]     } [EOL]     iRuleSets.add(new RuleSet()); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) { [EOL]     getLastRuleSet().setFixedSavings(nameKey, saveMillis); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) { [EOL]     getLastRuleSet().setFixedSavings(nameKey, saveMillis); [EOL]     return this; [EOL] }
private RuleSet getLastRuleSet() { [EOL]     if (iRuleSets.size() == 0) { [EOL]         addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0); [EOL]     } [EOL]     return iRuleSets.get(iRuleSets.size() - 1); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
public void writeTo(String zoneID, OutputStream out) throws IOException { [EOL]     if (out instanceof DataOutput) { [EOL]         writeTo(zoneID, (DataOutput) out); [EOL]     } else { [EOL]         writeTo(zoneID, (DataOutput) new DataOutputStream(out)); [EOL]     } [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
public long setInstant(int year, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long millis = chrono.year().set(0, year); [EOL]     millis = chrono.monthOfYear().set(millis, iMonthOfYear); [EOL]     millis = chrono.millisOfDay().set(millis, iMillisOfDay); [EOL]     millis = setDayOfMonth(chrono, millis); [EOL]     if (iDayOfWeek != 0) { [EOL]         millis = setDayOfWeek(chrono, millis); [EOL]     } [EOL]     return millis - offset; [EOL] }
public long setInstant(int year, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long millis = chrono.year().set(0, year); [EOL]     millis = chrono.monthOfYear().set(millis, iMonthOfYear); [EOL]     millis = chrono.millisOfDay().set(millis, iMillisOfDay); [EOL]     millis = setDayOfMonth(chrono, millis); [EOL]     if (iDayOfWeek != 0) { [EOL]         millis = setDayOfWeek(chrono, millis); [EOL]     } [EOL]     return millis - offset; [EOL] }
public long setInstant(int year, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long millis = chrono.year().set(0, year); [EOL]     millis = chrono.monthOfYear().set(millis, iMonthOfYear); [EOL]     millis = chrono.millisOfDay().set(millis, iMillisOfDay); [EOL]     millis = setDayOfMonth(chrono, millis); [EOL]     if (iDayOfWeek != 0) { [EOL]         millis = setDayOfWeek(chrono, millis); [EOL]     } [EOL]     return millis - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     out.writeByte(iMode); [EOL]     out.writeByte(iMonthOfYear); [EOL]     out.writeByte(iDayOfMonth); [EOL]     out.writeByte(iDayOfWeek); [EOL]     out.writeBoolean(iAdvance); [EOL]     writeMillis(out, iMillisOfDay); [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     iOfYear.writeTo(out); [EOL]     out.writeUTF(iNameKey); [EOL]     writeMillis(out, iSaveMillis); [EOL] }
public long next(final long instant, int standardOffset, int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     final int wallOffset = standardOffset + saveMillis; [EOL]     long testInstant = instant; [EOL]     int year; [EOL]     if (instant == Long.MIN_VALUE) { [EOL]         year = Integer.MIN_VALUE; [EOL]     } else { [EOL]         year = chrono.year().get(instant + wallOffset); [EOL]     } [EOL]     if (year < iFromYear) { [EOL]         testInstant = chrono.year().set(0, iFromYear) - wallOffset; [EOL]         testInstant -= 1; [EOL]     } [EOL]     long next = iRecurrence.next(testInstant, standardOffset, saveMillis); [EOL]     if (next > instant) { [EOL]         year = chrono.year().get(next + wallOffset); [EOL]         if (year > iToYear) { [EOL]             next = instant; [EOL]         } [EOL]     } [EOL]     return next; [EOL] }
Transition(long millis, Transition tr) { [EOL]     iMillis = millis; [EOL]     iNameKey = tr.iNameKey; [EOL]     iWallOffset = tr.iWallOffset; [EOL]     iStandardOffset = tr.iStandardOffset; [EOL] }
Transition(long millis, String nameKey, int wallOffset, int standardOffset) { [EOL]     iMillis = millis; [EOL]     iNameKey = nameKey; [EOL]     iWallOffset = wallOffset; [EOL]     iStandardOffset = standardOffset; [EOL] }
public void setFixedSavings(String nameKey, int saveMillis) { [EOL]     iInitialNameKey = nameKey; [EOL]     iInitialSaveMillis = saveMillis; [EOL] }
public void setUpperLimit(int year, OfYear ofYear) { [EOL]     iUpperYear = year; [EOL]     iUpperOfYear = ofYear; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] }
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] }
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public int getStandardOffset(long instant) { [EOL]     return iStandardOffset; [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     writeMillis(out, iStandardOffset); [EOL]     iStartRecurrence.writeTo(out); [EOL]     iEndRecurrence.writeTo(out); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     int size = iTransitions.length; [EOL]     Set<String> poolSet = new HashSet<String>(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         poolSet.add(iNameKeys[i]); [EOL]     } [EOL]     int poolSize = poolSet.size(); [EOL]     if (poolSize > 65535) { [EOL]         throw new UnsupportedOperationException("String pool is too large"); [EOL]     } [EOL]     String[] pool = new String[poolSize]; [EOL]     Iterator<String> it = poolSet.iterator(); [EOL]     for (int i = 0; it.hasNext(); i++) { [EOL]         pool[i] = it.next(); [EOL]     } [EOL]     out.writeShort(poolSize); [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         out.writeUTF(pool[i]); [EOL]     } [EOL]     out.writeInt(size); [EOL]     for (int i = 0; i < size; i++) { [EOL]         writeMillis(out, iTransitions[i]); [EOL]         writeMillis(out, iWallOffsets[i]); [EOL]         writeMillis(out, iStandardOffsets[i]); [EOL]         String nameKey = iNameKeys[i]; [EOL]         for (int j = 0; j < poolSize; j++) { [EOL]             if (pool[j].equals(nameKey)) { [EOL]                 if (poolSize < 256) { [EOL]                     out.writeByte(j); [EOL]                 } else { [EOL]                     out.writeShort(j); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     out.writeBoolean(iTailZone != null); [EOL]     if (iTailZone != null) { [EOL]         iTailZone.writeTo(out); [EOL]     } [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     int size = iTransitions.length; [EOL]     Set<String> poolSet = new HashSet<String>(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         poolSet.add(iNameKeys[i]); [EOL]     } [EOL]     int poolSize = poolSet.size(); [EOL]     if (poolSize > 65535) { [EOL]         throw new UnsupportedOperationException("String pool is too large"); [EOL]     } [EOL]     String[] pool = new String[poolSize]; [EOL]     Iterator<String> it = poolSet.iterator(); [EOL]     for (int i = 0; it.hasNext(); i++) { [EOL]         pool[i] = it.next(); [EOL]     } [EOL]     out.writeShort(poolSize); [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         out.writeUTF(pool[i]); [EOL]     } [EOL]     out.writeInt(size); [EOL]     for (int i = 0; i < size; i++) { [EOL]         writeMillis(out, iTransitions[i]); [EOL]         writeMillis(out, iWallOffsets[i]); [EOL]         writeMillis(out, iStandardOffsets[i]); [EOL]         String nameKey = iNameKeys[i]; [EOL]         for (int j = 0; j < poolSize; j++) { [EOL]             if (pool[j].equals(nameKey)) { [EOL]                 if (poolSize < 256) { [EOL]                     out.writeByte(j); [EOL]                 } else { [EOL]                     out.writeShort(j); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     out.writeBoolean(iTailZone != null); [EOL]     if (iTailZone != null) { [EOL]         iTailZone.writeTo(out); [EOL]     } [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     int size = iTransitions.length; [EOL]     Set<String> poolSet = new HashSet<String>(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         poolSet.add(iNameKeys[i]); [EOL]     } [EOL]     int poolSize = poolSet.size(); [EOL]     if (poolSize > 65535) { [EOL]         throw new UnsupportedOperationException("String pool is too large"); [EOL]     } [EOL]     String[] pool = new String[poolSize]; [EOL]     Iterator<String> it = poolSet.iterator(); [EOL]     for (int i = 0; it.hasNext(); i++) { [EOL]         pool[i] = it.next(); [EOL]     } [EOL]     out.writeShort(poolSize); [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         out.writeUTF(pool[i]); [EOL]     } [EOL]     out.writeInt(size); [EOL]     for (int i = 0; i < size; i++) { [EOL]         writeMillis(out, iTransitions[i]); [EOL]         writeMillis(out, iWallOffsets[i]); [EOL]         writeMillis(out, iStandardOffsets[i]); [EOL]         String nameKey = iNameKeys[i]; [EOL]         for (int j = 0; j < poolSize; j++) { [EOL]             if (pool[j].equals(nameKey)) { [EOL]                 if (poolSize < 256) { [EOL]                     out.writeByte(j); [EOL]                 } else { [EOL]                     out.writeShort(j); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     out.writeBoolean(iTailZone != null); [EOL]     if (iTailZone != null) { [EOL]         iTailZone.writeTo(out); [EOL]     } [EOL] }
public void writeTo(DataOutput out) throws IOException { [EOL]     int size = iTransitions.length; [EOL]     Set<String> poolSet = new HashSet<String>(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         poolSet.add(iNameKeys[i]); [EOL]     } [EOL]     int poolSize = poolSet.size(); [EOL]     if (poolSize > 65535) { [EOL]         throw new UnsupportedOperationException("String pool is too large"); [EOL]     } [EOL]     String[] pool = new String[poolSize]; [EOL]     Iterator<String> it = poolSet.iterator(); [EOL]     for (int i = 0; it.hasNext(); i++) { [EOL]         pool[i] = it.next(); [EOL]     } [EOL]     out.writeShort(poolSize); [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         out.writeUTF(pool[i]); [EOL]     } [EOL]     out.writeInt(size); [EOL]     for (int i = 0; i < size; i++) { [EOL]         writeMillis(out, iTransitions[i]); [EOL]         writeMillis(out, iWallOffsets[i]); [EOL]         writeMillis(out, iStandardOffsets[i]); [EOL]         String nameKey = iNameKeys[i]; [EOL]         for (int j = 0; j < poolSize; j++) { [EOL]             if (pool[j].equals(nameKey)) { [EOL]                 if (poolSize < 256) { [EOL]                     out.writeByte(j); [EOL]                 } else { [EOL]                     out.writeShort(j); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     out.writeBoolean(iTailZone != null); [EOL]     if (iTailZone != null) { [EOL]         iTailZone.writeTo(out); [EOL]     } [EOL] }
public DateTimeZone getUncachedZone() { [EOL]     return iZone; [EOL] }
public int getOffset(long instant) { [EOL]     return getInfo(instant).getOffset(instant); [EOL] }
public int getStandardOffset(long instant) { [EOL]     return getInfo(instant).getStandardOffset(instant); [EOL] }
public int hashCode() { [EOL]     return iZone.hashCode(); [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public int getOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iOffset == Integer.MIN_VALUE) { [EOL]             iOffset = iZoneRef.getOffset(iPeriodStart); [EOL]         } [EOL]         return iOffset; [EOL]     } [EOL]     return iNextInfo.getOffset(millis); [EOL] }
public int getStandardOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iStandardOffset == Integer.MIN_VALUE) { [EOL]             iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart); [EOL]         } [EOL]         return iStandardOffset; [EOL]     } [EOL]     return iNextInfo.getStandardOffset(millis); [EOL] }
public int getStandardOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iStandardOffset == Integer.MIN_VALUE) { [EOL]             iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart); [EOL]         } [EOL]         return iStandardOffset; [EOL]     } [EOL]     return iNextInfo.getStandardOffset(millis); [EOL] }
public int getStandardOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iStandardOffset == Integer.MIN_VALUE) { [EOL]             iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart); [EOL]         } [EOL]         return iStandardOffset; [EOL]     } [EOL]     return iNextInfo.getStandardOffset(millis); [EOL] }
public int getStandardOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iStandardOffset == Integer.MIN_VALUE) { [EOL]             iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart); [EOL]         } [EOL]         return iStandardOffset; [EOL]     } [EOL]     return iNextInfo.getStandardOffset(millis); [EOL] }
public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) { [EOL]     super(field, type); [EOL]     if (scalar == 0 || scalar == 1) { [EOL]         throw new IllegalArgumentException("The scalar must not be 0 or 1"); [EOL]     } [EOL]     iScalar = scalar; [EOL] }
public long getValueAsLong(long duration) { [EOL]     return getWrappedField().getValueAsLong(duration) / iScalar; [EOL] }
public long add(long instant, int value) { [EOL]     long scaled = ((long) value) * ((long) iScalar); [EOL]     return getWrappedField().add(instant, scaled); [EOL] }
public static ISOChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
private Object writeReplace() { [EOL]     return new Stub(getZone()); [EOL] }
Stub(DateTimeZone zone) { [EOL]     iZone = zone; [EOL] }
Stub(DateTimeZone zone) { [EOL]     iZone = zone; [EOL] }
private Object readResolve() { [EOL]     return ISOChronology.getInstance(iZone); [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL]     out.writeObject(iZone); [EOL] }
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     iZone = (DateTimeZone) in.readObject(); [EOL] }
protected BaseDurationField(DurationFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
protected BaseDurationField(DurationFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
public String toString() { [EOL]     return "DurationField[" + getName() + ']'; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]         fields.era = ERA_FIELD; [EOL]         fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]     } [EOL] }
protected DateConverter() { [EOL]     super(); [EOL] }
public static Months monthsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int months = chrono.months().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Months.months(months); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Months.months(amount); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.months(); [EOL] }
public Months multipliedBy(int scalar) { [EOL]     return Months.months(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Months multipliedBy(int scalar) { [EOL]     return Months.months(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Months multipliedBy(int scalar) { [EOL]     return Months.months(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Months multipliedBy(int scalar) { [EOL]     return Months.months(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public static DateTimeField getInstance(DateTimeField field, Chronology base) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof StrictDateTimeField) { [EOL]         field = ((StrictDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new LenientDateTimeField(field, base); [EOL] }
public static DateTimeField getInstance(DateTimeField field, Chronology base) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof StrictDateTimeField) { [EOL]         field = ((StrictDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new LenientDateTimeField(field, base); [EOL] }
public static DateTimeField getInstance(DateTimeField field, Chronology base) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof StrictDateTimeField) { [EOL]         field = ((StrictDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new LenientDateTimeField(field, base); [EOL] }
public static DateTimeField getInstance(DateTimeField field, Chronology base) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof StrictDateTimeField) { [EOL]         field = ((StrictDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new LenientDateTimeField(field, base); [EOL] }
protected LenientDateTimeField(DateTimeField field, Chronology base) { [EOL]     super(field); [EOL]     iBase = base; [EOL] }
protected LenientDateTimeField(DateTimeField field, Chronology base) { [EOL]     super(field); [EOL]     iBase = base; [EOL] }
protected LenientDateTimeField(DateTimeField field, Chronology base) { [EOL]     super(field); [EOL]     iBase = base; [EOL] }
public long set(long instant, int value) { [EOL]     long localInstant = iBase.getZone().convertUTCToLocal(instant); [EOL]     long difference = FieldUtils.safeSubtract(value, get(instant)); [EOL]     localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); [EOL]     return iBase.getZone().convertLocalToUTC(localInstant, false, instant); [EOL] }
public long set(long instant, int value) { [EOL]     long localInstant = iBase.getZone().convertUTCToLocal(instant); [EOL]     long difference = FieldUtils.safeSubtract(value, get(instant)); [EOL]     localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); [EOL]     return iBase.getZone().convertLocalToUTC(localInstant, false, instant); [EOL] }
public long set(long instant, int value) { [EOL]     long localInstant = iBase.getZone().convertUTCToLocal(instant); [EOL]     long difference = FieldUtils.safeSubtract(value, get(instant)); [EOL]     localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); [EOL]     return iBase.getZone().convertLocalToUTC(localInstant, false, instant); [EOL] }
public static Interval parse(String str) { [EOL]     return new Interval(str); [EOL] }
public static Interval parse(String str) { [EOL]     return new Interval(str); [EOL] }
public static Interval parse(String str) { [EOL]     return new Interval(str); [EOL] }
public Interval(long startInstant, long endInstant, Chronology chronology) { [EOL]     super(startInstant, endInstant, chronology); [EOL] }
public Interval(long startInstant, long endInstant, Chronology chronology) { [EOL]     super(startInstant, endInstant, chronology); [EOL] }
public Interval overlap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     if (overlaps(interval) == false) { [EOL]         return null; [EOL]     } [EOL]     long start = Math.max(getStartMillis(), interval.getStartMillis()); [EOL]     long end = Math.min(getEndMillis(), interval.getEndMillis()); [EOL]     return new Interval(start, end, getChronology()); [EOL] }
public Interval overlap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     if (overlaps(interval) == false) { [EOL]         return null; [EOL]     } [EOL]     long start = Math.max(getStartMillis(), interval.getStartMillis()); [EOL]     long end = Math.min(getEndMillis(), interval.getEndMillis()); [EOL]     return new Interval(start, end, getChronology()); [EOL] }
public Interval overlap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     if (overlaps(interval) == false) { [EOL]         return null; [EOL]     } [EOL]     long start = Math.max(getStartMillis(), interval.getStartMillis()); [EOL]     long end = Math.min(getEndMillis(), interval.getEndMillis()); [EOL]     return new Interval(start, end, getChronology()); [EOL] }
public Interval withChronology(Chronology chronology) { [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), getEndMillis(), chronology); [EOL] }
public Interval withChronology(Chronology chronology) { [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), getEndMillis(), chronology); [EOL] }
public Interval withEndMillis(long endInstant) { [EOL]     if (endInstant == getEndMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), endInstant, getChronology()); [EOL] }
public Interval withEnd(ReadableInstant end) { [EOL]     long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]     return withEndMillis(endMillis); [EOL] }
public Interval withEnd(ReadableInstant end) { [EOL]     long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]     return withEndMillis(endMillis); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static YearMonth fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new YearMonth(date.getYear() + 1900, date.getMonth() + 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
@SuppressWarnings("deprecation") [EOL] public static YearMonth fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new YearMonth(date.getYear() + 1900, date.getMonth() + 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.yearMonth().print(this); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String getAsShortText(long instant, Locale locale) { [EOL]     return getAsShortText(get(instant), locale); [EOL] }
public long add(long instant, int value) { [EOL]     return getDurationField().add(instant, value); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 throw new IllegalArgumentException("Maximum value exceeded for add"); [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.add(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public DurationField getLeapDurationField() { [EOL]     return null; [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     int max = getMaximumValue(); [EOL]     if (max >= 0) { [EOL]         if (max < 10) { [EOL]             return 1; [EOL]         } else if (max < 100) { [EOL]             return 2; [EOL]         } else if (max < 1000) { [EOL]             return 3; [EOL]         } [EOL]     } [EOL]     return Integer.toString(max).length(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     int max = getMaximumValue(); [EOL]     if (max >= 0) { [EOL]         if (max < 10) { [EOL]             return 1; [EOL]         } else if (max < 100) { [EOL]             return 2; [EOL]         } else if (max < 1000) { [EOL]             return 3; [EOL]         } [EOL]     } [EOL]     return Integer.toString(max).length(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     int max = getMaximumValue(); [EOL]     if (max >= 0) { [EOL]         if (max < 10) { [EOL]             return 1; [EOL]         } else if (max < 100) { [EOL]             return 2; [EOL]         } else if (max < 1000) { [EOL]             return 3; [EOL]         } [EOL]     } [EOL]     return Integer.toString(max).length(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     int max = getMaximumValue(); [EOL]     if (max >= 0) { [EOL]         if (max < 10) { [EOL]             return 1; [EOL]         } else if (max < 100) { [EOL]             return 2; [EOL]         } else if (max < 1000) { [EOL]             return 3; [EOL]         } [EOL]     } [EOL]     return Integer.toString(max).length(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     int max = getMaximumValue(); [EOL]     if (max >= 0) { [EOL]         if (max < 10) { [EOL]             return 1; [EOL]         } else if (max < 100) { [EOL]             return 2; [EOL]         } else if (max < 1000) { [EOL]             return 3; [EOL]         } [EOL]     } [EOL]     return Integer.toString(max).length(); [EOL] }
public long roundCeiling(long instant) { [EOL]     long newInstant = roundFloor(instant); [EOL]     if (newInstant != instant) { [EOL]         instant = add(newInstant, 1); [EOL]     } [EOL]     return instant; [EOL] }
public long roundCeiling(long instant) { [EOL]     long newInstant = roundFloor(instant); [EOL]     if (newInstant != instant) { [EOL]         instant = add(newInstant, 1); [EOL]     } [EOL]     return instant; [EOL] }
public long roundHalfFloor(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor <= diffToCeiling) { [EOL]         return floor; [EOL]     } else { [EOL]         return ceiling; [EOL]     } [EOL] }
public long roundHalfFloor(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor <= diffToCeiling) { [EOL]         return floor; [EOL]     } else { [EOL]         return ceiling; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     return getWrappedField().roundFloor(instant); [EOL] }
public int get(long instant) { [EOL]     return iChronology.getDayOfMonth(instant); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
static int parseTwoDigits(String text, int position) { [EOL]     int value = text.charAt(position) - '0'; [EOL]     return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0'; [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
protected ReadableInstantConverter() { [EOL]     super(); [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     Chronology chrono = ((ReadableInstant) object).getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL]     DateTimeZone chronoZone = chrono.getZone(); [EOL]     if (chronoZone != zone) { [EOL]         chrono = chrono.withZone(zone); [EOL]         if (chrono == null) { [EOL]             return ISOChronology.getInstance(zone); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     Chronology chrono = ((ReadableInstant) object).getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL]     DateTimeZone chronoZone = chrono.getZone(); [EOL]     if (chronoZone != zone) { [EOL]         chrono = chrono.withZone(zone); [EOL]         if (chrono == null) { [EOL]             return ISOChronology.getInstance(zone); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     Chronology chrono = ((ReadableInstant) object).getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL]     DateTimeZone chronoZone = chrono.getZone(); [EOL]     if (chronoZone != zone) { [EOL]         chrono = chrono.withZone(zone); [EOL]         if (chrono == null) { [EOL]             return ISOChronology.getInstance(zone); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     return ((ReadableInstant) object).getMillis(); [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     return ((ReadableInstant) object).getMillis(); [EOL] }
public static BuddhistChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     return base == null ? getInstanceUTC() : getInstance(base.getZone()); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     return base == null ? getInstanceUTC() : getInstance(base.getZone()); [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getParam() == null) { [EOL]         fields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras()); [EOL]         DateTimeField field = fields.year; [EOL]         fields.year = new OffsetDateTimeField(new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET); [EOL]         field = fields.yearOfEra; [EOL]         fields.yearOfEra = new DelegatedDateTimeField(fields.year, fields.eras, DateTimeFieldType.yearOfEra()); [EOL]         field = fields.weekyear; [EOL]         fields.weekyear = new OffsetDateTimeField(new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET); [EOL]         field = new OffsetDateTimeField(fields.yearOfEra, 99); [EOL]         fields.centuryOfEra = new DividedDateTimeField(field, fields.eras, DateTimeFieldType.centuryOfEra(), 100); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         field = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra); [EOL]         fields.yearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.yearOfCentury(), 1); [EOL]         field = new RemainderDateTimeField(fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100); [EOL]         fields.weekyearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.weekyearOfCentury(), 1); [EOL]         fields.era = ERA_FIELD; [EOL]     } [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getParam() == null) { [EOL]         fields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras()); [EOL]         DateTimeField field = fields.year; [EOL]         fields.year = new OffsetDateTimeField(new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET); [EOL]         field = fields.yearOfEra; [EOL]         fields.yearOfEra = new DelegatedDateTimeField(fields.year, fields.eras, DateTimeFieldType.yearOfEra()); [EOL]         field = fields.weekyear; [EOL]         fields.weekyear = new OffsetDateTimeField(new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET); [EOL]         field = new OffsetDateTimeField(fields.yearOfEra, 99); [EOL]         fields.centuryOfEra = new DividedDateTimeField(field, fields.eras, DateTimeFieldType.centuryOfEra(), 100); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         field = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra); [EOL]         fields.yearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.yearOfCentury(), 1); [EOL]         field = new RemainderDateTimeField(fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100); [EOL]         fields.weekyearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.weekyearOfCentury(), 1); [EOL]         fields.era = ERA_FIELD; [EOL]     } [EOL] }
public int hashCode() { [EOL]     long millis = iUnitMillis; [EOL]     int hash = (int) (millis ^ (millis >>> 32)); [EOL]     hash += getType().hashCode(); [EOL]     return hash; [EOL] }
public int get(long instant) { [EOL]     return iChronology.getMonthOfYear(instant); [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, long months) { [EOL]     int i_months = (int) months; [EOL]     if (i_months == months) { [EOL]         return add(instant, i_months); [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     long yearToUse; [EOL]     long monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = (int) (monthToUse % iMax); [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     if (yearToUse < iChronology.getMinYear() || yearToUse > iChronology.getMaxYear()) { [EOL]         throw new IllegalArgumentException("Magnitude of add amount is too large: " + months); [EOL]     } [EOL]     int i_yearToUse = (int) yearToUse; [EOL]     int i_monthToUse = (int) monthToUse; [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long roundFloor(long instant) { [EOL]     int year = iChronology.getYear(instant); [EOL]     int month = iChronology.getMonthOfYear(instant, year); [EOL]     return iChronology.getYearMonthMillis(year, month); [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeToInt(long value) { [EOL]     if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) { [EOL]         return (int) value; [EOL]     } [EOL]     throw new ArithmeticException("Value cannot fit in an int: " + value); [EOL] }
public static int safeToInt(long value) { [EOL]     if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) { [EOL]         return (int) value; [EOL]     } [EOL]     throw new ArithmeticException("Value cannot fit in an int: " + value); [EOL] }
public static int safeToInt(long value) { [EOL]     if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) { [EOL]         return (int) value; [EOL]     } [EOL]     throw new ArithmeticException("Value cannot fit in an int: " + value); [EOL] }
public static int safeToInt(long value) { [EOL]     if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) { [EOL]         return (int) value; [EOL]     } [EOL]     throw new ArithmeticException("Value cannot fit in an int: " + value); [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public boolean isLenient() { [EOL]     return iField.isLenient(); [EOL] }
public boolean isLenient() { [EOL]     return iField.isLenient(); [EOL] }
public long set(long instant, int value) { [EOL]     return iField.set(instant, value); [EOL] }
public long set(long instant, int value) { [EOL]     return iField.set(instant, value); [EOL] }
public int getMinimumValue() { [EOL]     return iField.getMinimumValue(); [EOL] }
public int getMaximumValue() { [EOL]     return iField.getMaximumValue(); [EOL] }
public static ConverterManager getInstance() { [EOL]     if (INSTANCE == null) { [EOL]         INSTANCE = new ConverterManager(); [EOL]     } [EOL]     return INSTANCE; [EOL] }
public static ConverterManager getInstance() { [EOL]     if (INSTANCE == null) { [EOL]         INSTANCE = new ConverterManager(); [EOL]     } [EOL]     return INSTANCE; [EOL] }
protected ConverterManager() { [EOL]     super(); [EOL]     iInstantConverters = new ConverterSet(new Converter[] { ReadableInstantConverter.INSTANCE, StringConverter.INSTANCE, CalendarConverter.INSTANCE, DateConverter.INSTANCE, LongConverter.INSTANCE, NullConverter.INSTANCE }); [EOL]     iPartialConverters = new ConverterSet(new Converter[] { ReadablePartialConverter.INSTANCE, ReadableInstantConverter.INSTANCE, StringConverter.INSTANCE, CalendarConverter.INSTANCE, DateConverter.INSTANCE, LongConverter.INSTANCE, NullConverter.INSTANCE }); [EOL]     iDurationConverters = new ConverterSet(new Converter[] { ReadableDurationConverter.INSTANCE, ReadableIntervalConverter.INSTANCE, StringConverter.INSTANCE, LongConverter.INSTANCE, NullConverter.INSTANCE }); [EOL]     iPeriodConverters = new ConverterSet(new Converter[] { ReadableDurationConverter.INSTANCE, ReadablePeriodConverter.INSTANCE, ReadableIntervalConverter.INSTANCE, StringConverter.INSTANCE, NullConverter.INSTANCE }); [EOL]     iIntervalConverters = new ConverterSet(new Converter[] { ReadableIntervalConverter.INSTANCE, StringConverter.INSTANCE, NullConverter.INSTANCE }); [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public PartialConverter addPartialConverter(PartialConverter converter) throws SecurityException { [EOL]     checkAlterPartialConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PartialConverter[] removed = new PartialConverter[1]; [EOL]     iPartialConverters = iPartialConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter[] getPeriodConverters() { [EOL]     ConverterSet set = iPeriodConverters; [EOL]     PeriodConverter[] converters = new PeriodConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public PeriodConverter[] getPeriodConverters() { [EOL]     ConverterSet set = iPeriodConverters; [EOL]     PeriodConverter[] converters = new PeriodConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public PeriodConverter addPeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter addPeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
private void checkAlterPeriodConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterPeriodConverters")); [EOL]     } [EOL] }
private void checkAlterPeriodConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterPeriodConverters")); [EOL]     } [EOL] }
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public DelegatedDateTimeField(DateTimeField field) { [EOL]     this(field, null); [EOL] }
public DelegatedDateTimeField(DateTimeField field) { [EOL]     this(field, null); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     this(field, null, type); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     this(field, null, type); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     this(field, null, type); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type) { [EOL]     super(); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     iField = field; [EOL]     iRangeDurationField = rangeField; [EOL]     iType = (type == null ? field.getType() : type); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type) { [EOL]     super(); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     iField = field; [EOL]     iRangeDurationField = rangeField; [EOL]     iType = (type == null ? field.getType() : type); [EOL] }
public DelegatedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type) { [EOL]     super(); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     iField = field; [EOL]     iRangeDurationField = rangeField; [EOL]     iType = (type == null ? field.getType() : type); [EOL] }
public DateTimeFieldType getType() { [EOL]     return iType; [EOL] }
public long remainder(long instant) { [EOL]     return iField.remainder(instant); [EOL] }
public static DateTimeComparator getDateOnlyInstance() { [EOL]     return DATE_INSTANCE; [EOL] }
public int compare(Object lhsObj, Object rhsObj) { [EOL]     InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); [EOL]     Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); [EOL]     long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); [EOL]     conv = ConverterManager.getInstance().getInstantConverter(rhsObj); [EOL]     Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); [EOL]     long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); [EOL]     if (iLowerLimit != null) { [EOL]         lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); [EOL]         rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); [EOL]     } [EOL]     if (iUpperLimit != null) { [EOL]         lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); [EOL]         rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); [EOL]     } [EOL]     if (lhsMillis < rhsMillis) { [EOL]         return -1; [EOL]     } else if (lhsMillis > rhsMillis) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getValue(); [EOL] }
public int getValue(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getValue(); [EOL] }
public MutablePeriod toMutablePeriod() { [EOL]     MutablePeriod period = new MutablePeriod(); [EOL]     period.add(this); [EOL]     return period; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL]     return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int seconds = chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Seconds.seconds(seconds); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int seconds = chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Seconds.seconds(seconds); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Seconds.seconds(amount); [EOL] }
@FromString [EOL] public static Seconds parseSeconds(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Seconds.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Seconds.seconds(p.getSeconds()); [EOL] }
@FromString [EOL] public static Seconds parseSeconds(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Seconds.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Seconds.seconds(p.getSeconds()); [EOL] }
@FromString [EOL] public static Seconds parseSeconds(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Seconds.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Seconds.seconds(p.getSeconds()); [EOL] }
public int getValue(long duration, long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getValue(duration, instant); [EOL] }
public int getValue(long duration, long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getValue(duration, instant); [EOL] }
public long getMillis(int value, long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMillis(value, instant); [EOL] }
public long getMillis(long value, long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMillis(value, instant); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getAsShortText(instant, locale); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getAsShortText(instant, locale); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getAsShortText(instant, locale); [EOL] }
protected AbstractDateTime() { [EOL]     super(); [EOL] }
public int getWeekyear() { [EOL]     return getChronology().weekyear().get(getMillis()); [EOL] }
public int getWeekOfWeekyear() { [EOL]     return getChronology().weekOfWeekyear().get(getMillis()); [EOL] }
public int getHourOfDay() { [EOL]     return getChronology().hourOfDay().get(getMillis()); [EOL] }
public int getMinuteOfDay() { [EOL]     return getChronology().minuteOfDay().get(getMillis()); [EOL] }
public int getMinuteOfHour() { [EOL]     return getChronology().minuteOfHour().get(getMillis()); [EOL] }
public int getSecondOfDay() { [EOL]     return getChronology().secondOfDay().get(getMillis()); [EOL] }
public int getSecondOfMinute() { [EOL]     return getChronology().secondOfMinute().get(getMillis()); [EOL] }
public int getMillisOfDay() { [EOL]     return getChronology().millisOfDay().get(getMillis()); [EOL] }
public int getMillisOfSecond() { [EOL]     return getChronology().millisOfSecond().get(getMillis()); [EOL] }
public Calendar toCalendar(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     DateTimeZone zone = getZone(); [EOL]     Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale); [EOL]     cal.setTime(toDate()); [EOL]     return cal; [EOL] }
public Calendar toCalendar(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     DateTimeZone zone = getZone(); [EOL]     Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale); [EOL]     cal.setTime(toDate()); [EOL]     return cal; [EOL] }
public GregorianCalendar toGregorianCalendar() { [EOL]     DateTimeZone zone = getZone(); [EOL]     GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone()); [EOL]     cal.setTime(toDate()); [EOL]     return cal; [EOL] }
public static LenientChronology getInstance(Chronology base) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     return new LenientChronology(base); [EOL] }
private LenientChronology(Chronology base) { [EOL]     super(base, null); [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = LenientChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = LenientChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == DateTimeZone.UTC) { [EOL]         return withUTC(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return LenientChronology.getInstance(getBase().withZone(zone)); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == DateTimeZone.UTC) { [EOL]         return withUTC(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return LenientChronology.getInstance(getBase().withZone(zone)); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == DateTimeZone.UTC) { [EOL]         return withUTC(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return LenientChronology.getInstance(getBase().withZone(zone)); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == DateTimeZone.UTC) { [EOL]         return withUTC(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return LenientChronology.getInstance(getBase().withZone(zone)); [EOL] }
protected void assemble(Fields fields) { [EOL]     fields.year = convertField(fields.year); [EOL]     fields.yearOfEra = convertField(fields.yearOfEra); [EOL]     fields.yearOfCentury = convertField(fields.yearOfCentury); [EOL]     fields.centuryOfEra = convertField(fields.centuryOfEra); [EOL]     fields.era = convertField(fields.era); [EOL]     fields.dayOfWeek = convertField(fields.dayOfWeek); [EOL]     fields.dayOfMonth = convertField(fields.dayOfMonth); [EOL]     fields.dayOfYear = convertField(fields.dayOfYear); [EOL]     fields.monthOfYear = convertField(fields.monthOfYear); [EOL]     fields.weekOfWeekyear = convertField(fields.weekOfWeekyear); [EOL]     fields.weekyear = convertField(fields.weekyear); [EOL]     fields.weekyearOfCentury = convertField(fields.weekyearOfCentury); [EOL]     fields.millisOfSecond = convertField(fields.millisOfSecond); [EOL]     fields.millisOfDay = convertField(fields.millisOfDay); [EOL]     fields.secondOfMinute = convertField(fields.secondOfMinute); [EOL]     fields.secondOfDay = convertField(fields.secondOfDay); [EOL]     fields.minuteOfHour = convertField(fields.minuteOfHour); [EOL]     fields.minuteOfDay = convertField(fields.minuteOfDay); [EOL]     fields.hourOfDay = convertField(fields.hourOfDay); [EOL]     fields.hourOfHalfday = convertField(fields.hourOfHalfday); [EOL]     fields.clockhourOfDay = convertField(fields.clockhourOfDay); [EOL]     fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday); [EOL]     fields.halfdayOfDay = convertField(fields.halfdayOfDay); [EOL] }
private final DateTimeField convertField(DateTimeField field) { [EOL]     return LenientDateTimeField.getInstance(field, getBase()); [EOL] }
private final DateTimeField convertField(DateTimeField field) { [EOL]     return LenientDateTimeField.getInstance(field, getBase()); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant)); [EOL] }
public long add(long instant, int value) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value); [EOL] }
public long add(long instant, long value) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return ImpreciseDateTimeField.this.getDifference(minuendInstant, subtrahendInstant); [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks standardWeeksIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks standardWeeksIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks standardWeeksIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK); [EOL]     return Weeks.weeks(amount); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK)); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK)); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK)); [EOL] }
public Weeks negated() { [EOL]     return Weeks.weeks(FieldUtils.safeNegate(getValue())); [EOL] }
public Weeks negated() { [EOL]     return Weeks.weeks(FieldUtils.safeNegate(getValue())); [EOL] }
public Weeks negated() { [EOL]     return Weeks.weeks(FieldUtils.safeNegate(getValue())); [EOL] }
public Weeks negated() { [EOL]     return Weeks.weeks(FieldUtils.safeNegate(getValue())); [EOL] }
public Weeks negated() { [EOL]     return Weeks.weeks(FieldUtils.safeNegate(getValue())); [EOL] }
public boolean isGreaterThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength(); [EOL] }
public static DateTime now() { [EOL]     return new DateTime(); [EOL] }
public static DateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateTime(zone); [EOL] }
public static DateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateTime(zone); [EOL] }
public DateTime() { [EOL]     super(); [EOL] }
public DateTime(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public DateTime(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] }
public DateTime withZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return this; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     return new DateTime(millis, getChronology().withZone(newZone)); [EOL] }
public DateTime withZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return this; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     return new DateTime(millis, getChronology().withZone(newZone)); [EOL] }
public DateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateTime plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public DateTime plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public DateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateTime minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public DateTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public DateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
@Deprecated [EOL] public DateMidnight toDateMidnight() { [EOL]     return new DateMidnight(getMillis(), getChronology()); [EOL] }
public LocalDate toLocalDate() { [EOL]     return new LocalDate(getMillis(), getChronology()); [EOL] }
public LocalDate toLocalDate() { [EOL]     return new LocalDate(getMillis(), getChronology()); [EOL] }
public DateTime withHourOfDay(int hour) { [EOL]     return withMillis(getChronology().hourOfDay().set(getMillis(), hour)); [EOL] }
public DateTime withHourOfDay(int hour) { [EOL]     return withMillis(getChronology().hourOfDay().set(getMillis(), hour)); [EOL] }
public DateTime withMillisOfSecond(int millis) { [EOL]     return withMillis(getChronology().millisOfSecond().set(getMillis(), millis)); [EOL] }
public Property era() { [EOL]     return new Property(this, getChronology().era()); [EOL] }
public Property weekOfWeekyear() { [EOL]     return new Property(this, getChronology().weekOfWeekyear()); [EOL] }
public Property millisOfDay() { [EOL]     return new Property(this, getChronology().millisOfDay()); [EOL] }
protected Chronology getChronology() { [EOL]     return iInstant.getChronology(); [EOL] }
public DateTime withMinimumValue() { [EOL]     try { [EOL]         return setCopy(getMinimumValue()); [EOL]     } catch (RuntimeException ex) { [EOL]         if (IllegalInstantException.isIllegalInstant(ex)) { [EOL]             long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY); [EOL]             return new DateTime(afterGap, getChronology()); [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public DateTime withMinimumValue() { [EOL]     try { [EOL]         return setCopy(getMinimumValue()); [EOL]     } catch (RuntimeException ex) { [EOL]         if (IllegalInstantException.isIllegalInstant(ex)) { [EOL]             long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY); [EOL]             return new DateTime(afterGap, getChronology()); [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public ZoneInfoProvider(File fileDir) throws IOException { [EOL]     if (fileDir == null) { [EOL]         throw new IllegalArgumentException("No file directory provided"); [EOL]     } [EOL]     if (!fileDir.exists()) { [EOL]         throw new IOException("File directory doesn't exist: " + fileDir); [EOL]     } [EOL]     if (!fileDir.isDirectory()) { [EOL]         throw new IOException("File doesn't refer to a directory: " + fileDir); [EOL]     } [EOL]     iFileDir = fileDir; [EOL]     iResourcePath = null; [EOL]     iLoader = null; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
public ZoneInfoProvider(File fileDir) throws IOException { [EOL]     if (fileDir == null) { [EOL]         throw new IllegalArgumentException("No file directory provided"); [EOL]     } [EOL]     if (!fileDir.exists()) { [EOL]         throw new IOException("File directory doesn't exist: " + fileDir); [EOL]     } [EOL]     if (!fileDir.isDirectory()) { [EOL]         throw new IOException("File doesn't refer to a directory: " + fileDir); [EOL]     } [EOL]     iFileDir = fileDir; [EOL]     iResourcePath = null; [EOL]     iLoader = null; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
public ZoneInfoProvider(File fileDir) throws IOException { [EOL]     if (fileDir == null) { [EOL]         throw new IllegalArgumentException("No file directory provided"); [EOL]     } [EOL]     if (!fileDir.exists()) { [EOL]         throw new IOException("File directory doesn't exist: " + fileDir); [EOL]     } [EOL]     if (!fileDir.isDirectory()) { [EOL]         throw new IOException("File doesn't refer to a directory: " + fileDir); [EOL]     } [EOL]     iFileDir = fileDir; [EOL]     iResourcePath = null; [EOL]     iLoader = null; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
public ZoneInfoProvider(File fileDir) throws IOException { [EOL]     if (fileDir == null) { [EOL]         throw new IllegalArgumentException("No file directory provided"); [EOL]     } [EOL]     if (!fileDir.exists()) { [EOL]         throw new IOException("File directory doesn't exist: " + fileDir); [EOL]     } [EOL]     if (!fileDir.isDirectory()) { [EOL]         throw new IOException("File doesn't refer to a directory: " + fileDir); [EOL]     } [EOL]     iFileDir = fileDir; [EOL]     iResourcePath = null; [EOL]     iLoader = null; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
public ZoneInfoProvider(String resourcePath) throws IOException { [EOL]     this(resourcePath, null, false); [EOL] }
public ZoneInfoProvider(String resourcePath) throws IOException { [EOL]     this(resourcePath, null, false); [EOL] }
private ZoneInfoProvider(String resourcePath, ClassLoader loader, boolean favorSystemLoader) throws IOException { [EOL]     if (resourcePath == null) { [EOL]         throw new IllegalArgumentException("No resource path provided"); [EOL]     } [EOL]     if (!resourcePath.endsWith("/")) { [EOL]         resourcePath += '/'; [EOL]     } [EOL]     iFileDir = null; [EOL]     iResourcePath = resourcePath; [EOL]     if (loader == null && !favorSystemLoader) { [EOL]         loader = getClass().getClassLoader(); [EOL]     } [EOL]     iLoader = loader; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
private ZoneInfoProvider(String resourcePath, ClassLoader loader, boolean favorSystemLoader) throws IOException { [EOL]     if (resourcePath == null) { [EOL]         throw new IllegalArgumentException("No resource path provided"); [EOL]     } [EOL]     if (!resourcePath.endsWith("/")) { [EOL]         resourcePath += '/'; [EOL]     } [EOL]     iFileDir = null; [EOL]     iResourcePath = resourcePath; [EOL]     if (loader == null && !favorSystemLoader) { [EOL]         loader = getClass().getClassLoader(); [EOL]     } [EOL]     iLoader = loader; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
private ZoneInfoProvider(String resourcePath, ClassLoader loader, boolean favorSystemLoader) throws IOException { [EOL]     if (resourcePath == null) { [EOL]         throw new IllegalArgumentException("No resource path provided"); [EOL]     } [EOL]     if (!resourcePath.endsWith("/")) { [EOL]         resourcePath += '/'; [EOL]     } [EOL]     iFileDir = null; [EOL]     iResourcePath = resourcePath; [EOL]     if (loader == null && !favorSystemLoader) { [EOL]         loader = getClass().getClassLoader(); [EOL]     } [EOL]     iLoader = loader; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
private ZoneInfoProvider(String resourcePath, ClassLoader loader, boolean favorSystemLoader) throws IOException { [EOL]     if (resourcePath == null) { [EOL]         throw new IllegalArgumentException("No resource path provided"); [EOL]     } [EOL]     if (!resourcePath.endsWith("/")) { [EOL]         resourcePath += '/'; [EOL]     } [EOL]     iFileDir = null; [EOL]     iResourcePath = resourcePath; [EOL]     if (loader == null && !favorSystemLoader) { [EOL]         loader = getClass().getClassLoader(); [EOL]     } [EOL]     iLoader = loader; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
private ZoneInfoProvider(String resourcePath, ClassLoader loader, boolean favorSystemLoader) throws IOException { [EOL]     if (resourcePath == null) { [EOL]         throw new IllegalArgumentException("No resource path provided"); [EOL]     } [EOL]     if (!resourcePath.endsWith("/")) { [EOL]         resourcePath += '/'; [EOL]     } [EOL]     iFileDir = null; [EOL]     iResourcePath = resourcePath; [EOL]     if (loader == null && !favorSystemLoader) { [EOL]         loader = getClass().getClassLoader(); [EOL]     } [EOL]     iLoader = loader; [EOL]     iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap")); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public Set<String> getAvailableIDs() { [EOL]     return new TreeSet<String>(iZoneInfoMap.keySet()); [EOL] }
public Set<String> getAvailableIDs() { [EOL]     return new TreeSet<String>(iZoneInfoMap.keySet()); [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException { [EOL]     Map<String, Object> map = new ConcurrentHashMap<String, Object>(); [EOL]     DataInputStream din = new DataInputStream(in); [EOL]     try { [EOL]         readZoneInfoMap(din, map); [EOL]     } finally { [EOL]         try { [EOL]             din.close(); [EOL]         } catch (IOException ex) { [EOL]         } [EOL]     } [EOL]     map.put("UTC", new SoftReference<DateTimeZone>(DateTimeZone.UTC)); [EOL]     return map; [EOL] }
private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException { [EOL]     int size = din.readUnsignedShort(); [EOL]     String[] pool = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         pool[i] = din.readUTF().intern(); [EOL]     } [EOL]     size = din.readUnsignedShort(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         try { [EOL]             zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             throw new IOException("Corrupt zone info map"); [EOL]         } [EOL]     } [EOL] }
private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException { [EOL]     int size = din.readUnsignedShort(); [EOL]     String[] pool = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         pool[i] = din.readUTF().intern(); [EOL]     } [EOL]     size = din.readUnsignedShort(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         try { [EOL]             zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             throw new IOException("Corrupt zone info map"); [EOL]         } [EOL]     } [EOL] }
public PeriodFormatter(PeriodPrinter printer, PeriodParser parser) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = null; [EOL]     iParseType = null; [EOL] }
public PeriodFormatter(PeriodPrinter printer, PeriodParser parser) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = null; [EOL]     iParseType = null; [EOL] }
public PeriodPrinter getPrinter() { [EOL]     return iPrinter; [EOL] }
public PeriodFormatter withParseType(PeriodType type) { [EOL]     if (type == iParseType) { [EOL]         return this; [EOL]     } [EOL]     return new PeriodFormatter(iPrinter, iParser, iLocale, type); [EOL] }
public PeriodFormatter withParseType(PeriodType type) { [EOL]     if (type == iParseType) { [EOL]         return this; [EOL]     } [EOL]     return new PeriodFormatter(iPrinter, iParser, iLocale, type); [EOL] }
public PeriodType getParseType() { [EOL]     return iParseType; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period) { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     getPrinter().printTo(buf, period, iLocale); [EOL] }
public String print(ReadablePeriod period) { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     PeriodPrinter printer = getPrinter(); [EOL]     StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale)); [EOL]     printer.printTo(buf, period, iLocale); [EOL]     return buf.toString(); [EOL] }
public String print(ReadablePeriod period) { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     PeriodPrinter printer = getPrinter(); [EOL]     StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale)); [EOL]     printer.printTo(buf, period, iLocale); [EOL]     return buf.toString(); [EOL] }
public String print(ReadablePeriod period) { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     PeriodPrinter printer = getPrinter(); [EOL]     StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale)); [EOL]     printer.printTo(buf, period, iLocale); [EOL]     return buf.toString(); [EOL] }
private void checkPrinter() { [EOL]     if (iPrinter == null) { [EOL]         throw new UnsupportedOperationException("Printing not supported"); [EOL]     } [EOL] }
private void checkPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         throw new IllegalArgumentException("Period must not be null"); [EOL]     } [EOL] }
private void checkPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         throw new IllegalArgumentException("Period must not be null"); [EOL]     } [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new Partial(this, newValues); [EOL] }
public Partial plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public Partial plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public Partial minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public Partial minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public boolean isMatch(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         int value = partial.get(iTypes[i]); [EOL]         if (value != iValues[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean isMatch(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         int value = partial.get(iTypes[i]); [EOL]         if (value != iValues[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean isMatch(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         int value = partial.get(iTypes[i]); [EOL]         if (value != iValues[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toStringList() { [EOL]     int size = size(); [EOL]     StringBuilder buf = new StringBuilder(20 * size); [EOL]     buf.append('['); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (i > 0) { [EOL]             buf.append(',').append(' '); [EOL]         } [EOL]         buf.append(iTypes[i].getName()); [EOL]         buf.append('='); [EOL]         buf.append(iValues[i]); [EOL]     } [EOL]     buf.append(']'); [EOL]     return buf.toString(); [EOL] }
public String toStringList() { [EOL]     int size = size(); [EOL]     StringBuilder buf = new StringBuilder(20 * size); [EOL]     buf.append('['); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (i > 0) { [EOL]             buf.append(',').append(' '); [EOL]         } [EOL]         buf.append(iTypes[i].getName()); [EOL]         buf.append('='); [EOL]         buf.append(iValues[i]); [EOL]     } [EOL]     buf.append(']'); [EOL]     return buf.toString(); [EOL] }
public String toStringList() { [EOL]     int size = size(); [EOL]     StringBuilder buf = new StringBuilder(20 * size); [EOL]     buf.append('['); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (i > 0) { [EOL]             buf.append(',').append(' '); [EOL]         } [EOL]         buf.append(iTypes[i].getName()); [EOL]         buf.append('='); [EOL]         buf.append(iValues[i]); [EOL]     } [EOL]     buf.append(']'); [EOL]     return buf.toString(); [EOL] }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] }
public String toString(String pattern, Locale locale) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public String toString(String pattern, Locale locale) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public Partial addToCopy(int valueToAdd) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial addToCopy(int valueToAdd) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] }
protected BaseDuration(long startInstant, long endInstant) { [EOL]     super(); [EOL]     iMillis = FieldUtils.safeAdd(endInstant, -startInstant); [EOL] }
protected BaseDuration(long startInstant, long endInstant) { [EOL]     super(); [EOL]     iMillis = FieldUtils.safeAdd(endInstant, -startInstant); [EOL] }
protected BaseDuration(long startInstant, long endInstant) { [EOL]     super(); [EOL]     iMillis = FieldUtils.safeAdd(endInstant, -startInstant); [EOL] }
public Period toPeriodFrom(ReadableInstant startInstant) { [EOL]     return new Period(startInstant, this); [EOL] }
public Period toPeriodFrom(ReadableInstant startInstant) { [EOL]     return new Period(startInstant, this); [EOL] }
public static Years yearsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years()); [EOL]     return Years.years(amount); [EOL] }
public static Years yearsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years()); [EOL]     return Years.years(amount); [EOL] }
private Object readResolve() { [EOL]     return Years.years(getValue()); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.years(); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.years(); [EOL] }
public Years plus(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(FieldUtils.safeAdd(getValue(), years)); [EOL] }
public Years plus(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(FieldUtils.safeAdd(getValue(), years)); [EOL] }
public Years plus(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(FieldUtils.safeAdd(getValue(), years)); [EOL] }
public Years plus(Years years) { [EOL]     if (years == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(years.getValue()); [EOL] }
public Years plus(Years years) { [EOL]     if (years == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(years.getValue()); [EOL] }
public Instant withMillis(long newMillis) { [EOL]     return (newMillis == iMillis ? this : new Instant(newMillis)); [EOL] }
public Instant withMillis(long newMillis) { [EOL]     return (newMillis == iMillis ? this : new Instant(newMillis)); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Instant plus(long duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public Instant minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Instant minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Instant minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Instant minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
@Deprecated [EOL] public DateTime toDateTimeISO() { [EOL]     return toDateTime(); [EOL] }
public static LocalDate now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalDate(zone); [EOL] }
public static LocalDate now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalDate(zone); [EOL] }
public static LocalDate now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new LocalDate(chronology); [EOL] }
public LocalDate() { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); [EOL] }
public LocalDate(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalDate(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalDate(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public LocalDate(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public LocalDate(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalDate(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalDate(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public int size() { [EOL]     return 3; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public int hashCode() { [EOL]     int hash = iHash; [EOL]     if (hash == 0) { [EOL]         hash = iHash = super.hashCode(); [EOL]     } [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = iHash; [EOL]     if (hash == 0) { [EOL]         hash = iHash = super.hashCode(); [EOL]     } [EOL]     return hash; [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public LocalDate minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public LocalDate minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public Property year() { [EOL]     return new Property(this, getChronology().year()); [EOL] }
public Property monthOfYear() { [EOL]     return new Property(this, getChronology().monthOfYear()); [EOL] }
public DateTimeField getField() { [EOL]     return iField; [EOL] }
protected long getMillis() { [EOL]     return iInstant.getLocalMillis(); [EOL] }
public LocalDate addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDate setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDate setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDate withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] }
public LocalDate withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1963; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1963; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1963; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] }
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] }
public int get(long instant) { [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         return DateTimeConstants.BCE; [EOL]     } else { [EOL]         return DateTimeConstants.CE; [EOL]     } [EOL] }
public int get(long instant) { [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         return DateTimeConstants.BCE; [EOL]     } else { [EOL]         return DateTimeConstants.CE; [EOL]     } [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue); [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (get(instant) == DateTimeConstants.CE) { [EOL]         return iChronology.setYear(0, 1); [EOL]     } else { [EOL]         return Long.MIN_VALUE; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (get(instant) == DateTimeConstants.CE) { [EOL]         return iChronology.setYear(0, 1); [EOL]     } else { [EOL]         return Long.MIN_VALUE; [EOL]     } [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength(); [EOL] }
public static PeriodType yearWeekDayTime() { [EOL]     PeriodType type = cYWDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 }); [EOL]         cYWDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearWeekDayTime() { [EOL]     PeriodType type = cYWDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 }); [EOL]         cYWDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType dayTime() { [EOL]     PeriodType type = cDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("DayTime", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 }); [EOL]         cDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType dayTime() { [EOL]     PeriodType type = cDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("DayTime", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 }); [EOL]         cDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType weeks() { [EOL]     PeriodType type = cWeeks; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Weeks", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 }); [EOL]         cWeeks = type; [EOL]     } [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException { [EOL]     checkPermission(); [EOL]     cMillisProvider = new FixedMillisProvider(fixedMillis); [EOL] }
public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException { [EOL]     checkPermission(); [EOL]     cMillisProvider = new FixedMillisProvider(fixedMillis); [EOL] }
public static final long getInstantMillis(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return DateTimeUtils.currentTimeMillis(); [EOL]     } [EOL]     return instant.getMillis(); [EOL] }
public static final long getInstantMillis(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return DateTimeUtils.currentTimeMillis(); [EOL]     } [EOL]     return instant.getMillis(); [EOL] }
FixedMillisProvider(long fixedMillis) { [EOL]     iMillis = fixedMillis; [EOL] }
FixedMillisProvider(long fixedMillis) { [EOL]     iMillis = fixedMillis; [EOL] }
FixedMillisProvider(long fixedMillis) { [EOL]     iMillis = fixedMillis; [EOL] }
public long getMillis() { [EOL]     return iMillis; [EOL] }
protected NullConverter() { [EOL]     super(); [EOL] }
public long getDurationMillis(Object object) { [EOL]     return 0L; [EOL] }
public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) { [EOL]     duration.setPeriod((Period) null); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     iChronology = chrono; [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     if (period == null) { [EOL]         iEndMillis = iStartMillis; [EOL]     } else { [EOL]         iEndMillis = chrono.add(period, iStartMillis, 1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     iChronology = chrono; [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     if (period == null) { [EOL]         iEndMillis = iStartMillis; [EOL]     } else { [EOL]         iEndMillis = chrono.add(period, iStartMillis, 1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL]     super(); [EOL]     IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL]     if (converter.isReadableInterval(interval, chrono)) { [EOL]         ReadableInterval input = (ReadableInterval) interval; [EOL]         iChronology = (chrono != null ? chrono : input.getChronology()); [EOL]         iStartMillis = input.getStartMillis(); [EOL]         iEndMillis = input.getEndMillis(); [EOL]     } else if (this instanceof ReadWritableInterval) { [EOL]         converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL]     } else { [EOL]         MutableInterval mi = new MutableInterval(); [EOL]         converter.setInto(mi, interval, chrono); [EOL]         iChronology = mi.getChronology(); [EOL]         iStartMillis = mi.getStartMillis(); [EOL]         iEndMillis = mi.getEndMillis(); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL]     super(); [EOL]     IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL]     if (converter.isReadableInterval(interval, chrono)) { [EOL]         ReadableInterval input = (ReadableInterval) interval; [EOL]         iChronology = (chrono != null ? chrono : input.getChronology()); [EOL]         iStartMillis = input.getStartMillis(); [EOL]         iEndMillis = input.getEndMillis(); [EOL]     } else if (this instanceof ReadWritableInterval) { [EOL]         converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL]     } else { [EOL]         MutableInterval mi = new MutableInterval(); [EOL]         converter.setInto(mi, interval, chrono); [EOL]         iChronology = mi.getChronology(); [EOL]         iStartMillis = mi.getStartMillis(); [EOL]         iEndMillis = mi.getEndMillis(); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL]     super(); [EOL]     IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL]     if (converter.isReadableInterval(interval, chrono)) { [EOL]         ReadableInterval input = (ReadableInterval) interval; [EOL]         iChronology = (chrono != null ? chrono : input.getChronology()); [EOL]         iStartMillis = input.getStartMillis(); [EOL]         iEndMillis = input.getEndMillis(); [EOL]     } else if (this instanceof ReadWritableInterval) { [EOL]         converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL]     } else { [EOL]         MutableInterval mi = new MutableInterval(); [EOL]         converter.setInto(mi, interval, chrono); [EOL]         iChronology = mi.getChronology(); [EOL]         iStartMillis = mi.getStartMillis(); [EOL]         iEndMillis = mi.getEndMillis(); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL]     super(); [EOL]     IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL]     if (converter.isReadableInterval(interval, chrono)) { [EOL]         ReadableInterval input = (ReadableInterval) interval; [EOL]         iChronology = (chrono != null ? chrono : input.getChronology()); [EOL]         iStartMillis = input.getStartMillis(); [EOL]         iEndMillis = input.getEndMillis(); [EOL]     } else if (this instanceof ReadWritableInterval) { [EOL]         converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL]     } else { [EOL]         MutableInterval mi = new MutableInterval(); [EOL]         converter.setInto(mi, interval, chrono); [EOL]         iChronology = mi.getChronology(); [EOL]         iStartMillis = mi.getStartMillis(); [EOL]         iEndMillis = mi.getEndMillis(); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
public static DateTimeZone getDefault() { [EOL]     DateTimeZone zone = cDefault; [EOL]     if (zone == null) { [EOL]         synchronized (DateTimeZone.class) { [EOL]             zone = cDefault; [EOL]             if (zone == null) { [EOL]                 DateTimeZone temp = null; [EOL]                 try { [EOL]                     try { [EOL]                         String id = System.getProperty("user.timezone"); [EOL]                         if (id != null) { [EOL]                             temp = forID(id); [EOL]                         } [EOL]                     } catch (RuntimeException ex) { [EOL]                     } [EOL]                     if (temp == null) { [EOL]                         temp = forTimeZone(TimeZone.getDefault()); [EOL]                     } [EOL]                 } catch (IllegalArgumentException ex) { [EOL]                 } [EOL]                 if (temp == null) { [EOL]                     temp = UTC; [EOL]                 } [EOL]                 cDefault = zone = temp; [EOL]             } [EOL]         } [EOL]     } [EOL]     return zone; [EOL] }
public static DateTimeZone getDefault() { [EOL]     DateTimeZone zone = cDefault; [EOL]     if (zone == null) { [EOL]         synchronized (DateTimeZone.class) { [EOL]             zone = cDefault; [EOL]             if (zone == null) { [EOL]                 DateTimeZone temp = null; [EOL]                 try { [EOL]                     try { [EOL]                         String id = System.getProperty("user.timezone"); [EOL]                         if (id != null) { [EOL]                             temp = forID(id); [EOL]                         } [EOL]                     } catch (RuntimeException ex) { [EOL]                     } [EOL]                     if (temp == null) { [EOL]                         temp = forTimeZone(TimeZone.getDefault()); [EOL]                     } [EOL]                 } catch (IllegalArgumentException ex) { [EOL]                 } [EOL]                 if (temp == null) { [EOL]                     temp = UTC; [EOL]                 } [EOL]                 cDefault = zone = temp; [EOL]             } [EOL]         } [EOL]     } [EOL]     return zone; [EOL] }
public static DateTimeZone getDefault() { [EOL]     DateTimeZone zone = cDefault; [EOL]     if (zone == null) { [EOL]         synchronized (DateTimeZone.class) { [EOL]             zone = cDefault; [EOL]             if (zone == null) { [EOL]                 DateTimeZone temp = null; [EOL]                 try { [EOL]                     try { [EOL]                         String id = System.getProperty("user.timezone"); [EOL]                         if (id != null) { [EOL]                             temp = forID(id); [EOL]                         } [EOL]                     } catch (RuntimeException ex) { [EOL]                     } [EOL]                     if (temp == null) { [EOL]                         temp = forTimeZone(TimeZone.getDefault()); [EOL]                     } [EOL]                 } catch (IllegalArgumentException ex) { [EOL]                 } [EOL]                 if (temp == null) { [EOL]                     temp = UTC; [EOL]                 } [EOL]                 cDefault = zone = temp; [EOL]             } [EOL]         } [EOL]     } [EOL]     return zone; [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static Set<String> getAvailableIDs() { [EOL]     return cAvailableIDs; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
protected DateTimeZone(String id) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException("Id must not be null"); [EOL]     } [EOL]     iID = id; [EOL] }
protected DateTimeZone(String id) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException("Id must not be null"); [EOL]     } [EOL]     iID = id; [EOL] }
@ToString [EOL] public final String getID() { [EOL]     return iID; [EOL] }
public boolean isStandardOffset(long instant) { [EOL]     return getOffset(instant) == getStandardOffset(instant); [EOL] }
public boolean isStandardOffset(long instant) { [EOL]     return getOffset(instant) == getStandardOffset(instant); [EOL] }
public long convertUTCToLocal(long instantUTC) { [EOL]     int offset = getOffset(instantUTC); [EOL]     long instantLocal = instantUTC + offset; [EOL]     if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { [EOL]         throw new ArithmeticException("Adding time zone offset caused overflow"); [EOL]     } [EOL]     return instantLocal; [EOL] }
public long convertUTCToLocal(long instantUTC) { [EOL]     int offset = getOffset(instantUTC); [EOL]     long instantLocal = instantUTC + offset; [EOL]     if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { [EOL]         throw new ArithmeticException("Adding time zone offset caused overflow"); [EOL]     } [EOL]     return instantLocal; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { [EOL]     int offsetOriginal = getOffset(originalInstantUTC); [EOL]     long instantUTC = instantLocal - offsetOriginal; [EOL]     int offsetLocalFromOriginal = getOffset(instantUTC); [EOL]     if (offsetLocalFromOriginal == offsetOriginal) { [EOL]         return instantUTC; [EOL]     } [EOL]     return convertLocalToUTC(instantLocal, strict); [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { [EOL]     int offsetOriginal = getOffset(originalInstantUTC); [EOL]     long instantUTC = instantLocal - offsetOriginal; [EOL]     int offsetLocalFromOriginal = getOffset(instantUTC); [EOL]     if (offsetLocalFromOriginal == offsetOriginal) { [EOL]         return instantUTC; [EOL]     } [EOL]     return convertLocalToUTC(instantLocal, strict); [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
public java.util.TimeZone toTimeZone() { [EOL]     return java.util.TimeZone.getTimeZone(iID); [EOL] }
public java.util.TimeZone toTimeZone() { [EOL]     return java.util.TimeZone.getTimeZone(iID); [EOL] }
public java.util.TimeZone toTimeZone() { [EOL]     return java.util.TimeZone.getTimeZone(iID); [EOL] }
public int hashCode() { [EOL]     return 57 + getID().hashCode(); [EOL] }
BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param); [EOL]     if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) { [EOL]         throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]     } [EOL]     iMinDaysInFirstWeek = minDaysInFirstWeek; [EOL] }
BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param); [EOL]     if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) { [EOL]         throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]     } [EOL]     iMinDaysInFirstWeek = minDaysInFirstWeek; [EOL] }
BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param); [EOL]     if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) { [EOL]         throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]     } [EOL]     iMinDaysInFirstWeek = minDaysInFirstWeek; [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return DateTimeZone.UTC; [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return DateTimeZone.UTC; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
long getYearMillis(int year) { [EOL]     return getYearInfo(year).iFirstDayMillis; [EOL] }
long getYearMonthDayMillis(int year, int month, int dayOfMonth) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getYearMonthDayMillis(int year, int month, int dayOfMonth) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getYearMonthDayMillis(int year, int month, int dayOfMonth) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getYearMonthDayMillis(int year, int month, int dayOfMonth) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getYearMonthDayMillis(int year, int month, int dayOfMonth) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getMonthOfYear(long millis) { [EOL]     return getMonthOfYear(millis, getYear(millis)); [EOL] }
int getDayOfMonth(long millis) { [EOL]     int year = getYear(millis); [EOL]     int month = getMonthOfYear(millis, year); [EOL]     return getDayOfMonth(millis, year, month); [EOL] }
int getDayOfMonth(long millis) { [EOL]     int year = getYear(millis); [EOL]     int month = getMonthOfYear(millis, year); [EOL]     return getDayOfMonth(millis, year, month); [EOL] }
int getDayOfMonth(long millis) { [EOL]     int year = getYear(millis); [EOL]     int month = getMonthOfYear(millis, year); [EOL]     return getDayOfMonth(millis, year, month); [EOL] }
int getDayOfMonth(long millis, int year, int month) { [EOL]     long dateMillis = getYearMillis(year); [EOL]     dateMillis += getTotalMillisByYearMonth(year, month); [EOL]     return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfMonth(long millis, int year, int month) { [EOL]     long dateMillis = getYearMillis(year); [EOL]     dateMillis += getTotalMillisByYearMonth(year, month); [EOL]     return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfMonth(long millis, int year, int month) { [EOL]     long dateMillis = getYearMillis(year); [EOL]     dateMillis += getTotalMillisByYearMonth(year, month); [EOL]     return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfMonth(long millis, int year, int month) { [EOL]     long dateMillis = getYearMillis(year); [EOL]     dateMillis += getTotalMillisByYearMonth(year, month); [EOL]     return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getMillisOfDay(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } else { [EOL]         return (DateTimeConstants.MILLIS_PER_DAY - 1) + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) { [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear()); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year)); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear)); [EOL]     return getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] }
int getMaxMonth(int year) { [EOL]     return getMaxMonth(); [EOL] }
int getMaxMonth() { [EOL]     return 12; [EOL] }
private YearInfo getYearInfo(int year) { [EOL]     YearInfo info = iYearInfoCache[year & CACHE_MASK]; [EOL]     if (info == null || info.iYear != year) { [EOL]         info = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL]         iYearInfoCache[year & CACHE_MASK] = info; [EOL]     } [EOL]     return info; [EOL] }
private YearInfo getYearInfo(int year) { [EOL]     YearInfo info = iYearInfoCache[year & CACHE_MASK]; [EOL]     if (info == null || info.iYear != year) { [EOL]         info = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL]         iYearInfoCache[year & CACHE_MASK] = info; [EOL]     } [EOL]     return info; [EOL] }
private YearInfo getYearInfo(int year) { [EOL]     YearInfo info = iYearInfoCache[year & CACHE_MASK]; [EOL]     if (info == null || info.iYear != year) { [EOL]         info = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL]         iYearInfoCache[year & CACHE_MASK] = info; [EOL]     } [EOL]     return info; [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength(); [EOL] }
protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     iType = type; [EOL]     iValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startInstant, endInstant); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     if (startInstant == null && endInstant == null) { [EOL]         iType = type; [EOL]         iValues = new int[size()]; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]     long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]     long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]     long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]     long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public Duration toDurationTo(ReadableInstant endInstant) { [EOL]     long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL]     long startMillis = chrono.add(this, endMillis, -1); [EOL]     return new Duration(startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         if (newValue != 0) { [EOL]             throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL]         } [EOL]     } else { [EOL]         values[index] = newValue; [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     int[] newValues = new int[size()]; [EOL]     checkAndUpdate(DurationFieldType.years(), newValues, years); [EOL]     checkAndUpdate(DurationFieldType.months(), newValues, months); [EOL]     checkAndUpdate(DurationFieldType.weeks(), newValues, weeks); [EOL]     checkAndUpdate(DurationFieldType.days(), newValues, days); [EOL]     checkAndUpdate(DurationFieldType.hours(), newValues, hours); [EOL]     checkAndUpdate(DurationFieldType.minutes(), newValues, minutes); [EOL]     checkAndUpdate(DurationFieldType.seconds(), newValues, seconds); [EOL]     checkAndUpdate(DurationFieldType.millis(), newValues, millis); [EOL]     return newValues; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     int[] newValues = new int[size()]; [EOL]     checkAndUpdate(DurationFieldType.years(), newValues, years); [EOL]     checkAndUpdate(DurationFieldType.months(), newValues, months); [EOL]     checkAndUpdate(DurationFieldType.weeks(), newValues, weeks); [EOL]     checkAndUpdate(DurationFieldType.days(), newValues, days); [EOL]     checkAndUpdate(DurationFieldType.hours(), newValues, hours); [EOL]     checkAndUpdate(DurationFieldType.minutes(), newValues, minutes); [EOL]     checkAndUpdate(DurationFieldType.seconds(), newValues, seconds); [EOL]     checkAndUpdate(DurationFieldType.millis(), newValues, millis); [EOL]     return newValues; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     int[] newValues = new int[size()]; [EOL]     checkAndUpdate(DurationFieldType.years(), newValues, years); [EOL]     checkAndUpdate(DurationFieldType.months(), newValues, months); [EOL]     checkAndUpdate(DurationFieldType.weeks(), newValues, weeks); [EOL]     checkAndUpdate(DurationFieldType.days(), newValues, days); [EOL]     checkAndUpdate(DurationFieldType.hours(), newValues, hours); [EOL]     checkAndUpdate(DurationFieldType.minutes(), newValues, minutes); [EOL]     checkAndUpdate(DurationFieldType.seconds(), newValues, seconds); [EOL]     checkAndUpdate(DurationFieldType.millis(), newValues, millis); [EOL]     return newValues; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setField(DurationFieldType field, int value) { [EOL]     setFieldInto(iValues, field, value); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setFieldInto(int[] values, DurationFieldType field, int value) { [EOL]     int index = indexOf(field); [EOL]     if (index == -1) { [EOL]         if (value != 0 || field == null) { [EOL]             throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL]         } [EOL]     } else { [EOL]         values[index] = value; [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) { [EOL]     if (extended) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL] }
private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) { [EOL]     if (extended) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL] }
public static DateTimeFormatter dateParser() { [EOL]     return Constants.dp; [EOL] }
public static DateTimeFormatter localTimeParser() { [EOL]     return Constants.ltp; [EOL] }
public static DateTimeFormatter timeElementParser() { [EOL]     return Constants.tpe; [EOL] }
public static DateTimeFormatter dateOptionalTimeParser() { [EOL]     return Constants.dotp; [EOL] }
public static DateTimeFormatter tTime() { [EOL]     return Constants.tt; [EOL] }
public static DateTimeFormatter ordinalDate() { [EOL]     return Constants.od; [EOL] }
public static DateTimeFormatter basicTimeNoMillis() { [EOL]     return Constants.btx; [EOL] }
public static DateTimeFormatter basicDateTimeNoMillis() { [EOL]     return Constants.bdtx; [EOL] }
public static DateTimeFormatter basicOrdinalDate() { [EOL]     return Constants.bod; [EOL] }
public static DateTimeFormatter basicWeekDateTimeNoMillis() { [EOL]     return Constants.bwdtx; [EOL] }
public static DateTimeFormatter year() { [EOL]     return Constants.ye; [EOL] }
public static DateTimeFormatter yearMonth() { [EOL]     return Constants.ym; [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutesBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.minutes()); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes minutesBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.minutes()); [EOL]     return Minutes.minutes(amount); [EOL] }
private Minutes(int minutes) { [EOL]     super(minutes); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE)); [EOL] }
public boolean isLessThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public static void main(String[] args) throws Exception { [EOL]     if (args.length == 0) { [EOL]         printUsage(); [EOL]         return; [EOL]     } [EOL]     File inputDir = null; [EOL]     File outputDir = null; [EOL]     boolean verbose = false; [EOL]     int i; [EOL]     for (i = 0; i < args.length; i++) { [EOL]         try { [EOL]             if ("-src".equals(args[i])) { [EOL]                 inputDir = new File(args[++i]); [EOL]             } else if ("-dst".equals(args[i])) { [EOL]                 outputDir = new File(args[++i]); [EOL]             } else if ("-verbose".equals(args[i])) { [EOL]                 verbose = true; [EOL]             } else if ("-?".equals(args[i])) { [EOL]                 printUsage(); [EOL]                 return; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } catch (IndexOutOfBoundsException e) { [EOL]             printUsage(); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (i >= args.length) { [EOL]         printUsage(); [EOL]         return; [EOL]     } [EOL]     File[] sources = new File[args.length - i]; [EOL]     for (int j = 0; i < args.length; i++, j++) { [EOL]         sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]); [EOL]     } [EOL]     cVerbose.set(verbose); [EOL]     ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL]     zic.compile(outputDir, sources); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static DateTimeOfYear getStartOfYear() { [EOL]     if (cStartOfYear == null) { [EOL]         cStartOfYear = new DateTimeOfYear(); [EOL]     } [EOL]     return cStartOfYear; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static Chronology getLenientISOChronology() { [EOL]     if (cLenientISO == null) { [EOL]         cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     return cLenientISO; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException { [EOL]     Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size()); [EOL]     TreeMap<Short, String> indexToId = new TreeMap<Short, String>(); [EOL]     short count = 0; [EOL]     for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL]         String id = (String) entry.getKey(); [EOL]         if (!idToIndex.containsKey(id)) { [EOL]             Short index = Short.valueOf(count); [EOL]             idToIndex.put(id, index); [EOL]             indexToId.put(index, id); [EOL]             if (++count == 0) { [EOL]                 throw new InternalError("Too many time zone ids"); [EOL]             } [EOL]         } [EOL]         id = ((DateTimeZone) entry.getValue()).getID(); [EOL]         if (!idToIndex.containsKey(id)) { [EOL]             Short index = Short.valueOf(count); [EOL]             idToIndex.put(id, index); [EOL]             indexToId.put(index, id); [EOL]             if (++count == 0) { [EOL]                 throw new InternalError("Too many time zone ids"); [EOL]             } [EOL]         } [EOL]     } [EOL]     dout.writeShort(indexToId.size()); [EOL]     for (String id : indexToId.values()) { [EOL]         dout.writeUTF(id); [EOL]     } [EOL]     dout.writeShort(zimap.size()); [EOL]     for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL]         String id = entry.getKey(); [EOL]         dout.writeShort(idToIndex.get(id).shortValue()); [EOL]         id = entry.getValue().getID(); [EOL]         dout.writeShort(idToIndex.get(id).shortValue()); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static int parseYear(String str, int def) { [EOL]     str = str.toLowerCase(); [EOL]     if (str.equals("minimum") || str.equals("min")) { [EOL]         return Integer.MIN_VALUE; [EOL]     } else if (str.equals("maximum") || str.equals("max")) { [EOL]         return Integer.MAX_VALUE; [EOL]     } else if (str.equals("only")) { [EOL]         return def; [EOL]     } [EOL]     return Integer.parseInt(str); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static String parseOptional(String str) { [EOL]     return (str.equals("-")) ? null : str; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static int parseTime(String str) { [EOL]     DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction(); [EOL]     MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology()); [EOL]     int pos = 0; [EOL]     if (str.startsWith("-")) { [EOL]         pos = 1; [EOL]     } [EOL]     int newPos = p.parseInto(mdt, str, pos); [EOL]     if (newPos == ~pos) { [EOL]         throw new IllegalArgumentException(str); [EOL]     } [EOL]     int millis = (int) mdt.getMillis(); [EOL]     if (pos == 1) { [EOL]         millis = -millis; [EOL]     } [EOL]     return millis; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static char parseZoneChar(char c) { [EOL]     switch(c) { [EOL]         case 's': [EOL]         case 'S': [EOL]             return 's'; [EOL]         case 'u': [EOL]         case 'U': [EOL]         case 'g': [EOL]         case 'G': [EOL]         case 'z': [EOL]         case 'Z': [EOL]             return 'u'; [EOL]         case 'w': [EOL]         case 'W': [EOL]         default: [EOL]             return 'w'; [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public ZoneInfoCompiler() { [EOL]     iRuleSets = new HashMap<String, RuleSet>(); [EOL]     iZones = new ArrayList<Zone>(); [EOL]     iLinks = new ArrayList<String>(); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
DateTimeOfYear() { [EOL]     iMonthOfYear = 1; [EOL]     iDayOfMonth = 1; [EOL]     iDayOfWeek = 0; [EOL]     iAdvanceDayOfWeek = false; [EOL]     iMillisOfDay = 0; [EOL]     iZoneChar = 'w'; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
DateTimeOfYear(StringTokenizer st) { [EOL]     int month = 1; [EOL]     int day = 1; [EOL]     int dayOfWeek = 0; [EOL]     int millis = 0; [EOL]     boolean advance = false; [EOL]     char zoneChar = 'w'; [EOL]     if (st.hasMoreTokens()) { [EOL]         month = parseMonth(st.nextToken()); [EOL]         if (st.hasMoreTokens()) { [EOL]             String str = st.nextToken(); [EOL]             if (str.startsWith("last")) { [EOL]                 day = -1; [EOL]                 dayOfWeek = parseDayOfWeek(str.substring(4)); [EOL]                 advance = false; [EOL]             } else { [EOL]                 try { [EOL]                     day = Integer.parseInt(str); [EOL]                     dayOfWeek = 0; [EOL]                     advance = false; [EOL]                 } catch (NumberFormatException e) { [EOL]                     int index = str.indexOf(">="); [EOL]                     if (index > 0) { [EOL]                         day = Integer.parseInt(str.substring(index + 2)); [EOL]                         dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                         advance = true; [EOL]                     } else { [EOL]                         index = str.indexOf("<="); [EOL]                         if (index > 0) { [EOL]                             day = Integer.parseInt(str.substring(index + 2)); [EOL]                             dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                             advance = false; [EOL]                         } else { [EOL]                             throw new IllegalArgumentException(str); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (st.hasMoreTokens()) { [EOL]                 str = st.nextToken(); [EOL]                 zoneChar = parseZoneChar(str.charAt(str.length() - 1)); [EOL]                 if (str.equals("24:00")) { [EOL]                     LocalDate date = (day == -1 ? new LocalDate(2001, month, 1).plusMonths(1) : new LocalDate(2001, month, day).plusDays(1)); [EOL]                     advance = (day != -1); [EOL]                     month = date.getMonthOfYear(); [EOL]                     day = date.getDayOfMonth(); [EOL]                     dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1; [EOL]                 } else { [EOL]                     millis = parseTime(str); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     iMonthOfYear = month; [EOL]     iDayOfMonth = day; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvanceDayOfWeek = advance; [EOL]     iMillisOfDay = millis; [EOL]     iZoneChar = zoneChar; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear) { [EOL]     builder.addRecurringSavings(nameKey, saveMillis, fromYear, toYear, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void addCutover(DateTimeZoneBuilder builder, int year) { [EOL]     builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
Rule(StringTokenizer st) { [EOL]     iName = st.nextToken().intern(); [EOL]     iFromYear = parseYear(st.nextToken(), 0); [EOL]     iToYear = parseYear(st.nextToken(), iFromYear); [EOL]     if (iToYear < iFromYear) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = parseOptional(st.nextToken()); [EOL]     iDateTimeOfYear = new DateTimeOfYear(st); [EOL]     iSaveMillis = parseTime(st.nextToken()); [EOL]     iLetterS = parseOptional(st.nextToken()); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL]     String nameKey = formatName(nameFormat); [EOL]     iDateTimeOfYear.addRecurring(builder, nameKey, iSaveMillis, iFromYear, iToYear); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
private String formatName(String nameFormat) { [EOL]     int index = nameFormat.indexOf('/'); [EOL]     if (index > 0) { [EOL]         if (iSaveMillis == 0) { [EOL]             return nameFormat.substring(0, index).intern(); [EOL]         } else { [EOL]             return nameFormat.substring(index + 1).intern(); [EOL]         } [EOL]     } [EOL]     index = nameFormat.indexOf("%s"); [EOL]     if (index < 0) { [EOL]         return nameFormat; [EOL]     } [EOL]     String left = nameFormat.substring(0, index); [EOL]     String right = nameFormat.substring(index + 2); [EOL]     String name; [EOL]     if (iLetterS == null) { [EOL]         name = left.concat(right); [EOL]     } else { [EOL]         name = left + iLetterS + right; [EOL]     } [EOL]     return name.intern(); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
RuleSet(Rule rule) { [EOL]     iRules = new ArrayList<Rule>(); [EOL]     iRules.add(rule); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
void addRule(Rule rule) { [EOL]     if (!(rule.iName.equals(iRules.get(0).iName))) { [EOL]         throw new IllegalArgumentException("Rule name mismatch"); [EOL]     } [EOL]     iRules.add(rule); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL]     for (int i = 0; i < iRules.size(); i++) { [EOL]         Rule rule = iRules.get(i); [EOL]         rule.addRecurring(builder, nameFormat); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
Zone(StringTokenizer st) { [EOL]     this(st.nextToken(), st); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
Zone(StringTokenizer st) { [EOL]     this(st.nextToken(), st); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
private Zone(String name, StringTokenizer st) { [EOL]     iName = name.intern(); [EOL]     iOffsetMillis = parseTime(st.nextToken()); [EOL]     iRules = parseOptional(st.nextToken()); [EOL]     iFormat = st.nextToken().intern(); [EOL]     int year = Integer.MAX_VALUE; [EOL]     DateTimeOfYear dtOfYear = getStartOfYear(); [EOL]     if (st.hasMoreTokens()) { [EOL]         year = Integer.parseInt(st.nextToken()); [EOL]         if (st.hasMoreTokens()) { [EOL]             dtOfYear = new DateTimeOfYear(st); [EOL]         } [EOL]     } [EOL]     iUntilYear = year; [EOL]     iUntilDateTimeOfYear = dtOfYear; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
void chain(StringTokenizer st) { [EOL]     if (iNext != null) { [EOL]         iNext.chain(st); [EOL]     } else { [EOL]         iNext = new Zone(iName, st); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL]     addToBuilder(this, builder, ruleSets); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL]     for (; zone != null; zone = zone.iNext) { [EOL]         builder.setStandardOffset(zone.iOffsetMillis); [EOL]         if (zone.iRules == null) { [EOL]             builder.setFixedSavings(zone.iFormat, 0); [EOL]         } else { [EOL]             try { [EOL]                 int saveMillis = parseTime(zone.iRules); [EOL]                 builder.setFixedSavings(zone.iFormat, saveMillis); [EOL]             } catch (Exception e) { [EOL]                 RuleSet rs = ruleSets.get(zone.iRules); [EOL]                 if (rs == null) { [EOL]                     throw new IllegalArgumentException("Rules not found: " + zone.iRules); [EOL]                 } [EOL]                 rs.addRecurring(builder, zone.iFormat); [EOL]             } [EOL]         } [EOL]         if (zone.iUntilYear == Integer.MAX_VALUE) { [EOL]             break; [EOL]         } [EOL]         zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear); [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]     } [EOL] }
long getAverageMillisPerYear() { [EOL]     return MILLIS_PER_YEAR; [EOL] }
long getAverageMillisPerMonth() { [EOL]     return MILLIS_PER_MONTH; [EOL] }
public BaseDateTime() { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); [EOL] }
public BaseDateTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public BaseDateTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public BaseDateTime(long instant, Chronology chronology) { [EOL]     super(); [EOL]     iChronology = checkChronology(chronology); [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
public BaseDateTime(long instant, Chronology chronology) { [EOL]     super(); [EOL]     iChronology = checkChronology(chronology); [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
public BaseDateTime(long instant, Chronology chronology) { [EOL]     super(); [EOL]     iChronology = checkChronology(chronology); [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
protected Chronology checkChronology(Chronology chronology) { [EOL]     return DateTimeUtils.getChronology(chronology); [EOL] }
public Chronology getChronology() { [EOL]     return iChronology; [EOL] }
public int getOffset(long instant) { [EOL]     return iWallOffset; [EOL] }
public java.util.TimeZone toTimeZone() { [EOL]     String id = getID(); [EOL]     if (id.length() == 6 && (id.startsWith("+") || id.startsWith("-"))) { [EOL]         return java.util.TimeZone.getTimeZone("GMT" + getID()); [EOL]     } [EOL]     return new java.util.SimpleTimeZone(iWallOffset, getID()); [EOL] }
public java.util.TimeZone toTimeZone() { [EOL]     String id = getID(); [EOL]     if (id.length() == 6 && (id.startsWith("+") || id.startsWith("-"))) { [EOL]         return java.util.TimeZone.getTimeZone("GMT" + getID()); [EOL]     } [EOL]     return new java.util.SimpleTimeZone(iWallOffset, getID()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
protected ReadableDurationConverter() { [EOL]     super(); [EOL] }
public DateTimeFieldType getFieldType() { [EOL]     return getField().getType(); [EOL] }
public int getDifference(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifference(getMillis(), instant.getMillis()); [EOL] }
public int getDifference(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifference(getMillis(), instant.getMillis()); [EOL] }
public long getDifferenceAsLong(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); [EOL] }
public long getDifferenceAsLong(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); [EOL] }
public Interval toInterval() { [EOL]     DateTimeField field = getField(); [EOL]     long start = field.roundFloor(getMillis()); [EOL]     long end = field.add(start, 1); [EOL]     Interval interval = new Interval(start, end); [EOL]     return interval; [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public int get(long instant) { [EOL]     throw unsupported(); [EOL] }
public String getAsText(long instant, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsText(long instant) { [EOL]     throw unsupported(); [EOL] }
public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsText(ReadablePartial partial, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(long instant) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(ReadablePartial partial, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(ReadablePartial partial, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     throw unsupported(); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     throw unsupported(); [EOL] }
public long addWrapField(long instant, int value) { [EOL]     throw unsupported(); [EOL] }
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     throw unsupported(); [EOL] }
public long set(long instant, int value) { [EOL]     throw unsupported(); [EOL] }
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) { [EOL]     throw unsupported(); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public long set(long instant, String text) { [EOL]     throw unsupported(); [EOL] }
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { [EOL]     throw unsupported(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return null; [EOL] }
public boolean isLeap(long instant) { [EOL]     throw unsupported(); [EOL] }
public int getLeapAmount(long instant) { [EOL]     throw unsupported(); [EOL] }
public int getMinimumValue() { [EOL]     throw unsupported(); [EOL] }
public int getMinimumValue(long instant) { [EOL]     throw unsupported(); [EOL] }
public int getMinimumValue(ReadablePartial instant) { [EOL]     throw unsupported(); [EOL] }
public int getMinimumValue(ReadablePartial instant, int[] values) { [EOL]     throw unsupported(); [EOL] }
public int getMaximumValue() { [EOL]     throw unsupported(); [EOL] }
public int getMaximumValue(long instant) { [EOL]     throw unsupported(); [EOL] }
public int getMaximumValue(ReadablePartial instant) { [EOL]     throw unsupported(); [EOL] }
public int getMaximumValue(ReadablePartial instant, int[] values) { [EOL]     throw unsupported(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     throw unsupported(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     throw unsupported(); [EOL] }
public long roundFloor(long instant) { [EOL]     throw unsupported(); [EOL] }
public long roundCeiling(long instant) { [EOL]     throw unsupported(); [EOL] }
public long roundHalfFloor(long instant) { [EOL]     throw unsupported(); [EOL] }
public long roundHalfCeiling(long instant) { [EOL]     throw unsupported(); [EOL] }
public long roundHalfEven(long instant) { [EOL]     throw unsupported(); [EOL] }
public long remainder(long instant) { [EOL]     throw unsupported(); [EOL] }
public String toString() { [EOL]     return "UnsupportedDateTimeField"; [EOL] }
private UnsupportedOperationException unsupported() { [EOL]     return new UnsupportedOperationException(iType + " field is unsupported"); [EOL] }
public int get(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) ((instant / getUnitMillis()) % iRange); [EOL]     } else { [EOL]         return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); [EOL]     } [EOL] }
public int get(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) ((instant / getUnitMillis()) % iRange); [EOL]     } else { [EOL]         return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); [EOL]     } [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public DateTimeZone getZone() { [EOL]     return (DateTimeZone) getParam(); [EOL] }
public long add(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long add(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long set(long instant, int value) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     localInstant = iField.set(localInstant, value); [EOL]     long result = iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     if (get(result) != value) { [EOL]         IllegalInstantException cause = new IllegalInstantException(localInstant, iZone.getID()); [EOL]         IllegalFieldValueException ex = new IllegalFieldValueException(iField.getType(), Integer.valueOf(value), cause.getMessage()); [EOL]         ex.initCause(cause); [EOL]         throw ex; [EOL]     } [EOL]     return result; [EOL] }
public long set(long instant, int value) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     localInstant = iField.set(localInstant, value); [EOL]     long result = iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     if (get(result) != value) { [EOL]         IllegalInstantException cause = new IllegalInstantException(localInstant, iZone.getID()); [EOL]         IllegalFieldValueException ex = new IllegalFieldValueException(iField.getType(), Integer.valueOf(value), cause.getMessage()); [EOL]         ex.initCause(cause); [EOL]         throw ex; [EOL]     } [EOL]     return result; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifference(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long roundFloor(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundFloor(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundFloor(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundFloor(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundFloor(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return iEraText; [EOL] }
protected BaseLocal() { [EOL]     super(); [EOL] }
public IllegalInstantException(long instantLocal, String zoneId) { [EOL]     super(createMessage(instantLocal, zoneId)); [EOL] }
private static String createMessage(long instantLocal, String zoneId) { [EOL]     String localDateTime = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(instantLocal)); [EOL]     String zone = (zoneId != null ? " (" + zoneId + ")" : ""); [EOL]     return "Illegal instant due to time zone offset transition (daylight savings time 'gap'): " + localDateTime + zone; [EOL] }
private static String createMessage(long instantLocal, String zoneId) { [EOL]     String localDateTime = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(instantLocal)); [EOL]     String zone = (zoneId != null ? " (" + zoneId + ")" : ""); [EOL]     return "Illegal instant due to time zone offset transition (daylight savings time 'gap'): " + localDateTime + zone; [EOL] }
public static boolean isIllegalInstant(Throwable ex) { [EOL]     if (ex instanceof IllegalInstantException) { [EOL]         return true; [EOL]     } [EOL]     while (ex.getCause() != null && ex.getCause() != ex) { [EOL]         return isIllegalInstant(ex.getCause()); [EOL]     } [EOL]     return false; [EOL] }
public static boolean isIllegalInstant(Throwable ex) { [EOL]     if (ex instanceof IllegalInstantException) { [EOL]         return true; [EOL]     } [EOL]     while (ex.getCause() != null && ex.getCause() != ex) { [EOL]         return isIllegalInstant(ex.getCause()); [EOL]     } [EOL]     return false; [EOL] }
public static boolean isIllegalInstant(Throwable ex) { [EOL]     if (ex instanceof IllegalInstantException) { [EOL]         return true; [EOL]     } [EOL]     while (ex.getCause() != null && ex.getCause() != ex) { [EOL]         return isIllegalInstant(ex.getCause()); [EOL]     } [EOL]     return false; [EOL] }
public static boolean isIllegalInstant(Throwable ex) { [EOL]     if (ex instanceof IllegalInstantException) { [EOL]         return true; [EOL]     } [EOL]     while (ex.getCause() != null && ex.getCause() != ex) { [EOL]         return isIllegalInstant(ex.getCause()); [EOL]     } [EOL]     return false; [EOL] }
public static boolean isIllegalInstant(Throwable ex) { [EOL]     if (ex instanceof IllegalInstantException) { [EOL]         return true; [EOL]     } [EOL]     while (ex.getCause() != null && ex.getCause() != ex) { [EOL]         return isIllegalInstant(ex.getCause()); [EOL]     } [EOL]     return false; [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public IllegalFieldValueException(DateTimeFieldType fieldType, Number value, Number lowerBound, Number upperBound) { [EOL]     super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null)); [EOL]     iDateTimeFieldType = fieldType; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldType.getName(); [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = lowerBound; [EOL]     iUpperBound = upperBound; [EOL]     iMessage = super.getMessage(); [EOL] }
public DateTimeFieldType getDateTimeFieldType() { [EOL]     return iDateTimeFieldType; [EOL] }
public DurationFieldType getDurationFieldType() { [EOL]     return iDurationFieldType; [EOL] }
public String getFieldName() { [EOL]     return iFieldName; [EOL] }
public Number getIllegalNumberValue() { [EOL]     return iNumberValue; [EOL] }
public String getIllegalStringValue() { [EOL]     return iStringValue; [EOL] }
public String getIllegalValueAsString() { [EOL]     String value = iStringValue; [EOL]     if (value == null) { [EOL]         value = String.valueOf(iNumberValue); [EOL]     } [EOL]     return value; [EOL] }
public String getIllegalValueAsString() { [EOL]     String value = iStringValue; [EOL]     if (value == null) { [EOL]         value = String.valueOf(iNumberValue); [EOL]     } [EOL]     return value; [EOL] }
public Number getLowerBound() { [EOL]     return iLowerBound; [EOL] }
public Number getLowerBound() { [EOL]     return iLowerBound; [EOL] }
public Number getLowerBound() { [EOL]     return iLowerBound; [EOL] }
public Number getUpperBound() { [EOL]     return iUpperBound; [EOL] }
public static LocalTime now() { [EOL]     return new LocalTime(); [EOL] }
public static LocalTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new LocalTime(chronology); [EOL] }
public static LocalTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new LocalTime(chronology); [EOL] }
@FromString [EOL] public static LocalTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localTimeParser()); [EOL] }
public static LocalTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalTime(str); [EOL] }
public static LocalTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalTime(str); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new LocalTime(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
public LocalTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public LocalTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public LocalTime getLocalTime() { [EOL]     return iInstant; [EOL] }
public LocalTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime roundFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public LocalTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min - 1; [EOL]     } else if (min == skip) { [EOL]         iMinValue = skip + 1; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min - 1; [EOL]     } else if (min == skip) { [EOL]         iMinValue = skip + 1; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min - 1; [EOL]     } else if (min == skip) { [EOL]         iMinValue = skip + 1; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return value; [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return value; [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public static DurationFieldType days() { [EOL]     return DAYS_TYPE; [EOL] }
public static DurationFieldType weekyears() { [EOL]     return WEEKYEARS_TYPE; [EOL] }
public static DurationFieldType months() { [EOL]     return MONTHS_TYPE; [EOL] }
public static DurationFieldType eras() { [EOL]     return ERAS_TYPE; [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public static MutableDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new MutableDateTime(zone); [EOL] }
public static MutableDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new MutableDateTime(zone); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     setMillis(instantMillis); [EOL] }
public void setMillis(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     setMillis(instantMillis); [EOL] }
public void setZone(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     Chronology chrono = getChronology(); [EOL]     if (chrono.getZone() != newZone) { [EOL]         setChronology(chrono.withZone(newZone)); [EOL]     } [EOL] }
public void setZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     setChronology(getChronology().withZone(newZone)); [EOL]     setMillis(millis); [EOL] }
public void setZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     setChronology(getChronology().withZone(newZone)); [EOL]     setMillis(millis); [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void setMonthOfYear(final int monthOfYear) { [EOL]     setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public void setMonthOfYear(final int monthOfYear) { [EOL]     setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public void setMonthOfYear(final int monthOfYear) { [EOL]     setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public void setDayOfWeek(final int dayOfWeek) { [EOL]     setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public void setDayOfWeek(final int dayOfWeek) { [EOL]     setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public void addHours(final int hours) { [EOL]     if (hours != 0) { [EOL]         setMillis(getChronology().hours().add(getMillis(), hours)); [EOL]     } [EOL] }
public void addHours(final int hours) { [EOL]     if (hours != 0) { [EOL]         setMillis(getChronology().hours().add(getMillis(), hours)); [EOL]     } [EOL] }
public void addHours(final int hours) { [EOL]     if (hours != 0) { [EOL]         setMillis(getChronology().hours().add(getMillis(), hours)); [EOL]     } [EOL] }
public void setMinuteOfHour(final int minuteOfHour) { [EOL]     setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); [EOL] }
public void setMinuteOfHour(final int minuteOfHour) { [EOL]     setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); [EOL] }
public void setMinuteOfHour(final int minuteOfHour) { [EOL]     setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); [EOL] }
public void setSecondOfMinute(final int secondOfMinute) { [EOL]     setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void setDateTime(final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { [EOL]     long instant = getChronology().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     setMillis(instant); [EOL] }
public MutableDateTime add(int value) { [EOL]     iInstant.setMillis(getField().add(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime add(int value) { [EOL]     iInstant.setMillis(getField().add(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime add(int value) { [EOL]     iInstant.setMillis(getField().add(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfCeiling() { [EOL]     iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfCeiling() { [EOL]     iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public static Hours hoursBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.hours()); [EOL]     return Hours.hours(amount); [EOL] }
public static Hours hoursBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.hours()); [EOL]     return Hours.hours(amount); [EOL] }
public static Hours hoursIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours()); [EOL]     return Hours.hours(amount); [EOL] }
public static Hours hoursIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours()); [EOL]     return Hours.hours(amount); [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR)); [EOL] }
public Hours minus(Hours hours) { [EOL]     if (hours == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(hours.getValue()); [EOL] }
public Hours minus(Hours hours) { [EOL]     if (hours == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(hours.getValue()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "H"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "H"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "H"; [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, false)); [EOL] }
public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, false)); [EOL] }
public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, false)); [EOL] }
public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, false)); [EOL] }
public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, true)); [EOL] }
public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, true)); [EOL] }
public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, true)); [EOL] }
public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, true)); [EOL] }
public DateTimeFormatterBuilder appendDayOfWeekText() { [EOL]     return appendText(DateTimeFieldType.dayOfWeek()); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(fieldType, maxParsedDigits, signed); [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType)); [EOL]         } catch (RuntimeException e) { [EOL]             buf.append('\ufffd'); [EOL]         } [EOL]     } else { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType)); [EOL]         } catch (RuntimeException e) { [EOL]             buf.append('\ufffd'); [EOL]         } [EOL]     } else { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType)); [EOL]         } catch (RuntimeException e) { [EOL]             buf.append('\ufffd'); [EOL]         } [EOL]     } else { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) { [EOL]     super(fieldType, numDigits, signed, numDigits); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] }
public int estimateParsedLength() { [EOL]     return iLenientParse ? 4 : 2; [EOL] }
public int estimateParsedLength() { [EOL]     return iLenientParse ? 4 : 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         printTo(buf, null, instant, chrono); [EOL]     } catch (IOException e) { [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         printTo(buf, null, instant, chrono); [EOL]     } catch (IOException e) { [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     long millis = partial.getChronology().set(partial, 0L); [EOL]     try { [EOL]         printTo(buf, null, millis, partial.getChronology()); [EOL]     } catch (IOException e) { [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     long millis = partial.getChronology().set(partial, 0L); [EOL]     try { [EOL]         printTo(buf, null, millis, partial.getChronology()); [EOL]     } catch (IOException e) { [EOL]     } [EOL] }
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     int minDigits = iMinDigits; [EOL]     long fraction; [EOL]     try { [EOL]         fraction = field.remainder(instant); [EOL]     } catch (RuntimeException e) { [EOL]         if (buf != null) { [EOL]             appendUnknownString(buf, minDigits); [EOL]         } else { [EOL]             printUnknownString(out, minDigits); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (fraction == 0) { [EOL]         if (buf != null) { [EOL]             while (--minDigits >= 0) { [EOL]                 buf.append('0'); [EOL]             } [EOL]         } else { [EOL]             while (--minDigits >= 0) { [EOL]                 out.write('0'); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     String str; [EOL]     long[] fractionData = getFractionData(fraction, field); [EOL]     long scaled = fractionData[0]; [EOL]     int maxDigits = (int) fractionData[1]; [EOL]     if ((scaled & 0x7fffffff) == scaled) { [EOL]         str = Integer.toString((int) scaled); [EOL]     } else { [EOL]         str = Long.toString(scaled); [EOL]     } [EOL]     int length = str.length(); [EOL]     int digits = maxDigits; [EOL]     while (length < digits) { [EOL]         if (buf != null) { [EOL]             buf.append('0'); [EOL]         } else { [EOL]             out.write('0'); [EOL]         } [EOL]         minDigits--; [EOL]         digits--; [EOL]     } [EOL]     if (minDigits < digits) { [EOL]         while (minDigits < digits) { [EOL]             if (length <= 1 || str.charAt(length - 1) != '0') { [EOL]                 break; [EOL]             } [EOL]             digits--; [EOL]             length--; [EOL]         } [EOL]         if (length < str.length()) { [EOL]             if (buf != null) { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     buf.append(str.charAt(i)); [EOL]                 } [EOL]             } else { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     out.write(str.charAt(i)); [EOL]                 } [EOL]             } [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (buf != null) { [EOL]         buf.append(str); [EOL]     } else { [EOL]         out.write(str); [EOL]     } [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] parsers = iParsers; [EOL]     int length = parsers.length; [EOL]     final Object originalState = bucket.saveState(); [EOL]     boolean isOptional = false; [EOL]     int bestValidPos = position; [EOL]     Object bestValidState = null; [EOL]     int bestInvalidPos = position; [EOL]     for (int i = 0; i < length; i++) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser == null) { [EOL]             if (bestValidPos <= position) { [EOL]                 return position; [EOL]             } [EOL]             isOptional = true; [EOL]             break; [EOL]         } [EOL]         int parsePos = parser.parseInto(bucket, text, position); [EOL]         if (parsePos >= position) { [EOL]             if (parsePos > bestValidPos) { [EOL]                 if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL]                     return parsePos; [EOL]                 } [EOL]                 bestValidPos = parsePos; [EOL]                 bestValidState = bucket.saveState(); [EOL]             } [EOL]         } else { [EOL]             if (parsePos < 0) { [EOL]                 parsePos = ~parsePos; [EOL]                 if (parsePos > bestInvalidPos) { [EOL]                     bestInvalidPos = parsePos; [EOL]                 } [EOL]             } [EOL]         } [EOL]         bucket.restoreState(originalState); [EOL]     } [EOL]     if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL]         if (bestValidState != null) { [EOL]             bucket.restoreState(bestValidState); [EOL]         } [EOL]         return bestValidPos; [EOL]     } [EOL]     return ~bestInvalidPos; [EOL] }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay() { [EOL]     super(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusSeconds(int seconds) { [EOL]     return withFieldAdded(DurationFieldType.seconds(), seconds); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusSeconds(int seconds) { [EOL]     return withFieldAdded(DurationFieldType.seconds(), seconds); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusSeconds(int seconds) { [EOL]     return withFieldAdded(DurationFieldType.seconds(), seconds); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTime getStart() { [EOL]     return new DateTime(getStartMillis(), getChronology()); [EOL] }
public DateTime getEnd() { [EOL]     return new DateTime(getEndMillis(), getChronology()); [EOL] }
public boolean contains(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); [EOL] }
public boolean contains(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); [EOL] }
public boolean contains(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); [EOL] }
public boolean contains(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public Duration toDuration() { [EOL]     long durMillis = toDurationMillis(); [EOL]     if (durMillis == 0) { [EOL]         return Duration.ZERO; [EOL]     } else { [EOL]         return new Duration(durMillis); [EOL]     } [EOL] }
public Duration toDuration() { [EOL]     long durMillis = toDurationMillis(); [EOL]     if (durMillis == 0) { [EOL]         return Duration.ZERO; [EOL]     } else { [EOL]         return new Duration(durMillis); [EOL]     } [EOL] }
public int get(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         return 0; [EOL]     } [EOL]     return getValue(index); [EOL] }
public int get(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         return 0; [EOL]     } [EOL]     return getValue(index); [EOL] }
public int indexOf(DurationFieldType type) { [EOL]     return getPeriodType().indexOf(type); [EOL] }
public MutablePeriod toMutablePeriod() { [EOL]     return new MutablePeriod(this); [EOL] }
@FromString [EOL] public static MutablePeriod parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
@FromString [EOL] public static MutablePeriod parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
@FromString [EOL] public static MutablePeriod parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
public static MutablePeriod parse(String str, PeriodFormatter formatter) { [EOL]     return formatter.parsePeriod(str).toMutablePeriod(); [EOL] }
public static MutablePeriod parse(String str, PeriodFormatter formatter) { [EOL]     return formatter.parsePeriod(str).toMutablePeriod(); [EOL] }
public static MutablePeriod parse(String str, PeriodFormatter formatter) { [EOL]     return formatter.parsePeriod(str).toMutablePeriod(); [EOL] }
public MutablePeriod() { [EOL]     super(0L, null, null); [EOL] }
public MutablePeriod(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null, null); [EOL] }
public MutablePeriod(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null, null); [EOL] }
public MutablePeriod(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null, null); [EOL] }
public void setPeriod(long duration) { [EOL]     setPeriod(duration, null); [EOL] }
public void setPeriod(long duration) { [EOL]     setPeriod(duration, null); [EOL] }
public void setPeriod(long duration) { [EOL]     setPeriod(duration, null); [EOL] }
public void setPeriod(long duration, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     setValues(chrono.get(this, duration)); [EOL] }
public void setPeriod(long duration, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     setValues(chrono.get(this, duration)); [EOL] }
public void add(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     setPeriod(FieldUtils.safeAdd(getYears(), years), FieldUtils.safeAdd(getMonths(), months), FieldUtils.safeAdd(getWeeks(), weeks), FieldUtils.safeAdd(getDays(), days), FieldUtils.safeAdd(getHours(), hours), FieldUtils.safeAdd(getMinutes(), minutes), FieldUtils.safeAdd(getSeconds(), seconds), FieldUtils.safeAdd(getMillis(), millis)); [EOL] }
public void add(long duration) { [EOL]     add(new Period(duration, getPeriodType())); [EOL] }
public void add(long duration, Chronology chrono) { [EOL]     add(new Period(duration, getPeriodType(), chrono)); [EOL] }
public int getWeeks() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX); [EOL] }
public void setWeeks(int weeks) { [EOL]     super.setField(DurationFieldType.weeks(), weeks); [EOL] }
public void setWeeks(int weeks) { [EOL]     super.setField(DurationFieldType.weeks(), weeks); [EOL] }
public void setWeeks(int weeks) { [EOL]     super.setField(DurationFieldType.weeks(), weeks); [EOL] }
public void addHours(int hours) { [EOL]     super.addField(DurationFieldType.hours(), hours); [EOL] }
public void addHours(int hours) { [EOL]     super.addField(DurationFieldType.hours(), hours); [EOL] }
public void addHours(int hours) { [EOL]     super.addField(DurationFieldType.hours(), hours); [EOL] }
public int get(long instant) { [EOL]     return iChronology.getYear(instant); [EOL] }
public int get(long instant) { [EOL]     return iChronology.getYear(instant); [EOL] }
public long add(long instant, long years) { [EOL]     return add(instant, FieldUtils.safeToInt(years)); [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
public long roundCeiling(long instant) { [EOL]     return getWrappedField().roundCeiling(instant); [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 365) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 365) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 365) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
boolean isLeapYear(int year) { [EOL]     return (year & 3) == 3; [EOL] }
boolean isLeapYear(int year) { [EOL]     return (year & 3) == 3; [EOL] }
int getDaysInMonthMax() { [EOL]     return MONTH_LENGTH; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH; [EOL]     return ((int) monthZeroBased) + 1; [EOL] }
public int getMaximumValue(long instant) { [EOL]     int weekyear = iChronology.getWeekyear(instant); [EOL]     return iChronology.getWeeksInYear(weekyear); [EOL] }
public int getMaximumValue(long instant) { [EOL]     int weekyear = iChronology.getWeekyear(instant); [EOL]     return iChronology.getWeeksInYear(weekyear); [EOL] }
public int getMaximumValue(long instant) { [EOL]     int weekyear = iChronology.getWeekyear(instant); [EOL]     return iChronology.getWeeksInYear(weekyear); [EOL] }
protected AssembledChronology(Chronology base, Object param) { [EOL]     iBase = base; [EOL]     iParam = param; [EOL]     setFields(); [EOL] }
protected AssembledChronology(Chronology base, Object param) { [EOL]     iBase = base; [EOL]     iParam = param; [EOL]     setFields(); [EOL] }
protected AssembledChronology(Chronology base, Object param) { [EOL]     iBase = base; [EOL]     iParam = param; [EOL]     setFields(); [EOL] }
protected AssembledChronology(Chronology base, Object param) { [EOL]     iBase = base; [EOL]     iParam = param; [EOL]     setFields(); [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return null; [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return null; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 5) == 5) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 5) == 5) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 5) == 5) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public final DurationField millis() { [EOL]     return iMillis; [EOL] }
public final DateTimeField millisOfSecond() { [EOL]     return iMillisOfSecond; [EOL] }
public final DurationField seconds() { [EOL]     return iSeconds; [EOL] }
public final DateTimeField secondOfMinute() { [EOL]     return iSecondOfMinute; [EOL] }
public final DateTimeField secondOfDay() { [EOL]     return iSecondOfDay; [EOL] }
public final DateTimeField minuteOfHour() { [EOL]     return iMinuteOfHour; [EOL] }
public final DateTimeField minuteOfDay() { [EOL]     return iMinuteOfDay; [EOL] }
public final DateTimeField hourOfDay() { [EOL]     return iHourOfDay; [EOL] }
public final DateTimeField clockhourOfDay() { [EOL]     return iClockhourOfDay; [EOL] }
public final DurationField halfdays() { [EOL]     return iHalfdays; [EOL] }
public final DateTimeField hourOfHalfday() { [EOL]     return iHourOfHalfday; [EOL] }
public final DateTimeField clockhourOfHalfday() { [EOL]     return iClockhourOfHalfday; [EOL] }
public final DateTimeField halfdayOfDay() { [EOL]     return iHalfdayOfDay; [EOL] }
public final DurationField days() { [EOL]     return iDays; [EOL] }
public final DateTimeField dayOfMonth() { [EOL]     return iDayOfMonth; [EOL] }
public final DateTimeField dayOfYear() { [EOL]     return iDayOfYear; [EOL] }
public final DurationField weeks() { [EOL]     return iWeeks; [EOL] }
public final DateTimeField weekOfWeekyear() { [EOL]     return iWeekOfWeekyear; [EOL] }
public final DurationField weekyears() { [EOL]     return iWeekyears; [EOL] }
public final DateTimeField weekyear() { [EOL]     return iWeekyear; [EOL] }
public final DateTimeField weekyearOfCentury() { [EOL]     return iWeekyearOfCentury; [EOL] }
public final DurationField months() { [EOL]     return iMonths; [EOL] }
public final DateTimeField monthOfYear() { [EOL]     return iMonthOfYear; [EOL] }
public final DurationField years() { [EOL]     return iYears; [EOL] }
public final DateTimeField year() { [EOL]     return iYear; [EOL] }
public final DateTimeField yearOfEra() { [EOL]     return iYearOfEra; [EOL] }
public final DateTimeField yearOfCentury() { [EOL]     return iYearOfCentury; [EOL] }
public final DurationField centuries() { [EOL]     return iCenturies; [EOL] }
public final DateTimeField centuryOfEra() { [EOL]     return iCenturyOfEra; [EOL] }
public final DurationField eras() { [EOL]     return iEras; [EOL] }
public final DateTimeField era() { [EOL]     return iEra; [EOL] }
protected final Chronology getBase() { [EOL]     return iBase; [EOL] }
protected final Object getParam() { [EOL]     return iParam; [EOL] }
private void setFields() { [EOL]     Fields fields = new Fields(); [EOL]     if (iBase != null) { [EOL]         fields.copyFieldsFrom(iBase); [EOL]     } [EOL]     assemble(fields); [EOL]     { [EOL]         DurationField f; [EOL]         iMillis = (f = fields.millis) != null ? f : super.millis(); [EOL]         iSeconds = (f = fields.seconds) != null ? f : super.seconds(); [EOL]         iMinutes = (f = fields.minutes) != null ? f : super.minutes(); [EOL]         iHours = (f = fields.hours) != null ? f : super.hours(); [EOL]         iHalfdays = (f = fields.halfdays) != null ? f : super.halfdays(); [EOL]         iDays = (f = fields.days) != null ? f : super.days(); [EOL]         iWeeks = (f = fields.weeks) != null ? f : super.weeks(); [EOL]         iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears(); [EOL]         iMonths = (f = fields.months) != null ? f : super.months(); [EOL]         iYears = (f = fields.years) != null ? f : super.years(); [EOL]         iCenturies = (f = fields.centuries) != null ? f : super.centuries(); [EOL]         iEras = (f = fields.eras) != null ? f : super.eras(); [EOL]     } [EOL]     { [EOL]         DateTimeField f; [EOL]         iMillisOfSecond = (f = fields.millisOfSecond) != null ? f : super.millisOfSecond(); [EOL]         iMillisOfDay = (f = fields.millisOfDay) != null ? f : super.millisOfDay(); [EOL]         iSecondOfMinute = (f = fields.secondOfMinute) != null ? f : super.secondOfMinute(); [EOL]         iSecondOfDay = (f = fields.secondOfDay) != null ? f : super.secondOfDay(); [EOL]         iMinuteOfHour = (f = fields.minuteOfHour) != null ? f : super.minuteOfHour(); [EOL]         iMinuteOfDay = (f = fields.minuteOfDay) != null ? f : super.minuteOfDay(); [EOL]         iHourOfDay = (f = fields.hourOfDay) != null ? f : super.hourOfDay(); [EOL]         iClockhourOfDay = (f = fields.clockhourOfDay) != null ? f : super.clockhourOfDay(); [EOL]         iHourOfHalfday = (f = fields.hourOfHalfday) != null ? f : super.hourOfHalfday(); [EOL]         iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday(); [EOL]         iHalfdayOfDay = (f = fields.halfdayOfDay) != null ? f : super.halfdayOfDay(); [EOL]         iDayOfWeek = (f = fields.dayOfWeek) != null ? f : super.dayOfWeek(); [EOL]         iDayOfMonth = (f = fields.dayOfMonth) != null ? f : super.dayOfMonth(); [EOL]         iDayOfYear = (f = fields.dayOfYear) != null ? f : super.dayOfYear(); [EOL]         iWeekOfWeekyear = (f = fields.weekOfWeekyear) != null ? f : super.weekOfWeekyear(); [EOL]         iWeekyear = (f = fields.weekyear) != null ? f : super.weekyear(); [EOL]         iWeekyearOfCentury = (f = fields.weekyearOfCentury) != null ? f : super.weekyearOfCentury(); [EOL]         iMonthOfYear = (f = fields.monthOfYear) != null ? f : super.monthOfYear(); [EOL]         iYear = (f = fields.year) != null ? f : super.year(); [EOL]         iYearOfEra = (f = fields.yearOfEra) != null ? f : super.yearOfEra(); [EOL]         iYearOfCentury = (f = fields.yearOfCentury) != null ? f : super.yearOfCentury(); [EOL]         iCenturyOfEra = (f = fields.centuryOfEra) != null ? f : super.centuryOfEra(); [EOL]         iEra = (f = fields.era) != null ? f : super.era(); [EOL]     } [EOL]     int flags; [EOL]     if (iBase == null) { [EOL]         flags = 0; [EOL]     } else { [EOL]         flags = ((iHourOfDay == iBase.hourOfDay() && iMinuteOfHour == iBase.minuteOfHour() && iSecondOfMinute == iBase.secondOfMinute() && iMillisOfSecond == iBase.millisOfSecond()) ? 1 : 0) | ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) | ((iYear == iBase.year() && iMonthOfYear == iBase.monthOfYear() && iDayOfMonth == iBase.dayOfMonth()) ? 4 : 0); [EOL]     } [EOL]     iBaseFlags = flags; [EOL] }
Fields() { [EOL] }
public void copyFieldsFrom(Chronology chrono) { [EOL]     { [EOL]         DurationField f; [EOL]         if (isSupported(f = chrono.millis())) { [EOL]             millis = f; [EOL]         } [EOL]         if (isSupported(f = chrono.seconds())) { [EOL]             seconds = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minutes())) { [EOL]             minutes = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hours())) { [EOL]             hours = f; [EOL]         } [EOL]         if (isSupported(f = chrono.halfdays())) { [EOL]             halfdays = f; [EOL]         } [EOL]         if (isSupported(f = chrono.days())) { [EOL]             days = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weeks())) { [EOL]             weeks = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyears())) { [EOL]             weekyears = f; [EOL]         } [EOL]         if (isSupported(f = chrono.months())) { [EOL]             months = f; [EOL]         } [EOL]         if (isSupported(f = chrono.years())) { [EOL]             years = f; [EOL]         } [EOL]         if (isSupported(f = chrono.centuries())) { [EOL]             centuries = f; [EOL]         } [EOL]         if (isSupported(f = chrono.eras())) { [EOL]             eras = f; [EOL]         } [EOL]     } [EOL]     { [EOL]         DateTimeField f; [EOL]         if (isSupported(f = chrono.millisOfSecond())) { [EOL]             millisOfSecond = f; [EOL]         } [EOL]         if (isSupported(f = chrono.millisOfDay())) { [EOL]             millisOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.secondOfMinute())) { [EOL]             secondOfMinute = f; [EOL]         } [EOL]         if (isSupported(f = chrono.secondOfDay())) { [EOL]             secondOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minuteOfHour())) { [EOL]             minuteOfHour = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minuteOfDay())) { [EOL]             minuteOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hourOfDay())) { [EOL]             hourOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.clockhourOfDay())) { [EOL]             clockhourOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hourOfHalfday())) { [EOL]             hourOfHalfday = f; [EOL]         } [EOL]         if (isSupported(f = chrono.clockhourOfHalfday())) { [EOL]             clockhourOfHalfday = f; [EOL]         } [EOL]         if (isSupported(f = chrono.halfdayOfDay())) { [EOL]             halfdayOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfWeek())) { [EOL]             dayOfWeek = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfMonth())) { [EOL]             dayOfMonth = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfYear())) { [EOL]             dayOfYear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekOfWeekyear())) { [EOL]             weekOfWeekyear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyear())) { [EOL]             weekyear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyearOfCentury())) { [EOL]             weekyearOfCentury = f; [EOL]         } [EOL]         if (isSupported(f = chrono.monthOfYear())) { [EOL]             monthOfYear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.year())) { [EOL]             year = f; [EOL]         } [EOL]         if (isSupported(f = chrono.yearOfEra())) { [EOL]             yearOfEra = f; [EOL]         } [EOL]         if (isSupported(f = chrono.yearOfCentury())) { [EOL]             yearOfCentury = f; [EOL]         } [EOL]         if (isSupported(f = chrono.centuryOfEra())) { [EOL]             centuryOfEra = f; [EOL]         } [EOL]         if (isSupported(f = chrono.era())) { [EOL]             era = f; [EOL]         } [EOL]     } [EOL] }
public void copyFieldsFrom(Chronology chrono) { [EOL]     { [EOL]         DurationField f; [EOL]         if (isSupported(f = chrono.millis())) { [EOL]             millis = f; [EOL]         } [EOL]         if (isSupported(f = chrono.seconds())) { [EOL]             seconds = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minutes())) { [EOL]             minutes = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hours())) { [EOL]             hours = f; [EOL]         } [EOL]         if (isSupported(f = chrono.halfdays())) { [EOL]             halfdays = f; [EOL]         } [EOL]         if (isSupported(f = chrono.days())) { [EOL]             days = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weeks())) { [EOL]             weeks = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyears())) { [EOL]             weekyears = f; [EOL]         } [EOL]         if (isSupported(f = chrono.months())) { [EOL]             months = f; [EOL]         } [EOL]         if (isSupported(f = chrono.years())) { [EOL]             years = f; [EOL]         } [EOL]         if (isSupported(f = chrono.centuries())) { [EOL]             centuries = f; [EOL]         } [EOL]         if (isSupported(f = chrono.eras())) { [EOL]             eras = f; [EOL]         } [EOL]     } [EOL]     { [EOL]         DateTimeField f; [EOL]         if (isSupported(f = chrono.millisOfSecond())) { [EOL]             millisOfSecond = f; [EOL]         } [EOL]         if (isSupported(f = chrono.millisOfDay())) { [EOL]             millisOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.secondOfMinute())) { [EOL]             secondOfMinute = f; [EOL]         } [EOL]         if (isSupported(f = chrono.secondOfDay())) { [EOL]             secondOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minuteOfHour())) { [EOL]             minuteOfHour = f; [EOL]         } [EOL]         if (isSupported(f = chrono.minuteOfDay())) { [EOL]             minuteOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hourOfDay())) { [EOL]             hourOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.clockhourOfDay())) { [EOL]             clockhourOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.hourOfHalfday())) { [EOL]             hourOfHalfday = f; [EOL]         } [EOL]         if (isSupported(f = chrono.clockhourOfHalfday())) { [EOL]             clockhourOfHalfday = f; [EOL]         } [EOL]         if (isSupported(f = chrono.halfdayOfDay())) { [EOL]             halfdayOfDay = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfWeek())) { [EOL]             dayOfWeek = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfMonth())) { [EOL]             dayOfMonth = f; [EOL]         } [EOL]         if (isSupported(f = chrono.dayOfYear())) { [EOL]             dayOfYear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekOfWeekyear())) { [EOL]             weekOfWeekyear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyear())) { [EOL]             weekyear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.weekyearOfCentury())) { [EOL]             weekyearOfCentury = f; [EOL]         } [EOL]         if (isSupported(f = chrono.monthOfYear())) { [EOL]             monthOfYear = f; [EOL]         } [EOL]         if (isSupported(f = chrono.year())) { [EOL]             year = f; [EOL]         } [EOL]         if (isSupported(f = chrono.yearOfEra())) { [EOL]             yearOfEra = f; [EOL]         } [EOL]         if (isSupported(f = chrono.yearOfCentury())) { [EOL]             yearOfCentury = f; [EOL]         } [EOL]         if (isSupported(f = chrono.centuryOfEra())) { [EOL]             centuryOfEra = f; [EOL]         } [EOL]         if (isSupported(f = chrono.era())) { [EOL]             era = f; [EOL]         } [EOL]     } [EOL] }
private static boolean isSupported(DurationField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
private static boolean isSupported(DurationField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
private static boolean isSupported(DurationField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
private static boolean isSupported(DateTimeField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
private static boolean isSupported(DateTimeField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
private static boolean isSupported(DateTimeField field) { [EOL]     return field == null ? false : field.isSupported(); [EOL] }
public static Days standardDaysIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY); [EOL]     return Days.days(amount); [EOL] }
public static Days standardDaysIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY); [EOL]     return Days.days(amount); [EOL] }
public static Days standardDaysIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY); [EOL]     return Days.days(amount); [EOL] }
public static Days standardDaysIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY); [EOL]     return Days.days(amount); [EOL] }
@FromString [EOL] public static Days parseDays(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Days.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Days.days(p.getDays()); [EOL] }
@FromString [EOL] public static Days parseDays(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Days.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Days.days(p.getDays()); [EOL] }
@FromString [EOL] public static Days parseDays(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Days.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Days.days(p.getDays()); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.days(); [EOL] }
public Duration toStandardDuration() { [EOL]     long days = getValue(); [EOL]     return new Duration(days * DateTimeConstants.MILLIS_PER_DAY); [EOL] }
public Days multipliedBy(int scalar) { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Days multipliedBy(int scalar) { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Days multipliedBy(int scalar) { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Days multipliedBy(int scalar) { [EOL]     return Days.days(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Days negated() { [EOL]     return Days.days(FieldUtils.safeNegate(getValue())); [EOL] }
public Days negated() { [EOL]     return Days.days(FieldUtils.safeNegate(getValue())); [EOL] }
public Days negated() { [EOL]     return Days.days(FieldUtils.safeNegate(getValue())); [EOL] }
public Days negated() { [EOL]     return Days.days(FieldUtils.safeNegate(getValue())); [EOL] }
public Days negated() { [EOL]     return Days.days(FieldUtils.safeNegate(getValue())); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue()); [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return super.set(instant, year); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue()); [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return super.set(instant, year); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue()); [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return super.set(instant, year); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue()); [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return super.set(instant, year); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static MonthDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new MonthDay(date.getMonth() + 1, date.getDate()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
@SuppressWarnings("deprecation") [EOL] public static MonthDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new MonthDay(date.getMonth() + 1, date.getDate()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth) { [EOL]     this(monthOfYear, dayOfMonth, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { monthOfYear, dayOfMonth }, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int size() { [EOL]     return 2; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static LocalDateTime now() { [EOL]     return new LocalDateTime(); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
public LocalDateTime() { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); [EOL] }
public LocalDateTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalDateTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalDateTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalDateTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
protected long getLocalMillis() { [EOL]     return iLocalMillis; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); [EOL]     date.setTime(date.getTime() + getMillisOfSecond()); [EOL]     return correctDstTransition(date, TimeZone.getDefault()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); [EOL]     date.setTime(date.getTime() + getMillisOfSecond()); [EOL]     return correctDstTransition(date, TimeZone.getDefault()); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
public LocalDateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public int getYear() { [EOL]     return getChronology().year().get(getLocalMillis()); [EOL] }
public int getMonthOfYear() { [EOL]     return getChronology().monthOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfMonth() { [EOL]     return getChronology().dayOfMonth().get(getLocalMillis()); [EOL] }
public int getHourOfDay() { [EOL]     return getChronology().hourOfDay().get(getLocalMillis()); [EOL] }
public int getMinuteOfHour() { [EOL]     return getChronology().minuteOfHour().get(getLocalMillis()); [EOL] }
public int getSecondOfMinute() { [EOL]     return getChronology().secondOfMinute().get(getLocalMillis()); [EOL] }
public int getMillisOfSecond() { [EOL]     return getChronology().millisOfSecond().get(getLocalMillis()); [EOL] }
public Property dayOfMonth() { [EOL]     return new Property(this, getChronology().dayOfMonth()); [EOL] }
public Property minuteOfHour() { [EOL]     return new Property(this, getChronology().minuteOfHour()); [EOL] }
public Property secondOfMinute() { [EOL]     return new Property(this, getChronology().secondOfMinute()); [EOL] }
public LocalDateTime getLocalDateTime() { [EOL]     return iInstant; [EOL] }
public LocalDateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDateTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public LocalDateTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
protected CalendarConverter() { [EOL]     super(); [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if ("UTC".equalsIgnoreCase(id)) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return null; [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if ("UTC".equalsIgnoreCase(id)) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return null; [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if ("UTC".equalsIgnoreCase(id)) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return null; [EOL] }
private DateTimeFormatter(DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iOffsetParsed = offsetParsed; [EOL]     iChrono = chrono; [EOL]     iZone = zone; [EOL]     iPivotYear = pivotYear; [EOL]     iDefaultYear = defaultYear; [EOL] }
private DateTimeFormatter(DateTimePrinter printer, DateTimeParser parser, Locale locale, boolean offsetParsed, Chronology chrono, DateTimeZone zone, Integer pivotYear, int defaultYear) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iOffsetParsed = offsetParsed; [EOL]     iChrono = chrono; [EOL]     iZone = zone; [EOL]     iPivotYear = pivotYear; [EOL]     iDefaultYear = defaultYear; [EOL] }
public DateTimeFormatter withOffsetParsed() { [EOL]     if (iOffsetParsed == true) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withOffsetParsed() { [EOL]     if (iOffsetParsed == true) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear); [EOL] }
public boolean isOffsetParsed() { [EOL]     return iOffsetParsed; [EOL] }
public boolean isOffsetParsed() { [EOL]     return iOffsetParsed; [EOL] }
public DateTimeFormatter withChronology(Chronology chrono) { [EOL]     if (iChrono == chrono) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withChronology(Chronology chrono) { [EOL]     if (iChrono == chrono) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withZone(DateTimeZone zone) { [EOL]     if (iZone == zone) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withZone(DateTimeZone zone) { [EOL]     if (iZone == zone) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeZone getZone() { [EOL]     return iZone; [EOL] }
public DateTimeFormatter withPivotYear(Integer pivotYear) { [EOL]     if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withPivotYear(Integer pivotYear) { [EOL]     if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withPivotYear(Integer pivotYear) { [EOL]     if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withPivotYear(Integer pivotYear) { [EOL]     if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withPivotYear(int pivotYear) { [EOL]     return withPivotYear(Integer.valueOf(pivotYear)); [EOL] }
public DateTimeFormatter withPivotYear(int pivotYear) { [EOL]     return withPivotYear(Integer.valueOf(pivotYear)); [EOL] }
public void printTo(Appendable appendable, ReadableInstant instant) throws IOException { [EOL]     appendable.append(print(instant)); [EOL] }
public void printTo(Appendable appendable, ReadableInstant instant) throws IOException { [EOL]     appendable.append(print(instant)); [EOL] }
public void printTo(Appendable appendable, ReadableInstant instant) throws IOException { [EOL]     appendable.append(print(instant)); [EOL] }
public void printTo(Appendable appendable, long instant) throws IOException { [EOL]     appendable.append(print(instant)); [EOL] }
public void printTo(Appendable appendable, long instant) throws IOException { [EOL]     appendable.append(print(instant)); [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial) { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     printer.printTo(buf, partial, iLocale); [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial) { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     printer.printTo(buf, partial, iLocale); [EOL] }
public void printTo(Appendable appendable, ReadablePartial partial) throws IOException { [EOL]     appendable.append(print(partial)); [EOL] }
public void printTo(Appendable appendable, ReadablePartial partial) throws IOException { [EOL]     appendable.append(print(partial)); [EOL] }
public void printTo(Appendable appendable, ReadablePartial partial) throws IOException { [EOL]     appendable.append(print(partial)); [EOL] }
public String print(ReadablePartial partial) { [EOL]     StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength()); [EOL]     printTo(buf, partial); [EOL]     return buf.toString(); [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalTime parseLocalTime(String text) { [EOL]     return parseLocalDateTime(text).toLocalTime(); [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
private DateTimeParser requireParser() { [EOL]     DateTimeParser parser = iParser; [EOL]     if (parser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL]     return parser; [EOL] }
private DateTimeParser requireParser() { [EOL]     DateTimeParser parser = iParser; [EOL]     if (parser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL]     return parser; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
protected BaseChronology() { [EOL]     super(); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     return millisOfDay().set(instant, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     return millisOfDay().set(instant, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     return millisOfDay().set(instant, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     return millisOfDay().set(instant, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = year().set(0, year); [EOL]     instant = monthOfYear().set(instant, monthOfYear); [EOL]     instant = dayOfMonth().set(instant, dayOfMonth); [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     instant = hourOfDay().set(instant, hourOfDay); [EOL]     instant = minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = secondOfMinute().set(instant, secondOfMinute); [EOL]     return millisOfSecond().set(instant, millisOfSecond); [EOL] }
public long add(ReadablePeriod period, long instant, int scalar) { [EOL]     if (scalar != 0 && period != null) { [EOL]         for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]             long value = period.getValue(i); [EOL]             if (value != 0) { [EOL]                 instant = period.getFieldType(i).getField(this).add(instant, value * scalar); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(ReadablePeriod period, long instant, int scalar) { [EOL]     if (scalar != 0 && period != null) { [EOL]         for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]             long value = period.getValue(i); [EOL]             if (value != 0) { [EOL]                 instant = period.getFieldType(i).getField(this).add(instant, value * scalar); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(ReadablePeriod period, long instant, int scalar) { [EOL]     if (scalar != 0 && period != null) { [EOL]         for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]             long value = period.getValue(i); [EOL]             if (value != 0) { [EOL]                 instant = period.getFieldType(i).getField(this).add(instant, value * scalar); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(ReadablePeriod period, long instant, int scalar) { [EOL]     if (scalar != 0 && period != null) { [EOL]         for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]             long value = period.getValue(i); [EOL]             if (value != 0) { [EOL]                 instant = period.getFieldType(i).getField(this).add(instant, value * scalar); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(ReadablePeriod period, long instant, int scalar) { [EOL]     if (scalar != 0 && period != null) { [EOL]         for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]             long value = period.getValue(i); [EOL]             if (value != 0) { [EOL]                 instant = period.getFieldType(i).getField(this).add(instant, value * scalar); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public DurationField eras() { [EOL]     return UnsupportedDurationField.getInstance(DurationFieldType.eras()); [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value; [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public boolean equals(Object duration) { [EOL]     if (this == duration) { [EOL]         return true; [EOL]     } [EOL]     if (duration instanceof ReadableDuration == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableDuration other = (ReadableDuration) duration; [EOL]     return (getMillis() == other.getMillis()); [EOL] }
public boolean equals(Object duration) { [EOL]     if (this == duration) { [EOL]         return true; [EOL]     } [EOL]     if (duration instanceof ReadableDuration == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableDuration other = (ReadableDuration) duration; [EOL]     return (getMillis() == other.getMillis()); [EOL] }
protected ReadableIntervalConverter() { [EOL]     super(); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     ReadableInterval input = (ReadableInterval) object; [EOL]     writableInterval.setInterval(input); [EOL]     if (chrono != null) { [EOL]         writableInterval.setChronology(chrono); [EOL]     } else { [EOL]         writableInterval.setChronology(input.getChronology()); [EOL]     } [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     ReadableInterval input = (ReadableInterval) object; [EOL]     writableInterval.setInterval(input); [EOL]     if (chrono != null) { [EOL]         writableInterval.setChronology(chrono); [EOL]     } else { [EOL]         writableInterval.setChronology(input.getChronology()); [EOL]     } [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
public String eraValueToText(int value) { [EOL]     return iEras[value]; [EOL] }
public String eraValueToText(int value) { [EOL]     return iEras[value]; [EOL] }
public int getEraMaxTextLength() { [EOL]     return iMaxEraLength; [EOL] }
public int getMonthMaxShortTextLength() { [EOL]     return iMaxShortMonthLength; [EOL] }
protected AbstractInstant() { [EOL]     super(); [EOL] }
public DateTimeZone getZone() { [EOL]     return getChronology().getZone(); [EOL] }
public DateTimeZone getZone() { [EOL]     return getChronology().getZone(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public int get(DateTimeField field) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The DateTimeField must not be null"); [EOL]     } [EOL]     return field.get(getMillis()); [EOL] }
public int get(DateTimeField field) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The DateTimeField must not be null"); [EOL]     } [EOL]     return field.get(getMillis()); [EOL] }
public DateTime toDateTime() { [EOL]     return new DateTime(getMillis(), getZone()); [EOL] }
public MutableDateTime toMutableDateTimeISO() { [EOL]     return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone())); [EOL] }
public MutableDateTime toMutableDateTimeISO() { [EOL]     return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone())); [EOL] }
public boolean isAfter(long instant) { [EOL]     return (getMillis() > instant); [EOL] }
public boolean isAfter(long instant) { [EOL]     return (getMillis() > instant); [EOL] }
public boolean isAfter(long instant) { [EOL]     return (getMillis() > instant); [EOL] }
public boolean isAfterNow() { [EOL]     return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isAfter(instantMillis); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isAfter(instantMillis); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isAfter(instantMillis); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isAfter(instantMillis); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.dateTime().print(this); [EOL] }
public MutableInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(start, period); [EOL] }
public MutableInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(start, period); [EOL] }
public void setInterval(long startInstant, long endInstant) { [EOL]     super.setInterval(startInstant, endInstant, getChronology()); [EOL] }
public void setInterval(long startInstant, long endInstant) { [EOL]     super.setInterval(startInstant, endInstant, getChronology()); [EOL] }
public void setChronology(Chronology chrono) { [EOL]     super.setInterval(getStartMillis(), getEndMillis(), chrono); [EOL] }
public void setChronology(Chronology chrono) { [EOL]     super.setInterval(getStartMillis(), getEndMillis(), chrono); [EOL] }
public void setDurationBeforeEnd(long duration) { [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration)); [EOL] }
public void setDurationBeforeEnd(long duration) { [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration)); [EOL] }
public void setDurationBeforeEnd(long duration) { [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration)); [EOL] }
public static DateMidnight now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateMidnight(chronology); [EOL] }
public static DateMidnight now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateMidnight(chronology); [EOL] }
@FromString [EOL] public static DateMidnight parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
@FromString [EOL] public static DateMidnight parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
@FromString [EOL] public static DateMidnight parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
public DateMidnight(long instant) { [EOL]     super(instant); [EOL] }
public DateMidnight(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public DateMidnight(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public DateMidnight(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateMidnight(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateMidnight(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateMidnight(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone); [EOL] }
protected long checkInstant(long instant, Chronology chronology) { [EOL]     return chronology.dayOfMonth().roundFloor(instant); [EOL] }
public DateMidnight withZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return this; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     return new DateMidnight(millis, getChronology().withZone(newZone)); [EOL] }
public DateMidnight withZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return this; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     return new DateMidnight(millis, getChronology().withZone(newZone)); [EOL] }
public DateMidnight withFields(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         return this; [EOL]     } [EOL]     return withMillis(getChronology().set(partial, getMillis())); [EOL] }
public DateMidnight withFields(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         return this; [EOL]     } [EOL]     return withMillis(getChronology().set(partial, getMillis())); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateMidnight minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateMidnight minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateMidnight minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
@Deprecated [EOL] public YearMonthDay toYearMonthDay() { [EOL]     return new YearMonthDay(getMillis(), getChronology()); [EOL] }
public DateMidnight withEra(int era) { [EOL]     return withMillis(getChronology().era().set(getMillis(), era)); [EOL] }
public DateMidnight withEra(int era) { [EOL]     return withMillis(getChronology().era().set(getMillis(), era)); [EOL] }
public DateMidnight withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateMidnight withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateMidnight withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateMidnight withYearOfEra(int yearOfEra) { [EOL]     return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra)); [EOL] }
public DateMidnight withYearOfEra(int yearOfEra) { [EOL]     return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra)); [EOL] }
public DateMidnight withYearOfCentury(int yearOfCentury) { [EOL]     return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury)); [EOL] }
public DateMidnight withYearOfCentury(int yearOfCentury) { [EOL]     return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury)); [EOL] }
public DateMidnight withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateMidnight withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateMidnight withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateMidnight withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateMidnight withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateMidnight withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateMidnight withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateMidnight withMonthOfYear(int monthOfYear) { [EOL]     return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public DateMidnight withMonthOfYear(int monthOfYear) { [EOL]     return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public DateMidnight withMonthOfYear(int monthOfYear) { [EOL]     return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public DateMidnight withDayOfYear(int dayOfYear) { [EOL]     return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public DateMidnight withDayOfYear(int dayOfYear) { [EOL]     return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public DateMidnight withDayOfMonth(int dayOfMonth) { [EOL]     return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public DateMidnight withDayOfMonth(int dayOfMonth) { [EOL]     return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public DateMidnight withDayOfWeek(int dayOfWeek) { [EOL]     return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public DateMidnight withDayOfWeek(int dayOfWeek) { [EOL]     return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public Property weekyear() { [EOL]     return new Property(this, getChronology().weekyear()); [EOL] }
public DateMidnight addWrapFieldToCopy(int value) { [EOL]     return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addWrapFieldToCopy(int value) { [EOL]     return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addWrapFieldToCopy(int value) { [EOL]     return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value)); [EOL] }
public DateMidnight roundHalfEvenCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis())); [EOL] }
