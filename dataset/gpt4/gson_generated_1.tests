public void testGetTypeInfoForFieldWithGenericType() { [EOL] Field field = MyClass.class.getDeclaredField("genericField"); [EOL] Type typeDefiningF = MyClass.class.getGenericSuperclass(); [EOL] TypeInfo typeInfo = TypeInfo.getTypeInfoForField(field, typeDefiningF); [EOL] Type expectedType = ((ParameterizedType) typeDefiningF).getActualTypeArguments()[0]; [EOL] assertEquals(expectedType, typeInfo.getType()); [EOL] } [EOL] public void testGetTypeInfoForFieldWithNonGenericType() { [EOL] Field field = MyClass.class.getDeclaredField("nonGenericField"); [EOL] Type typeDefiningF = MyClass.class; [EOL] TypeInfo typeInfo = TypeInfo.getTypeInfoForField(field, typeDefiningF); [EOL] Type expectedType = field.getType(); [EOL] assertEquals(expectedType, typeInfo.getType()); [EOL] }
public void testGetTypeInfoForFieldWithInheritedGenericType() { [EOL] Field field = MySubclass.class.getDeclaredField("inheritedGenericField"); [EOL] Type typeDefiningF = MySubclass.class.getGenericSuperclass(); [EOL] TypeInfo typeInfo = TypeInfo.getTypeInfoForField(field, typeDefiningF); [EOL] Type expectedType = ((ParameterizedType) typeDefiningF).getActualTypeArguments()[0]; [EOL] assertEquals(expectedType, typeInfo.getType()); [EOL] }
public void testGetActualTypeWithClass() { [EOL] Type result = getActualType(String.class, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithParameterizedType() { [EOL] Type typeToEvaluate = new ParameterizedTypeImpl(List.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeToEvaluate, null, List.class); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedResult = (ParameterizedType) result; [EOL] assertEquals(List.class, parameterizedResult.getRawType()); [EOL] assertArrayEquals(new Type[]{String.class}, parameterizedResult.getActualTypeArguments()); [EOL] }
public void testGetActualTypeWithGenericArrayType() { [EOL] Type componentType = new GenericArrayTypeImpl(String.class); [EOL] Type typeToEvaluate = new GenericArrayTypeImpl(componentType); [EOL] Type result = getActualType(typeToEvaluate, null, null); [EOL] assertTrue(result instanceof GenericArrayType); [EOL] GenericArrayType arrayResult = (GenericArrayType) result; [EOL] assertEquals(componentType, arrayResult.getGenericComponentType()); [EOL] }
public void testGetActualTypeWithTypeVariable() { [EOL] TypeVariable<Class<TypeVariableDummy>> typeVariable = TypeVariableDummy.class.getTypeParameters()[0]; [EOL] Type parentType = new ParameterizedTypeImpl(TypeVariableDummy.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeVariable, parentType, TypeVariableDummy.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithWildcardType() { [EOL] WildcardType wildcardType = new WildcardTypeImpl(new Type[]{String.class}, new Type[]{}); [EOL] Type result = getActualType(wildcardType, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithUnsupportedType() { [EOL] Type unsupportedType = new UnsupportedTypeImpl(); [EOL] try { [EOL] getActualType(unsupportedType, null, null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] class ParameterizedTypeImpl implements ParameterizedType { [EOL] } [EOL] class GenericArrayTypeImpl implements GenericArrayType { [EOL] } [EOL] class WildcardTypeImpl implements WildcardType { [EOL] } [EOL] class UnsupportedTypeImpl implements Type { [EOL] } [EOL] class TypeVariableDummy<T> { [EOL] }
public void testExtractRealTypesWithNonNullArguments() { [EOL] Type[] actualTypeArguments = new Type[] {String.class, Integer.class}; [EOL] Type parentType = List.class.getGenericSuperclass(); [EOL] Class<?> rawParentClass = List.class; [EOL] Type[] result = extractRealTypes(actualTypeArguments, parentType, rawParentClass); [EOL] assertNotNull(result); [EOL] assertEquals(actualTypeArguments.length, result.length); [EOL] for (int i = 0; i < actualTypeArguments.length; i++) { [EOL] assertEquals(actualTypeArguments[i], result[i]); [EOL] } [EOL] }
public void testExtractRealTypesWithNullArguments() { [EOL] try { [EOL] extractRealTypes(null, List.class.getGenericSuperclass(), List.class); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testVisitArrayFieldWithNullFieldAndSerializeNullsTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new MockJsonSerializationContext(true); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context).addChildAsElement(eq(f), any(JsonNull.class)); [EOL] }
public void testVisitArrayFieldWithNonNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] Object array = new Object(); [EOL] JsonSerializationContext context = new MockJsonSerializationContext(false); [EOL] when(context.getFieldValue(f, obj)).thenReturn(array); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context).addAsChildOfObject(eq(f), any(ObjectTypePair.class)); [EOL] }
public void testVisitArrayFieldWithNullFieldAndSerializeNullsFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new MockJsonSerializationContext(false); [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] verify(context, never()).addChildAsElement(eq(f), any(JsonNull.class)); [EOL] }
public void testVisitArrayFieldThrowsCircularReferenceException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new MockJsonSerializationContext(false); [EOL] CircularReferenceException exception = new CircularReferenceException(); [EOL] doThrow(exception).when(context).getFieldValue(f, obj); [EOL] try { [EOL] context.visitArrayField(f, typeOfF, obj); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] assertEquals(exception.createDetailedException(f), e); [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_RootIsJsonObject_SerializeNullsTrue_NullField() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(null); [EOL] serializeNulls = true; [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] }
public void testVisitFieldUsingCustomHandler_RootIsJsonObject_SerializeNullsFalse_NullField() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(null); [EOL] serializeNulls = false; [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] }
public void testVisitFieldUsingCustomHandler_RootIsJsonObject_CustomSerializerReturnsNonNull() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement customSerializedElement = new JsonObject(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(new Object()); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(customSerializedElement); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] verify(this, times(1)).findAndInvokeCustomSerializer(any(ObjectTypePair.class)); [EOL] }
public void testVisitFieldUsingCustomHandler_RootIsJsonObject_CustomSerializerReturnsNull() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(new Object()); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(null); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] verify(this, times(1)).findAndInvokeCustomSerializer(any(ObjectTypePair.class)); [EOL] }
public void testVisitFieldUsingCustomHandler_RootIsNotJsonObject_ThrowsException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(false); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] verify(root, times(1)).isJsonObject(); [EOL] }
public void testVisitFieldUsingCustomHandler_IllegalAccessException_ThrowsRuntimeException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenThrow(new IllegalAccessException()); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] }
public void testVisitFieldUsingCustomHandler_CircularReferenceException_ThrowsDetailedException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] CircularReferenceException cre = mock(CircularReferenceException.class); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenThrow(cre); [EOL] when(cre.createDetailedException(f)).thenReturn(new CircularReferenceException()); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] verify(root, times(1)).isJsonObject(); [EOL] verify(f, times(1)).get(parent); [EOL] verify(cre, times(1)).createDetailedException(f); [EOL] }
public void testJsonWriterConstructorWithNonNullWriter() { [EOL] Writer writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] assertNotNull(jsonWriter); [EOL] }
public void testJsonWriterConstructorWithNullWriter() { [EOL] try { [EOL] new JsonWriter(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("out == null", e.getMessage()); [EOL] } [EOL] }
public void testBeginArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter result = writer.beginArray(); [EOL] assertNotNull(result); [EOL] assertEquals(JsonScope.EMPTY_ARRAY, result.peek()); [EOL] }
public void testEndArrayEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] }
public void testEndArrayNonEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.value(1); [EOL] writer.endArray(); [EOL] }
public void testOpenWithEmptyScopeAndOpenBracket() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter result = writer.open(JsonScope.EMPTY_ARRAY, "["); [EOL] assertNotNull(result); [EOL] assertEquals("[", result.getOutput().toString()); [EOL] }
public void testOpenWithEmptyScopeAndOpenBrace() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter result = writer.open(JsonScope.EMPTY_OBJECT, "{"); [EOL] assertNotNull(result); [EOL] assertEquals("{", result.getOutput().toString()); [EOL] }
public void testOpenWithNonEmptyScope() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.open(JsonScope.EMPTY_ARRAY, "["); [EOL] JsonWriter result = writer.open(JsonScope.NONEMPTY_ARRAY, "["); [EOL] assertNotNull(result); [EOL] assertEquals("[[", result.getOutput().toString()); [EOL] }
public void testCloseWithEmptyContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] try { [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }
public void testCloseWithNonemptyContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.value(1); [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] assertEquals("Should match", "[1\n]", writer.toString()); [EOL] }
public void testCloseWithInvalidContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.beginObject(); [EOL] try { [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] fail("Expected IllegalStateException due to invalid context"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }
private JsonScope peek() { [EOL] return stack.get(stack.size() - 1); [EOL] }
public void testReplaceTopWithEmptyStack() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.replaceTop(JsonScope.EMPTY_DOCUMENT); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }
public void testReplaceTopWithNonEmptyStack() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setIndent("  "); [EOL] writer.beginArray(); // Push JsonScope.EMPTY_ARRAY onto the stack [EOL] writer.replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL] try { [EOL] writer.value(true); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }
public void testValueWithNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter returnedWriter = writer.value((Number) null); [EOL] assertNull(returnedWriter); [EOL] }
public void testValueWithNegativeInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NEGATIVE_INFINITY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was -Infinity", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException was thrown"); [EOL] } [EOL] }
public void testValueWithPositiveInfinity() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.POSITIVE_INFINITY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was Infinity", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException was thrown"); [EOL] } [EOL] }
public void testValueWithNaN() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NaN); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Numeric values must be finite, but was NaN", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException was thrown"); [EOL] } [EOL] }
public void testValueWithFiniteNumber() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] Number finiteNumber = 123; [EOL] JsonWriter returnedWriter = writer.value(finiteNumber); [EOL] assertNotNull(returnedWriter); [EOL] assertEquals(writer, returnedWriter); [EOL] }
public void testStringWithSpecialCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("text\"with\\special\tcharacters\b\n\r\f"); [EOL] assertEquals("\"text\\\"with\\\\special\\tcharacters\\b\\n\\r\\f\"", writer.toString()); [EOL] }
public void testStringWithHtmlCharactersHtmlSafe() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.setHtmlSafe(true); [EOL] jsonWriter.string("text<with>special&chars='"); [EOL] assertEquals("\"text\\u003cwith\\u003especial\\u0026chars=\\u0027\"", writer.toString()); [EOL] }
public void testStringWithHtmlCharactersNotHtmlSafe() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.setHtmlSafe(false); [EOL] jsonWriter.string("text<with>special&chars='"); [EOL] assertEquals("\"text<with>special&chars='\"", writer.toString()); [EOL] }
public void testStringWithControlCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("text\u001fwithControlChars"); [EOL] assertEquals("\"text\\u001fwithControlChars\"", writer.toString()); [EOL] }
public void testStringWithNonControlCharacters() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] JsonWriter jsonWriter = new JsonWriter(writer); [EOL] jsonWriter.string("textWithNonControlChars"); [EOL] assertEquals("\"textWithNonControlChars\"", writer.toString()); [EOL] }
public void testNewlineWithNoIndent() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent(null); [EOL] jsonWriter.newline(); // This should not write anything as indent is null [EOL] assertEquals("", jsonWriter.getBuffer().toString()); [EOL] }
public void testNewlineWithIndent() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent("  "); // Set indent to two spaces [EOL] jsonWriter.beginArray(); // This will add one element to the stack [EOL] jsonWriter.newline(); [EOL] assertEquals("\n  ", jsonWriter.getBuffer().toString()); // Expect newline and one level of indentation [EOL] }
public void testNewlineWithMultipleIndents() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent("  "); // Set indent to two spaces [EOL] jsonWriter.beginArray(); // This will add one element to the stack [EOL] jsonWriter.beginArray(); // This will add another element to the stack [EOL] jsonWriter.newline(); [EOL] assertEquals("\n    ", jsonWriter.getBuffer().toString()); // Expect newline and two levels of indentation [EOL] }
public void testBeforeValueWithEmptyDocumentAndLenient() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndNotRoot() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must start with an array or an object.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithNonemptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.value(true); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithDanglingName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithNonemptyDocument() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] try { [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must have only one top-level value.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testBeforeValueWithInvalidState() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] try { [EOL] writer.close(); [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testShouldSkipFieldWithSkippableModifier() { [EOL] FieldAttributes mockFieldAttributes = Mockito.mock(FieldAttributes.class); [EOL] int[] modifiers = new int[] { Modifier.PUBLIC, Modifier.PRIVATE }; [EOL] Excluder excluder = new Excluder().withModifiers(modifiers); [EOL] Mockito.when(mockFieldAttributes.hasModifier(Modifier.PUBLIC)).thenReturn(true); [EOL] boolean result = excluder.shouldSkipField(mockFieldAttributes); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipFieldWithNonSkippableModifier() { [EOL] FieldAttributes mockFieldAttributes = Mockito.mock(FieldAttributes.class); [EOL] int[] modifiers = new int[] { Modifier.PUBLIC, Modifier.PRIVATE }; [EOL] Excluder excluder = new Excluder().withModifiers(modifiers); [EOL] Mockito.when(mockFieldAttributes.hasModifier(Modifier.PROTECTED)).thenReturn(false); [EOL] boolean result = excluder.shouldSkipField(mockFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testJsonReaderConstructorWithNullReader() { [EOL] try { [EOL] new JsonReader(null); [EOL] fail("JsonReader constructor should throw NullPointerException on null Reader"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("in == null", e.getMessage()); [EOL] } [EOL] }
public void testJsonReaderConstructorWithNonNullReader() { [EOL] Reader reader = new StringReader("{}"); [EOL] JsonReader jsonReader = new JsonReader(reader); [EOL] assertNotNull(jsonReader); [EOL] }
private void testConsumeNonExecutePrefixWithNonMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("NonMatching")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(jsonReader.peek(), JsonToken.BEGIN_ARRAY); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'\n[")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(jsonReader.peek(), JsonToken.BEGIN_ARRAY); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithPartialPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(jsonReader.peek(), JsonToken.BEGIN_ARRAY); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithEmptyInput() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(jsonReader.peek(), JsonToken.END_DOCUMENT); [EOL] }
public void testNextNameWithValidName() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] reader.beginObject(); [EOL] String name = reader.nextName(); [EOL] assertEquals("name", name); [EOL] }
public void testNextNameWithInvalidToken() { [EOL] JsonReader reader = new JsonReader(new StringReader("[true]")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextName(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNextNameAtEndOfObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] reader.beginObject(); [EOL] reader.nextName(); [EOL] reader.nextBoolean(); [EOL] reader.endObject(); [EOL] try { [EOL] reader.nextName(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNextNullWithNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("null")); [EOL] jsonReader.nextNull(); [EOL] }
public void testNextNullWithNonNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"notnull\"")); [EOL] try { [EOL] jsonReader.nextNull(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Not a null: notnull", e.getMessage()); [EOL] } [EOL] }
public void testNextNullWithEmptyReader() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] try { [EOL] jsonReader.nextNull(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNextNullWithInvalidToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"string\"")); [EOL] try { [EOL] jsonReader.nextNull(); [EOL] fail("Expected IllegalStateException for invalid token"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected null but was STRING", e.getMessage()); [EOL] } [EOL] }
public void testNextDoubleWithValidDouble() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("123.45")); [EOL] reader.beginArray(); [EOL] double result = reader.nextDouble(); [EOL] assertEquals(123.45, result, 0.0); [EOL] reader.endArray(); [EOL] }
public void testNextDoubleWithInvalidState() { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalStateException, not IOException"); [EOL] } [EOL] }
public void testNextDoubleWithOctalNumber() { [EOL] JsonReader reader = new JsonReader(new StringReader("0123.45")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Expected NumberFormatException for octal number"); [EOL] } catch (NumberFormatException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected NumberFormatException, not IOException"); [EOL] } [EOL] reader.endArray(); [EOL] }
public void testNextDoubleWithNaNAndLenientOff() { [EOL] JsonReader reader = new JsonReader(new StringReader("NaN")); [EOL] reader.setLenient(false); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Expected NumberFormatException for NaN with lenient off"); [EOL] } catch (NumberFormatException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected NumberFormatException, not IOException"); [EOL] } [EOL] reader.endArray(); [EOL] }
public void testNextDoubleWithInfinityAndLenientOff() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("Infinity")); [EOL] reader.setLenient(false); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Expected NumberFormatException for Infinity with lenient off"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] reader.endArray(); [EOL] }
public void testNextLongWithValidLong() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345")); [EOL] reader.beginArray(); [EOL] long result = reader.nextLong(); [EOL] assertEquals(12345L, result); [EOL] }
public void testNextLongWithInvalidState() { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextLong(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNextLongWithNumberFormatException() { [EOL] JsonReader reader = new JsonReader(new StringReader("not_a_number")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextLong(); [EOL] fail("Expected NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testNextLongWithDoubleConversion() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345.67")); [EOL] reader.beginArray(); [EOL] long result = reader.nextLong(); [EOL] assertEquals(12345L, result); [EOL] }
public void testNextLongWithOctalNumber() { [EOL] JsonReader reader = new JsonReader(new StringReader("012345")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextLong(); [EOL] fail("Expected NumberFormatException due to octal number"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testNextInt_ValidInt() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("123")); [EOL] reader.beginArray(); [EOL] int result = reader.nextInt(); [EOL] assertEquals(123, result); [EOL] }
public void testNextInt_InvalidState() { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextInt(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected an int but was BOOLEAN", e.getMessage()); [EOL] } [EOL] }
public void testNextInt_NumberFormatException() { [EOL] JsonReader reader = new JsonReader(new StringReader("\"abc\"")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextInt(); [EOL] fail("Expected NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testNextInt_DoubleToInt() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("123.456")); [EOL] reader.beginArray(); [EOL] int result = reader.nextInt(); [EOL] assertEquals(123, result); [EOL] }
public void testNextInt_OctalNumberFormatException() { [EOL] JsonReader reader = new JsonReader(new StringReader("0123")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextInt(); [EOL] fail("Expected NumberFormatException for octal number"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("JSON forbids octal prefixes: 0123", e.getMessage()); [EOL] } [EOL] }
public void testNextInArray_FirstElementEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[]")); [EOL] reader.beginArray(); [EOL] assertEquals(JsonToken.END_ARRAY, reader.nextInArray(true)); [EOL] }
public void testNextInArray_FirstElementNonEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null]")); [EOL] reader.beginArray(); [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(true)); [EOL] }
public void testNextInArray_NonFirstElementEndArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null,]")); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.END_ARRAY, reader.nextInArray(false)); [EOL] }
public void testNextInArray_NonFirstElementWithComma() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null,,null]")); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(false)); [EOL] }
public void testNextInArray_NonFirstElementWithSemicolon() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null;null]")); [EOL] reader.setLenient(true); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(false)); [EOL] }
public void testNextInArray_WithSyntaxError() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null null]")); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] try { [EOL] reader.nextInArray(false); [EOL] fail("Should have thrown a syntax error"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL] if (firstElement) { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] default: [EOL] pos--; [EOL] } [EOL] } else { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] case ';': [EOL] case ',': [EOL] break; [EOL] default: [EOL] throw syntaxError("Unterminated object"); [EOL] } [EOL] } [EOL] int quote = nextNonWhitespace(); [EOL] switch(quote) { [EOL] case '\'': [EOL] checkLenient(); [EOL] case '"': [EOL] name = nextString((char) quote); [EOL] break; [EOL] default: [EOL] checkLenient(); [EOL] pos--; [EOL] name = nextLiteral(); [EOL] if (name.length() == 0) { [EOL] throw syntaxError("Expected name"); [EOL] } [EOL] } [EOL] replaceTop(JsonScope.DANGLING_NAME); [EOL] hasToken = true; [EOL] return token = JsonToken.NAME; [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
public void testFillBufferWithNonEmptyBuffer() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.buffer = new char[]{'a', 'b', 'c'}; [EOL] jsonReader.pos = 1; [EOL] jsonReader.limit = 3; [EOL] boolean result = jsonReader.fillBuffer(2); [EOL] assertTrue(result); [EOL] assertEquals(2, jsonReader.limit); [EOL] assertEquals('b', jsonReader.buffer[0]); [EOL] assertEquals('c', jsonReader.buffer[1]); [EOL] }
public void testFillBufferWithEmptyBuffer() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("abc")); [EOL] jsonReader.buffer = new char[3]; [EOL] boolean result = jsonReader.fillBuffer(1); [EOL] assertTrue(result); [EOL] assertEquals(3, jsonReader.limit); [EOL] assertEquals('a', jsonReader.buffer[0]); [EOL] assertEquals('b', jsonReader.buffer[1]); [EOL] assertEquals('c', jsonReader.buffer[2]); [EOL] }
public void testFillBufferWithExactMinimum() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("abc")); [EOL] jsonReader.buffer = new char[3]; [EOL] boolean result = jsonReader.fillBuffer(3); [EOL] assertTrue(result); [EOL] assertEquals(3, jsonReader.limit); [EOL] }
public void testFillBufferWithInsufficientData() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("ab")); [EOL] jsonReader.buffer = new char[3]; [EOL] boolean result = jsonReader.fillBuffer(4); [EOL] assertFalse(result); [EOL] assertEquals(2, jsonReader.limit); [EOL] }
public void testFillBufferWithReaderReturningMinusOne() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.buffer = new char[3]; [EOL] boolean result = jsonReader.fillBuffer(1); [EOL] assertFalse(result); [EOL] assertEquals(0, jsonReader.limit); [EOL] }
public void testNextNonWhitespaceWithWhitespaceCharacters() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader(" \r\n\t")); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] assertEquals('\r', reader.nextNonWhitespace()); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] assertEquals('\t', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSlash() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/")); [EOL] reader.setLenient(true); [EOL] assertEquals('/', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithAsteriskComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/* comment */")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should have thrown syntax error for unterminated comment"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testNextNonWhitespaceWithSlashComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("// comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithHash() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("# comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithEOF() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should have thrown EOFException"); [EOL] } catch (EOFException e) { [EOL] } [EOL] }
private String nextString(char quote) throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] if (c == quote) { [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start - 1); [EOL] } else { [EOL] builder.append(buffer, start, pos - start - 1); [EOL] return builder.toString(); [EOL] } [EOL] } else if (c == '\\') { [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start - 1); [EOL] builder.append(readEscapeCharacter()); [EOL] start = pos; [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] throw syntaxError("Unterminated string"); [EOL] }
private String nextLiteral() throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] switch(c) { [EOL] case '/': [EOL] case '\\': [EOL] case ';': [EOL] case '#': [EOL] case '=': [EOL] checkLenient(); [EOL] case '{': [EOL] case '}': [EOL] case '[': [EOL] case ']': [EOL] case ':': [EOL] case ',': [EOL] case ' ': [EOL] case '\t': [EOL] case '\f': [EOL] case '\r': [EOL] case '\n': [EOL] pos--; [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start); [EOL] } else { [EOL] builder.append(buffer, start, pos - start); [EOL] return builder.toString(); [EOL] } [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] return builder.toString(); [EOL] }
public void testReadEscapeCharacter_UnterminatedEscapeSequence() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\\u123")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.readEscapeCharacter(); [EOL] fail("Expected IOException for unterminated escape sequence"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testReadEscapeCharacter_UnexpectedCharacter() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\\x")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.readEscapeCharacter(); [EOL] fail("Expected IOException for unexpected escape character"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testReadEscapeCharacter_ValidEscapeSequences() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\\u0041\\t\\b\\n\\r\\f\\'\\\"\\\\")); [EOL] reader.setLenient(true); [EOL] assertEquals('A', reader.readEscapeCharacter()); [EOL] assertEquals('\t', reader.readEscapeCharacter()); [EOL] assertEquals('\b', reader.readEscapeCharacter()); [EOL] assertEquals('\n', reader.readEscapeCharacter()); [EOL] assertEquals('\r', reader.readEscapeCharacter()); [EOL] assertEquals('\f', reader.readEscapeCharacter()); [EOL] assertEquals('\'', reader.readEscapeCharacter()); [EOL] assertEquals('\"', reader.readEscapeCharacter()); [EOL] assertEquals('\\', reader.readEscapeCharacter()); [EOL] }
public void testReadEscapeCharacter_ValidUnicode() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\\u0041")); [EOL] reader.setLenient(true); [EOL] assertEquals('A', reader.readEscapeCharacter()); [EOL] }
public void testReadEscapeCharacter_InvalidUnicode() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\\uXYZZ")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.readEscapeCharacter(); [EOL] fail("Expected NumberFormatException for invalid unicode escape sequence"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
private void testDecodeLiteralWithNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("null")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NULL, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithBooleanTrueValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithBooleanFalseValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("false")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithNumberValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("123.45")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NUMBER, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithStringValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("notANumber")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.STRING, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithNumberFormatException() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("notANumber")); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.decodeLiteral(); [EOL] fail("Should have thrown a NumberFormatException"); [EOL] } catch (NumberFormatException ignored) { [EOL] } [EOL] }
public void testVisitObjectFieldWithJsonObject() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonObject(); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ((JsonObject) json).addProperty("fieldName", "fieldValue"); [EOL] visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithNonJsonObject() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonPrimitive("Not a JsonObject"); [EOL] try { [EOL] visitObjectField(f, typeOfF, obj); [EOL] fail("Expected JsonParseException was not thrown."); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testVisitObjectFieldWithNullChild() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonObject(); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithIllegalAccessException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonObject(); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ((JsonObject) json).addProperty("fieldName", "fieldValue"); [EOL] doThrow(new IllegalAccessException()).when(f).set(any(), any()); [EOL] try { [EOL] visitObjectField(f, typeOfF, obj); [EOL] fail("Expected RuntimeException was not thrown."); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_JsonParseException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement json = new JsonPrimitive("not a JsonObject"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(json); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_NullChild() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", JsonNull.INSTANCE); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_NoMatchingHandler() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] adapter.deserializers = new HashMap<TypeToken<?>, JsonDeserializer<?>>(); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandler_SuccessfulDeserialization() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] Map<TypeToken<?>, JsonDeserializer<?>> deserializers = new HashMap<>(); [EOL] TypeToken<?> typeToken = TypeToken.get(declaredTypeOfField); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] deserializers.put(typeToken, deserializer); [EOL] adapter.deserializers = deserializers; [EOL] when(deserializer.deserialize(any(JsonElement.class), any(Type.class), any(JsonDeserializationContext.class))) [EOL] .thenReturn(new Object()); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_IllegalAccessException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] Map<TypeToken<?>, JsonDeserializer<?>> deserializers = new HashMap<>(); [EOL] TypeToken<?> typeToken = TypeToken.get(declaredTypeOfField); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] deserializers.put(typeToken, deserializer); [EOL] adapter.deserializers = deserializers; [EOL] when(deserializer.deserialize(any(JsonElement.class), any(Type.class), any(JsonDeserializationContext.class))) [EOL] .thenReturn(new Object()); [EOL] doThrow(new IllegalAccessException()).when(f).set(anyObject(), anyObject()); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown RuntimeException"); [EOL] } catch (RuntimeException expected) { [EOL] } [EOL] }
public void testVisitPrimitiveWithJsonPrimitive() { [EOL] JsonElement json = new JsonPrimitive(10); [EOL] Visitor visitor = new Visitor(json); [EOL] visitor.visitPrimitive(10); [EOL] assertEquals(10, visitor.getTarget()); [EOL] } [EOL] public void testVisitPrimitiveWithNonJsonPrimitive() { [EOL] JsonElement json = new JsonArray(); [EOL] Visitor visitor = new Visitor(json); [EOL] try { [EOL] visitor.visitPrimitive(10); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGetDefaultSerializersWithSpecialFloatingPointValues() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = YourClass.getDefaultSerializers(true, LongSerializationPolicy.DEFAULT); [EOL] assertNotNull(serializers.getHandlerFor(Double.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(double.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(Float.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(float.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(Long.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(long.class, false)); [EOL] }
public void testGetDefaultSerializersWithoutSpecialFloatingPointValues() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = YourClass.getDefaultSerializers(false, LongSerializationPolicy.DEFAULT); [EOL] assertNotNull(serializers.getHandlerFor(Double.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(double.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(Float.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(float.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(Long.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(long.class, false)); [EOL] }
public void testGetDefaultSerializersWithLongSerializationPolicyString() { [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = YourClass.getDefaultSerializers(false, LongSerializationPolicy.STRING); [EOL] assertNotNull(serializers.getHandlerFor(Long.class, false)); [EOL] assertNotNull(serializers.getHandlerFor(long.class, false)); [EOL] }
public void testGetDefaultDeserializers() { [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = GsonBuilder.getDefaultDeserializers(); [EOL] assertNotNull(deserializers); [EOL] }
static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() { [EOL] return DEFAULT_INSTANCE_CREATORS; [EOL] }
public void testDeserializeWithNonJsonPrimitive() { [EOL] JsonElement json = new JsonArray(); // Not a JsonPrimitive [EOL] Type typeOfT = Time.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("The date should be a string value", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithValidJsonPrimitive() { [EOL] JsonElement json = new JsonPrimitive("1970-01-01T00:00:00Z"); [EOL] Type typeOfT = Time.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US); [EOL] format.setTimeZone(TimeZone.getTimeZone("UTC")); [EOL] Time result = deserialize(json, typeOfT, context); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getTime()); // Assuming the format.parse will return the epoch [EOL] }
public void testDeserializeWithInvalidJsonPrimitive() { [EOL] JsonElement json = new JsonPrimitive("invalid-date"); [EOL] Type typeOfT = Time.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] assertNotNull(e.getCause()); [EOL] assertTrue(e.getCause() instanceof ParseException); [EOL] } [EOL] }
public void testDeserializeWithValidJson() { [EOL] JsonElement json = new JsonObject(); [EOL] json.getAsJsonObject().addProperty("year", 2021); [EOL] json.getAsJsonObject().addProperty("month", 5); [EOL] json.getAsJsonObject().addProperty("dayOfMonth", 20); [EOL] json.getAsJsonObject().addProperty("hourOfDay", 13); [EOL] json.getAsJsonObject().addProperty("minute", 45); [EOL] json.getAsJsonObject().addProperty("second", 30); [EOL] Type typeOfT = GregorianCalendar.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContext() { [EOL] }; [EOL] GregorianCalendar calendar = deserialize(json, typeOfT, context); [EOL] assertEquals(2021, calendar.get(Calendar.YEAR)); [EOL] assertEquals(5, calendar.get(Calendar.MONTH)); [EOL] assertEquals(20, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] assertEquals(13, calendar.get(Calendar.HOUR_OF_DAY)); [EOL] assertEquals(45, calendar.get(Calendar.MINUTE)); [EOL] assertEquals(30, calendar.get(Calendar.SECOND)); [EOL] }
public void testSerializeWithValidURI() { [EOL] Gson gson = new Gson(); [EOL] Type uriType = new TypeToken<URI>() {}.getType(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] public JsonElement serialize(JsonElement src) { [EOL] return src; [EOL] } [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return gson.toJsonTree(src, typeOfSrc); [EOL] } [EOL] }; [EOL] URI uri = URI.create("http://www.google.com"); [EOL] JsonElement result = gson.toJsonTree(uri, uriType, context); [EOL] assertEquals("\"http://www.google.com\"", result.toString()); [EOL] }
public void testSerializeWithNullURI() { [EOL] Gson gson = new Gson(); [EOL] Type uriType = new TypeToken<URI>() {}.getType(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] public JsonElement serialize(JsonElement src) { [EOL] return src; [EOL] } [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return gson.toJsonTree(src, typeOfSrc); [EOL] } [EOL] }; [EOL] URI uri = null; [EOL] JsonElement result = gson.toJsonTree(uri, uriType, context); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testDeserializeValidURI() { [EOL] JsonElement json = new JsonPrimitive("http://www.google.com"); [EOL] Type typeOfT = URI.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] URI result = deserialize(json, typeOfT, context); [EOL] assertEquals("http://www.google.com", result.toString()); [EOL] }
public void testDeserializeInvalidURI() { [EOL] JsonElement json = new JsonPrimitive("invalid_uri"); [EOL] Type typeOfT = URI.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] URI result = deserialize(json, typeOfT, context); [EOL] fail("JsonSyntaxException expected"); [EOL] } catch (JsonSyntaxException e) { [EOL] } [EOL] }
public void testSerializeWithNonNullLocale() { [EOL] Locale src = new Locale("en", "US"); [EOL] Type typeOfSrc = new TypeToken<Locale>() {}.getType(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return new JsonPrimitive(src.toString()); [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return new JsonPrimitive(src.toString()); [EOL] } [EOL] }; [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertEquals("\"en_US\"", result.toString()); [EOL] }
public void testSerializeWithNullLocale() { [EOL] Locale src = null; [EOL] Type typeOfSrc = new TypeToken<Locale>() {}.getType(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return src == null ? JsonNull.INSTANCE : new JsonPrimitive(src.toString()); [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return src == null ? JsonNull.INSTANCE : new JsonPrimitive(src.toString()); [EOL] } [EOL] }; [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertEquals(JsonNull.INSTANCE, result); [EOL] }
public void testSerializeWithNonParameterizedMap() { [EOL] Map src = new HashMap(); [EOL] src.put("key1", "value1"); [EOL] src.put("key2", "value2"); [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize("value1", String.class)).thenReturn(new JsonPrimitive("value1")); [EOL] when(context.serialize("value2", String.class)).thenReturn(new JsonPrimitive("value2")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("key1", new JsonPrimitive("value1")); [EOL] expected.add("key2", new JsonPrimitive("value2")); [EOL] assertEquals(expected, result); [EOL] }
public void testSerializeWithParameterizedMap() { [EOL] Map<String, Integer> src = new HashMap<>(); [EOL] src.put("one", 1); [EOL] src.put("two", 2); [EOL] Type typeOfSrc = new TypeToken<Map<String, Integer>>() {}.getType(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(1, Integer.class)).thenReturn(new JsonPrimitive(1)); [EOL] when(context.serialize(2, Integer.class)).thenReturn(new JsonPrimitive(2)); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("one", new JsonPrimitive(1)); [EOL] expected.add("two", new JsonPrimitive(2)); [EOL] assertEquals(expected, result); [EOL] }
public void testSerializeWithNullValues() { [EOL] Map src = new HashMap(); [EOL] src.put("key1", null); [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("key1", JsonNull.createJsonNull()); [EOL] assertEquals(expected, result); [EOL] }
private LongSerializer(LongSerializationPolicy longSerializationPolicy) { [EOL] this.longSerializationPolicy = longSerializationPolicy; [EOL] }
public void testFloatSerializerWithTrue() { [EOL] FloatSerializer serializer = new FloatSerializer(true); [EOL] assertTrue(serializer.serializeSpecialFloatingPointValues); [EOL] }
public void testFloatSerializerWithFalse() { [EOL] FloatSerializer serializer = new FloatSerializer(false); [EOL] assertFalse(serializer.serializeSpecialFloatingPointValues); [EOL] }
public void testSerializeWithFiniteFloat() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float finiteFloat = 123.45f; [EOL] JsonElement result = gson.serialize(finiteFloat, Float.class, null); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123.45", result.getAsString()); [EOL] }
public void testSerializeWithNaN() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float nanValue = Float.NaN; [EOL] try { [EOL] gson.serialize(nanValue, Float.class, null); [EOL] fail("Expected IllegalArgumentException for NaN value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Float.NaN + " is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithPositiveInfinity() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float positiveInfinity = Float.POSITIVE_INFINITY; [EOL] try { [EOL] gson.serialize(positiveInfinity, Float.class, null); [EOL] fail("Expected IllegalArgumentException for positive infinity value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Float.POSITIVE_INFINITY + " is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNegativeInfinity() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float negativeInfinity = Float.NEGATIVE_INFINITY; [EOL] try { [EOL] gson.serialize(negativeInfinity, Float.class, null); [EOL] fail("Expected IllegalArgumentException for negative infinity value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Float.NEGATIVE_INFINITY + " is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithSpecialFloatingPointValuesAllowed() { [EOL] Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL] Float nanValue = Float.NaN; [EOL] JsonElement resultNaN = gson.serialize(nanValue, Float.class, null); [EOL] assertTrue(resultNaN.isJsonPrimitive()); [EOL] assertEquals("NaN", resultNaN.getAsString()); [EOL] Float positiveInfinity = Float.POSITIVE_INFINITY; [EOL] JsonElement resultPositiveInfinity = gson.serialize(positiveInfinity, Float.class, null); [EOL] assertTrue(resultPositiveInfinity.isJsonPrimitive()); [EOL] assertEquals("Infinity", resultPositiveInfinity.getAsString()); [EOL] Float negativeInfinity = Float.NEGATIVE_INFINITY; [EOL] JsonElement resultNegativeInfinity = gson.serialize(negativeInfinity, Float.class, null); [EOL] assertTrue(resultNegativeInfinity.isJsonPrimitive()); [EOL] assertEquals("-Infinity", resultNegativeInfinity.getAsString()); [EOL] }
public void testDeserializeValidFloat() { [EOL] JsonElement json = new JsonPrimitive(10.5f); [EOL] Type typeOfT = Float.class; [EOL] JsonDeserializationContext context = new Gson().getAdapter(Float.class); [EOL] Float result = deserialize(json, typeOfT, context); [EOL] assertEquals(10.5f, result, 0.0f); [EOL] }
public void testDeserializeInvalidFloat() { [EOL] JsonElement json = new JsonPrimitive("not a float"); [EOL] Type typeOfT = Float.class; [EOL] JsonDeserializationContext context = new Gson().getAdapter(Float.class); [EOL] try { [EOL] Float result = deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = Float.class; [EOL] JsonDeserializationContext context = new Gson().getAdapter(Float.class); [EOL] try { [EOL] Float result = deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDoubleSerializerWithTrue() { [EOL] DoubleSerializer serializer = new DoubleSerializer(true); [EOL] assertTrue(serializer.serializeSpecialFloatingPointValues); [EOL] }
public void testDoubleSerializerWithFalse() { [EOL] DoubleSerializer serializer = new DoubleSerializer(false); [EOL] assertFalse(serializer.serializeSpecialFloatingPointValues); [EOL] }
public void testSerializeWithNormalDouble() { [EOL] Double src = 123.45; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(src, result.getAsDouble(), 0.0); [EOL] }
public void testSerializeWithNaN() { [EOL] Double src = Double.NaN; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Double.toString(src) + " is not a valid double value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithInfinity() { [EOL] Double src = Double.POSITIVE_INFINITY; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Double.toString(src) + " is not a valid double value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNegativeInfinity() { [EOL] Double src = Double.NEGATIVE_INFINITY; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.serialize(src, typeOfSrc, context); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals(Double.toString(src) + " is not a valid double value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialDoubleValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithSpecialDoubleValuesEnabled() { [EOL] Double src = Double.NaN; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertTrue(Double.isNaN(result.getAsDouble())); [EOL] }
public void testShouldSkipField_NoAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(null); [EOL] Excluder excluder = new Excluder(); [EOL] boolean result = excluder.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithAnnotation_SerializeFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Expose annotation = mock(Expose.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(annotation); [EOL] when(annotation.serialize()).thenReturn(false); [EOL] Excluder excluder = new Excluder(); [EOL] boolean result = excluder.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithAnnotation_SerializeTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Expose annotation = mock(Expose.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(annotation); [EOL] when(annotation.serialize()).thenReturn(true); [EOL] Excluder excluder = new Excluder(); [EOL] boolean result = excluder.shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testGetRawTypeWithClass() { [EOL] Class<?> result = getRawType(String.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetRawTypeWithParameterizedType() { [EOL] Type type = new TypeToken<Map<String, String>>(){}.getType(); [EOL] Class<?> result = getRawType(type); [EOL] assertEquals(Map.class, result); [EOL] }
public void testGetRawTypeWithGenericArrayType() { [EOL] Type type = new TypeToken<List<String>[]>(){}.getType(); [EOL] Class<?> result = getRawType(type); [EOL] assertTrue(result.isArray()); [EOL] }
public void testGetRawTypeWithUnexpectedType() { [EOL] Type type = new TypeToken<Void>(){}.getType(); [EOL] try { [EOL] getRawType(type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructTargetWithNonJsonArrayInput() { [EOL] JsonElement json = new JsonPrimitive("not a json array"); [EOL] Type targetType = String.class; [EOL] ObjectConstructor objectConstructor = new ObjectConstructor() { [EOL] @Override [EOL] public <T> T construct(Class<T> type) { [EOL] return type.cast("constructed"); [EOL] } [EOL] @Override [EOL] public <T> T[] constructArray(Type componentType, int length) { [EOL] return (T[]) Array.newInstance((Class<?>) componentType, length); [EOL] } [EOL] }; [EOL] YourClass yourClassInstance = new YourClass(targetType, json, objectConstructor); [EOL] try { [EOL] yourClassInstance.constructTarget(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Expecting array found: not a json array", e.getMessage()); [EOL] } [EOL] }
public void testConstructTargetWithJsonArrayAndArrayType() { [EOL] JsonElement json = new JsonArray(); [EOL] Type targetType = String[].class; [EOL] ObjectConstructor objectConstructor = new ObjectConstructor() { [EOL] @Override [EOL] public <T> T construct(Class<T> type) { [EOL] return type.cast("constructed"); [EOL] } [EOL] @Override [EOL] public <T> T[] constructArray(Type componentType, int length) { [EOL] return (T[]) Array.newInstance((Class<?>) componentType, length); [EOL] } [EOL] }; [EOL] YourClass yourClassInstance = new YourClass(targetType, json, objectConstructor); [EOL] Object result = yourClassInstance.constructTarget(); [EOL] assertTrue(result.getClass().isArray()); [EOL] assertEquals(String[].class, result.getClass()); [EOL] }
public void testConstructTargetWithJsonArrayAndNonArrayType() { [EOL] JsonElement json = new JsonArray(); [EOL] Type targetType = List.class; [EOL] ObjectConstructor objectConstructor = new ObjectConstructor() { [EOL] @Override [EOL] public <T> T construct(Class<T> type) { [EOL] return type.cast(new ArrayList<>()); [EOL] } [EOL] @Override [EOL] public <T> T[] constructArray(Type componentType, int length) { [EOL] return (T[]) Array.newInstance((Class<?>) componentType, length); [EOL] } [EOL] }; [EOL] YourClass yourClassInstance = new YourClass(targetType, json, objectConstructor); [EOL] Object result = yourClassInstance.constructTarget(); [EOL] assertTrue(result instanceof List); [EOL] }
public void testVisitArrayWithJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add(2); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] visitArray(array, arrayType); [EOL] assertEquals(Array.get(array, 0), 1); [EOL] assertEquals(Array.get(array, 1), 2); [EOL] } [EOL] public void testVisitArrayWithEmptyJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] visitArray(array, arrayType); [EOL] assertEquals(Array.getLength(array), 0); [EOL] } [EOL] public void testVisitArrayWithInvalidJson() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(1); [EOL] Object array = Array.newInstance(Integer.class, 1); [EOL] Type arrayType = Integer[].class; [EOL] try { [EOL] visitArray(array, arrayType); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testVisitArrayWithJsonNull() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(JsonNull.INSTANCE); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] visitArray(array, arrayType); [EOL] assertNull(Array.get(array, 0)); [EOL] } [EOL] public void testVisitArrayWithJsonObject() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] jsonArray.add(jsonObject); [EOL] Object array = Array.newInstance(JsonObject.class, jsonArray.size()); [EOL] Type arrayType = JsonObject[].class; [EOL] visitArray(array, arrayType); [EOL] assertEquals(((JsonObject) Array.get(array, 0)).get("key").getAsString(), "value"); [EOL] } [EOL] public void testVisitArrayWithNestedJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonArray nestedJsonArray = new JsonArray(); [EOL] nestedJsonArray.add(3); [EOL] jsonArray.add(nestedJsonArray); [EOL] Object array = Array.newInstance(Integer[].class, jsonArray.size()); [EOL] Type arrayType = Integer[][].class; [EOL] visitArray(array, arrayType); [EOL] Integer[] nestedArray = (Integer[]) Array.get(array, 0); [EOL] assertEquals((int) nestedArray[0], 3); [EOL] } [EOL] public void testVisitArrayWithJsonPrimitive() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(4)); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] visitArray(array, arrayType); [EOL] assertEquals(Array.get(array, 0), 4); [EOL] } [EOL] public void testVisitArrayWithUnsupportedType() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("unsupported")); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] try { [EOL] visitArray(array, arrayType); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testVisitPrimitiveWithNonPrimitive() { [EOL] JsonParseException expectedException = null; [EOL] Object nonPrimitive = new Object(); [EOL] try { [EOL] new JsonTreeWriter().visitPrimitive(nonPrimitive); [EOL] } catch (JsonParseException e) { [EOL] expectedException = e; [EOL] } [EOL] assertNotNull(expectedException); [EOL] assertEquals("Type information is unavailable, and the target is not a primitive: " + nonPrimitive.toString(), expectedException.getMessage()); [EOL] }
public void testParseString() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"testString\"")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("testString", result.getAsString()); [EOL] }
public void testParseNumber() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(12345, result.getAsInt()); [EOL] }
public void testParseBoolean() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertTrue(result.getAsBoolean()); [EOL] }
public void testParseNull() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("null")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testParseArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[\"item1\", 2, true, null]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals(4, array.size()); [EOL] assertEquals("item1", array.get(0).getAsString()); [EOL] assertEquals(2, array.get(1).getAsInt()); [EOL] assertTrue(array.get(2).getAsBoolean()); [EOL] assertTrue(array.get(3).isJsonNull()); [EOL] }
public void testParseObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key1\":\"value1\",\"key2\":2,\"key3\":true,\"key4\":null}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] JsonObject object = result.getAsJsonObject(); [EOL] assertEquals("value1", object.get("key1").getAsString()); [EOL] assertEquals(2, object.get("key2").getAsInt()); [EOL] assertTrue(object.get("key3").getAsBoolean()); [EOL] assertTrue(object.get("key4").isJsonNull()); [EOL] }
public void testParseEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(0, result.getAsJsonArray().size()); [EOL] }
public void testParseEmptyObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] assertEquals(0, result.getAsJsonObject().entrySet().size()); [EOL] }
public void testParseInvalidInput() { [EOL] JsonReader reader = new JsonReader(new StringReader("{")); [EOL] try { [EOL] parse(reader); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseEOFException() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testParseNumberFormatException() { [EOL] JsonReader reader = new JsonReader(new StringReader("[1.2e-3.4]")); [EOL] try { [EOL] parse(reader); [EOL] fail("Expected JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] } [EOL] }
public void testWriteNullElementWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, true, writer); [EOL] verify(writer).nullValue(); [EOL] }
public void testWriteNullElementWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, false, writer); [EOL] verify(writer, never()).nullValue(); [EOL] }
public void testWriteJsonPrimitiveNumber() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(10); [EOL] write(element, true, writer); [EOL] verify(writer).value(10); [EOL] }
public void testWriteJsonPrimitiveBoolean() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(true); [EOL] write(element, true, writer); [EOL] verify(writer).value(true); [EOL] }
public void testWriteJsonPrimitiveString() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] write(element, true, writer); [EOL] verify(writer).value("test"); [EOL] }
public void testWriteJsonArray() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add("string"); [EOL] JsonElement element = jsonArray; [EOL] write(element, true, writer); [EOL] verify(writer).beginArray(); [EOL] verify(writer).value(1); [EOL] verify(writer).value("string"); [EOL] verify(writer).endArray(); [EOL] }
public void testWriteJsonObjectWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] jsonObject.add("key2", new JsonPrimitive(2)); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).nullValue(); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value(2); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] jsonObject.add("key2", new JsonPrimitive(2)); [EOL] JsonElement element = jsonObject; [EOL] write(element, false, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer, never()).name("key1"); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value(2); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteIllegalArgument() { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = mock(JsonElement.class); [EOL] when(element.isJsonNull()).thenReturn(false); [EOL] when(element.isJsonPrimitive()).thenReturn(false); [EOL] when(element.isJsonArray()).thenReturn(false); [EOL] when(element.isJsonObject()).thenReturn(false); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] write(element, true, writer); [EOL] }); [EOL] assertEquals("Couldn't write " + element.getClass(), exception.getMessage()); [EOL] }
public void testToStringEmptyArray() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = mock(Escaper.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.toString(sb, escaper); [EOL] assertEquals("[]", sb.toString()); [EOL] }
public void testToStringSingleElementArray() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = mock(Escaper.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonElement element = mock(JsonElement.class); [EOL] jsonArray.add(element); [EOL] jsonArray.toString(sb, escaper); [EOL] verify(element).toString(sb, escaper); [EOL] assertTrue(sb.toString().startsWith("[")); [EOL] assertTrue(sb.toString().endsWith("]")); [EOL] }
public void testToStringMultipleElementsArray() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = mock(Escaper.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonElement firstElement = mock(JsonElement.class); [EOL] JsonElement secondElement = mock(JsonElement.class); [EOL] jsonArray.add(firstElement); [EOL] jsonArray.add(secondElement); [EOL] jsonArray.toString(sb, escaper); [EOL] verify(firstElement).toString(sb, escaper); [EOL] verify(secondElement).toString(sb, escaper); [EOL] assertEquals("[,]", sb.toString()); [EOL] }
public void testNext_ThrowsNoSuchElementException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNext_ReturnsValidJsonElement() throws JsonParseException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.setLenient(true); [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] JsonElement element = parser.next(); [EOL] assertNotNull(element); [EOL] assertTrue(element.isJsonArray()); [EOL] }
public void testNext_ThrowsJsonParseExceptionOnStackOverflowError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")) { [EOL] @Override [EOL] public void beginArray() throws IOException { [EOL] throw new StackOverflowError(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsJsonParseExceptionOnOutOfMemoryError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")) { [EOL] @Override [EOL] public void beginArray() throws IOException { [EOL] throw new OutOfMemoryError(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsJsonParseExceptionOnJsonParseException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,")); [EOL] jsonReader.setLenient(true); [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsNoSuchElementExceptionOnEOFException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3")) { [EOL] @Override [EOL] public JsonElement peek() throws IOException { [EOL] throw new EOFException(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testHasNextWithNonEndDocumentToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] assertTrue(jsonReader.hasNext()); [EOL] }
public void testHasNextWithEndDocumentToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] assertFalse(jsonReader.hasNext()); [EOL] }
public void testHasNextThrowsJsonSyntaxException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{")); [EOL] try { [EOL] jsonReader.hasNext(); [EOL] fail("Should have thrown JsonSyntaxException"); [EOL] } catch (JsonSyntaxException expected) { [EOL] } [EOL] }
public void testHasNextThrowsJsonIOException() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")) { [EOL] @Override [EOL] public JsonToken peek() throws IOException { [EOL] throw new IOException("Forced IOException for testing"); [EOL] } [EOL] }; [EOL] try { [EOL] jsonReader.hasNext(); [EOL] fail("Should have thrown JsonIOException"); [EOL] } catch (JsonIOException expected) { [EOL] } [EOL] }
public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) { [EOL] if (!modifiable) { [EOL] throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL] } [EOL] int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first); [EOL] if (index >= 0) { [EOL] logger.log(Level.WARNING, "Overriding the existing type handler for {0}", pair.first); [EOL] typeHierarchyList.remove(index); [EOL] } [EOL] index = getIndexOfAnOverriddenHandler(pair.first); [EOL] if (index >= 0) { [EOL] throw new IllegalArgumentException("The specified type handler for type " + pair.first + " hides the previously registered type hierarchy handler for " + typeHierarchyList.get(index).first + ". Gson does not allow this."); [EOL] } [EOL] typeHierarchyList.add(0, pair); [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithEmptyTypeHierarchyList() { [EOL] typeHierarchyList.clear(); // Make sure the list is empty [EOL] int index = getIndexOfAnOverriddenHandler(Object.class); [EOL] assertEquals(-1, index); // Expecting -1 since the list is empty [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithNonEmptyListAndTypeNotPresent() { [EOL] typeHierarchyList.add(new Pair<>(String.class, someHandlerInstance)); [EOL] int index = getIndexOfAnOverriddenHandler(Integer.class); [EOL] assertEquals(-1, index); // Expecting -1 since Integer.class is not assignable from String.class [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithNonEmptyListAndTypePresent() { [EOL] typeHierarchyList.add(new Pair<>(Number.class, someHandlerInstance)); [EOL] typeHierarchyList.add(new Pair<>(Integer.class, someHandlerInstance)); [EOL] int index = getIndexOfAnOverriddenHandler(Integer.class); [EOL] assertTrue(index >= 0); // Expecting a non-negative index since Integer.class is present [EOL] }
public void testGetIndexOfAnOverriddenHandler_WithInheritance() { [EOL] typeHierarchyList.add(new Pair<>(Number.class, someHandlerInstance)); [EOL] typeHierarchyList.add(new Pair<>(Object.class, someHandlerInstance)); [EOL] int index = getIndexOfAnOverriddenHandler(Integer.class); [EOL] assertEquals(0, index); // Expecting index 0 since Integer is assignable from Number and it's the last added [EOL] }
public void testJsonSyntaxExceptionWithCause() { [EOL] Throwable cause = new Exception("Cause"); [EOL] JsonSyntaxException exception = new JsonSyntaxException(cause); [EOL] assertNotNull(exception.getCause()); [EOL] assertEquals("Cause", exception.getCause().getMessage()); [EOL] }
public void testEquals_withNonParameterizedTypeObject() { [EOL] ParameterizedTypeImpl parameterizedType = createDummyParameterizedType(); [EOL] Object nonParameterizedTypeObject = new Object(); [EOL] assertFalse(parameterizedType.equals(nonParameterizedTypeObject)); [EOL] } [EOL] public void testEquals_withItself() { [EOL] ParameterizedTypeImpl parameterizedType = createDummyParameterizedType(); [EOL] assertTrue(parameterizedType.equals(parameterizedType)); [EOL] } [EOL] public void testEquals_withDifferentParameterizedType_SameData() { [EOL] ParameterizedTypeImpl parameterizedType1 = createDummyParameterizedType(); [EOL] ParameterizedTypeImpl parameterizedType2 = createDummyParameterizedType(); [EOL] assertTrue(parameterizedType1.equals(parameterizedType2)); [EOL] } [EOL] public void testEquals_withDifferentParameterizedType_DifferentOwner() { [EOL] ParameterizedTypeImpl parameterizedType1 = createDummyParameterizedType(); [EOL] ParameterizedTypeImpl parameterizedType2 = createDummyParameterizedTypeWithDifferentOwner(); [EOL] assertFalse(parameterizedType1.equals(parameterizedType2)); [EOL] } [EOL] public void testEquals_withDifferentParameterizedType_DifferentRawType() { [EOL] ParameterizedTypeImpl parameterizedType1 = createDummyParameterizedType(); [EOL] ParameterizedTypeImpl parameterizedType2 = createDummyParameterizedTypeWithDifferentRawType(); [EOL] assertFalse(parameterizedType1.equals(parameterizedType2)); [EOL] } [EOL] public void testEquals_withDifferentParameterizedType_DifferentActualArguments() { [EOL] ParameterizedTypeImpl parameterizedType1 = createDummyParameterizedType(); [EOL] ParameterizedTypeImpl parameterizedType2 = createDummyParameterizedTypeWithDifferentArguments(); [EOL] assertFalse(parameterizedType1.equals(parameterizedType2)); [EOL] }

public void testGetActualTypeForFirstTypeVariableWithClass() { [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(String.class); [EOL] assertEquals(Object.class, result); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithParameterizedType() throws NoSuchFieldException { [EOL] Type type = YourClass.class.getDeclaredField("someFieldWithParameterizedType").getGenericType(); [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(type); [EOL] assertTrue(result instanceof Class<?>); [EOL] assertEquals(ExpectedType.class, result); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithGenericArrayType() throws NoSuchFieldException { [EOL] Type type = YourClass.class.getDeclaredField("someFieldWithGenericArrayType").getGenericType(); [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(type); [EOL] assertTrue(result instanceof GenericArrayType); [EOL] assertTrue(((GenericArrayType) result).getGenericComponentType() instanceof ParameterizedType); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithInvalidType() { [EOL] Type type = new Type() { [EOL] }; [EOL] try { [EOL] YourClass.getActualTypeForFirstTypeVariable(type); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsArrayWithClassType() { [EOL] assertTrue($CLASS$.isArray(int[].class)); [EOL] assertFalse($CLASS$.isArray(int.class)); [EOL] }
public void testIsArrayWithGenericArrayType() throws NoSuchFieldException { [EOL] Type genericArrayType = ((ParameterizedType) getClass().getDeclaredField("listOfArrays").getGenericType()).getActualTypeArguments()[0]; [EOL] assertTrue($CLASS$.isArray(genericArrayType)); [EOL] }
public void testIsArrayWithNonArrayType() { [EOL] assertFalse($CLASS$.isArray(String.class)); [EOL] }
public void testToRawClassWithClassType() { [EOL] Class<?> expected = String.class; [EOL] Class<?> actual = toRawClass(String.class); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithParameterizedType() { [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] Class<?> expected = List.class; [EOL] Class<?> actual = toRawClass(type); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithGenericArrayType() { [EOL] Type type = new TypeToken<List<String>[]>() {}.getType(); [EOL] Class<?> expected = List[].class; [EOL] Class<?> actual = toRawClass(type); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithWildcardType() { [EOL] Type type = new TypeToken<?>(){ }.getType(); [EOL] Type wildcardType = ((WildcardType)type).getUpperBounds()[0]; [EOL] Class<?> expected = Object.class; [EOL] Class<?> actual = toRawClass(wildcardType); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithInvalidType() { [EOL] Type type = new TypeToken<Map.Entry<String, String>>() {}.getType(); [EOL] try { [EOL] toRawClass(type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWrapWithArrayWithNonNullClass() { [EOL] Class<?> wrappedClass = wrapWithArray(String.class); [EOL] assertTrue(wrappedClass.isArray()); [EOL] assertEquals(String[].class, wrappedClass); [EOL] }
public void testWrapWithArrayWithPrimitiveType() { [EOL] Class<?> wrappedClass = wrapWithArray(int.class); [EOL] assertTrue(wrappedClass.isArray()); [EOL] assertEquals(int[].class, wrappedClass); [EOL] }
public void testToJsonTreeWithNullObject() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.toJsonTree(null); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testToJsonTreeWithNonNullObject() { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] JsonElement result = gson.toJsonTree(src); [EOL] assertNotNull(result); [EOL] assertFalse(result.isJsonNull()); [EOL] }
public void testToJsonTreeWithNullObject() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.toJsonTree(null, Object.class); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testToJsonTreeWithNonNullObject() { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonElement result = gson.toJsonTree(src, typeOfSrc); [EOL] assertNotNull(result); [EOL] assertFalse(result.isJsonNull()); [EOL] }
public void testToJsonWithNullObjectAndSerializeNullsTrue() { [EOL] Gson gson = new GsonBuilder().serializeNulls().create(); [EOL] String json = gson.toJson(null); [EOL] assertEquals("null", json); [EOL] }
public void testToJsonWithNullObjectAndSerializeNullsFalse() { [EOL] Gson gson = new Gson(); [EOL] String json = gson.toJson(null); [EOL] assertEquals("", json); [EOL] }
public void testToJsonWithNonNullObject() { [EOL] Gson gson = new Gson(); [EOL] String json = gson.toJson(new Object()); [EOL] assertNotNull(json); [EOL] assertFalse(json.isEmpty()); [EOL] }
public void testToJsonWithObjectAndType() { [EOL] Gson gson = new Gson(); [EOL] MyType src = new MyType(); [EOL] Type typeOfSrc = new TypeToken<MyType>() {}.getType(); [EOL] String json = gson.toJson(src, typeOfSrc); [EOL] assertNotNull(json); [EOL] assertFalse(json.isEmpty()); [EOL] }
public void testToJsonWithNullObjectAndType() { [EOL] Gson gson = new Gson(); [EOL] Object src = null; [EOL] Type typeOfSrc = new TypeToken<Object>() {}.getType(); [EOL] String json = gson.toJson(src, typeOfSrc); [EOL] assertEquals("null", json); [EOL] }
public void testToJsonWithObjectAndNullType() { [EOL] Gson gson = new Gson(); [EOL] MyType src = new MyType(); [EOL] Type typeOfSrc = null; [EOL] try { [EOL] gson.toJson(src, typeOfSrc); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void toJson_ObjectTypeJsonWriter_CallsToJsonTreeAndWrites() throws IOException { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] Type typeOfSrc = src.getClass(); [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(stringWriter); [EOL] gson.toJson(src, typeOfSrc, writer); [EOL] writer.flush(); [EOL] String jsonResult = stringWriter.toString(); [EOL] assertNotNull(jsonResult); [EOL] assertFalse(jsonResult.isEmpty()); [EOL] }
public void toJson_NullObjectGiven_InvokesWriteOutNullString() throws IOException { [EOL] Gson gson = new Gson(); [EOL] Object src = null; [EOL] Type typeOfSrc = Object.class; [EOL] StringWriter stringWriter = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(stringWriter); [EOL] gson.toJson(src, typeOfSrc, writer); [EOL] writer.flush(); [EOL] String jsonResult = stringWriter.toString(); [EOL] assertEquals("null", jsonResult); [EOL] }
public void testToJsonWithNonExecutableJsonAndPrettyPrinting() throws IOException { [EOL] Gson gson = new GsonBuilder().generateNonExecutableJson().setPrettyPrinting().create(); [EOL] JsonElement jsonElement = new JsonPrimitive("value"); [EOL] StringWriter writer = new StringWriter(); [EOL] gson.toJson(jsonElement, writer); [EOL] assertEquals(")]=}'value'", writer.toString()); [EOL] }
public void testToJsonWithNonExecutableJsonWithoutPrettyPrinting() throws IOException { [EOL] Gson gson = new GsonBuilder().generateNonExecutableJson().create(); [EOL] JsonElement jsonElement = new JsonPrimitive("value"); [EOL] StringWriter writer = new StringWriter(); [EOL] gson.toJson(jsonElement, writer); [EOL] assertEquals(")]}'value'", writer.toString()); [EOL] }
public void testToJsonWithoutNonExecutableJsonAndPrettyPrinting() throws IOException { [EOL] Gson gson = new GsonBuilder().setPrettyPrinting().create(); [EOL] JsonElement jsonElement = new JsonPrimitive("value"); [EOL] StringWriter writer = new StringWriter(); [EOL] gson.toJson(jsonElement, writer); [EOL] assertEquals("'value'", writer.toString()); [EOL] }
public void testToJsonWithoutNonExecutableJsonWithoutPrettyPrinting() throws IOException { [EOL] Gson gson = new GsonBuilder().create(); [EOL] JsonElement jsonElement = new JsonPrimitive("value"); [EOL] StringWriter writer = new StringWriter(); [EOL] gson.toJson(jsonElement, writer); [EOL] assertEquals("'value'", writer.toString()); [EOL] }
public void toJson(JsonElement jsonElement, JsonWriter writer) { [EOL] boolean oldLenient = writer.isLenient(); [EOL] writer.setLenient(true); [EOL] boolean oldHtmlSafe = writer.isHtmlSafe(); [EOL] writer.setHtmlSafe(htmlSafe); [EOL] try { [EOL] Streams.write(jsonElement, serializeNulls, writer); [EOL] } catch (IOException e) { [EOL] throw new JsonIOException(e); [EOL] } finally { [EOL] writer.setLenient(oldLenient); [EOL] writer.setHtmlSafe(oldHtmlSafe); [EOL] } [EOL] }
public void testDisjunctionExclusionStrategyWithNonNullStrategies() { [EOL] Collection<ExclusionStrategy> strategies = new ArrayList<>(); [EOL] strategies.add(mock(ExclusionStrategy.class)); [EOL] DisjunctionExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies); [EOL] assertNotNull(exclusionStrategy); [EOL] }
public void testDisjunctionExclusionStrategyWithNullStrategies() { [EOL] try { [EOL] new DisjunctionExclusionStrategy(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testShouldSkipField_WithNoExclusionStrategies() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] ExclusionStrategy[] strategies = new ExclusionStrategy[0]; [EOL] Gson gson = new GsonBuilder().setExclusionStrategies(strategies).create(); [EOL] boolean result = gson.shouldSkipField(mockFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_WithOneExclusionStrategy_ReturningTrue() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] ExclusionStrategy mockStrategy = mock(ExclusionStrategy.class); [EOL] when(mockStrategy.shouldSkipField(mockFieldAttributes)).thenReturn(true); [EOL] ExclusionStrategy[] strategies = new ExclusionStrategy[]{mockStrategy}; [EOL] Gson gson = new GsonBuilder().setExclusionStrategies(strategies).create(); [EOL] boolean result = gson.shouldSkipField(mockFieldAttributes); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_WithMultipleExclusionStrategies_AllReturningFalse() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] ExclusionStrategy mockStrategy1 = mock(ExclusionStrategy.class); [EOL] ExclusionStrategy mockStrategy2 = mock(ExclusionStrategy.class); [EOL] when(mockStrategy1.shouldSkipField(mockFieldAttributes)).thenReturn(false); [EOL] when(mockStrategy2.shouldSkipField(mockFieldAttributes)).thenReturn(false); [EOL] ExclusionStrategy[] strategies = new ExclusionStrategy[]{mockStrategy1, mockStrategy2}; [EOL] Gson gson = new GsonBuilder().setExclusionStrategies(strategies).create(); [EOL] boolean result = gson.shouldSkipField(mockFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_WithMultipleExclusionStrategies_OneReturningTrue() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] ExclusionStrategy mockStrategy1 = mock(ExclusionStrategy.class); [EOL] ExclusionStrategy mockStrategy2 = mock(ExclusionStrategy.class); [EOL] when(mockStrategy1.shouldSkipField(mockFieldAttributes)).thenReturn(false); [EOL] when(mockStrategy2.shouldSkipField(mockFieldAttributes)).thenReturn(true); [EOL] ExclusionStrategy[] strategies = new ExclusionStrategy[]{mockStrategy1, mockStrategy2}; [EOL] Gson gson = new GsonBuilder().setExclusionStrategies(strategies).create(); [EOL] boolean result = gson.shouldSkipField(mockFieldAttributes); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_WithNoStrategies() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] boolean result = gson.shouldSkipClass(Object.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testShouldSkipClass_WithExclusionStrategySkippingClass() { [EOL] ExclusionStrategy strategy = new ExclusionStrategy() { [EOL] @Override [EOL] public boolean shouldSkipField(FieldAttributes f) { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean shouldSkipClass(Class<?> clazz) { [EOL] return clazz.equals(Object.class); [EOL] } [EOL] }; [EOL] Gson gson = new GsonBuilder().addSerializationExclusionStrategy(strategy).create(); [EOL] boolean result = gson.shouldSkipClass(Object.class); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_WithExclusionStrategyNotSkippingClass() { [EOL] ExclusionStrategy strategy = new ExclusionStrategy() { [EOL] @Override [EOL] public boolean shouldSkipField(FieldAttributes f) { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean shouldSkipClass(Class<?> clazz) { [EOL] return false; [EOL] } [EOL] }; [EOL] Gson gson = new GsonBuilder().addSerializationExclusionStrategy(strategy).create(); [EOL] boolean result = gson.shouldSkipClass(Object.class); [EOL] assertFalse(result); [EOL] }
public void testCreateJsonNull() { [EOL] JsonNull jsonNull1 = JsonNull.createJsonNull(); [EOL] JsonNull jsonNull2 = JsonNull.createJsonNull(); [EOL] assertSame(jsonNull1, jsonNull2); [EOL] assertSame(JsonNull.INSTANCE, jsonNull1); [EOL] }
public void testJsonParseExceptionWithCause() { [EOL] Throwable cause = new Exception("This is the cause"); [EOL] JsonParseException exception = new JsonParseException(cause); [EOL] assertEquals(cause, exception.getCause()); [EOL] }
public void testVisitChildAsObjectWithJsonObject() { [EOL] Type childType = new TypeToken<Object>() {}.getType(); [EOL] JsonElement jsonChild = new JsonObject(); [EOL] Gson gson = new Gson(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] ConstructorConstructor constructor = new ConstructorConstructor(Collections.emptyMap()); [EOL] ObjectConstructor<Object> objectConstructor = constructor.get(childType); [EOL] Map<Type, InstanceCreator<?>> instanceCreators = Collections.emptyMap(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationVisitorFactory factory = new JsonDeserializationVisitorFactory(); [EOL] JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL] Object result = visitChild(childType, childVisitor); [EOL] assertNotNull(result); [EOL] }
public void testVisitChildAsObjectWithJsonArray() { [EOL] Type childType = new TypeToken<Object>() {}.getType(); [EOL] JsonElement jsonChild = new JsonArray(); [EOL] Gson gson = new Gson(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] ConstructorConstructor constructor = new ConstructorConstructor(Collections.emptyMap()); [EOL] ObjectConstructor<Object> objectConstructor = constructor.get(childType); [EOL] Map<Type, InstanceCreator<?>> instanceCreators = Collections.emptyMap(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationVisitorFactory factory = new JsonDeserializationVisitorFactory(); [EOL] JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL] Object result = visitChild(childType, childVisitor); [EOL] assertNotNull(result); [EOL] }
public void testVisitChildAsObjectWithJsonPrimitive() { [EOL] Type childType = new TypeToken<Object>() {}.getType(); [EOL] JsonElement jsonChild = new JsonPrimitive("test"); [EOL] Gson gson = new Gson(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] ConstructorConstructor constructor = new ConstructorConstructor(Collections.emptyMap()); [EOL] ObjectConstructor<Object> objectConstructor = constructor.get(childType); [EOL] Map<Type, InstanceCreator<?>> instanceCreators = Collections.emptyMap(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationVisitorFactory factory = new JsonDeserializationVisitorFactory(); [EOL] JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL] Object result = visitChild(childType, childVisitor); [EOL] assertNotNull(result); [EOL] }
public void testVisitChildAsObjectWithJsonNull() { [EOL] Type childType = new TypeToken<Object>() {}.getType(); [EOL] JsonElement jsonChild = JsonNull.INSTANCE; [EOL] Gson gson = new Gson(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] ConstructorConstructor constructor = new ConstructorConstructor(Collections.emptyMap()); [EOL] ObjectConstructor<Object> objectConstructor = constructor.get(childType); [EOL] Map<Type, InstanceCreator<?>> instanceCreators = Collections.emptyMap(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationVisitorFactory factory = new JsonDeserializationVisitorFactory(); [EOL] JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL] Object result = visitChild(childType, childVisitor); [EOL] assertNull(result); [EOL] }
public void testAcceptWithExclusionStrategySkippingClass() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] TypeInfo mockTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(mockTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(true); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockExclusionStrategy).shouldSkipClass(Object.class); [EOL] verify(mockVisitor, never()).visitUsingCustomHandler(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithCustomHandler() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(mockVisitor.visitUsingCustomHandler(objTypePair)).thenReturn(true); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockVisitor).visitUsingCustomHandler(objTypePair); [EOL] verify(mockVisitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithNullObjectAndTarget() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(mockVisitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] when(mockVisitor.getTarget()).thenReturn(null); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockVisitor).getTarget(); [EOL] verify(mockVisitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithArray() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] TypeInfo mockTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object[0], Object[].class, false); [EOL] when(mockTypeInfo.getRawClass()).thenReturn(Object[].class); [EOL] when(mockTypeInfo.isArray()).thenReturn(true); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(mockVisitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockVisitor).visitArray(any(), any(Class.class)); [EOL] }
public void testAcceptWithPrimitiveOrString() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] TypeInfo mockTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair("test", String.class, false); [EOL] when(mockTypeInfo.getRawClass()).thenReturn(String.class); [EOL] when(mockTypeInfo.getActualType()).thenReturn(Object.class); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(mockVisitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockVisitor).visitPrimitive("test"); [EOL] }
public void testAcceptWithVisitingObject() { [EOL] ExclusionStrategy mockExclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor mockVisitor = mock(Visitor.class); [EOL] TypeInfo mockTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] when(mockTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(mockTypeInfo.getActualType()).thenReturn(Object.class); [EOL] when(mockExclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(mockVisitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor underTest = new JsonElementVisitor(mockExclusionStrategy, objTypePair); [EOL] underTest.accept(mockVisitor); [EOL] verify(mockVisitor).startVisitingObject(any()); [EOL] }
public void testIsPrimitiveOrString_withObjectClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isPrimitiveOrString(new Object()); [EOL] assertFalse(result); [EOL] }
public void testIsPrimitiveOrString_withStringClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isPrimitiveOrString("Test String"); [EOL] assertTrue(result); [EOL] }
public void testIsPrimitiveOrString_withPrimitiveClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isPrimitiveOrString(10);  // int is a primitive type [EOL] assertTrue(result); [EOL] }
public void testIsPrimitiveOrString_withPrimitiveWrapperClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isPrimitiveOrString(Integer.valueOf(10));  // Integer is a primitive wrapper [EOL] assertTrue(result); [EOL] }
public void testNavigateClassFields_SkipAllFields() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(true); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor, exclusionStrategy); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFields_VisitFieldUsingCustomHandler() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any())).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor, exclusionStrategy); [EOL] verify(visitor, atLeastOnce()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFields_VisitArrayField() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfoFactory typeInfoFactory = mock(TypeInfoFactory.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any())).thenReturn(false); [EOL] when(typeInfoFactory.getTypeInfoForField(any(Field.class), any(Class.class))).thenReturn(typeInfo); [EOL] when(typeInfo.isArray()).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor, exclusionStrategy, typeInfoFactory); [EOL] verify(visitor, atLeastOnce()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFields_VisitObjectField() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfoFactory typeInfoFactory = mock(TypeInfoFactory.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any())).thenReturn(false); [EOL] when(typeInfoFactory.getTypeInfoForField(any(Field.class), any(Class.class))).thenReturn(typeInfo); [EOL] when(typeInfo.isArray()).thenReturn(false); [EOL] navigateClassFields(obj, clazz, visitor, exclusionStrategy, typeInfoFactory); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, atLeastOnce()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testDisableInnerClassSerialization() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.disableInnerClassSerialization(); [EOL] Field serializeInnerClassesField = GsonBuilder.class.getDeclaredField("serializeInnerClasses"); [EOL] serializeInnerClassesField.setAccessible(true); [EOL] assertFalse(serializeInnerClassesField.getBoolean(builder)); [EOL] }
public void testDisableHtmlEscaping() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.disableHtmlEscaping(); [EOL] Gson gson = builder.create(); [EOL] String json = gson.toJson("<html>"); [EOL] assertEquals("<html>", json); [EOL] }
public void testSetDateFormatWithValidPattern() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] GsonBuilder returnedGsonBuilder = gsonBuilder.setDateFormat("yyyy-MM-dd"); [EOL] assertNotNull(returnedGsonBuilder); [EOL] assertSame(gsonBuilder, returnedGsonBuilder); [EOL] }
public void testSetDateFormatWithNull() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] GsonBuilder returnedGsonBuilder = gsonBuilder.setDateFormat(null); [EOL] assertNotNull(returnedGsonBuilder); [EOL] assertSame(gsonBuilder, returnedGsonBuilder); [EOL] }
public void testSetDateFormatWithValidStyle() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] int style = DateFormat.MEDIUM; [EOL] builder.setDateFormat(style); [EOL] assertEquals(style, builder.getDateStyle()); [EOL] assertNull(builder.getDatePattern()); [EOL] }
public void testSetDateFormatWithDifferentValidStyle() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] int style = DateFormat.LONG; [EOL] builder.setDateFormat(style); [EOL] assertEquals(style, builder.getDateStyle()); [EOL] assertNull(builder.getDatePattern()); [EOL] }
public void testCreateWithSerializeInnerClassesAndIgnoreVersions() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(false); [EOL] builder.setVersion(1.0); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithoutSerializeInnerClassesAndIgnoreVersions() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(true); [EOL] builder.setVersion(1.0); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithSerializeInnerClassesAndNotIgnoreVersions() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(false); [EOL] builder.setVersion(VersionConstants.IGNORE_VERSIONS); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithoutSerializeInnerClassesAndNotIgnoreVersions() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(true); [EOL] builder.setVersion(VersionConstants.IGNORE_VERSIONS); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithExcludeFieldsWithoutExposeAnnotation() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.excludeFieldsWithoutExposeAnnotation(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] } [EOL] public void testCreateWithoutExcludeFieldsWithoutExposeAnnotation() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }

public void testAddTypeAdaptersForDateWithPattern() { [EOL] String datePattern = "yyyy-MM-dd"; [EOL] int dateStyle = DateFormat.DEFAULT; [EOL] int timeStyle = DateFormat.DEFAULT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertTrue(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertTrue(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testAddTypeAdaptersForDateWithStyle() { [EOL] String datePattern = null; [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertTrue(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertTrue(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testAddTypeAdaptersForDateWithDefaultStyle() { [EOL] String datePattern = null; [EOL] int dateStyle = DateFormat.DEFAULT; [EOL] int timeStyle = DateFormat.DEFAULT; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers); [EOL] assertFalse(serializers.hasSpecificHandlerFor(Date.class)); [EOL] assertFalse(deserializers.hasSpecificHandlerFor(Date.class)); [EOL] }
public void testIsValidUntilWithNullAnnotation() { [EOL] final double version = 1.0; [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(null); [EOL] assertTrue(result); [EOL] }
public void testIsValidUntilWithValidAnnotation() { [EOL] final double version = 1.0; [EOL] Until annotation = new Until(1.5); // Assuming Until is a class with a constructor that takes a double for the version [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(annotation); [EOL] assertTrue(result); [EOL] }
public void testIsValidUntilWithInvalidAnnotation() { [EOL] final double version = 1.0; [EOL] Until annotation = new Until(0.5); // Assuming Until is a class with a constructor that takes a double for the version [EOL] ExclusionStrategy underTest = new CustomExclusionStrategy(version); [EOL] boolean result = underTest.isValidUntil(annotation); [EOL] assertFalse(result); [EOL] }
public void testTypeInfoWithClassType() { [EOL] Type actualType = String.class; [EOL] TypeInfo typeInfo = new TypeInfo(actualType); [EOL] assertEquals(String.class, typeInfo.rawClass); [EOL] assertEquals(actualType, typeInfo.actualType); [EOL] }
public void testTypeInfoWithParameterizedType() { [EOL] Type actualType = new TypeToken<List<String>>() {}.getType(); [EOL] TypeInfo typeInfo = new TypeInfo(actualType); [EOL] assertEquals(List.class, typeInfo.rawClass); [EOL] assertTrue(actualType instanceof ParameterizedType); [EOL] assertEquals(actualType, typeInfo.actualType); [EOL] }
public void testTypeInfoWithGenericArrayType() { [EOL] Type actualType = new TypeToken<String[]>() {}.getType(); [EOL] TypeInfo typeInfo = new TypeInfo(actualType); [EOL] assertTrue(typeInfo.rawClass.isArray()); [EOL] assertEquals(String[].class, typeInfo.rawClass); [EOL] assertEquals(actualType, typeInfo.actualType); [EOL] }
public void testTypeInfoWithWildcardType() { [EOL] Type actualType = new TypeToken<List<? extends Number>>() {}.getType(); [EOL] ParameterizedType parameterizedType = (ParameterizedType) actualType; [EOL] Type wildcardType = parameterizedType.getActualTypeArguments()[0]; [EOL] TypeInfo typeInfo = new TypeInfo(wildcardType); [EOL] assertTrue(wildcardType instanceof WildcardType); [EOL] assertEquals(wildcardType, typeInfo.actualType); [EOL] assertNotNull(typeInfo.rawClass); [EOL] }
public void testGetActualType() { [EOL] MyClass instance = new MyClass(); [EOL] Type expected = // initialize with the expected Type [EOL] instance.actualType = expected; [EOL] Type result = instance.getActualType(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetRawClass() { [EOL] TypeToken<?> typeToken = new TypeToken<String>() {} ; [EOL] Class<?> rawClass = typeToken.getRawClass(); [EOL] assertEquals(String.class, rawClass); [EOL] }
public void testIsArrayWithArrayType() { [EOL] TypeToken<?> arrayTypeToken = TypeToken.get(String[].class); [EOL] assertTrue(arrayTypeToken.isArray()); [EOL] }
public void testIsArrayWithNonArrayType() { [EOL] TypeToken<?> nonArrayTypeToken = TypeToken.get(String.class); [EOL] assertFalse(nonArrayTypeToken.isArray()); [EOL] }
public void testIsEnumWithEnumType() { [EOL] TypeToken<?> enumTypeToken = TypeToken.get(SomeEnumClass.class); [EOL] assertTrue(enumTypeToken.isEnum()); [EOL] }
public void testIsEnumWithNonEnumType() { [EOL] TypeToken<?> nonEnumTypeToken = TypeToken.get(String.class); [EOL] assertFalse(nonEnumTypeToken.isEnum()); [EOL] }
public void testStringToNumberWithIntRangeValue() { [EOL] Number result = JsonPrimitive.stringToNumber("12345"); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(12345, result.intValue()); [EOL] }
public void testStringToNumberWithLongValue() { [EOL] Number result = JsonPrimitive.stringToNumber(String.valueOf(Long.MAX_VALUE)); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(Long.MAX_VALUE, result.longValue()); [EOL] }
public void testStringToNumberWithBigDecimal() { [EOL] Number result = JsonPrimitive.stringToNumber("12345.6789"); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("12345.6789"), result); [EOL] }
public void testStringToNumberWithDouble() { [EOL] Number result = JsonPrimitive.stringToNumber("1.7976931348623157E308"); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(Double.parseDouble("1.7976931348623157E308"), result.doubleValue()); [EOL] }
public void testGetAsBigInteger_withBigInteger() { [EOL] BigInteger bigIntegerValue = new BigInteger("123456789"); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigIntegerValue); [EOL] BigInteger result = jsonPrimitive.getAsBigInteger(); [EOL] assertEquals(bigIntegerValue, result); [EOL] }
public void testGetAsBigInteger_withNonBigIntegerNumber() { [EOL] Number numberValue = 123456789; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(numberValue); [EOL] BigInteger result = jsonPrimitive.getAsBigInteger(); [EOL] assertEquals(new BigInteger(numberValue.toString()), result); [EOL] }
public void testGetAsBigInteger_withStringRepresentingNumber() { [EOL] String stringValue = "123456789"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(stringValue); [EOL] BigInteger result = jsonPrimitive.getAsBigInteger(); [EOL] assertEquals(new BigInteger(stringValue), result); [EOL] }
public void testGetAsBigInteger_withBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsBigInteger(); [EOL] fail("Expected exception not thrown for boolean value"); [EOL] } catch (UnsupportedOperationException expected) { [EOL] } [EOL] }
public void testGetAsBigInteger_withCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsBigInteger(); [EOL] fail("Expected exception not thrown for character value"); [EOL] } catch (UnsupportedOperationException expected) { [EOL] } [EOL] }
public void testGetAsFloat_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.45); [EOL] float result = jsonPrimitive.getAsFloat(); [EOL] assertEquals(123.45f, result, 0.0f); [EOL] }
public void testGetAsFloat_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("123.45"); [EOL] float result = jsonPrimitive.getAsFloat(); [EOL] assertEquals(123.45f, result, 0.0f); [EOL] }
public void testGetAsFloat_withBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsFloat(); [EOL] fail("getAsFloat should fail for boolean values"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
public void testGetAsFloat_withCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsFloat(); [EOL] fail("getAsFloat should fail for character values"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
public void testGetAsLong_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10L); [EOL] long result = jsonPrimitive.getAsLong(); [EOL] assertEquals(10L, result); [EOL] }
public void testGetAsLong_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10"); [EOL] long result = jsonPrimitive.getAsLong(); [EOL] assertEquals(10L, result); [EOL] }
public void testGetAsLong_withBoolean_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsLong(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetAsLong_withCharacter_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsLong(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetAsShort_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] short result = jsonPrimitive.getAsShort(); [EOL] assertEquals(123, result); [EOL] }
public void testGetAsShort_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("123"); [EOL] short result = jsonPrimitive.getAsShort(); [EOL] assertEquals(123, result); [EOL] }
public void testGetAsShort_withBoolean_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertThrows(NumberFormatException.class, jsonPrimitive::getAsShort); [EOL] }
public void testGetAsShort_withStringNotRepresentingNumber_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("not a number"); [EOL] assertThrows(NumberFormatException.class, jsonPrimitive::getAsShort); [EOL] }
public void testGetAsShort_withCharacter_shouldReturnCharValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] short result = jsonPrimitive.getAsShort(); [EOL] assertEquals((short) 'a', result); [EOL] }
public void testGetAsByte_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] byte result = jsonPrimitive.getAsByte(); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testGetAsByte_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10"); [EOL] byte result = jsonPrimitive.getAsByte(); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testGetAsByte_withBoolean_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsByte(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetAsByte_withCharacter_shouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsByte(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testEquals_Reflexive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.equals(jsonPrimitive)); [EOL] }
public void testEquals_Null() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.equals(new Object())); [EOL] }
public void testEquals_SameValueDifferentType() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive("10"); [EOL] assertFalse(jsonPrimitiveInt.equals(jsonPrimitiveString)); [EOL] }
public void testEquals_SameIntegralValue() { [EOL] JsonPrimitive jsonPrimitiveInt1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveInt2 = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitiveInt1.equals(jsonPrimitiveInt2)); [EOL] }
public void testEquals_DifferentIntegralValue() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitiveLong = new JsonPrimitive(10L); [EOL] assertTrue(jsonPrimitiveInt.equals(jsonPrimitiveLong)); [EOL] }
public void testEquals_SameFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitiveDouble1 = new JsonPrimitive(10.0); [EOL] JsonPrimitive jsonPrimitiveDouble2 = new JsonPrimitive(10.0); [EOL] assertTrue(jsonPrimitiveDouble1.equals(jsonPrimitiveDouble2)); [EOL] }
public void testEquals_DifferentFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitiveFloat = new JsonPrimitive(10.0f); [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(10.0); [EOL] assertTrue(jsonPrimitiveFloat.equals(jsonPrimitiveDouble)); [EOL] }
public void testEquals_NullValue() { [EOL] JsonPrimitive jsonPrimitiveNull1 = new JsonPrimitive((String) null); [EOL] JsonPrimitive jsonPrimitiveNull2 = new JsonPrimitive((String) null); [EOL] assertTrue(jsonPrimitiveNull1.equals(jsonPrimitiveNull2)); [EOL] }
public void testEquals_NonNullValueWithNull() { [EOL] JsonPrimitive jsonPrimitiveNonNull = new JsonPrimitive("test"); [EOL] JsonPrimitive jsonPrimitiveNull = new JsonPrimitive((String) null); [EOL] assertFalse(jsonPrimitiveNonNull.equals(jsonPrimitiveNull)); [EOL] }
public void testEquals_DifferentNonIntegralNonFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitiveString1 = new JsonPrimitive("test"); [EOL] JsonPrimitive jsonPrimitiveString2 = new JsonPrimitive("test2"); [EOL] assertFalse(jsonPrimitiveString1.equals(jsonPrimitiveString2)); [EOL] }
public void testIsIntegralWithBigInteger() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(new BigInteger("123456789")); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithLong() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123456789L); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithInteger() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithShort() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((short) 123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithByte() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((byte) 123); [EOL] assertTrue(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithFloat() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.45f); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithDouble() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.45d); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("123"); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
public void testIsIntegralWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(isIntegral(jsonPrimitive)); [EOL] }
private static boolean isFloatingPoint(JsonPrimitive primitive) { [EOL] if (primitive.value instanceof Number) { [EOL] Number number = (Number) primitive.value; [EOL] return number instanceof BigDecimal || number instanceof Double || number instanceof Float; [EOL] } [EOL] return false; [EOL] } [EOL] public JsonPrimitive(Boolean bool); [EOL] public JsonPrimitive(Number number); [EOL] public JsonPrimitive(String string); [EOL] public JsonPrimitive(Character c); [EOL] JsonPrimitive(Object primitive); [EOL] void setValue(Object primitive); [EOL] public boolean isBoolean(); [EOL] Boolean getAsBooleanWrapper(); [EOL] public boolean getAsBoolean(); [EOL] public boolean isNumber(); [EOL] public Number getAsNumber(); [EOL] static Number stringToNumber(String value); [EOL] public boolean isString(); [EOL] public String getAsString(); [EOL] public double getAsDouble(); [EOL] public BigDecimal getAsBigDecimal(); [EOL] public BigInteger getAsBigInteger(); [EOL] public float getAsFloat(); [EOL] public long getAsLong(); [EOL] public short getAsShort(); [EOL] public int getAsInt(); [EOL] public byte getAsByte(); [EOL] public char getAsCharacter(); [EOL] Object getAsObject(); [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException; [EOL] private static boolean isPrimitiveOrString(Object target); [EOL] public int hashCode(); [EOL] public boolean equals(Object obj); [EOL] private static boolean isIntegral(JsonPrimitive primitive); [EOL] private static boolean isFloatingPoint(JsonPrimitive primitive); [EOL] Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };
public void testShouldSkipFieldWithNoAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(null); [EOL] ExclusionStrategy strategy = new ExclusionStrategyUnderTest(); [EOL] boolean result = strategy.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipFieldWithAnnotationDeserializeTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Expose expose = mock(Expose.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(expose); [EOL] when(expose.deserialize()).thenReturn(true); [EOL] ExclusionStrategy strategy = new ExclusionStrategyUnderTest(); [EOL] boolean result = strategy.shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipFieldWithAnnotationDeserializeFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Expose expose = mock(Expose.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(expose); [EOL] when(expose.deserialize()).thenReturn(false); [EOL] ExclusionStrategy strategy = new ExclusionStrategyUnderTest(); [EOL] boolean result = strategy.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testToString() { [EOL] JsonElement element = new JsonPrimitive("Test"); [EOL] String result = element.toString(); [EOL] assertNotNull(result); [EOL] assertEquals("\"Test\"", result); [EOL] }
public void testToStringWithException() { [EOL] JsonElement element = new JsonPrimitive("Test") { [EOL] @Override [EOL] public void toString(StringBuilder sb, Escaper escaper) throws IOException { [EOL] throw new IOException("Fake IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] element.toString(); [EOL] fail("Expected RuntimeException due to IOException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals(IOException.class, e.getCause().getClass()); [EOL] assertEquals("Fake IOException", e.getCause().getMessage()); [EOL] } [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL] return isInnerClass(f.getDeclaredClass()); [EOL] }
private boolean isInnerClass(Class<?> clazz) { [EOL] return clazz.isMemberClass() && !isStatic(clazz); [EOL] }
public void testIsStaticWithStaticClass() { [EOL] boolean result = isStatic(StaticClass.class); [EOL] assertTrue(result); [EOL] }
public void testIsStaticWithNonStaticClass() { [EOL] boolean result = isStatic(NonStaticClass.class); [EOL] assertFalse(result); [EOL] }
public void testValidateWithNullFieldName() { [EOL] try { [EOL] validate(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testValidateWithEmptyFieldName() { [EOL] try { [EOL] validate(""); [EOL] fail("Expected IllegalArgumentException to be thrown for empty string"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(" is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidateWithOnlySpacesFieldName() { [EOL] try { [EOL] validate("   "); [EOL] fail("Expected IllegalArgumentException to be thrown for whitespace string"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("    is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidateWithInvalidFieldName() { [EOL] try { [EOL] validate("123"); [EOL] fail("Expected IllegalArgumentException to be thrown for invalid field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("123 is not a valid JSON field name.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidateWithValidFieldName() { [EOL] String fieldName = "validFieldName"; [EOL] String result = validate(fieldName); [EOL] assertEquals(fieldName, result); [EOL] }

public void testToStringWithEmptyObject() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{}", sb.toString()); [EOL] }
public void testToStringWithSingleElement() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key", new JsonPrimitive("value")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key\":\"value\"}", sb.toString()); [EOL] }
public void testToStringWithMultipleElements() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", new JsonPrimitive("value1")); [EOL] jsonObject.add("key2", new JsonPrimitive("value2")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key1\":\"value1\",\"key2\":\"value2\"}", sb.toString()); [EOL] }
