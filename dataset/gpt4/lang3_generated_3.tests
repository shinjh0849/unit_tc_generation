public void testIsFalse_WithTrue() { [EOL] boolean result = isFalse(Boolean.TRUE); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsFalse_WithFalse() { [EOL] boolean result = isFalse(Boolean.FALSE); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsFalse_WithNull() { [EOL] boolean result = isFalse(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotFalse_WhenTrue() { [EOL] boolean result = isNotFalse(Boolean.TRUE); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNotFalse_WhenFalse() { [EOL] boolean result = isNotFalse(Boolean.FALSE); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNotFalse_WhenNull() { [EOL] boolean result = isNotFalse(null); [EOL] assertTrue(result); [EOL] }
public void testToBoolean_True() { [EOL] boolean result = toBoolean(1, 1, 0); [EOL] assertTrue(result); [EOL] } [EOL] public void testToBoolean_False() { [EOL] boolean result = toBoolean(0, 1, 0); [EOL] assertFalse(result); [EOL] } [EOL] public void testToBoolean_IllegalArgumentException() { [EOL] try { [EOL] toBoolean(2, 1, 0); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToBooleanObject_ValueIsNullTrueValueIsNull() { [EOL] Integer value = null; [EOL] Integer trueValue = null; [EOL] Integer falseValue = 1; [EOL] Integer nullValue = 2; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBooleanObject_ValueIsNullFalseValueIsNull() { [EOL] Integer value = null; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = null; [EOL] Integer nullValue = 2; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testToBooleanObject_ValueIsNullNullValueIsNull() { [EOL] Integer value = null; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 2; [EOL] Integer nullValue = null; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_ValueEqualsTrueValue() { [EOL] Integer value = 1; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 2; [EOL] Integer nullValue = 3; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBooleanObject_ValueEqualsFalseValue() { [EOL] Integer value = 2; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 2; [EOL] Integer nullValue = 3; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testToBooleanObject_ValueEqualsNullValue() { [EOL] Integer value = 3; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 2; [EOL] Integer nullValue = 3; [EOL] Boolean result = BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_IllegalArgumentException() { [EOL] Integer value = 4; [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 2; [EOL] Integer nullValue = 3; [EOL] try { [EOL] BooleanUtils.toBooleanObject(value, trueValue, falseValue, nullValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToIntegerTrue() { [EOL] int result = ClassName.toInteger(true); [EOL] assertEquals(1, result); [EOL] }
public void testToIntegerFalse() { [EOL] int result = ClassName.toInteger(false); [EOL] assertEquals(0, result); [EOL] }
public void testToIntegerObjectTrue() { [EOL] Integer expected = NumberUtils.INTEGER_ONE; [EOL] Integer actual = BooleanUtils.toIntegerObject(true); [EOL] assertEquals(expected, actual); [EOL] }
public void testToIntegerObjectFalse() { [EOL] Integer expected = NumberUtils.INTEGER_ZERO; [EOL] Integer actual = BooleanUtils.toIntegerObject(false); [EOL] assertEquals(expected, actual); [EOL] }
public void testToIntegerWithTrue() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int result = Lang3.toInteger(Boolean.TRUE, trueValue, falseValue, nullValue); [EOL] assertEquals(trueValue, result); [EOL] }
public void testToIntegerWithFalse() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int result = Lang3.toInteger(Boolean.FALSE, trueValue, falseValue, nullValue); [EOL] assertEquals(falseValue, result); [EOL] }
public void testToIntegerWithNull() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int result = Lang3.toInteger(null, trueValue, falseValue, nullValue); [EOL] assertEquals(nullValue, result); [EOL] }
public void testToIntegerObject_WithTrueBoolean() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 0; [EOL] Integer nullValue = -1; [EOL] Integer result = Lang3.toIntegerObject(true, trueValue, falseValue, nullValue); [EOL] assertEquals(trueValue, result); [EOL] }
public void testToIntegerObject_WithFalseBoolean() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 0; [EOL] Integer nullValue = -1; [EOL] Integer result = Lang3.toIntegerObject(false, trueValue, falseValue, nullValue); [EOL] assertEquals(falseValue, result); [EOL] }
public void testToIntegerObject_WithNullBoolean() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 0; [EOL] Integer nullValue = -1; [EOL] Integer result = Lang3.toIntegerObject(null, trueValue, falseValue, nullValue); [EOL] assertEquals(nullValue, result); [EOL] }
public void testToBooleanObject_AllNullInputs() { [EOL] Boolean result = toBooleanObject(null, null, null, null); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_TrueStringMatches() { [EOL] Boolean result = toBooleanObject("true", "true", "false", "null"); [EOL] assertTrue(result); [EOL] }
public void testToBooleanObject_FalseStringMatches() { [EOL] Boolean result = toBooleanObject("false", "true", "false", "null"); [EOL] assertFalse(result); [EOL] }
public void testToBooleanObject_NullStringMatches() { [EOL] Boolean result = toBooleanObject("null", "true", "false", "null"); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_NoMatchThrowsException() { [EOL] try { [EOL] toBooleanObject("unknown", "true", "false", "null"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToStringOnOffTrue() { [EOL] String result = StringUtils.toStringOnOff(true); [EOL] assertEquals("on", result); [EOL] }
public void testToStringOnOffFalse() { [EOL] String result = StringUtils.toStringOnOff(false); [EOL] assertEquals("off", result); [EOL] }
public void testToStringYesNo_True() { [EOL] String result = StringUtils.toStringYesNo(true); [EOL] assertEquals("yes", result); [EOL] }
public void testToStringYesNo_False() { [EOL] String result = StringUtils.toStringYesNo(false); [EOL] assertEquals("no", result); [EOL] }
public void testToStringTrue() { [EOL] String trueString = "It's true"; [EOL] String falseString = "It's false"; [EOL] String result = StringUtils.toString(true, trueString, falseString); [EOL] assertEquals("It's true", result); [EOL] }
public void testToStringFalse() { [EOL] String trueString = "It's true"; [EOL] String falseString = "It's false"; [EOL] String result = StringUtils.toString(false, trueString, falseString); [EOL] assertEquals("It's false", result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_AllTrue_ReturnsTrue() { [EOL] boolean result = Lang3.and(new boolean[]{true, true, true}); [EOL] assertTrue(result); [EOL] }
public void testAnd_OneFalse_ReturnsFalse() { [EOL] boolean result = Lang3.and(new boolean[]{true, false, true}); [EOL] assertFalse(result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.and(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ValidArray_AllTrue() { [EOL] Boolean result = Lang3.and(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testAnd_ValidArray_NotAllTrue() { [EOL] Boolean result = Lang3.and(new Boolean[]{true, false, true}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.or((boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.or(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_AllFalse_ReturnsFalse() { [EOL] boolean result = Lang3.or(false, false, false); [EOL] assertFalse(result); [EOL] }
public void testOr_OneTrue_ReturnsTrue() { [EOL] boolean result = Lang3.or(false, true, false); [EOL] assertTrue(result); [EOL] }
public void testOr_AllTrue_ReturnsTrue() { [EOL] boolean result = Lang3.or(true, true, true); [EOL] assertTrue(result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ValidArray_AllTrue() { [EOL] Boolean result = Lang3.or(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testOr_ValidArray_AllFalse() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_ValidArray_MixedValues() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testMethodUtilsConstructor() throws Exception { [EOL] Constructor<MethodUtils> constructor = MethodUtils.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] constructor.newInstance(); [EOL] }
public void testGetAccessibleMethod_NullIfInaccessible() { [EOL] Method inaccessibleMethod = ... // obtain a reference to an inaccessible method [EOL] Method result = ClassUnderTest.getAccessibleMethod(inaccessibleMethod); [EOL] assertNull(result); [EOL] } [EOL] public void testGetAccessibleMethod_ReturnsMethodIfPublicClass() { [EOL] Method publicMethod = ... // obtain a reference to a public method in a public class [EOL] Method result = ClassUnderTest.getAccessibleMethod(publicMethod); [EOL] assertNotNull(result); [EOL] assertEquals(publicMethod, result); [EOL] } [EOL] public void testGetAccessibleMethod_ReturnsMethodFromInterfaceNest() { [EOL] Method interfaceMethod = ... // obtain a reference to a method from an interface that the class implements [EOL] Method result = ClassUnderTest.getAccessibleMethod(interfaceMethod); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetAccessibleMethod_ReturnsMethodFromSuperclass() { [EOL] Method superclassMethod = ... // obtain a reference to a public method in a superclass that is not public [EOL] Method result = ClassUnderTest.getAccessibleMethod(superclassMethod); [EOL] assertNotNull(result); [EOL] }
public void testToInt_NullString() { [EOL] int defaultValue = 5; [EOL] int result = StringUtils.toInt(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testToInt_ValidNumberString() { [EOL] String validNumber = "123"; [EOL] int defaultValue = 5; [EOL] int expected = 123; [EOL] int result = StringUtils.toInt(validNumber, defaultValue); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testToInt_InvalidNumberString() { [EOL] String invalidNumber = "abc"; [EOL] int defaultValue = 5; [EOL] int result = StringUtils.toInt(invalidNumber, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public static long toLong(final String str) { [EOL] return toLong(str, 0L); [EOL] }
public void testToLongWithNullString() { [EOL] final long defaultValue = 42L; [EOL] long result = StringUtils.toLong(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToLongWithValidString() { [EOL] final long expected = 123L; [EOL] long result = StringUtils.toLong("123", 0L); [EOL] assertEquals(expected, result); [EOL] }
public void testToLongWithInvalidString() { [EOL] final long defaultValue = 42L; [EOL] long result = StringUtils.toLong("invalid", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToFloat_NullString() { [EOL] float result = StringUtils.toFloat(null); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] } [EOL] public void testToFloat_EmptyString() { [EOL] float result = StringUtils.toFloat(""); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] } [EOL] public void testToFloat_ValidString() { [EOL] float result = StringUtils.toFloat("1.23"); [EOL] assertEquals(1.23f, result, 0.0f); [EOL] } [EOL] public void testToFloat_InvalidString() { [EOL] float result = StringUtils.toFloat("abc"); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }

public void testToFloat_NullString() { [EOL] final float defaultValue = 1.0f; [EOL] float result = toFloat(null, defaultValue); [EOL] assertEquals(defaultValue, result, 0.0f); [EOL] } [EOL] public void testToFloat_ValidString() { [EOL] final float defaultValue = 1.0f; [EOL] float result = toFloat("2.5", defaultValue); [EOL] assertEquals(2.5f, result, 0.0f); [EOL] } [EOL] public void testToFloat_InvalidString() { [EOL] final float defaultValue = 1.0f; [EOL] float result = toFloat("invalid", defaultValue); [EOL] assertEquals(defaultValue, result, 0.0f); [EOL] }
public void testCreateDoubleWithNull() { [EOL] Double result = StringUtils.createDouble(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateDoubleWithEmptyString() { [EOL] try { [EOL] StringUtils.createDouble(""); [EOL] fail("Should have thrown NumberFormatException because empty string is not a valid double"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateDoubleWithValidString() { [EOL] Double result = StringUtils.createDouble("123.45"); [EOL] assertNotNull(result); [EOL] assertEquals(123.45, result, 0.0); [EOL] } [EOL] public void testCreateDoubleWithInvalidString() { [EOL] try { [EOL] StringUtils.createDouble("abc"); [EOL] fail("Should have thrown NumberFormatException because 'abc' is not a valid double"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateBigDecimalWithNullInput() { [EOL] BigDecimal result = YourClass.createBigDecimal(null); [EOL] assertNull(result); [EOL] }
public void testCreateBigDecimalWithBlankString() { [EOL] try { [EOL] YourClass.createBigDecimal(" "); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("A blank string is not a valid number", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithDoubleMinus() { [EOL] try { [EOL] YourClass.createBigDecimal("--123"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("--123 is not a valid number.", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithValidString() { [EOL] BigDecimal expected = new BigDecimal("123"); [EOL] BigDecimal result = YourClass.createBigDecimal("123"); [EOL] assertEquals(expected, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] int[] array = new int[]{42}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(42, result); [EOL] } [EOL] public void testMaxWithMultipleElementsArray() { [EOL] int[] array = new int[]{1, 3, 5, 4, 2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(5, result); [EOL] } [EOL] public void testMaxWithAllNegativeNumbers() { [EOL] int[] array = new int[]{-1, -3, -5, -4, -2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testMaxWithMixedNumbers() { [EOL] int[] array = new int[]{-1, 3, -5, 4, 2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(4, result); [EOL] } [EOL] public void testMaxThrowsExceptionForEmptyArray() { [EOL] try { [EOL] int[] array = new int[]{}; [EOL] ClassName.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testMaxThrowsExceptionForNullArray() { [EOL] try { [EOL] ClassName.max(null); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMax_withValidArray() { [EOL] double[] array = {1.0, 3.0, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(3.0, result, 0.01); [EOL] }
public void testMax_withNaN() { [EOL] double[] array = {1.0, Double.NaN, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testMax_withEmptyArray() { [EOL] double[] array = {}; [EOL] try { [EOL] ArrayUtils.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMax_withSingleElementArray() { [EOL] double[] array = {42.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(42.0, result, 0.01); [EOL] }
public void testMaxWithValidArray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float result = YourClass.max(array); [EOL] assertEquals(3.0f, result, 0.01f); [EOL] }
public void testMaxWithFirstElementMax() { [EOL] float[] array = {3.0f, 2.0f, 1.0f}; [EOL] float result = YourClass.max(array); [EOL] assertEquals(3.0f, result, 0.01f); [EOL] }
public void testMaxWithNegativeNumbers() { [EOL] float[] array = {-1.0f, -2.0f, -3.0f}; [EOL] float result = YourClass.max(array); [EOL] assertEquals(-1.0f, result, 0.01f); [EOL] }
public void testMaxWithAllEqualElements() { [EOL] float[] array = {2.0f, 2.0f, 2.0f}; [EOL] float result = YourClass.max(array); [EOL] assertEquals(2.0f, result, 0.01f); [EOL] }
public void testMaxWithNaN() { [EOL] float[] array = {1.0f, Float.NaN, 3.0f}; [EOL] float result = YourClass.max(array); [EOL] assertTrue(Float.isNaN(result)); [EOL] }
public void testMaxWithEmptyArray() { [EOL] float[] array = {}; [EOL] try { [EOL] YourClass.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithNullArray() { [EOL] try { [EOL] YourClass.max(null); [EOL] fail("Should have thrown a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testValidateArrayWithNullArray() { [EOL] try { [EOL] validateArray(null); [EOL] fail("Expected IllegalArgumentException for null array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testValidateArrayWithEmptyArray() { [EOL] try { [EOL] validateArray(new int[0]); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array cannot be empty.", ex.getMessage()); [EOL] } [EOL] }
public void testValidateArrayWithNonEmptyArray() { [EOL] try { [EOL] validateArray(new int[]{1, 2, 3}); [EOL] } catch (IllegalArgumentException ex) { [EOL] fail("No exception expected for non-empty array"); [EOL] } [EOL] }
public void testMinWithFirstNumberBeingTheSmallest() { [EOL] short a = 1; [EOL] short b = 2; [EOL] short c = 3; [EOL] short result = NumberUtils.min(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMinWithSecondNumberBeingTheSmallest() { [EOL] short a = 3; [EOL] short b = 1; [EOL] short c = 2; [EOL] short result = NumberUtils.min(a, b, c); [EOL] assertEquals(b, result); [EOL] } [EOL] public void testMinWithThirdNumberBeingTheSmallest() { [EOL] short a = 3; [EOL] short b = 2; [EOL] short c = 1; [EOL] short result = NumberUtils.min(a, b, c); [EOL] assertEquals(c, result); [EOL] } [EOL] public void testMinWithAllNumbersBeingEqual() { [EOL] short a = 2; [EOL] short b = 2; [EOL] short c = 2; [EOL] short result = NumberUtils.min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMax_AllEqual() { [EOL] double a = 5.0; [EOL] double b = 5.0; [EOL] double c = 5.0; [EOL] double result = YourClass.max(a, b, c); [EOL] assertEquals(5.0, result, 0.0); [EOL] }
public void testMax_FirstMax() { [EOL] double a = 10.0; [EOL] double b = 5.0; [EOL] double c = 1.0; [EOL] double result = YourClass.max(a, b, c); [EOL] assertEquals(10.0, result, 0.0); [EOL] }
public void testMax_SecondMax() { [EOL] double a = 2.0; [EOL] double b = 8.0; [EOL] double c = 4.0; [EOL] double result = YourClass.max(a, b, c); [EOL] assertEquals(8.0, result, 0.0); [EOL] }
public void testMax_ThirdMax() { [EOL] double a = 3.0; [EOL] double b = 6.0; [EOL] double c = 9.0; [EOL] double result = YourClass.max(a, b, c); [EOL] assertEquals(9.0, result, 0.0); [EOL] }
public void testConcurrentExceptionWithNullCause() { [EOL] Throwable cause = null; [EOL] ConcurrentException exception = new ConcurrentException(cause); [EOL] assertNull(exception.getCause()); [EOL] }
public void testConcurrentExceptionWithNonNullCause() { [EOL] Throwable cause = new RuntimeException("Test"); [EOL] ConcurrentException exception = new ConcurrentException(cause); [EOL] assertNotNull(exception.getCause()); [EOL] assertEquals("Test", exception.getCause().getMessage()); [EOL] }
public void testConcurrentExceptionWithMessageAndCause() { [EOL] String expectedMessage = "Test Message"; [EOL] Throwable expectedCause = new RuntimeException("Cause"); [EOL] ConcurrentException exception = new ConcurrentException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testConcurrentExceptionWithNullMessageAndCause() { [EOL] ConcurrentException exception = new ConcurrentException(null, null); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getCause()); [EOL] }
@Override [EOL] public final void applyPattern(final String pattern) { [EOL] if (registry == null) { [EOL] super.applyPattern(pattern); [EOL] toPattern = super.toPattern(); [EOL] return; [EOL] } [EOL] final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL] final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL] final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] final char[] c = pattern.toCharArray(); [EOL] int fmtCount = 0; [EOL] while (pos.getIndex() < pattern.length()) { [EOL] switch(c[pos.getIndex()]) { [EOL] case QUOTE: [EOL] appendQuotedString(pattern, pos, stripCustom, true); [EOL] break; [EOL] case START_FE: [EOL] fmtCount++; [EOL] seekNonWs(pattern, pos); [EOL] final int start = pos.getIndex(); [EOL] final int index = readArgumentIndex(pattern, next(pos)); [EOL] stripCustom.append(START_FE).append(index); [EOL] seekNonWs(pattern, pos); [EOL] Format format = null; [EOL] String formatDescription = null; [EOL] if (c[pos.getIndex()] == START_FMT) { [EOL] formatDescription = parseFormatDescription(pattern, next(pos)); [EOL] format = getFormat(formatDescription); [EOL] if (format == null) { [EOL] stripCustom.append(START_FMT).append(formatDescription); [EOL] } [EOL] } [EOL] foundFormats.add(format); [EOL] foundDescriptions.add(format == null ? null : formatDescription); [EOL] Validate.isTrue(foundFormats.size() == fmtCount); [EOL] Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL] if (c[pos.getIndex()] != END_FE) { [EOL] throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL] } [EOL] default: [EOL] stripCustom.append(c[pos.getIndex()]); [EOL] next(pos); [EOL] } [EOL] } [EOL] super.applyPattern(stripCustom.toString()); [EOL] toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL] if (containsElements(foundFormats)) { [EOL] final Format[] origFormats = getFormats(); [EOL] int i = 0; [EOL] for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL] final Format f = it.next(); [EOL] if (f != null) { [EOL] origFormats[i] = f; [EOL] } [EOL] } [EOL] super.setFormats(origFormats); [EOL] } [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FMT=Optional[',']; [EOL] char END_FE=Optional['}'];
public void testEquals_Reflexive() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern"); [EOL] assertTrue(emf.equals(emf)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern"); [EOL] assertFalse(emf.equals(null)); [EOL] } [EOL] public void testEquals_SuperNotEquals() { [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern"); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("different pattern") { [EOL] }; [EOL] assertFalse(emf1.equals(emf2)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern"); [EOL] Object obj = new Object(); [EOL] assertFalse(emf.equals(obj)); [EOL] } [EOL] public void testEquals_DifferentToPattern() { [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern"); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("different pattern"); [EOL] assertFalse(emf1.equals(emf2)); [EOL] } [EOL] public void testEquals_DifferentRegistry() { [EOL] Map<String, FormatFactory> registry1 = new HashMap<>(); [EOL] registry1.put("key", new FormatFactory() { [EOL] @Override [EOL] public Format getFormat(String name, String arguments, Locale locale) { [EOL] return null; [EOL] } [EOL] }); [EOL] Map<String, FormatFactory> registry2 = new HashMap<>(); [EOL] registry2.put("key", new FormatFactory() { [EOL] @Override [EOL] public Format getFormat(String name, String arguments, Locale locale) { [EOL] return new DecimalFormat(); [EOL] } [EOL] }); [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern", registry1); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("pattern", registry2); [EOL] assertFalse(emf1.equals(emf2)); [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat("pattern"); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat("pattern"); [EOL] assertTrue(emf1.equals(emf2)); [EOL] }
public void testHashCodeWithNonNullValues() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern", Locale.US); [EOL] emf.setFormat(0, NumberFormat.getInstance()); [EOL] int result = emf.hashCode(); [EOL] int expectedHashCode = //... some expected hash code value [EOL] assertEquals(expectedHashCode, result); [EOL] }
public void testHashCodeWithNullValues() { [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat("pattern"); [EOL] int result = emf.hashCode(); [EOL] int expectedHashCode = //... some expected hash code value [EOL] assertEquals(expectedHashCode, result); [EOL] }
private Format getFormat(final String desc) { [EOL] if (registry != null) { [EOL] String name = desc; [EOL] String args = null; [EOL] final int i = desc.indexOf(START_FMT); [EOL] if (i > 0) { [EOL] name = desc.substring(0, i).trim(); [EOL] args = desc.substring(i + 1).trim(); [EOL] } [EOL] final FormatFactory factory = registry.get(name); [EOL] if (factory != null) { [EOL] return factory.getFormat(name, args, getLocale()); [EOL] } [EOL] } [EOL] return null; [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FMT=Optional[',']; [EOL] char END_FE=Optional['}'];
private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL] final int start = pos.getIndex(); [EOL] seekNonWs(pattern, pos); [EOL] final StringBuilder result = new StringBuilder(); [EOL] boolean error = false; [EOL] for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL] char c = pattern.charAt(pos.getIndex()); [EOL] if (Character.isWhitespace(c)) { [EOL] seekNonWs(pattern, pos); [EOL] c = pattern.charAt(pos.getIndex()); [EOL] if (c != START_FMT && c != END_FE) { [EOL] error = true; [EOL] continue; [EOL] } [EOL] } [EOL] if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL] try { [EOL] return Integer.parseInt(result.toString()); [EOL] } catch (final NumberFormatException e) { [EOL] } [EOL] } [EOL] error = !Character.isDigit(c); [EOL] result.append(c); [EOL] } [EOL] if (error) { [EOL] throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL] } [EOL] throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] }
private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL] final int start = pos.getIndex(); [EOL] seekNonWs(pattern, pos); [EOL] final int text = pos.getIndex(); [EOL] int depth = 1; [EOL] for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL] switch(pattern.charAt(pos.getIndex())) { [EOL] case START_FE: [EOL] depth++; [EOL] break; [EOL] case END_FE: [EOL] depth--; [EOL] if (depth == 0) { [EOL] return pattern.substring(text, pos.getIndex()); [EOL] } [EOL] break; [EOL] case QUOTE: [EOL] getQuotedString(pattern, pos, false); [EOL] break; [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FE=Optional[',']; [EOL] char END_FE=Optional['}'];
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL] if (!containsElements(customPatterns)) { [EOL] return pattern; [EOL] } [EOL] final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] int fe = -1; [EOL] int depth = 0; [EOL] while (pos.getIndex() < pattern.length()) { [EOL] final char c = pattern.charAt(pos.getIndex()); [EOL] switch(c) { [EOL] case QUOTE: [EOL] appendQuotedString(pattern, pos, sb, false); [EOL] break; [EOL] case START_FE: [EOL] depth++; [EOL] if (depth == 1) { [EOL] fe++; [EOL] sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL] final String customPattern = customPatterns.get(fe); [EOL] if (customPattern != null) { [EOL] sb.append(START_FMT).append(customPattern); [EOL] } [EOL] } [EOL] break; [EOL] case END_FE: [EOL] depth--; [EOL] default: [EOL] sb.append(c); [EOL] next(pos); [EOL] } [EOL] } [EOL] return sb.toString(); [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FMT=Optional[',']; [EOL] char END_FE=Optional['}'];
private void seekNonWs(final String pattern, final ParsePosition pos) { [EOL] int len = 0; [EOL] final char[] buffer = pattern.toCharArray(); [EOL] do { [EOL] len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex()); [EOL] pos.setIndex(pos.getIndex() + len); [EOL] } while (len > 0 && pos.getIndex() < pattern.length()); [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FMT=Optional[',']; [EOL] char END_FE=Optional['}'];
public void testNextWithValidParsePosition() { [EOL] ParsePosition pos = new ParsePosition(0); [EOL] ParsePosition result = next(pos); [EOL] assertEquals(1, result.getIndex()); [EOL] }
public void testNextWithMaxIntParsePosition() { [EOL] ParsePosition pos = new ParsePosition(Integer.MAX_VALUE); [EOL] try { [EOL] next(pos); [EOL] fail("Should throw an ArithmeticException when index is at MAX_VALUE"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testContainsElementsWithNullCollection() { [EOL] boolean result = containsElements(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsElementsWithEmptyCollection() { [EOL] boolean result = containsElements(Collections.emptyList()); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsElementsWithNonNullNonEmptyCollection() { [EOL] boolean result = containsElements(Arrays.asList("element")); [EOL] assertTrue(result); [EOL] } [EOL] public void testContainsElementsWithNonNullNonEmptyCollectionHavingNullElement() { [EOL] boolean result = containsElements(Arrays.asList((Object) null)); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsElementsWithNonNullNonEmptyCollectionHavingNonNullAndNullElements() { [EOL] boolean result = containsElements(Arrays.asList(null, "element")); [EOL] assertTrue(result); [EOL] }
public void testGetKeyReturnsCorrectLeftValue() { [EOL] Pair<String, String> pair = Pair.of("left", "right"); [EOL] String key = pair.getKey(); [EOL] assertEquals("left", key); [EOL] }
public void testGetKeyReturnsNullForLeftNull() { [EOL] Pair<String, String> pair = Pair.of(null, "right"); [EOL] String key = pair.getKey(); [EOL] assertNull(key); [EOL] }
public void testGetValueShouldReturnRight() { [EOL] Pair<String, Integer> pair = Pair.of("Left", 42); [EOL] Integer rightValue = pair.getRight(); [EOL] assertEquals(rightValue, pair.getValue()); [EOL] }
public void testEquals_SameObject() { [EOL] Map.Entry<?, ?> entry = new AbstractMap.SimpleEntry<>("key", "value"); [EOL] assertTrue(entry.equals(entry)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Map.Entry<?, ?> entry = new AbstractMap.SimpleEntry<>("key", "value"); [EOL] Object obj = new Object(); [EOL] assertFalse(entry.equals(obj)); [EOL] }
public void testEquals_EqualEntries() { [EOL] Map.Entry<?, ?> entry1 = new AbstractMap.SimpleEntry<>("key", "value"); [EOL] Map.Entry<?, ?> entry2 = new AbstractMap.SimpleEntry<>("key", "value"); [EOL] assertTrue(entry1.equals(entry2)); [EOL] }
public void testEquals_DifferentKeys() { [EOL] Map.Entry<?, ?> entry1 = new AbstractMap.SimpleEntry<>("key1", "value"); [EOL] Map.Entry<?, ?> entry2 = new AbstractMap.SimpleEntry<>("key2", "value"); [EOL] assertFalse(entry1.equals(entry2)); [EOL] }
public void testEquals_DifferentValues() { [EOL] Map.Entry<?, ?> entry1 = new AbstractMap.SimpleEntry<>("key", "value1"); [EOL] Map.Entry<?, ?> entry2 = new AbstractMap.SimpleEntry<>("key", "value2"); [EOL] assertFalse(entry1.equals(entry2)); [EOL] }
public void testEquals_Null() { [EOL] Map.Entry<?, ?> entry = new AbstractMap.SimpleEntry<>("key", "value"); [EOL] assertFalse(entry.equals(null)); [EOL] }
public void testHashCodeWithNonNullKeyAndValue() { [EOL] Pair<String, String> pair = new ImmutablePair<>("key", "value"); [EOL] int expectedHashCode = "key".hashCode() ^ "value".hashCode(); [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] } [EOL] public void testHashCodeWithNullKey() { [EOL] Pair<String, String> pair = new ImmutablePair<>(null, "value"); [EOL] int expectedHashCode = "value".hashCode(); [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] } [EOL] public void testHashCodeWithNullValue() { [EOL] Pair<String, String> pair = new ImmutablePair<>("key", null); [EOL] int expectedHashCode = "key".hashCode(); [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] } [EOL] public void testHashCodeWithNullKeyAndValue() { [EOL] Pair<String, String> pair = new ImmutablePair<>(null, null); [EOL] int expectedHashCode = 0; [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] }
public void testConstantInitializerWithNonNull() { [EOL] String testObject = "Test String"; [EOL] ConstantInitializer<String> initializer = new ConstantInitializer<>(testObject); [EOL] assertEquals(testObject, initializer.getObject()); [EOL] }
public void testConstantInitializerWithNull() { [EOL] ConstantInitializer<Object> initializer = new ConstantInitializer<>(null); [EOL] assertNull(initializer.getObject()); [EOL] }
public final T getObject() { [EOL] return object; [EOL] }
public void testHashCode_WithNonNullObject() { [EOL] MutableObject<Integer> mutableObject = new MutableObject<>(5); [EOL] int expectedHashCode = Integer.valueOf(5).hashCode(); [EOL] int actualHashCode = mutableObject.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCode_WithNullObject() { [EOL] MutableObject<Object> mutableObject = new MutableObject<>(null); [EOL] int expectedHashCode = 0; [EOL] int actualHashCode = mutableObject.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testEquals_Reflexive() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] assertTrue(constantInitializer.equals(constantInitializer)); [EOL] }
public void testEquals_Symmetric() { [EOL] ConstantInitializer<Integer> constantInitializer1 = new ConstantInitializer<>(5); [EOL] ConstantInitializer<Integer> constantInitializer2 = new ConstantInitializer<>(5); [EOL] assertTrue(constantInitializer1.equals(constantInitializer2)); [EOL] assertTrue(constantInitializer2.equals(constantInitializer1)); [EOL] }
public void testEquals_Null() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] assertFalse(constantInitializer.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] Object differentClassObj = new Object(); [EOL] assertFalse(constantInitializer.equals(differentClassObj)); [EOL] }
public void testEquals_DifferentValue() { [EOL] ConstantInitializer<Integer> constantInitializer1 = new ConstantInitializer<>(5); [EOL] ConstantInitializer<Integer> constantInitializer2 = new ConstantInitializer<>(10); [EOL] assertFalse(constantInitializer1.equals(constantInitializer2)); [EOL] }
public void testToStringWhenObjectIsNull() { [EOL] ObjectUtils.IdentityToString testInstance = new ObjectUtils.IdentityToString(null); [EOL] String expected = String.format(ObjectUtils.IdentityToString.FMT_TO_STRING, [EOL] Integer.valueOf(System.identityHashCode(testInstance)), [EOL] "null"); [EOL] String actual = testInstance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStringWhenObjectIsNotNull() { [EOL] Object object = new Object(); [EOL] ObjectUtils.IdentityToString testInstance = new ObjectUtils.IdentityToString(object); [EOL] String expected = String.format(ObjectUtils.IdentityToString.FMT_TO_STRING, [EOL] Integer.valueOf(System.identityHashCode(testInstance)), [EOL] String.valueOf(object)); [EOL] String actual = testInstance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSerializationExceptionWithCause() { [EOL] Throwable cause = new Exception("This is the cause"); [EOL] SerializationException exception = new SerializationException(cause); [EOL] assertSame(cause, exception.getCause()); [EOL] }
public void testBasicThreadFactoryWithDefaultWrappedFactory() { [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder(); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertNotNull(factory); [EOL] assertNotNull(factory.threadCounter); [EOL] assertNull(factory.namingPattern); [EOL] assertEquals(0, factory.priority); [EOL] assertFalse(factory.daemonFlag); [EOL] assertNull(factory.uncaughtExceptionHandler); [EOL] }
public void testBasicThreadFactoryWithCustomWrappedFactory() { [EOL] ThreadFactory customWrappedFactory = Executors.defaultThreadFactory(); [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .wrappedFactory(customWrappedFactory); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertSame(customWrappedFactory, factory.wrappedFactory); [EOL] assertNotNull(factory.threadCounter); [EOL] assertNull(factory.namingPattern); [EOL] assertEquals(0, factory.priority); [EOL] assertFalse(factory.daemonFlag); [EOL] assertNull(factory.uncaughtExceptionHandler); [EOL] }
public void testBasicThreadFactoryWithNamingPattern() { [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .namingPattern("test-thread-%d"); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertEquals("test-thread-%d", factory.namingPattern); [EOL] }
public void testBasicThreadFactoryWithPriority() { [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .priority(Thread.MAX_PRIORITY); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertEquals(Thread.MAX_PRIORITY, factory.priority); [EOL] }
public void testBasicThreadFactoryWithDaemonFlag() { [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .daemon(true); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertTrue(factory.daemonFlag); [EOL] }
public void testBasicThreadFactoryWithUncaughtExceptionHandler() { [EOL] Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() { [EOL] @Override [EOL] public void uncaughtException(Thread t, Throwable e) { [EOL] } [EOL] }; [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .uncaughtExceptionHandler(handler); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertSame(handler, factory.uncaughtExceptionHandler); [EOL] }
public void testInitializeThreadWithNamingPattern() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .namingPattern("test-thread-%d") [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.getName().matches("test-thread-\\d+")); [EOL] }
public void testInitializeThreadWithUncaughtExceptionHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (thread, throwable) -> { /* No-op */ }; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .uncaughtExceptionHandler(handler) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(handler, t.getUncaughtExceptionHandler()); [EOL] }
public void testInitializeThreadWithPriority() { [EOL] int priority = Thread.NORM_PRIORITY + 1; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .priority(priority) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(priority, t.getPriority()); [EOL] }
public void testInitializeThreadWithDaemonFlag() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .daemon(true) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.isDaemon()); [EOL] }
public void testInitializeThreadWithNullValues() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder().build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] }
public void testNamingPatternWithNull() { [EOL] Builder builder = new Builder(); [EOL] try { [EOL] builder.namingPattern(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Naming pattern must not be null!", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNamingPatternWithValidPattern() { [EOL] Builder builder = new Builder(); [EOL] String pattern = "testPattern"; [EOL] Builder returnedBuilder = builder.namingPattern(pattern); [EOL] assertSame("The builder returned should be the same as the one the method was called on", builder, returnedBuilder); [EOL] assertEquals("The naming pattern should match the one provided", pattern, builder.getNamingPattern()); [EOL] }
public void testPriorityWithValidValue() { [EOL] Builder builder = new Builder(); [EOL] int expectedPriority = 5; [EOL] Builder result = builder.priority(expectedPriority); [EOL] assertEquals(Integer.valueOf(expectedPriority), builder.priority); [EOL] assertSame(builder, result); [EOL] }
public void testPriorityWithMinimumValue() { [EOL] Builder builder = new Builder(); [EOL] int expectedPriority = Integer.MIN_VALUE; [EOL] Builder result = builder.priority(expectedPriority); [EOL] assertEquals(Integer.valueOf(expectedPriority), builder.priority); [EOL] assertSame(builder, result); [EOL] }
public void testPriorityWithMaximumValue() { [EOL] Builder builder = new Builder(); [EOL] int expectedPriority = Integer.MAX_VALUE; [EOL] Builder result = builder.priority(expectedPriority); [EOL] assertEquals(Integer.valueOf(expectedPriority), builder.priority); [EOL] assertSame(builder, result); [EOL] }
public void testTimedSemaphoreConstructorWithValidArguments() { [EOL] ScheduledExecutorService service = Mockito.mock(ScheduledExecutorService.class); [EOL] long timePeriod = 1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertFalse(semaphore.isOwnExecutor()); [EOL] }
public void testTimedSemaphoreConstructorWithNullService() { [EOL] long timePeriod = 1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(null, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertTrue(semaphore.isOwnExecutor()); [EOL] }
public void testTimedSemaphoreConstructorWithInvalidTimePeriod() { [EOL] ScheduledExecutorService service = Mockito.mock(ScheduledExecutorService.class); [EOL] long timePeriod = -1; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 10; [EOL] try { [EOL] new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Time period must be greater 0!", iae.getMessage()); [EOL] } [EOL] }
public void testAcquireWhenShutdown() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.shutdown(); [EOL] try { [EOL] semaphore.acquire(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("TimedSemaphore is shut down!", e.getMessage()); [EOL] } [EOL] }
public void testAcquireStartsTimerTask() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.acquire(); [EOL] assertNotNull(semaphore.getTask()); [EOL] }
public void testAcquireWhenNoLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(TimedSemaphore.NO_LIMIT); [EOL] semaphore.acquire(); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testAcquireWhenUnderLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(10); [EOL] for (int i = 0; i < 5; i++) { [EOL] semaphore.acquire(); [EOL] } [EOL] assertEquals(5, semaphore.getAcquireCount()); [EOL] }
public void testAcquireBlocksWhenAtLimit() throws InterruptedException { [EOL] final TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(1); [EOL] semaphore.acquire(); // should pass [EOL] Thread testThread = new Thread(new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] semaphore.acquire(); // should block [EOL] semaphore.acquire(); // should block [EOL] } catch (InterruptedException e) { [EOL] Thread.currentThread().interrupt(); [EOL] } [EOL] } [EOL] }); [EOL] testThread.start(); [EOL] Thread.sleep(100); // give enough time for the thread to block [EOL] testThread.interrupt(); // we interrupt the thread to end the test [EOL] testThread.join(); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testContextedRuntimeExceptionWithMessage() { [EOL] String message = "Test message"; [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertNotNull(exception.getContext()); [EOL] }
public void testContextedRuntimeExceptionWithNullCause() { [EOL] ContextedRuntimeException cre = new ContextedRuntimeException((Throwable) null); [EOL] assertNull(cre.getCause()); [EOL] assertNotNull(cre.getContext()); [EOL] }
public void testContextedRuntimeExceptionWithNonNullCause() { [EOL] Throwable cause = new RuntimeException("Test Cause"); [EOL] ContextedRuntimeException cre = new ContextedRuntimeException(cause); [EOL] assertEquals(cause, cre.getCause()); [EOL] assertNotNull(cre.getContext()); [EOL] }
public void testSetContextValueWithValidArguments() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] String label = "testLabel"; [EOL] String value = "testValue"; [EOL] ContextedRuntimeException result = exception.setContextValue(label, value); [EOL] assertEquals("Returned object should be the same as the exception itself", exception, result); [EOL] assertEquals("Context value should be set", value, exception.getContextValue(label)); [EOL] }
public void testSetContextValueWithNullLabel() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] String value = "testValue"; [EOL] try { [EOL] exception.setContextValue(null, value); [EOL] fail("Should throw NullPointerException for null label"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetContextValueWithNullValue() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] String label = "testLabel"; [EOL] ContextedRuntimeException result = exception.setContextValue(label, null); [EOL] assertEquals("Returned object should be the same as the exception itself", exception, result); [EOL] assertNull("Context value should be null", exception.getContextValue(label)); [EOL] }
public void testGetContextValuesWithExistingLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("testLabel", "testValue"); [EOL] ExceptionContextProvider provider = new ExceptionContextProvider(exceptionContext); [EOL] List<Object> values = provider.getContextValues("testLabel"); [EOL] assertNotNull(values); [EOL] assertEquals(1, values.size()); [EOL] assertEquals("testValue", values.get(0)); [EOL] }
public void testGetContextValuesWithNonExistingLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] ExceptionContextProvider provider = new ExceptionContextProvider(exceptionContext); [EOL] List<Object> values = provider.getContextValues("nonExistingLabel"); [EOL] assertNotNull(values); [EOL] assertTrue(values.isEmpty()); [EOL] }
public void testGetContextValuesWithNullLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("testLabel", "testValue"); [EOL] ExceptionContextProvider provider = new ExceptionContextProvider(exceptionContext); [EOL] List<Object> values = provider.getContextValues(null); [EOL] assertNotNull(values); [EOL] assertTrue(values.isEmpty()); [EOL] }
public void testGetFirstContextValueWithNullLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object result = exceptionContext.getFirstContextValue(null); [EOL] assertNull(result); [EOL] }
public void testGetFirstContextValueWithNonExistentLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object result = exceptionContext.getFirstContextValue("nonExistentLabel"); [EOL] assertNull(result); [EOL] }
public void testGetFirstContextValueWithExistingLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("existingLabel", "value1"); [EOL] exceptionContext.addContextValue("existingLabel", "value2"); [EOL] Object result = exceptionContext.getFirstContextValue("existingLabel"); [EOL] assertEquals("value1", result); [EOL] }
public void testRemoveListenerWithNonNullListener() { [EOL] EventListenerList<L> list = new EventListenerList<>(); [EOL] L mockListener = mock(L.class); [EOL] list.addListener(mockListener); [EOL] list.removeListener(mockListener); [EOL] assertFalse(list.getListeners().contains(mockListener)); [EOL] }
public void testRemoveListenerWithNullListener() { [EOL] EventListenerList<L> list = new EventListenerList<>(); [EOL] try { [EOL] list.removeListener(null); [EOL] fail("Should have thrown IllegalArgumentException for null listener"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetListenersWithNonNullPrototypeArray() { [EOL] ListenerHolder holder = new ListenerHolder(); [EOL] Listener listener1 = new Listener(); [EOL] Listener listener2 = new Listener(); [EOL] holder.addListener(listener1); [EOL] holder.addListener(listener2); [EOL] Listener[] prototypeArray = new Listener[0]; [EOL] Listener[] resultArray = holder.getListeners(prototypeArray); [EOL] assertNotNull(resultArray); [EOL] assertEquals(2, resultArray.length); [EOL] assertSame(listener1, resultArray[0]); [EOL] assertSame(listener2, resultArray[1]); [EOL] }
public void testGetListenersWithEmptyCollection() { [EOL] ListenerHolder holder = new ListenerHolder(); [EOL] Listener[] prototypeArray = new Listener[0]; [EOL] Listener[] resultArray = holder.getListeners(prototypeArray); [EOL] assertNotNull(resultArray); [EOL] assertEquals(0, resultArray.length); [EOL] }
public void testTranslateWithBackslashAndU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u0041", 0, out); [EOL] assertEquals("Should return 6 because it processes '\\u' and four hex digits", 6, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithMultipleUs() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\uuuu0041", 0, out); [EOL] assertEquals("Should return 8 because it processes multiple 'u's and four hex digits", 8, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithPlusSign() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u+0041", 0, out); [EOL] assertEquals("Should return 7 because it processes '\\u', a plus sign, and four hex digits", 7, result); [EOL] assertEquals("Output should be 'A'", "A", out.toString()); [EOL] }
public void testTranslateWithLessThanFourHexDigits() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u004", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to less than four hex digits"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Exception message should match", "Less than 4 hex digits in unicode value: '\\u004' due to end of CharSequence", e.getMessage()); [EOL] } [EOL] }
public void testTranslateWithInvalidHexDigits() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u00AG", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to invalid hex digits"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Exception message should match", "Unable to parse unicode value: 00AG", e.getMessage()); [EOL] } [EOL] }
public void testTranslateWithoutBackslashU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("A", 0, out); [EOL] assertEquals("Should return 0 because it does not start with '\\u'", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateWithBackslashNotFollowedByU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\n", 0, out); [EOL] assertEquals("Should return 0 because it starts with '\\' but not followed by 'u'", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateAtEndOfString() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u", 0, out); [EOL] fail("Should have thrown IllegalArgumentException due to string ending after '\\u'"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Exception message should match", "Less than 4 hex digits in unicode value: '\\u' due to end of CharSequence", e.getMessage()); [EOL] } [EOL] }
public void testGetShortClassNameWithNullObject() { [EOL] String result = StringUtils.getShortClassName(null, "NullObject"); [EOL] assertEquals("NullObject", result); [EOL] } [EOL] public void testGetShortClassNameWithNonNullObject() { [EOL] String result = StringUtils.getShortClassName(new Object(), null); [EOL] assertEquals("Object", result); [EOL] }
public void testGetShortClassNameEmpty() { [EOL] String className = ""; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetShortClassNameNull() { [EOL] String className = null; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetShortClassNameWithoutPackage() { [EOL] String className = "String"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNameWithPackage() { [EOL] String className = "java.lang.String"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNameInnerClass() { [EOL] String className = "java.lang.Map$Entry"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("Map.Entry", result); [EOL] } [EOL] public void testGetShortClassNameArray() { [EOL] String className = "[Ljava.lang.String;"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String[]", result); [EOL] } [EOL] public void testGetShortClassNameArrayOfArrays() { [EOL] String className = "[[[Ljava.lang.String;"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("String[][][]", result); [EOL] } [EOL] public void testGetShortClassNamePrimitiveArray() { [EOL] String className = "[I"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("int[]", result); [EOL] } [EOL] public void testGetShortClassNameArrayOfPrimitiveArrays() { [EOL] String className = "[[I"; [EOL] String result = ClassUtils.getShortClassName(className); [EOL] assertEquals("int[][]", result); [EOL] }
public void testGetPackageName_NullOrEmpty() { [EOL] assertEquals("", ClassUtils.getPackageName(null)); [EOL] assertEquals("", ClassUtils.getPackageName("")); [EOL] } [EOL] public void testGetPackageName_WithoutPackage() { [EOL] assertEquals("", ClassUtils.getPackageName("ClassWithoutPackage")); [EOL] } [EOL] public void testGetPackageName_WithPackage() { [EOL] assertEquals("java.lang", ClassUtils.getPackageName("java.lang.String")); [EOL] } [EOL] public void testGetPackageName_ArrayClasses() { [EOL] assertEquals("", ClassUtils.getPackageName("[Ljava.lang.String;")); [EOL] assertEquals("", ClassUtils.getPackageName("[[Ljava.lang.String;")); [EOL] } [EOL] public void testGetPackageName_PrimitiveArray() { [EOL] assertEquals("", ClassUtils.getPackageName("[I")); [EOL] assertEquals("", ClassUtils.getPackageName("[[I")); [EOL] } [EOL] public void testGetPackageName_SpecialCharacters() { [EOL] assertEquals("com.example", ClassUtils.getPackageName("com.example.SomeClass;")); [EOL] }
public void testPrimitivesToWrappersWithNullInput() { [EOL] Class<?>[] result = ClassUtils.primitivesToWrappers(null); [EOL] assertNull(result); [EOL] }
public void testPrimitivesToWrappersWithEmptyArray() { [EOL] Class<?>[] emptyArray = new Class<?>[0]; [EOL] Class<?>[] result = ClassUtils.primitivesToWrappers(emptyArray); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testPrimitivesToWrappersWithValidPrimitives() { [EOL] Class<?>[] primitives = {int.class, double.class, void.class}; [EOL] Class<?>[] expectedWrappers = {Integer.class, Double.class, Void.class}; [EOL] Class<?>[] result = ClassUtils.primitivesToWrappers(primitives); [EOL] assertArrayEquals(expectedWrappers, result); [EOL] }
public void testIsInnerClassWithNull() { [EOL] boolean result = isInnerClass(null); [EOL] assertFalse(result); [EOL] }
public void testIsInnerClassWithNonInnerClass() { [EOL] boolean result = isInnerClass(String.class); [EOL] assertFalse(result); [EOL] }
public void testIsInnerClassWithInnerClass() { [EOL] class InnerClass {} [EOL] boolean result = isInnerClass(InnerClass.class); [EOL] assertTrue(result); [EOL] }
protected BackgroundInitializer() { [EOL] this(null); [EOL] }
protected BackgroundInitializer(final ExecutorService exec) { [EOL] setExternalExecutor(exec); [EOL] }
public final synchronized ExecutorService getExternalExecutor() { [EOL] return externalExecutor; [EOL] }
public void testIsStartedWhenFutureIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] boolean result = instance.isStarted(); [EOL] assertFalse(result); [EOL] }
public void testIsStartedWhenFutureIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.future = mock(Future.class); [EOL] boolean result = instance.isStarted(); [EOL] assertTrue(result); [EOL] }
public void testSetExternalExecutor_WhenNotStarted() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] ExecutorService mockExecutorService = mock(ExecutorService.class); // Use a mocking framework like Mockito [EOL] instance.setExternalExecutor(mockExecutorService); [EOL] assertEquals(mockExecutorService, instance.getExternalExecutor()); // Assuming there's a getter for externalExecutor [EOL] }
public void testSetExternalExecutor_WhenStarted_ThrowsException() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] instance.start(); // Assuming there's a start method that sets the started flag [EOL] ExecutorService mockExecutorService = mock(ExecutorService.class); // Use a mocking framework like Mockito [EOL] try { [EOL] instance.setExternalExecutor(mockExecutorService); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Cannot set ExecutorService after start()!", e.getMessage()); [EOL] } [EOL] }
public void testStartWhenNotStartedWithExternalExecutor() { [EOL] MyObject underTest = new MyObject(); [EOL] ExecutorService externalExecutor = mock(ExecutorService.class); [EOL] when(underTest.getExternalExecutor()).thenReturn(externalExecutor); [EOL] when(underTest.isStarted()).thenReturn(false); [EOL] boolean result = underTest.start(); [EOL] assertNotNull(underTest.getFuture()); [EOL] assertTrue(result); [EOL] }
public void testStartWhenNotStartedWithoutExternalExecutor() { [EOL] MyObject underTest = new MyObject(); [EOL] when(underTest.getExternalExecutor()).thenReturn(null); [EOL] when(underTest.isStarted()).thenReturn(false); [EOL] when(underTest.createExecutor()).thenReturn(mock(ExecutorService.class)); [EOL] boolean result = underTest.start(); [EOL] assertNotNull(underTest.getFuture()); [EOL] assertTrue(result); [EOL] }
public void testStartWhenAlreadyStarted() { [EOL] MyObject underTest = new MyObject(); [EOL] when(underTest.isStarted()).thenReturn(true); [EOL] boolean result = underTest.start(); [EOL] assertNull(underTest.getFuture()); [EOL] assertFalse(result); [EOL] }
public void testGet_ExecutionException() throws Exception { [EOL] Future<T> future = mock(Future.class); [EOL] when(future.get()).thenThrow(new ExecutionException(new Exception())); [EOL] MyClass<T> myClass = new MyClass<>(future); [EOL] T result = myClass.get(); [EOL] assertNull(result); [EOL] }
public void testGet_InterruptedException() throws Exception { [EOL] Future<T> future = mock(Future.class); [EOL] when(future.get()).thenThrow(new InterruptedException()); [EOL] MyClass<T> myClass = new MyClass<>(future); [EOL] try { [EOL] myClass.get(); [EOL] fail("Should have thrown ConcurrentException"); [EOL] } catch (ConcurrentException e) { [EOL] } [EOL] assertTrue(Thread.currentThread().isInterrupted()); [EOL] }
public void testGetFutureWhenNotStarted() { [EOL] YourClass instance = new YourClass(); [EOL] try { [EOL] instance.getFuture(); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("start() must be called first!", e.getMessage()); [EOL] } [EOL] }
public void testGetFutureWhenStarted() { [EOL] YourClass instance = new YourClass(); [EOL] instance.start(); // Assuming start() method initializes the future. [EOL] assertNotNull(instance.getFuture()); [EOL] }
protected synchronized final ExecutorService getActiveExecutor() { [EOL] return executor; [EOL] }
protected int getTaskCount() { [EOL] return 1; [EOL] }
private Callable<T> createTask(final ExecutorService execDestroy) { [EOL] return new InitializationTask(execDestroy); [EOL] }
private ExecutorService createExecutor() { [EOL] return Executors.newFixedThreadPool(getTaskCount()); [EOL] }
public void testInitializationTaskWithValidExecutorService() { [EOL] ExecutorService executorService = Executors.newSingleThreadExecutor(); [EOL] InitializationTask task = new InitializationTask(executorService); [EOL] assertNotNull(task); [EOL] executorService.shutdown(); [EOL] }
public void testInitializationTaskWithNullExecutorService() { [EOL] try { [EOL] InitializationTask task = new InitializationTask(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testCall_ExecutesInitialize_WithoutException() throws Exception { [EOL] CallableWithFinally<T> callable = new CallableWithFinally<>(() -> "Initialization", null); [EOL] T result = callable.call(); [EOL] assertEquals("Initialization", result); [EOL] }
public void testCall_ExecutesFinally_WhenExecFinallyIsNotNull() throws Exception { [EOL] ExecutorService execFinallyMock = mock(ExecutorService.class); [EOL] CallableWithFinally<T> callable = new CallableWithFinally<>(() -> "Initialization", execFinallyMock); [EOL] callable.call(); [EOL] verify(execFinallyMock).shutdown(); [EOL] }
public void testCall_DoesNotExecuteFinally_WhenExecFinallyIsNull() throws Exception { [EOL] CallableWithFinally<T> callable = new CallableWithFinally<>(() -> "Initialization", null); [EOL] callable.call(); [EOL] }
public void testConcurrentRuntimeExceptionWithNullCause() { [EOL] Throwable cause = null; [EOL] ConcurrentRuntimeException exception = new ConcurrentRuntimeException(cause); [EOL] assertNull(exception.getCause()); [EOL] }
public void testConcurrentRuntimeExceptionWithCheckedException() { [EOL] Throwable cause = new Exception("Checked Exception"); [EOL] ConcurrentRuntimeException exception = new ConcurrentRuntimeException(cause); [EOL] assertNotNull(exception.getCause()); [EOL] assertEquals("Checked Exception", exception.getCause().getMessage()); [EOL] }
public void testConcurrentRuntimeExceptionWithUncheckedException() { [EOL] Throwable cause = new RuntimeException("Unchecked Exception"); [EOL] ConcurrentRuntimeException exception = new ConcurrentRuntimeException(cause); [EOL] assertNotNull(exception.getCause()); [EOL] assertEquals("Unchecked Exception", exception.getCause().getMessage()); [EOL] }
public void testSystemPropertiesLookup() { [EOL] StrLookup<String> lookup = StringUtils.systemPropertiesLookup(); [EOL] assertNotNull("Lookup should not be null", lookup); [EOL] String systemPropertyValue = System.getProperty("java.version"); [EOL] assertEquals("Lookup should return correct system property value", systemPropertyValue, lookup.lookup("java.version")); [EOL] }
public void testLookupWhenMapIsNull() { [EOL] MapLookup mapLookup = new MapLookup(null); [EOL] String result = mapLookup.lookup("anyKey"); [EOL] assertNull(result); [EOL] } [EOL] public void testLookupWhenKeyNotPresent() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] MapLookup mapLookup = new MapLookup(map); [EOL] String result = mapLookup.lookup("missingKey"); [EOL] assertNull(result); [EOL] } [EOL] public void testLookupWhenKeyPresent() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] map.put("existingKey", "value"); [EOL] MapLookup mapLookup = new MapLookup(map); [EOL] String result = mapLookup.lookup("existingKey"); [EOL] assertEquals("value", result); [EOL] }
public void testExtractCauseWithNullExecutionException() { [EOL] ExecutionException ex = null; [EOL] ConcurrentException result = Lang3Utils.extractCause(ex); [EOL] assertNull(result); [EOL] }
public void testExtractCauseWithExecutionExceptionHavingNullCause() { [EOL] ExecutionException ex = new ExecutionException("Error", null); [EOL] ConcurrentException result = Lang3Utils.extractCause(ex); [EOL] assertNull(result); [EOL] }
public void testExtractCauseWithExecutionExceptionHavingNonNullCause() { [EOL] Throwable cause = new RuntimeException("Cause"); [EOL] ExecutionException ex = new ExecutionException("Error", cause); [EOL] try { [EOL] Lang3Utils.extractCause(ex); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (ConcurrentException e) { [EOL] assertEquals("Error", e.getMessage()); [EOL] assertSame(cause, e.getCause()); [EOL] } [EOL] }
public void testExtractCauseUncheckedWithNullExecutionException() { [EOL] ExecutionException ex = null; [EOL] ConcurrentRuntimeException result = extractCauseUnchecked(ex); [EOL] assertNull(result); [EOL] } [EOL] public void testExtractCauseUncheckedWithNullCause() { [EOL] ExecutionException ex = new ExecutionException("Error", null); [EOL] ConcurrentRuntimeException result = extractCauseUnchecked(ex); [EOL] assertNull(result); [EOL] } [EOL] public void testExtractCauseUncheckedWithNonNullCause() { [EOL] Throwable cause = new RuntimeException("Cause"); [EOL] ExecutionException ex = new ExecutionException("Error", cause); [EOL] try { [EOL] extractCauseUnchecked(ex); [EOL] fail("Expected exception to be thrown"); [EOL] } catch (ConcurrentRuntimeException cre) { [EOL] assertEquals("Error", cre.getMessage()); [EOL] assertSame(cause, cre.getCause()); [EOL] } [EOL] }
public void testCheckedExceptionWithCheckedException() { [EOL] Exception checkedException = new Exception(); [EOL] Throwable result = YourClass.checkedException(checkedException); [EOL] assertEquals(checkedException, result); [EOL] } [EOL] public void testCheckedExceptionWithRuntimeException() { [EOL] try { [EOL] YourClass.checkedException(new RuntimeException()); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: java.lang.RuntimeException", e.getMessage()); [EOL] } [EOL] } [EOL] public void testCheckedExceptionWithError() { [EOL] try { [EOL] YourClass.checkedException(new Error()); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: java.lang.Error", e.getMessage()); [EOL] } [EOL] } [EOL] public void testCheckedExceptionWithNull() { [EOL] try { [EOL] YourClass.checkedException(null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: null", e.getMessage()); [EOL] } [EOL] }
public void testThrowCauseWithRuntimeException() { [EOL] ExecutionException ex = new ExecutionException(new RuntimeException("Test RuntimeException")); [EOL] try { [EOL] throwCause(ex); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Test RuntimeException", e.getMessage()); [EOL] } [EOL] }
public void testThrowCauseWithError() { [EOL] ExecutionException ex = new ExecutionException(new Error("Test Error")); [EOL] try { [EOL] throwCause(ex); [EOL] } catch (Error e) { [EOL] assertEquals("Test Error", e.getMessage()); [EOL] } [EOL] }
public void testThrowCauseWithNonRuntimeExceptionOrError() { [EOL] ExecutionException ex = new ExecutionException(new Exception("Test Exception")); [EOL] try { [EOL] throwCause(ex); [EOL] fail("Expected an Exception to be thrown"); [EOL] } catch (ExecutionException e) { [EOL] assertEquals("Test Exception", e.getCause().getMessage()); [EOL] } [EOL] }
public void testInitializeUncheckedWithValidInitializer() { [EOL] ConcurrentInitializer<String> initializer = () -> "Initialized"; [EOL] String result = ConcurrentUtils.initializeUnchecked(initializer); [EOL] assertEquals("Initialized", result); [EOL] }
public void testInitializeUncheckedWithException() { [EOL] ConcurrentInitializer<String> initializer = () -> { throw new ConcurrentException("Test Exception"); }; [EOL] try { [EOL] ConcurrentUtils.initializeUnchecked(initializer); [EOL] fail("Expected ConcurrentRuntimeException"); [EOL] } catch (ConcurrentRuntimeException crex) { [EOL] assertNotNull(crex.getCause()); [EOL] assertTrue(crex.getCause() instanceof ConcurrentException); [EOL] assertEquals("Test Exception", crex.getCause().getMessage()); [EOL] } [EOL] }
public void testCreateIfAbsentWithNullMap() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = null; [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, new Object(), init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithNullInitializer() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] ConcurrentInitializer<Object> init = null; [EOL] Object result = Lang3.createIfAbsent(map, new Object(), init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithExistingKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertSame(value, result); [EOL] }
public void testCreateIfAbsentWithAbsentKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertNotNull(result); [EOL] assertSame(result, map.get(key)); [EOL] }
protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] this.pattern = pattern; [EOL] this.timeZone = timeZone; [EOL] this.locale = locale; [EOL] init(); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testInitWithValidPattern() { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(parser.getParsePattern()); [EOL] }
public void testInitWithInvalidPattern() { [EOL] try { [EOL] FastDateParser parser = new FastDateParser("invalid-pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testInitWithUnmatchedPattern() { [EOL] try { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd'", TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL] if (!(obj instanceof FastDateParser)) { [EOL] return false; [EOL] } [EOL] final FastDateParser other = (FastDateParser) obj; [EOL] return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testParseWithUnparseableDate() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.US); [EOL] String source = "invalid-date"; [EOL] try { [EOL] parser.parse(source); [EOL] fail("Should have thrown ParseException"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testParseWithJapaneseImperialDateBefore1868() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("Gyyyy-MM-dd", TimeZone.getDefault(), FastDateParser.JAPANESE_IMPERIAL); [EOL] String source = "invalid-date"; [EOL] try { [EOL] parser.parse(source); [EOL] fail("Should have thrown ParseException for dates before 1868 AD"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testParseWithValidDate() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.US); [EOL] String source = "2023-01-01"; [EOL] Date date = parser.parse(source); [EOL] assertNotNull("Date should be parsed successfully", date); [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL] final int offset = pos.getIndex(); [EOL] final Matcher matcher = parsePattern.matcher(source.substring(offset)); [EOL] if (!matcher.lookingAt()) { [EOL] return null; [EOL] } [EOL] final Calendar cal = Calendar.getInstance(timeZone, locale); [EOL] cal.clear(); [EOL] for (int i = 0; i < strategies.length; ) { [EOL] final Strategy strategy = strategies[i++]; [EOL] strategy.setCalendar(this, cal, matcher.group(i)); [EOL] } [EOL] pos.setIndex(offset + matcher.end()); [EOL] return cal.getTime(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
public void testEscapeRegexWithUnquoteAndSingleQuoteAtEnd() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test'"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Expected result to end with \\E", "\\Qtest\\E", result.toString()); [EOL] }
public void testEscapeRegexWithUnquoteAndNoSingleQuote() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Expected result to be unchanged except for \\Q and \\E", "\\Qtest\\E", result.toString()); [EOL] }
public void testEscapeRegexWithUnquoteAndSingleQuoteNotAtEnd() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "te'st"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Expected result to remove single quote and not end with \\E", "\\Qtest\\E", result.toString()); [EOL] }
public void testEscapeRegexWithoutUnquoteAndWithBackslashAtEnd() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test\\"; [EOL] boolean unquote = false; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Expected result to end with \\E and include the backslash", "\\Qtest\\\\\\E", result.toString()); [EOL] }
public void testEscapeRegexWithoutUnquoteAndWithEscapedE() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test\\E"; [EOL] boolean unquote = false; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Expected result to escape the 'E' and not end with \\E", "\\Qtest\\EE\\\\E\\Q\\E", result.toString()); [EOL] }
public void testAdjustYearWithTwoDigitYearLessThan20() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] parser.thisYear = 2023; [EOL] int twoDigitYear = 5; [EOL] int expectedYear = 2005; [EOL] assertEquals(expectedYear, parser.adjustYear(twoDigitYear)); [EOL] }
public void testAdjustYearWithTwoDigitYearEqualTo20() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] parser.thisYear = 2023; [EOL] int twoDigitYear = 20; [EOL] int expectedYear = 1920; [EOL] assertEquals(expectedYear, parser.adjustYear(twoDigitYear)); [EOL] }
public void testAdjustYearWithTwoDigitYearGreaterThan20() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] parser.thisYear = 2023; [EOL] int twoDigitYear = 45; [EOL] int expectedYear = 1945; [EOL] assertEquals(expectedYear, parser.adjustYear(twoDigitYear)); [EOL] }
public void testIsNextNumberWhenNextStrategyIsNull() { [EOL] FastDateParser parser = new FastDateParser("", TimeZone.getDefault(), Locale.getDefault()); [EOL] parser.nextStrategy = null; [EOL] assertFalse(parser.isNextNumber()); [EOL] }
public void testIsNextNumberWhenNextStrategyIsNumber() { [EOL] FastDateParser parser = new FastDateParser("", TimeZone.getDefault(), Locale.getDefault()); [EOL] parser.nextStrategy = new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] assertTrue(parser.isNextNumber()); [EOL] }
public void testGetStrategyWithSingleQuote() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("'SingleQuote'", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("D", definingCalendar); [EOL] assertSame(DAY_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithDayOfWeek() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("E", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfWeekInMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("F", definingCalendar); [EOL] assertSame(DAY_OF_WEEK_IN_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithEra() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("G", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithHourOfDay() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("H", definingCalendar); [EOL] assertSame(MODULO_HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("K", definingCalendar); [EOL] assertSame(HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("M", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy || result instanceof NumberStrategy); [EOL] } [EOL] public void testGetStrategyWithMillisecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("S", definingCalendar); [EOL] assertSame(MILLISECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("W", definingCalendar); [EOL] assertSame(WEEK_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithAmPm() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("a", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("d", definingCalendar); [EOL] assertSame(DAY_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour12() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("h", definingCalendar); [EOL] assertSame(MODULO_HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour24() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("k", definingCalendar); [EOL] assertSame(HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMinute() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("m", definingCalendar); [EOL] assertSame(MINUTE_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithSecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("s", definingCalendar); [EOL] assertSame(SECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("w", definingCalendar); [EOL] assertSame(WEEK_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("y", definingCalendar); [EOL] assertTrue(result instanceof NumberStrategy); [EOL] } [EOL] public void testGetStrategyWithTimeZoneOffset() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("Z", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithTimeZone() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("z", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithEscapedText() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("'EscapedText'", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] } [EOL] public void testGetStrategyWithDefault() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("X", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] }
private static ConcurrentMap<Locale, Strategy> getCache(final int field) { [EOL] synchronized (caches) { [EOL] if (caches[field] == null) { [EOL] caches[field] = new ConcurrentHashMap<Locale, Strategy>(3); [EOL] } [EOL] return caches[field]; [EOL] } [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) { [EOL] final ConcurrentMap<Locale, Strategy> cache = getCache(field); [EOL] Strategy strategy = cache.get(locale); [EOL] if (strategy == null) { [EOL] strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new TextStrategy(field, definingCalendar, locale); [EOL] final Strategy inCache = cache.putIfAbsent(locale, strategy); [EOL] if (inCache != null) { [EOL] return inCache; [EOL] } [EOL] } [EOL] return strategy; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) {; ; [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {; [EOL] int iValue = Integer.parseInt(value);; [EOL] if (iValue < 100) {; [EOL] iValue = parser.adjustYear(iValue);; [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue);; [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) {; ; [EOL] int modify(final int iValue) {; [EOL] return iValue - 1;; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) {; ; [EOL] int modify(final int iValue) {; [EOL] return iValue % 24;; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) {; ; [EOL] int modify(final int iValue) {; [EOL] return iValue % 12;; [EOL] }; [EOL] };
CopyQuotedStrategy(final String formatField) { [EOL] this.formatField = formatField; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testIsNumber_withSingleQuotePrefix() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("'9"); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public void testIsNumber_withoutSingleQuotePrefix() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("5"); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public void testIsNumber_withNonDigit() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("A"); [EOL] assertFalse(strategy.isNumber()); [EOL] }
public void testIsNumber_withSingleQuoteAndNonDigit() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("'A"); [EOL] assertFalse(strategy.isNumber()); [EOL] }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL] escapeRegex(regex, formatField, true); [EOL] return false; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testAddRegexWithEmptyKeyValues() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] StringBuilder regex = new StringBuilder(); [EOL] boolean result = parser.addRegex(parser, regex); [EOL] assertEquals("()", regex.toString()); [EOL] assertTrue(result); [EOL] }
public void testAddRegexWithSingleKeyValue() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] StringBuilder regex = new StringBuilder(); [EOL] parser.keyValues.put("key", 1); [EOL] boolean result = parser.addRegex(parser, regex); [EOL] assertEquals("(key)", regex.toString()); [EOL] assertTrue(result); [EOL] }
public void testAddRegexWithMultipleKeyValues() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] StringBuilder regex = new StringBuilder(); [EOL] parser.keyValues.put("key1", 1); [EOL] parser.keyValues.put("key2", 2); [EOL] boolean result = parser.addRegex(parser, regex); [EOL] assertEquals("(key1|key2)", regex.toString()); [EOL] assertTrue(result); [EOL] }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] final Integer iVal = keyValues.get(value); [EOL] if (iVal == null) { [EOL] final StringBuilder sb = new StringBuilder(value); [EOL] sb.append(" not in ("); [EOL] for (final String textKeyValue : keyValues.keySet()) { [EOL] sb.append(textKeyValue).append(' '); [EOL] } [EOL] sb.setCharAt(sb.length() - 1, ')'); [EOL] throw new IllegalArgumentException(sb.toString()); [EOL] } [EOL] cal.set(field, iVal.intValue()); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
public void testAddRegexWhenNextIsNumber() { [EOL] FastDateParser parser = Mockito.mock(FastDateParser.class); [EOL] StringBuilder regex = new StringBuilder(); [EOL] Mockito.when(parser.isNextNumber()).thenReturn(true); [EOL] Mockito.when(parser.getFieldWidth()).thenReturn(2); [EOL] boolean result = addRegex(parser, regex); [EOL] assertTrue(result); [EOL] assertEquals("(\\p{IsNd}{2}+)", regex.toString()); [EOL] }
public void testAddRegexWhenNextIsNotNumber() { [EOL] FastDateParser parser = Mockito.mock(FastDateParser.class); [EOL] StringBuilder regex = new StringBuilder(); [EOL] Mockito.when(parser.isNextNumber()).thenReturn(false); [EOL] boolean result = addRegex(parser, regex); [EOL] assertTrue(result); [EOL] assertEquals("(\\p{IsNd}++)", regex.toString()); [EOL] }
public void testSetCalendarWithNumberStrategy() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "2023"; [EOL] NUMBER_MONTH_STRATEGY.setCalendar(parser, cal, value); [EOL] assertEquals(2022, cal.get(Calendar.MONTH)); [EOL] }
public void testSetCalendarWithAbbreviatedYearStrategy() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("yy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "23"; [EOL] ABBREVIATED_YEAR_STRATEGY.setCalendar(parser, cal, value); [EOL] int expectedYear = parser.adjustYear(Integer.parseInt(value)); [EOL] assertEquals(expectedYear, cal.get(Calendar.YEAR)); [EOL] }
public void testSetCalendarWithModuloHourOfDayStrategy() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("K", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "25"; [EOL] MODULO_HOUR_OF_DAY_STRATEGY.setCalendar(parser, cal, value); [EOL] assertEquals(1, cal.get(Calendar.HOUR_OF_DAY)); [EOL] }
public void testSetCalendarWithModuloHourStrategy() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("h", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "13"; [EOL] MODULO_HOUR_STRATEGY.setCalendar(parser, cal, value); [EOL] assertEquals(1, cal.get(Calendar.HOUR)); [EOL] }
public void testModify() { [EOL] FastDateParser.NumberStrategy strategy = new FastDateParser.NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] assertEquals(-1, strategy.modify(0)); [EOL] assertEquals(0, strategy.modify(1)); [EOL] assertEquals(11, strategy.modify(12)); [EOL] }
public void testModifyWithModuloHourOfDay() { [EOL] FastDateParser.NumberStrategy strategy = new FastDateParser.NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] assertEquals(0, strategy.modify(0)); [EOL] assertEquals(1, strategy.modify(25)); [EOL] assertEquals(23, strategy.modify(47)); [EOL] }
public void testModifyWithModuloHour() { [EOL] FastDateParser.NumberStrategy strategy = new FastDateParser.NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] }; [EOL] assertEquals(0, strategy.modify(0)); [EOL] assertEquals(1, strategy.modify(13)); [EOL] assertEquals(11, strategy.modify(23)); [EOL] }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL] regex.append(validTimeZoneChars); [EOL] return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; };
public void testSetCalendarWithPlusTimeZone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "+0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT+0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithMinusTimeZone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "-0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT-0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithGMTTimeZone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "GMT+0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT+0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithNamedTimeZone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "Europe/Paris"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("Europe/Paris", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithInvalidTimeZone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "Invalid/TimeZone"; [EOL] try { [EOL] parser.setCalendar(parser, cal, value); [EOL] fail("Should have thrown IllegalArgumentException for invalid timezone."); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
@Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
@Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testReplaceSystemPropertiesWithNullInput() { [EOL] String result = StringUtils.replaceSystemProperties(null); [EOL] assertNull("Result should be null for null input", result); [EOL] } [EOL] public void testReplaceSystemPropertiesWithEmptyString() { [EOL] String result = StringUtils.replaceSystemProperties(""); [EOL] assertEquals("Result should be an empty string for empty input", "", result); [EOL] } [EOL] public void testReplaceSystemPropertiesWithNoSystemProperties() { [EOL] String result = StringUtils.replaceSystemProperties("No system properties here"); [EOL] assertEquals("Result should be the same as input when there are no system properties", "No system properties here", result); [EOL] } [EOL] public void testReplaceSystemPropertiesWithSystemProperty() { [EOL] String original = "Java version: ${java.version}"; [EOL] String expected = "Java version: " + System.getProperty("java.version"); [EOL] String result = StringUtils.replaceSystemProperties(original); [EOL] assertEquals("Result should replace system property with its value", expected, result); [EOL] }
public void testReplaceSystemPropertiesWithMultipleSystemProperties() { [EOL] String original = "Java version: ${java.version}, OS name: ${os.name}"; [EOL] String expected = "Java version: " + System.getProperty("java.version") + ", OS name: " + System.getProperty("os.name"); [EOL] String result = StringUtils.replaceSystemProperties(original); [EOL] assertEquals("Result should replace multiple system properties with their values", expected, result); [EOL] }
public void testReplaceSystemPropertiesWithEscapedSystemProperty() { [EOL] String original = "Ignore this: $${java.version}"; [EOL] String expected = "Ignore this: ${java.version}"; [EOL] String result = StringUtils.replaceSystemProperties(original); [EOL] assertEquals("Result should not replace escaped system property", expected, result); [EOL] }
It seems there might be a misunderstanding. As an AI language model, I can generate Java unit test cases for you, but I don't have the capability to process or interpret actual Java code with surrounding comments or annotations. If you provide me with a specific method signature and its expected behavior, I can certainly help you write a test case for it. However, I cannot remove comments or annotations from existing Java code. If you have a specific method you'd like to test, please provide the details, and I'll be happy to assist you in writing a test case for it.
public void testStrSubstitutorWithVariableResolver() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor sub = new StrSubstitutor(variableResolver); [EOL] assertNotNull(sub.getVariableResolver()); [EOL] assertEquals(StrSubstitutor.DEFAULT_ESCAPE, sub.getEscapeChar()); [EOL] assertEquals(StrSubstitutor.DEFAULT_PREFIX, sub.getVariablePrefixMatcher()); [EOL] assertEquals(StrSubstitutor.DEFAULT_SUFFIX, sub.getVariableSuffixMatcher()); [EOL] }
public void testStrSubstitutorWithNullVariableResolver() { [EOL] StrSubstitutor sub = new StrSubstitutor((StrLookup<?>) null); [EOL] assertNull(sub.getVariableResolver()); [EOL] }
public String replace(final String source) { [EOL] if (source == null) { [EOL] return null; [EOL] } [EOL] final StrBuilder buf = new StrBuilder(source); [EOL] if (substitute(buf, 0, source.length()) == false) { [EOL] return source; [EOL] } [EOL] return buf.toString(); [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public String replace(final String source, final int offset, final int length) { [EOL] if (source == null) { [EOL] return null; [EOL] } [EOL] final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL] if (substitute(buf, 0, length) == false) { [EOL] return source.substring(offset, offset + length); [EOL] } [EOL] return buf.toString(); [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testReplaceWithCharArrayNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] char[] source = null; [EOL] String result = substitutor.replace(source); [EOL] assertNull(result); [EOL] }
public void testReplaceWithCharArrayNotNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] char[] source = {'h', 'e', 'l', 'l', 'o'}; [EOL] String result = substitutor.replace(source); [EOL] assertNotNull(result); [EOL] assertEquals("hello", result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_NullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = null; [EOL] String result = sub.replace(source, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_EmptySource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = new char[0]; [EOL] String result = sub.replace(source, 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_ValidSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = "HelloWorld".toCharArray(); [EOL] String result = sub.replace(source, 0, source.length); [EOL] assertNotNull(result); [EOL] assertEquals("HelloWorld", result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_SubstringSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = "HelloWorld".toCharArray(); [EOL] String result = sub.replace(source, 5, 5); [EOL] assertNotNull(result); [EOL] assertEquals("World", result); [EOL] }
public void testReplaceWithNullStringBuffer() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((StringBuffer) null); [EOL] assertNull(result); [EOL] }
public void testReplaceWithStringBuffer() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("abc${key}def"); [EOL] String result = substitutor.replace(source); [EOL] assertNotNull(result); [EOL] assertEquals("abc${key}def", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_NullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String result = sub.replace((StringBuffer) null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_EmptySource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer(""); [EOL] String result = sub.replace(source, 0, 10); [EOL] assertEquals("", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_ValidSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] String result = sub.replace(source, 0, 5); [EOL] assertEquals("hello", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_OffsetOutOfBounds() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] try { [EOL] sub.replace(source, 20, 5); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_LengthOutOfBounds() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] try { [EOL] sub.replace(source, 0, 50); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_StrBuilder_Null() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((StrBuilder) null); [EOL] assertNull(result); [EOL] }
public void testReplace_StrBuilder() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abc"); [EOL] String result = substitutor.replace(source); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testReplace_StrBuilderNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((StrBuilder) null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplace_StrBuilderValid() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] String result = substitutor.replace(source, 0, 6); [EOL] assertNotNull(result); [EOL] assertEquals("abcdef", result); [EOL] }
public void testReplace_StrBuilderPartial() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] String result = substitutor.replace(source, 2, 3); [EOL] assertNotNull(result); [EOL] assertEquals("cde", result); [EOL] }
public void testReplace_StrBuilderOffsetOutOfBounds() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] try { [EOL] substitutor.replace(source, 10, 3); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_StrBuilderLengthOutOfBounds() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] try { [EOL] substitutor.replace(source, 0, 10); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithNullSource() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] String result = strSubstitutor.replace((Object) null); [EOL] assertNull(result); [EOL] }
public void testReplaceWithNonNullSource() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] String result = strSubstitutor.replace("test"); [EOL] assertNotNull(result); [EOL] assertEquals("test", result); // Assuming no variables to substitute in the string "test" [EOL] }
public void testReplaceInWithNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] boolean result = substitutor.replaceIn(null); [EOL] assertFalse(result); [EOL] }
public void testReplaceInWithNonNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("test"); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue(result); [EOL] }
public boolean replaceIn(final StringBuffer source, final int offset, final int length) { [EOL] if (source == null) { [EOL] return false; [EOL] } [EOL] final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL] if (substitute(buf, 0, length) == false) { [EOL] return false; [EOL] } [EOL] source.replace(offset, offset + length, buf.toString()); [EOL] return true; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")]
public void testReplaceInStrBuilderWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] boolean result = substitutor.replaceIn((StrBuilder) null); [EOL] assertFalse(result); [EOL] }
public void testReplaceInStrBuilderWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("test"); [EOL] boolean result = substitutor.replaceIn(source); [EOL] assertTrue(result); [EOL] }
public void testReplaceInStrBuilderWithNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = null; [EOL] boolean result = substitutor.replaceIn(source, 0, 10); [EOL] assertFalse("replaceIn should return false when source is null", result); [EOL] }
public void testReplaceInStrBuilderWithValidSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("test"); [EOL] boolean result = substitutor.replaceIn(source, 0, source.length()); [EOL] assertTrue("replaceIn should return true when source is valid", result); [EOL] }
public void testSetVariableSuffixMatcherWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher("}"); [EOL] substitutor.setVariableSuffixMatcher(suffixMatcher); [EOL] assertEquals(suffixMatcher, substitutor.getVariableSuffixMatcher()); [EOL] }
public void testSetVariableSuffixMatcherWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.setVariableSuffixMatcher(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public StrSubstitutor setVariableSuffix(final char suffix) { [EOL] return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix)); [EOL] }
public void testSetVariableSuffixWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.setVariableSuffix(null); [EOL] fail("Should have thrown IllegalArgumentException for null suffix"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetVariableSuffixWithValidSuffix() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] substitutor.setVariableSuffix("}"); [EOL] assertEquals("Suffix matcher not set correctly", StrMatcher.stringMatcher("}"), substitutor.getVariableSuffixMatcher()); [EOL] }
public void testFractionConstructorValidDenominator() { [EOL] int numerator = 1; [EOL] int denominator = 2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] assertEquals(numerator, fraction.getNumerator()); [EOL] assertEquals(denominator, fraction.getDenominator()); [EOL] }
public void testFractionConstructorZeroDenominator() { [EOL] int numerator = 1; [EOL] int denominator = 0; [EOL] try { [EOL] new Fraction(numerator, denominator); [EOL] fail("Should have thrown an ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testGetFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 0); [EOL] fail("Expected ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_NegativeDenominator_PositiveNumerator() { [EOL] Fraction fraction = Fraction.getFraction(1, -2); [EOL] assertEquals(-1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_NegativeDenominator_NegativeNumerator() { [EOL] Fraction fraction = Fraction.getFraction(-1, -2); [EOL] assertEquals(1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_PositiveDenominator_PositiveNumerator() { [EOL] Fraction fraction = Fraction.getFraction(1, 2); [EOL] assertEquals(1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_MinValueNumerator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MIN_VALUE, -1); [EOL] fail("Expected ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_MinValueDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(-1, Integer.MIN_VALUE); [EOL] fail("Expected ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_PositiveWholeNumber() { [EOL] Fraction result = Fraction.getFraction(5.0); [EOL] assertEquals(5, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_NegativeWholeNumber() { [EOL] Fraction result = Fraction.getFraction(-5.0); [EOL] assertEquals(-5, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_PositiveFraction() { [EOL] Fraction result = Fraction.getFraction(1.5); [EOL] assertEquals(3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_NegativeFraction() { [EOL] Fraction result = Fraction.getFraction(-1.5); [EOL] assertEquals(-3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_ValueGreaterThanMaxInt() { [EOL] try { [EOL] Fraction.getFraction((double) Integer.MAX_VALUE + 1); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testGetFraction_NaN() { [EOL] try { [EOL] Fraction.getFraction(Double.NaN); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testGetFraction_Infinite() { [EOL] try { [EOL] Fraction.getFraction(Double.POSITIVE_INFINITY); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testGetFraction_Unconvertible() { [EOL] try { [EOL] Fraction.getFraction(0.0000000000000001); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }

public void testGetNumerator_PositiveNumerator() { [EOL] Fraction fraction = new Fraction(5, 10); [EOL] assertEquals(5, fraction.getNumerator()); [EOL] }
public void testGetNumerator_NegativeNumerator() { [EOL] Fraction fraction = new Fraction(-5, 10); [EOL] assertEquals(-5, fraction.getNumerator()); [EOL] }
public void testGetNumerator_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 10); [EOL] assertEquals(0, fraction.getNumerator()); [EOL] }
public void testGetDenominator() { [EOL] int expectedDenominator = 5; [EOL] Fraction fraction = new Fraction(1, expectedDenominator); [EOL] int actualDenominator = fraction.getDenominator(); [EOL] assertEquals(expectedDenominator, actualDenominator); [EOL] }
public void testInvert_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 1); [EOL] try { [EOL] fraction.invert(); [EOL] fail("Should have thrown ArithmeticException for zero numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Unable to invert zero.", ae.getMessage()); [EOL] } [EOL] }
public void testInvert_MinValueNumerator() { [EOL] Fraction fraction = new Fraction(Integer.MIN_VALUE, 1); [EOL] try { [EOL] fraction.invert(); [EOL] fail("Should have thrown ArithmeticException for Integer.MIN_VALUE numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate numerator", ae.getMessage()); [EOL] } [EOL] }
public void testInvert_NegativeNumerator() { [EOL] Fraction fraction = new Fraction(-3, 4); [EOL] Fraction result = fraction.invert(); [EOL] assertEquals(4, result.getNumerator()); [EOL] assertEquals(-3, result.getDenominator()); [EOL] }
public void testInvert_PositiveNumerator() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.invert(); [EOL] assertEquals(4, result.getNumerator()); [EOL] assertEquals(3, result.getDenominator()); [EOL] }
public void testGreatestCommonDivisor_bothZero() { [EOL] try { [EOL] int result = greatestCommonDivisor(0, 0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGreatestCommonDivisor_oneZero() { [EOL] assertEquals(10, greatestCommonDivisor(0, 10)); [EOL] assertEquals(10, greatestCommonDivisor(10, 0)); [EOL] } [EOL] public void testGreatestCommonDivisor_oneMinValue() { [EOL] try { [EOL] int result = greatestCommonDivisor(Integer.MIN_VALUE, 0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] try { [EOL] int result = greatestCommonDivisor(0, Integer.MIN_VALUE); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGreatestCommonDivisor_absOne() { [EOL] assertEquals(1, greatestCommonDivisor(1, 10)); [EOL] assertEquals(1, greatestCommonDivisor(10, 1)); [EOL] assertEquals(1, greatestCommonDivisor(-1, 10)); [EOL] assertEquals(1, greatestCommonDivisor(10, -1)); [EOL] } [EOL] public void testGreatestCommonDivisor_commonCase() { [EOL] assertEquals(2, greatestCommonDivisor(-2, -4)); [EOL] assertEquals(2, greatestCommonDivisor(-4, -2)); [EOL] } [EOL] public void testGreatestCommonDivisor_largeK() { [EOL] try { [EOL] int result = greatestCommonDivisor(Integer.MIN_VALUE, Integer.MIN_VALUE); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] }
public void testMulAndCheck_MinValueOverflow() { [EOL] try { [EOL] int result = mulAndCheck(Integer.MIN_VALUE, 2); [EOL] fail("Expected ArithmeticException for overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: mul", e.getMessage()); [EOL] } [EOL] } [EOL] public void testMulAndCheck_MaxValueOverflow() { [EOL] try { [EOL] int result = mulAndCheck(Integer.MAX_VALUE, 2); [EOL] fail("Expected ArithmeticException for overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: mul", e.getMessage()); [EOL] } [EOL] } [EOL] public void testMulAndCheck_NoOverflow() { [EOL] int result = mulAndCheck(10000, 20000); [EOL] assertEquals(200000000, result); [EOL] }
public void testMulAndCheck_Zero() { [EOL] int result = mulAndCheck(0, 123456); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testMulAndCheck_One() { [EOL] int result = mulAndCheck(1, -1); [EOL] assertEquals(-1, result); [EOL] }
public void testMulAndCheck_NegativeValues() { [EOL] int result = mulAndCheck(-10000, 20000); [EOL] assertEquals(-200000000, result); [EOL] }
public void testMulPosAndCheck_MaxValues() { [EOL] int x = Integer.MAX_VALUE; [EOL] int y = 1; [EOL] int result = mulPosAndCheck(x, y); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] }
public void testMulPosAndCheck_Overflow() { [EOL] int x = Integer.MAX_VALUE; [EOL] int y = 2; [EOL] try { [EOL] mulPosAndCheck(x, y); [EOL] fail("Expected ArithmeticException for overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: mulPos", e.getMessage()); [EOL] } [EOL] }
public void testMulPosAndCheck_NonOverflowProduct() { [EOL] int x = 12345; [EOL] int y = 6789; [EOL] int expectedProduct = x * y; [EOL] int result = mulPosAndCheck(x, y); [EOL] assertEquals(expectedProduct, result); [EOL] }
public void testMultiplyBy_NullFraction_ThrowsIllegalArgumentException() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] try { [EOL] fraction.multiplyBy(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMultiplyBy_ZeroNumerator_ReturnsZero() { [EOL] Fraction fraction1 = new Fraction(0, 3); [EOL] Fraction fraction2 = new Fraction(2, 3); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] assertEquals(Fraction.ZERO, result); [EOL] }
public void testMultiplyBy_ZeroNumeratorOther_ReturnsZero() { [EOL] Fraction fraction1 = new Fraction(3, 4); [EOL] Fraction fraction2 = new Fraction(0, 5); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] assertEquals(Fraction.ZERO, result); [EOL] }
public void testMultiplyBy_NonZeroFractions_ReturnsReducedProduct() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(2, 3); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] Fraction expected = new Fraction(1, 3); // Assuming getReducedFraction works correctly [EOL] assertEquals(expected, result); [EOL] }
public void testDivideBy_NullFraction_ThrowsIllegalArgumentException() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] try { [EOL] fraction.divideBy(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testDivideBy_ZeroNumerator_ThrowsArithmeticException() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Fraction zeroFraction = new Fraction(0, 1); [EOL] try { [EOL] fraction.divideBy(zeroFraction); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testDivideBy_ValidFraction_ReturnsCorrectResult() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Fraction otherFraction = new Fraction(2, 3); [EOL] Fraction result = fraction.divideBy(otherFraction); [EOL] assertEquals(new Fraction(3, 4), result); [EOL] }
public void testHashCodeWhenHashCodeIsZero() { [EOL] Fraction fraction = new Fraction(1, 2); // Assuming Fraction is the class and it has a constructor that accepts numerator and denominator [EOL] int expectedHashCode = 37 * (37 * 17 + fraction.getNumerator()) + fraction.getDenominator(); [EOL] int actualHashCode = fraction.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWhenHashCodeIsNotZero() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] fraction.hashCode(); // Call hashCode once to set it from zero [EOL] int expectedHashCode = fraction.hashCode(); [EOL] int actualHashCode = fraction.hashCode(); // Call hashCode again to check if it returns the precomputed value [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testCharSequenceUtilsConstructor() { [EOL] new CharSequenceUtils(); [EOL] }
public void testIndexOf_NullCs() { [EOL] int result = StringUtils.indexOf(null, "a", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NullSearchChar() { [EOL] int result = StringUtils.indexOf("abc", null, 0); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ValidInput() { [EOL] int result = StringUtils.indexOf("abc", "a", 0); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_ValidInputWithStart() { [EOL] int result = StringUtils.indexOf("abcabc", "a", 2); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOf_NotFound() { [EOL] int result = StringUtils.indexOf("abc", "d", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_EmptyCs() { [EOL] int result = StringUtils.indexOf("", "a", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_EmptySearchChar() { [EOL] int result = StringUtils.indexOf("abc", "", 0); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_StartGreaterThanLength() { [EOL] int result = StringUtils.indexOf("abc", "a", 5); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_NullCs() { [EOL] int result = StringUtils.lastIndexOf(null, "a", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_NullSearchChar() { [EOL] int result = StringUtils.lastIndexOf("abc", null, 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ValidInput() { [EOL] int result = StringUtils.lastIndexOf("abcabc", "a", 5); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_ValidInputFromStart() { [EOL] int result = StringUtils.lastIndexOf("abcabc", "a", 2); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_EmptyCs() { [EOL] int result = StringUtils.lastIndexOf("", "a", 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_EmptySearchChar() { [EOL] int result = StringUtils.lastIndexOf("abc", "", 2); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_StartOutOfBounds() { [EOL] int result = StringUtils.lastIndexOf("abc", "a", 10); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_NegativeStart() { [EOL] int result = StringUtils.lastIndexOf("abc", "a", -1); [EOL] assertEquals(-1, result); [EOL] }
public void testToCharArrayWithString() { [EOL] String input = "test"; [EOL] char[] expected = {'t', 'e', 's', 't'}; [EOL] char[] actual = StringUtils.toCharArray(input); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testToCharArrayWithCharSequence() { [EOL] CharSequence input = new StringBuilder("test"); [EOL] char[] expected = {'t', 'e', 's', 't'}; [EOL] char[] actual = StringUtils.toCharArray(input); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testPrevious_WithHasPrevious() { [EOL] String input = "token1 token2 token3"; [EOL] StringTokenizer tokenizer = new StringTokenizer(input); [EOL] while (tokenizer.hasMoreTokens()) { [EOL] tokenizer.nextToken(); [EOL] } [EOL] tokenizer.previous(); [EOL] String result = tokenizer.previous(); [EOL] assertEquals("token2", result); [EOL] }
public void testPrevious_WithoutHasPrevious_ExpectingException() { [EOL] StringTokenizer tokenizer = new StringTokenizer(""); [EOL] try { [EOL] tokenizer.previous(); [EOL] fail("Expected an NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testRemoveUnsupported() { [EOL] Iterator<Object> iterator = new AbstractIteratorDecorator<Object>(null) { [EOL] @Override [EOL] public Object next() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] iterator.remove(); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("remove() is unsupported", e.getMessage()); [EOL] } [EOL] }
public void testSetUnsupportedOperationException() { [EOL] try { [EOL] set("test"); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("set() is unsupported", e.getMessage()); [EOL] } [EOL] }
public void testAddUnsupportedOperationException() { [EOL] try { [EOL] add("test"); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("add() is unsupported", e.getMessage()); [EOL] } [EOL] }
public void testEquals_SameAnnotations_ShouldReturnTrue() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = a1; [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertTrue(result); [EOL] }
public void testEquals_OneNullAnnotation_ShouldReturnFalse() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = null; [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertFalse(result); [EOL] }
public void testEquals_DifferentTypes_ShouldReturnFalse() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Deprecated.class); [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameTypeDifferentMembers_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenReturn(Override.class); [EOL] when(method.invoke(a2)).thenReturn(Deprecated.class); [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameTypeSameMembers_ShouldReturnTrue() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenReturn(Override.class); [EOL] when(method.invoke(a2)).thenReturn(Override.class); [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertTrue(result); [EOL] }
public void testEquals_InvocationTargetException_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenThrow(new InvocationTargetException(new Exception())); [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertFalse(result); [EOL] }
public void testEquals_IllegalAccessException_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenThrow(new IllegalAccessException()); [EOL] boolean result = AnnotationUtils.equals(a1, a2); [EOL] assertFalse(result); [EOL] }
public void testIsValidAnnotationMemberType_Null() { [EOL] assertFalse(AnnotationUtils.isValidAnnotationMemberType(null)); [EOL] }
public void testIsValidAnnotationMemberType_Primitive() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(int.class)); [EOL] }
public void testIsValidAnnotationMemberType_Array() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(String[].class)); [EOL] }
public void testIsValidAnnotationMemberType_Enum() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(Thread.State.class)); [EOL] }
public void testIsValidAnnotationMemberType_Annotation() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(Override.class)); [EOL] }
public void testIsValidAnnotationMemberType_String() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(String.class)); [EOL] }
public void testIsValidAnnotationMemberType_Class() { [EOL] assertTrue(AnnotationUtils.isValidAnnotationMemberType(Class.class)); [EOL] }
public void testIsValidAnnotationMemberType_Other() { [EOL] assertFalse(AnnotationUtils.isValidAnnotationMemberType(Object.class)); [EOL] }
private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL] if (o1 == o2) { [EOL] return true; [EOL] } [EOL] if (o1 == null || o2 == null) { [EOL] return false; [EOL] } [EOL] if (type.isArray()) { [EOL] return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL] } [EOL] if (type.isAnnotation()) { [EOL] return equals((Annotation) o1, (Annotation) o2); [EOL] } [EOL] return o1.equals(o2); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=new ToStringStyle() { [EOL] private static final long serialVersionUID = 1L; [EOL] { [EOL] setDefaultFullDetail(true); [EOL] setArrayContentDetail(true); [EOL] setUseClassName(true); [EOL] setUseShortClassName(true); [EOL] setUseIdentityHashCode(false); [EOL] setContentStart("("); [EOL] setContentEnd(")"); [EOL] setFieldSeparator(", "); [EOL] setArrayStart("["); [EOL] setArrayEnd("]"); [EOL] } [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] };
private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL] if (componentType.isAnnotation()) { [EOL] return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL] } [EOL] if (componentType.equals(Byte.TYPE)) { [EOL] return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL] } [EOL] if (componentType.equals(Short.TYPE)) { [EOL] return Arrays.equals((short[]) o1, (short[]) o2); [EOL] } [EOL] if (componentType.equals(Integer.TYPE)) { [EOL] return Arrays.equals((int[]) o1, (int[]) o2); [EOL] } [EOL] if (componentType.equals(Character.TYPE)) { [EOL] return Arrays.equals((char[]) o1, (char[]) o2); [EOL] } [EOL] if (componentType.equals(Long.TYPE)) { [EOL] return Arrays.equals((long[]) o1, (long[]) o2); [EOL] } [EOL] if (componentType.equals(Float.TYPE)) { [EOL] return Arrays.equals((float[]) o1, (float[]) o2); [EOL] } [EOL] if (componentType.equals(Double.TYPE)) { [EOL] return Arrays.equals((double[]) o1, (double[]) o2); [EOL] } [EOL] if (componentType.equals(Boolean.TYPE)) { [EOL] return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL] } [EOL] return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] }
private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL] if (a1.length != a2.length) { [EOL] return false; [EOL] } [EOL] for (int i = 0; i < a1.length; i++) { [EOL] if (!equals(a1[i], a2[i])) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } [EOL] public AnnotationUtils(); [EOL] protected String getShortClassName(final java.lang.Class<?> cls); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); [EOL] public static boolean equals(final Annotation a1, final Annotation a2); [EOL] public static int hashCode(final Annotation a); [EOL] public static String toString(final Annotation a); [EOL] public static boolean isValidAnnotationMemberType(Class<?> type); [EOL] private static int hashMember(final String name, final Object value); [EOL] private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); [EOL] private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); [EOL] private static int arrayMemberHash(final Class<?> componentType, final Object o); [EOL] ToStringStyle TO_STRING_STYLE=new ToStringStyle() { [EOL] private static final long serialVersionUID = 1L; [EOL] { [EOL] setDefaultFullDetail(true); [EOL] setArrayContentDetail(true); [EOL] setUseClassName(true); [EOL] setUseShortClassName(true); [EOL] setUseIdentityHashCode(false); [EOL] setContentStart("("); [EOL] setContentEnd(")"); [EOL] setFieldSeparator(", "); [EOL] setArrayStart("["); [EOL] setArrayEnd("]"); [EOL] } [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] }
public void testToUtf16Escape_withNonSurrogatePair() { [EOL] String result = toUtf16Escape('A'); [EOL] assertEquals("\\u0041\\u0000", result); [EOL] }
public void testToUtf16Escape_withSurrogatePair() { [EOL] String result = toUtf16Escape(0x1D11E); // U+1D11E is a surrogate pair in UTF-16 [EOL] assertEquals("\\uD834\\uDD1E", result); [EOL] }
public void testFormatWithMillisPatternAndTimeZone() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] String formattedDate = StringUtils.format(millis, pattern, timeZone); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] sdf.setTimeZone(timeZone); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormatWithMillisPatternAndNullTimeZone() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(millis, pattern, null); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] assertEquals(sdf.format(new Date(millis)), formattedDate); [EOL] }
public void testFormat_withValidDatePatternTimeZone() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] String formattedDate = StringUtils.format(date, pattern, timeZone); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] sdf.setTimeZone(timeZone); [EOL] assertEquals(sdf.format(date), formattedDate); [EOL] }
public void testFormat_withNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] String formattedDate = StringUtils.format(null, pattern, timeZone); [EOL] assertNull(formattedDate); [EOL] }
public void testFormat_withNullPattern() { [EOL] Date date = new Date(); [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] try { [EOL] StringUtils.format(date, null, timeZone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormat_withNullTimeZone() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(date, pattern, null); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] assertEquals(sdf.format(date), formattedDate); [EOL] }
public void testFormat_withValidDatePatternTimeZoneLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(date, pattern, timeZone, locale); [EOL] assertNotNull(formattedDate); [EOL] FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL] String expected = df.format(date); [EOL] assertEquals(expected, formattedDate); [EOL] }
public void testFormat_withNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(null, pattern, timeZone, locale); [EOL] assertNull(formattedDate); [EOL] }
public void testFormat_withNullPattern() { [EOL] Date date = new Date(); [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] StringUtils.format(date, null, timeZone, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormat_withNullTimeZone() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(date, pattern, null, locale); [EOL] assertNotNull(formattedDate); [EOL] FastDateFormat df = FastDateFormat.getInstance(pattern, TimeZone.getDefault(), locale); [EOL] String expected = df.format(date); [EOL] assertEquals(expected, formattedDate); [EOL] }
public void testFormat_withNullLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] String formattedDate = StringUtils.format(date, pattern, timeZone, null); [EOL] assertNotNull(formattedDate); [EOL] FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, Locale.getDefault()); [EOL] String expected = df.format(date); [EOL] assertEquals(expected, formattedDate); [EOL] }
public void testEquals_withNonFastDatePrinterObject() { [EOL] FastDatePrinter printer = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] Object nonFastDatePrinterObject = new Object(); [EOL] boolean result = printer.equals(nonFastDatePrinterObject); [EOL] assertFalse(result); [EOL] }
public void testEquals_withFastDatePrinterDifferentPattern() { [EOL] FastDatePrinter printer1 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] FastDatePrinter printer2 = new FastDatePrinter("MM-dd-yyyy", TimeZone.getDefault(), Locale.getDefault()); [EOL] boolean result = printer1.equals(printer2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withFastDatePrinterDifferentTimeZone() { [EOL] FastDatePrinter printer1 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getTimeZone("GMT"), Locale.getDefault()); [EOL] FastDatePrinter printer2 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getTimeZone("UTC"), Locale.getDefault()); [EOL] boolean result = printer1.equals(printer2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withFastDatePrinterDifferentLocale() { [EOL] FastDatePrinter printer1 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.US); [EOL] FastDatePrinter printer2 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.UK); [EOL] boolean result = printer1.equals(printer2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withIdenticalFastDatePrinter() { [EOL] FastDatePrinter printer1 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] FastDatePrinter printer2 = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] boolean result = printer1.equals(printer2); [EOL] assertTrue(result); [EOL] }
public void testHashCode() { [EOL] Pattern pattern = Pattern.compile("test"); [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = new Locale("en", "US"); [EOL] CustomClass instance = new CustomClass(pattern, timeZone, locale); [EOL] int expectedHashCode = pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode()); [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testAppendSuperWhenIsEqualsIsTrue() { [EOL] EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL] equalsBuilder.isEquals = true; [EOL] EqualsBuilder result = equalsBuilder.appendSuper(true); [EOL] assertSame("Expected same EqualsBuilder instance", equalsBuilder, result); [EOL] assertTrue("Expected isEquals to be true", equalsBuilder.isEquals); [EOL] } [EOL] public void testAppendSuperWhenIsEqualsIsFalse() { [EOL] EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL] equalsBuilder.isEquals = false; [EOL] EqualsBuilder result = equalsBuilder.appendSuper(false); [EOL] assertSame("Expected same EqualsBuilder instance", equalsBuilder, result); [EOL] assertFalse("Expected isEquals to be false", equalsBuilder.isEquals); [EOL] } [EOL] public void testAppendSuperWhenIsEqualsIsTrueAndSuperEqualsIsFalse() { [EOL] EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL] equalsBuilder.isEquals = true; [EOL] EqualsBuilder result = equalsBuilder.appendSuper(false); [EOL] assertSame("Expected same EqualsBuilder instance", equalsBuilder, result); [EOL] assertFalse("Expected isEquals to be false", equalsBuilder.isEquals); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(null, null); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_SameObject() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj, obj); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentNonArrayObjects() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_OneObjectNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] builder.append(lhs, null); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_NonArrayDifferentClasses() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new String("Test"); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_LongArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long[] lhs = {1L, 2L, 3L}; [EOL] long[] rhs = {1L, 2L, 3L}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_IntArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] int[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ShortArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short[] lhs = {1, 2, 3}; [EOL] short[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_CharArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ByteArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = {1, 2, 3}; [EOL] byte[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DoubleArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] double[] lhs = {1.0, 2.0, 3.0}; [EOL] double[] rhs = {1.0, 2.0, 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_FloatArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_BooleanArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ObjectArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = {1, "test", 3.0}; [EOL] Object[] rhs = {1, "test", 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentArrayTypes() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] long[] rhs = {1L, 2L, 3L}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortEquals() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short lhs = 5; [EOL] short rhs = 5; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendShortNotEquals() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short lhs = 5; [EOL] short rhs = 10; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendShortWhenAlreadyNotEquals() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append((short)5, (short)10); // Set isEquals to false [EOL] builder.append((short)10, (short)10); // Should maintain isEquals as false [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithEqualArrays() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithDifferentArrays() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {4L, 5L, 6L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithDifferentLengths() { [EOL] long[] array1 = new long[] {1L, 2L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithNullAndNonNull() { [EOL] long[] array1 = null; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithBothNull() { [EOL] long[] array1 = null; [EOL] long[] array2 = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongArraysWhenEqualsIsAlreadyFalse() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithSameArrayInstance() { [EOL] long[] array = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendSameArrays() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendDifferentArraysSameLength() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 4}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendDifferentLengthArrays() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNonNullVsNullArrays() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNullVsNonNullArrays() { [EOL] int[] lhs = null; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNullArrays() { [EOL] int[] lhs = null; [EOL] int[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendArraysAlreadyNotEqual() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {4, 5, 6}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithEqualArrays() { [EOL] short[] lhs = new short[] {1, 2, 3}; [EOL] short[] rhs = new short[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithDifferentArrays() { [EOL] short[] lhs = new short[] {1, 2, 3}; [EOL] short[] rhs = new short[] {4, 5, 6}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithDifferentLengths() { [EOL] short[] lhs = new short[] {1, 2, 3}; [EOL] short[] rhs = new short[] {1, 2}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithNullLhs() { [EOL] short[] lhs = null; [EOL] short[] rhs = new short[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithNullRhs() { [EOL] short[] lhs = new short[] {1, 2, 3}; [EOL] short[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendShortArraysWithBothNulls() { [EOL] short[] lhs = null; [EOL] short[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendShortArraysWhenIsEqualsIsAlreadyFalse() { [EOL] short[] lhs = new short[] {1, 2, 3}; [EOL] short[] rhs = new short[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendSameArrays() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] array = new byte[]{1, 2, 3}; [EOL] EqualsBuilder result = builder.append(array, array); [EOL] assertTrue(result.isEquals()); [EOL] }
public void testAppendDifferentLengthArrays() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = new byte[]{1, 2, 3}; [EOL] byte[] rhs = new byte[]{1, 2}; [EOL] EqualsBuilder result = builder.append(lhs, rhs); [EOL] assertFalse(result.isEquals()); [EOL] }
public void testAppendDifferentArrays() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = new byte[]{1, 2, 3}; [EOL] byte[] rhs = new byte[]{4, 5, 6}; [EOL] EqualsBuilder result = builder.append(lhs, rhs); [EOL] assertFalse(result.isEquals()); [EOL] }
public void testAppendNullLeftArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] rhs = new byte[]{1, 2, 3}; [EOL] EqualsBuilder result = builder.append(null, rhs); [EOL] assertFalse(result.isEquals()); [EOL] }
public void testAppendNullRightArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = new byte[]{1, 2, 3}; [EOL] EqualsBuilder result = builder.append(lhs, null); [EOL] assertFalse(result.isEquals()); [EOL] }
public void testAppendNullBothArrays() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] EqualsBuilder result = builder.append(null, null); [EOL] assertTrue(result.isEquals()); [EOL] }
public void testAppendNonEqualIsEqualsFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] byte[] lhs = new byte[]{1, 2, 3}; [EOL] byte[] rhs = new byte[]{1, 2, 3}; [EOL] EqualsBuilder result = builder.append(lhs, rhs); [EOL] assertFalse(result.isEquals()); [EOL] }
public void testBuildReturnsTrueWhenEquals() { [EOL] EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL] equalsBuilder.append(1, 1); [EOL] Boolean result = equalsBuilder.build(); [EOL] assertTrue(result); [EOL] }
public void testBuildReturnsFalseWhenNotEquals() { [EOL] EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL] equalsBuilder.append(1, 2); [EOL] Boolean result = equalsBuilder.build(); [EOL] assertFalse(result); [EOL] }
public void testCommaMatcher() { [EOL] StrMatcher matcher = StrMatcher.commaMatcher(); [EOL] assertNotNull("The matcher should not be null", matcher); [EOL] assertTrue("The matcher should be a comma matcher instance", matcher instanceof StrMatcher.CharMatcher); [EOL] assertEquals("The matcher should be the same as COMMA_MATCHER", StrMatcher.COMMA_MATCHER, matcher); [EOL] }
public void testSpaceMatcher() { [EOL] StrMatcher matcher = StrMatcher.spaceMatcher(); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher.isMatch(" ".toCharArray(), 0, 0, 1)); [EOL] assertFalse(matcher.isMatch("a".toCharArray(), 0, 0, 1)); [EOL] }
public void testStringMatcherWithEmptyString() { [EOL] StrMatcher matcher = StrMatcher.stringMatcher(""); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testStringMatcherWithNullString() { [EOL] StrMatcher matcher = StrMatcher.stringMatcher(null); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testStringMatcherWithNonEmptyString() { [EOL] String testStr = "abc"; [EOL] StrMatcher matcher = StrMatcher.stringMatcher(testStr); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher instanceof StrMatcher.StringMatcher); [EOL] assertEquals(testStr, ((StrMatcher.StringMatcher) matcher).getPattern()); [EOL] }
public void testIsMatch_Match() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = buffer.length; [EOL] char ch = 'b'; [EOL] int expected = 1; [EOL] int actual = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsMatch_NoMatch() { [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = buffer.length; [EOL] char ch = 'x'; [EOL] int expected = 0; [EOL] int actual = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(expected, actual); [EOL] }
public void testDecrement_PositiveValue() { [EOL] MutableInt mutableInt = new MutableInt(1); [EOL] mutableInt.decrement(); [EOL] assertEquals(0, mutableInt.intValue()); [EOL] }
public void testDecrement_NegativeValue() { [EOL] MutableInt mutableInt = new MutableInt(-1); [EOL] mutableInt.decrement(); [EOL] assertEquals(-2, mutableInt.intValue()); [EOL] }
public void testDecrement_ZeroValue() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] mutableInt.decrement(); [EOL] assertEquals(-1, mutableInt.intValue()); [EOL] }
public void addTestWithPositiveOperand() { [EOL] ByteUtils byteUtils = new ByteUtils(); [EOL] byte operand = 10; [EOL] byteUtils.add(operand); [EOL] assertEquals(10, byteUtils.value); [EOL] }
public void addTestWithNegativeOperand() { [EOL] ByteUtils byteUtils = new ByteUtils(); [EOL] byte operand = -10; [EOL] byteUtils.add(operand); [EOL] assertEquals(-10, byteUtils.value); [EOL] }
public void addTestWithZeroOperand() { [EOL] ByteUtils byteUtils = new ByteUtils(); [EOL] byte operand = 0; [EOL] byteUtils.add(operand); [EOL] assertEquals(0, byteUtils.value); [EOL] }
public void testIntValue_PositiveValue() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(5, result); [EOL] }
public void testIntValue_NegativeValue() { [EOL] MutableInt mutableInt = new MutableInt(-5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(-5, result); [EOL] }
public void testIntValue_ZeroValue() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(5L, result); [EOL] }
public void testLongValue_Negative() { [EOL] MutableLong mutableLong = new MutableLong(-5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(-5L, result); [EOL] }
public void testLongValue_Zero() { [EOL] MutableLong mutableLong = new MutableLong(0); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testTranslateWithNullWriter() { [EOL] try { [EOL] new YourClass().translate("test", null); [EOL] fail("Expected IllegalArgumentException for null Writer"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The Writer must not be null", e.getMessage()); [EOL] } [EOL] }
public void testTranslateWithNullInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate(null, writer); [EOL] assertEquals("", writer.toString()); [EOL] }
public void testTranslateWithEmptyInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("", writer); [EOL] assertEquals("", writer.toString()); [EOL] }
public void testTranslateWithNonEmptyInput() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("abc", writer); [EOL] assertEquals("xyz", writer.toString()); [EOL] }
public void testTranslateWithInputRequiringMultipleTranslations() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] new YourClass().translate("abcdef", writer); [EOL] assertEquals("xyzuvw", writer.toString()); [EOL] }
public void testHexWithValidCodepoint() { [EOL] int codepoint = 65; // ASCII for 'A' [EOL] String result = hex(codepoint); [EOL] assertEquals("41", result); [EOL] } [EOL] public void testHexWithZero() { [EOL] int codepoint = 0; [EOL] String result = hex(codepoint); [EOL] assertEquals("0", result); [EOL] } [EOL] public void testHexWithNegativeCodepoint() { [EOL] int codepoint = -1; [EOL] String result = hex(codepoint); [EOL] assertEquals("FFFFFFFF", result); [EOL] } [EOL] public void testHexWithLargeCodepoint() { [EOL] int codepoint = Integer.MAX_VALUE; [EOL] String result = hex(codepoint); [EOL] assertEquals("7FFFFFFF", result); [EOL] }
public void testIsUseIdentityHashCode() { [EOL] MyClass myClass = new MyClass(); [EOL] boolean result = myClass.isUseIdentityHashCode(); [EOL] assertEquals("Expected and actual values should be the same", true, result); [EOL] }
public void testGenerateBitVectorsWithValidInput() { [EOL] long[] result = EnumUtils.generateBitVectors(TestEnum.class, EnumSet.allOf(TestEnum.class)); [EOL] assertNotNull(result); [EOL] for (TestEnum constant : TestEnum.values()) { [EOL] int index = constant.ordinal() / Long.SIZE; [EOL] int bitPosition = constant.ordinal() % Long.SIZE; [EOL] assertTrue((result[index] & (1L << bitPosition)) != 0); [EOL] } [EOL] }
public void testGenerateBitVectorsWithEmptyValues() { [EOL] long[] result = EnumUtils.generateBitVectors(TestEnum.class, EnumSet.noneOf(TestEnum.class)); [EOL] assertNotNull(result); [EOL] for (long bits : result) { [EOL] assertEquals(0L, bits); [EOL] } [EOL] }
public void testGenerateBitVectorsWithNullValues() { [EOL] try { [EOL] EnumUtils.generateBitVectors(TestEnum.class, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithNullEnumClass() { [EOL] try { [EOL] EnumUtils.generateBitVectors(null, EnumSet.allOf(TestEnum.class)); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithNullElement() { [EOL] Set<TestEnum> valuesWithNull = new HashSet<>(EnumSet.allOf(TestEnum.class)); [EOL] valuesWithNull.add(null); [EOL] try { [EOL] EnumUtils.generateBitVectors(TestEnum.class, valuesWithNull); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithValidEnumAndValues() { [EOL] long[] result = EnumUtils.generateBitVectors(TestEnum.class, TestEnum.FIRST, TestEnum.SECOND); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new long[]{0b0, 0b11}, result); [EOL] }
public void testGenerateBitVectorsWithEmptyValues() { [EOL] long[] result = EnumUtils.generateBitVectors(TestEnum.class); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new long[]{0b0, 0b0}, result); [EOL] }
public void testGenerateBitVectorsWithAllEnumValues() { [EOL] long[] result = EnumUtils.generateBitVectors(TestEnum.class, TestEnum.values()); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new long[]{0b0, 0b111}, result); [EOL] }
public void testGenerateBitVectorsWithNullEnumClass() { [EOL] try { [EOL] EnumUtils.generateBitVectors(null, TestEnum.FIRST); [EOL] fail("IllegalArgumentException expected for null enum class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithNullValues() { [EOL] try { [EOL] EnumUtils.generateBitVectors(TestEnum.class, (TestEnum[]) null); [EOL] fail("NullPointerException expected for null values"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithNullValueInValues() { [EOL] try { [EOL] EnumUtils.generateBitVectors(TestEnum.class, TestEnum.FIRST, null); [EOL] fail("IllegalArgumentException expected for null value in values"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testProcessBitVectorWithValidEnumAndValue() { [EOL] long value = 1; // Assuming 1 corresponds to a valid constant in the enum [EOL] EnumSet<TimeUnit> result = EnumUtils.processBitVector(TimeUnit.class, value); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(TimeUnit.NANOSECONDS)); // Assuming TimeUnit.NANOSECONDS.ordinal() == 0 [EOL] }
public void testProcessBitVectorWithInvalidEnum() { [EOL] long value = 1; [EOL] try { [EOL] EnumUtils.processBitVector(null, value); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testProcessBitVectorWithInvalidValue() { [EOL] long value = -1; // Assuming there is no constant with a negative ordinal [EOL] EnumSet<TimeUnit> result = EnumUtils.processBitVector(TimeUnit.class, value); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testProcessBitVectorsWithValidInput() { [EOL] long[] values = new long[] {1L, 2L}; // Binary: 01 and 10 [EOL] EnumSet<TestEnum> result = Lang3.processBitVectors(TestEnum.class, values); [EOL] assertTrue(result.contains(TestEnum.FIRST_CONSTANT)); [EOL] assertTrue(result.contains(TestEnum.SECOND_CONSTANT)); [EOL] assertFalse(result.contains(TestEnum.THIRD_CONSTANT)); [EOL] } [EOL] public void testProcessBitVectorsWithNullValues() { [EOL] try { [EOL] Lang3.processBitVectors(TestEnum.class, (long[]) null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testProcessBitVectorsWithEmptyValues() { [EOL] long[] values = new long[] {}; [EOL] EnumSet<TestEnum> result = Lang3.processBitVectors(TestEnum.class, values); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testProcessBitVectorsWithSingleValue() { [EOL] long[] values = new long[] {1L}; // Binary: 01 [EOL] EnumSet<TestEnum> result = Lang3.processBitVectors(TestEnum.class, values); [EOL] assertTrue(result.contains(TestEnum.FIRST_CONSTANT)); [EOL] assertFalse(result.contains(TestEnum.SECOND_CONSTANT)); [EOL] } [EOL] public void testProcessBitVectorsWithMultipleValues() { [EOL] long[] values = new long[] {1L, 2L, 4L}; // Binary: 01, 10, 100 [EOL] EnumSet<TestEnum> result = Lang3.processBitVectors(TestEnum.class, values); [EOL] assertTrue(result.contains(TestEnum.FIRST_CONSTANT)); [EOL] assertTrue(result.contains(TestEnum.SECOND_CONSTANT)); [EOL] assertTrue(result.contains(TestEnum.THIRD_CONSTANT)); [EOL] }

public void testAsEnumWithNonNullEnumClass() { [EOL] Class<Day> enumClass = Day.class; [EOL] Class<Day> result = asEnum(enumClass); [EOL] assertNotNull(result); [EOL] assertEquals(enumClass, result); [EOL] }
public void testAsEnumWithNullEnumClass() { [EOL] try { [EOL] asEnum(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testAsEnumWithNonEnumClass() { [EOL] try { [EOL] asEnum(String.class); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetDateTimeInstance_NullLocale() { [EOL] Integer dateStyle = DateFormat.SHORT; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale defaultLocale = Locale.getDefault(); [EOL] F result = getDateTimeInstance(dateStyle, timeStyle, timeZone, null); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPatternForDefaultLocale, result.getPattern()); [EOL] }
public void testGetDateTimeInstance_NonNullLocale() { [EOL] Integer dateStyle = DateFormat.SHORT; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale specificLocale = new Locale("fr", "CA"); [EOL] F result = getDateTimeInstance(dateStyle, timeStyle, timeZone, specificLocale); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPatternForSpecificLocale, result.getPattern()); [EOL] }
public void testGetDateTimeInstance_NullDateAndTimeStyle() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] F result = getDateTimeInstance(null, null, timeZone, locale); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPatternForNullStyles, result.getPattern()); [EOL] }
public void testGetDateInstanceWithDifferentDateStyles() { [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] DateFormat result; [EOL] result = YourClass.getDateInstance(DateFormat.SHORT, timeZone, locale); [EOL] assertNotNull(result); [EOL] result = YourClass.getDateInstance(DateFormat.MEDIUM, timeZone, locale); [EOL] assertNotNull(result); [EOL] result = YourClass.getDateInstance(DateFormat.LONG, timeZone, locale); [EOL] assertNotNull(result); [EOL] result = YourClass.getDateInstance(DateFormat.FULL, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetDateInstanceWithNullLocale() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] DateFormat result = YourClass.getDateInstance(DateFormat.DEFAULT, timeZone, null); [EOL] assertNotNull(result); [EOL] }
public void testGetDateInstanceWithNullTimeZone() { [EOL] Locale locale = Locale.getDefault(); [EOL] DateFormat result = YourClass.getDateInstance(DateFormat.DEFAULT, null, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetDateInstanceWithInvalidDateStyle() { [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] try { [EOL] YourClass.getDateInstance(Integer.MIN_VALUE, timeZone, locale); [EOL] fail("Should have thrown IllegalArgumentException for invalid date style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPatternForStyleWithDateStyleOnly() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(dateStyle, null, locale); [EOL] assertNotNull(pattern); [EOL] assertTrue(pattern.contains("M/d/yy")); [EOL] }
public void testGetPatternForStyleWithTimeStyleOnly() { [EOL] Locale locale = Locale.US; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(null, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] assertTrue(pattern.matches(".*h:mm:ss a")); [EOL] }
public void testGetPatternForStyleWithBothStyles() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.SHORT; [EOL] Integer timeStyle = DateFormat.SHORT; [EOL] String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] assertTrue(pattern.contains("M/d/yy h:mm a")); [EOL] }
public void testGetPatternForStyleWithCachedPattern() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.LONG; [EOL] Integer timeStyle = DateFormat.LONG; [EOL] MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL] String cachedPattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ"; [EOL] cDateTimeInstanceCache.put(key, cachedPattern); [EOL] String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] assertEquals(cachedPattern, pattern); [EOL] }
public void testGetPatternForStyleWithInvalidLocale() { [EOL] Locale locale = new Locale("invalid"); [EOL] Integer dateStyle = DateFormat.FULL; [EOL] try { [EOL] getPatternForStyle(dateStyle, null, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("No date time pattern for locale: " + locale, ex.getMessage()); [EOL] } [EOL] }
public void testGetDefaultStyle() { [EOL] ToStringStyle style = ToStringBuilder.getDefaultStyle(); [EOL] assertNotNull(style); [EOL] }
public void testReflectionToStringWithNullObject() { [EOL] String result = StringUtils.reflectionToString(null, ToStringStyle.DEFAULT_STYLE); [EOL] assertNull(result); [EOL] }
public void testReflectionToStringWithNonNullObjectAndDefaultStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.DEFAULT_STYLE); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)))); [EOL] }
public void testReflectionToStringWithNonNullObjectAndNoFieldNamesStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.NO_FIELD_NAMES_STYLE); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)))); [EOL] }
public void testReflectionToStringWithNullObject() { [EOL] String result = StringUtils.reflectionToString(null, ToStringStyle.DEFAULT_STYLE, false); [EOL] assertNull(result); [EOL] }
public void testReflectionToStringWithNonNullObjectAndDefaultStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.DEFAULT_STYLE, false); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)))); [EOL] }
public void testReflectionToStringWithNonNullObjectAndNoFieldStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.NO_FIELD_NAMES_STYLE, false); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches(".*\\[.*\\]")); [EOL] }
public void testReflectionToStringWithNonNullObjectAndSimpleStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.SIMPLE_STYLE, false); [EOL] assertNotNull(result); [EOL] assertFalse(result.contains(obj.getClass().getName())); [EOL] }
public void testReflectionToStringWithNonNullObjectAndOutputTransients() { [EOL] Object obj = new ExampleClassWithTransientFields(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.DEFAULT_STYLE, true); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("transientField")); [EOL] }
public void testReflectionToStringWithNonNullObjectAndNoOutputTransients() { [EOL] Object obj = new ExampleClassWithTransientFields(); [EOL] String result = StringUtils.reflectionToString(obj, ToStringStyle.DEFAULT_STYLE, false); [EOL] assertNotNull(result); [EOL] assertFalse(result.contains("transientField")); [EOL] }
public void testReflectionToStringWithNullObject() { [EOL] String result = StringUtils.reflectionToString(null, ToStringStyle.DEFAULT_STYLE, false, null); [EOL] assertNull("The result should be null for null object input", result); [EOL] }
public void testReflectionToStringWithNonNullObjectAndDefaultStyle() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.reflectionToString(object, ToStringStyle.DEFAULT_STYLE, false, null); [EOL] assertNotNull("The result should not be null for non-null object input", result); [EOL] assertTrue("The result should contain the class name", result.startsWith(object.getClass().getName())); [EOL] }
public void testReflectionToStringWithNonNullObjectAndCustomStyle() { [EOL] Object object = new Object(); [EOL] ToStringStyle customStyle = ToStringStyle.NO_FIELD_NAMES_STYLE; [EOL] String result = StringUtils.reflectionToString(object, customStyle, false, null); [EOL] assertNotNull("The result should not be null for non-null object input", result); [EOL] assertTrue("The result should contain the class name", result.startsWith(object.getClass().getName())); [EOL] assertFalse("The result should not contain field names", result.matches(".*=.*")); [EOL] }
public void testReflectionToStringWithTransients() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.reflectionToString(object, ToStringStyle.DEFAULT_STYLE, true, null); [EOL] assertNotNull("The result should not be null for non-null object input", result); [EOL] }
public void testReflectionToStringWithReflectUpToClass() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.reflectionToString(object, ToStringStyle.DEFAULT_STYLE, false, Object.class); [EOL] assertNotNull("The result should not be null for non-null object input", result); [EOL] }
public void testToStringBuilderWithNullObject() { [EOL] ToStringBuilder tsb = new ToStringBuilder(null); [EOL] assertNotNull("ToStringBuilder should not be null", tsb); [EOL] assertEquals("ToStringBuilder with null object should return empty string", "", tsb.toString()); [EOL] }
public void testToStringBuilderWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] ToStringBuilder tsb = new ToStringBuilder(obj); [EOL] assertNotNull("ToStringBuilder should not be null", tsb); [EOL] assertTrue("ToStringBuilder should contain object's hashcode", tsb.toString().contains(Integer.toHexString(System.identityHashCode(obj)))); [EOL] }
public void testToStringBuilderWithNullStyleAndNullBuffer() { [EOL] Object object = new Object(); [EOL] ToStringBuilder tsb = new ToStringBuilder(object, null, null); [EOL] assertNotNull(tsb); [EOL] assertTrue(tsb.toString().contains(object.getClass().getSimpleName())); [EOL] }
public void testToStringBuilderWithNonNullStyleAndNullBuffer() { [EOL] Object object = new Object(); [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] ToStringBuilder tsb = new ToStringBuilder(object, style, null); [EOL] assertNotNull(tsb); [EOL] assertTrue(tsb.toString().contains(object.getClass().getSimpleName())); [EOL] assertSame(style, tsb.getStyle()); [EOL] }
public void testToStringBuilderWithNullStyleAndNonNullBuffer() { [EOL] Object object = new Object(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] ToStringBuilder tsb = new ToStringBuilder(object, null, buffer); [EOL] assertNotNull(tsb); [EOL] assertTrue(tsb.toString().contains(object.getClass().getSimpleName())); [EOL] assertSame(buffer, tsb.getStringBuffer()); [EOL] }
public void testToStringBuilderWithNonNullStyleAndNonNullBuffer() { [EOL] Object object = new Object(); [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] StringBuffer buffer = new StringBuffer(); [EOL] ToStringBuilder tsb = new ToStringBuilder(object, style, buffer); [EOL] assertNotNull(tsb); [EOL] assertTrue(tsb.toString().contains(object.getClass().getSimpleName())); [EOL] assertSame(style, tsb.getStyle()); [EOL] assertSame(buffer, tsb.getStringBuffer()); [EOL] }
public void testAppendBooleanTrue() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append(true); [EOL] assertEquals(tsb.toString(), "BooleanTestObject@1[true]"); [EOL] }
public void testAppendBooleanFalse() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append(false); [EOL] assertEquals(tsb.toString(), "BooleanTestObject@1[false]"); [EOL] }
public void testAppendByte() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] byte value = 1; [EOL] tsb.append(value); [EOL] assertEquals(tsb.toString(), "ToStringBuilderTest@1[1]"); [EOL] }
public void testAppendDouble() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] double testValue = 123.456d; [EOL] tsb.append(testValue); [EOL] assertEquals(tsb.toString(), this.toString() + "[123.456]"); [EOL] }
public void testAppendDoubleNaN() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] double testValue = Double.NaN; [EOL] tsb.append(testValue); [EOL] assertTrue(tsb.toString().contains("NaN")); [EOL] }
public void testAppendDoublePositiveInfinity() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] double testValue = Double.POSITIVE_INFINITY; [EOL] tsb.append(testValue); [EOL] assertTrue(tsb.toString().contains("Infinity")); [EOL] }
public void testAppendDoubleNegativeInfinity() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] double testValue = Double.NEGATIVE_INFINITY; [EOL] tsb.append(testValue); [EOL] assertTrue(tsb.toString().contains("-Infinity")); [EOL] }
public void testAppend_doubleArray_null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] double[] array = null; [EOL] ToStringBuilder result = tsb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(tsb.toString(), result.toString()); [EOL] }
public void testAppend_doubleArray_empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] double[] array = new double[0]; [EOL] ToStringBuilder result = tsb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(tsb.toString(), result.toString()); [EOL] }
public void testAppend_doubleArray_nonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] double[] array = new double[] {1.0, 2.0, 3.0}; [EOL] ToStringBuilder result = tsb.append(array); [EOL] assertNotNull(result); [EOL] assertTrue(result.toString().contains("1.0")); [EOL] assertTrue(result.toString().contains("2.0")); [EOL] assertTrue(result.toString().contains("3.0")); [EOL] }
public void testAppendFloatArray_null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] float[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilderTest@1[]"); [EOL] }
public void testAppendFloatArray_empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] float[] array = new float[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilderTest@1[]"); [EOL] }
public void testAppendFloatArray_nonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilderTest@1[1.0,2.0,3.0]"); [EOL] }
public void testAppendInt() { [EOL] ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE; [EOL] ToStringBuilder builder = new ToStringBuilder(this, defaultStyle); [EOL] int testValue = 123; [EOL] builder.append(testValue); [EOL] assertEquals("Append method should append integer value", [EOL] this.toString() + "[" + testValue + "]", builder.toString()); [EOL] }
public void testAppendIntWithNullStyle() { [EOL] ToStringBuilder builder = new ToStringBuilder(this, null); [EOL] int testValue = 456; [EOL] builder.append(testValue); [EOL] assertEquals("Append method should handle null style", [EOL] this.toString() + "[" + testValue + "]", builder.toString()); [EOL] }
public void testAppendIntArray_null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] int[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] } [EOL] public void testAppendIntArray_empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] int[] array = new int[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] } [EOL] public void testAppendIntArray_nonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] int[] array = new int[] {1, 2, 3}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{1,2,3}"); [EOL] }

public void testAppendLong() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] long value = 123L; [EOL] ToStringBuilder result = tsb.append(value); [EOL] assertNotNull(result); [EOL] assertEquals(tsb.toString(), result.toString()); [EOL] }
public void testAppendWithNull() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append((Object) null); [EOL] assertNotNull(tsb.toString()); [EOL] }
public void testAppendWithNonNullObject() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] Object obj = new Object(); [EOL] tsb.append(obj); [EOL] assertTrue(tsb.toString().contains(obj.toString())); [EOL] }
public void testAppendObjectArray_Null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append((Object[]) null); [EOL] assertEquals(tsb.toString(), ""); [EOL] }
public void testAppendObjectArray_Empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append(new Object[0]); [EOL] assertEquals(tsb.toString(), ""); [EOL] }
public void testAppendObjectArray_NonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] Object[] array = new Object[] {"elem1", "elem2"}; [EOL] tsb.append(array); [EOL] assertTrue(tsb.toString().contains("elem1")); [EOL] assertTrue(tsb.toString().contains("elem2")); [EOL] }
public void testAppendBoolean() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("Field", true); [EOL] assertEquals("Field=true", tsb.toString()); [EOL] }
public void testAppendBooleanFalse() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("Field", false); [EOL] assertEquals("Field=false", tsb.toString()); [EOL] }
public void testAppendByte() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] byte testValue = 1; [EOL] tsb.append("Field", testValue); [EOL] assertEquals("Field=<1>", tsb.toString()); [EOL] }
public void testAppendStringDouble() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("Field", 1.0); [EOL] assertEquals("Field=1.0", tsb.toString()); [EOL] }
public void testAppendStringDoubleNullField() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append(null, 1.0); [EOL] assertEquals("1.0", tsb.toString()); [EOL] }
public void testAppendStringInt() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("Field", 10); [EOL] assertEquals("Field=10", tsb.toString()); [EOL] }

public void testAppendLong() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("LongField", 123L); [EOL] assertEquals("ToStringBuilder[this=LongField=123]", tsb.toString()); [EOL] }

public void testAppendWithFullDetailTrue() { [EOL] ToStringBuilder tsb = new ToStringBuilder(new Object(), ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("field", new Object(), true); [EOL] assertNotNull(tsb.toString()); [EOL] }
public void testAppendWithFullDetailFalse() { [EOL] ToStringBuilder tsb = new ToStringBuilder(new Object(), ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("field", new Object(), false); [EOL] assertNotNull(tsb.toString()); [EOL] }
public void testGetObjectWhenObjectIsNull() { [EOL] MyClass myClass = new MyClass(null); [EOL] assertNull("Expected object to be null", myClass.getObject()); [EOL] }
public void testGetObjectWhenObjectIsNotNull() { [EOL] Object expectedObject = new Object(); [EOL] MyClass myClass = new MyClass(expectedObject); [EOL] assertSame("Expected to get the same object that was set", expectedObject, myClass.getObject()); [EOL] }
public void testGetStringBuffer() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuffer stringBuffer = strBuilder.getStringBuffer(); [EOL] assertNotNull(stringBuffer); [EOL] assertEquals(0, stringBuffer.length()); [EOL] }
public void testGetStringBufferAfterAppend() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.append("test"); [EOL] StringBuffer stringBuffer = strBuilder.getStringBuffer(); [EOL] assertNotNull(stringBuffer); [EOL] assertEquals("test", stringBuffer.toString()); [EOL] }
public void testToStringWhenObjectIsNull() { [EOL] MyObjectUnderTest testObject = new MyObjectUnderTest(null); [EOL] String result = testObject.toString(); [EOL] assertNotNull("The result should not be null.", result); [EOL] assertTrue("The result should contain the null text representation.", result.contains(testObject.getStyle().getNullText())); [EOL] }
public void testToStringWhenObjectIsNotNull() { [EOL] MyObjectUnderTest testObject = new MyObjectUnderTest(new Object()); [EOL] String result = testObject.toString(); [EOL] assertNotNull("The result should not be null.", result); [EOL] assertFalse("The result should not contain the null text representation.", result.contains(testObject.getStyle().getNullText())); [EOL] assertTrue("The result should contain the appended end text.", result.endsWith("ExpectedEndText")); [EOL] }
public void testSetValue() { [EOL] MutableObject<Integer> mutable = new MutableObject<>(); [EOL] Integer newValue = 5; [EOL] mutable.setValue(newValue); [EOL] assertEquals(newValue, mutable.getValue()); [EOL] }
public void testHashCode_withNullValue() { [EOL] MyClass instance = new MyClass(null); [EOL] int expected = 0; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCode_withNonNullValue() { [EOL] MyClass instance = new MyClass("test"); [EOL] int expected = "test".hashCode(); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsSameDayWithNullDate1() { [EOL] try { [EOL] boolean result = DateUtils.isSameDay(null, new Date()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDayWithNullDate2() { [EOL] try { [EOL] boolean result = DateUtils.isSameDay(new Date(), null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDayWithBothNullDates() { [EOL] try { [EOL] boolean result = DateUtils.isSameDay(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDayWithSameInstanceDates() { [EOL] Date date = new Date(); [EOL] assertTrue("Dates with same instance should return true", DateUtils.isSameDay(date, date)); [EOL] } [EOL] public void testIsSameDayWithDifferentDayDates() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.DAY_OF_MONTH, 1); [EOL] assertFalse("Dates with different days should return false", DateUtils.isSameDay(cal1.getTime(), cal2.getTime())); [EOL] } [EOL] public void testIsSameDayWithSameDayDifferentTimeDates() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.HOUR_OF_DAY, 1); [EOL] assertTrue("Dates with same day but different times should return true", DateUtils.isSameDay(cal1.getTime(), cal2.getTime())); [EOL] }
public void testIsSameDay_NullCalendar1_ThrowsIllegalArgumentException() { [EOL] Calendar cal2 = Calendar.getInstance(); [EOL] try { [EOL] DateUtils.isSameDay(null, cal2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDay_NullCalendar2_ThrowsIllegalArgumentException() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] try { [EOL] DateUtils.isSameDay(cal1, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDay_BothCalendarsNull_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateUtils.isSameDay(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameDay_SameCalendarInstance_ReturnsTrue() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] assertTrue("Calendars are the same instance", DateUtils.isSameDay(cal1, cal1)); [EOL] } [EOL] public void testIsSameDay_SameDayDifferentTime_ReturnsTrue() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.HOUR, 1); [EOL] assertTrue("Calendars represent the same day", DateUtils.isSameDay(cal1, cal2)); [EOL] } [EOL] public void testIsSameDay_DifferentDay_ReturnsFalse() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.DAY_OF_YEAR, 1); [EOL] assertFalse("Calendars represent different days", DateUtils.isSameDay(cal1, cal2)); [EOL] } [EOL] public void testIsSameDay_DifferentMonth_ReturnsFalse() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.MONTH, 1); [EOL] assertFalse("Calendars represent different months", DateUtils.isSameDay(cal1, cal2)); [EOL] } [EOL] public void testIsSameDay_DifferentYear_ReturnsFalse() { [EOL] Calendar cal1 = Calendar.getInstance(); [EOL] Calendar cal2 = (Calendar) cal1.clone(); [EOL] cal2.add(Calendar.YEAR, 1); [EOL] assertFalse("Calendars represent different years", DateUtils.isSameDay(cal1, cal2)); [EOL] } [EOL] public void testIsSameDay_DifferentEra_ReturnsFalse() { [EOL] Calendar cal1 = new GregorianCalendar(); [EOL] Calendar cal2 = new GregorianCalendar(); [EOL] cal2.set(Calendar.ERA, GregorianCalendar.BC); [EOL] assertFalse("Calendars represent different eras", DateUtils.isSameDay(cal1, cal2)); [EOL] }
public void testIsSameInstantWithEqualDates() { [EOL] Date date1 = new Date(); [EOL] Date date2 = new Date(date1.getTime()); [EOL] assertTrue(DateUtils.isSameInstant(date1, date2)); [EOL] } [EOL] public void testIsSameInstantWithDifferentDates() { [EOL] Date date1 = new Date(); [EOL] Date date2 = new Date(date1.getTime() + 1000); // Different by 1 second [EOL] assertFalse(DateUtils.isSameInstant(date1, date2)); [EOL] } [EOL] public void testIsSameInstantWithOneNullDate() { [EOL] Date date1 = new Date(); [EOL] try { [EOL] DateUtils.isSameInstant(date1, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIsSameInstantWithBothNullDates() { [EOL] try { [EOL] DateUtils.isSameInstant(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL] if (cal1 == null || cal2 == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { [EOL] return parseDateWithLeniency(str, locale, parsePatterns, true); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] };
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL] if (str == null || parsePatterns == null) { [EOL] throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL] } [EOL] SimpleDateFormat parser; [EOL] if (locale == null) { [EOL] parser = new SimpleDateFormat(); [EOL] } else { [EOL] parser = new SimpleDateFormat("", locale); [EOL] } [EOL] parser.setLenient(lenient); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] for (final String parsePattern : parsePatterns) { [EOL] String pattern = parsePattern; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] pattern = pattern.substring(0, pattern.length() - 1); [EOL] } [EOL] parser.applyPattern(pattern); [EOL] pos.setIndex(0); [EOL] String str2 = str; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL] } [EOL] final Date date = parser.parse(str2, pos); [EOL] if (date != null && pos.getIndex() == str2.length()) { [EOL] return date; [EOL] } [EOL] } [EOL] throw new ParseException("Unable to parse the date: " + str, -1); [EOL] }
public void testSetMinutes() { [EOL] final Date date = new Date(); [EOL] final int amount = 45; [EOL] Date modifiedDate = DateUtils.setMinutes(date, amount); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTime(modifiedDate); [EOL] assertEquals(amount, cal.get(Calendar.MINUTE)); [EOL] }
public void testSetMinutesWithZero() { [EOL] final Date date = new Date(); [EOL] final int amount = 0; [EOL] Date modifiedDate = DateUtils.setMinutes(date, amount); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTime(modifiedDate); [EOL] assertEquals(amount, cal.get(Calendar.MINUTE)); [EOL] }
public void testSetMinutesWithNegative() { [EOL] final Date date = new Date(); [EOL] final int amount = -30; [EOL] Date modifiedDate = DateUtils.setMinutes(date, amount); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTime(modifiedDate); [EOL] assertEquals(30, cal.get(Calendar.MINUTE)); // Assuming that the negative value sets the minute back [EOL] }
private static void modify(final Calendar val, final int field, final int modType) { [EOL] if (val.get(Calendar.YEAR) > 280000000) { [EOL] throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL] } [EOL] if (field == Calendar.MILLISECOND) { [EOL] return; [EOL] } [EOL] final Date date = val.getTime(); [EOL] long time = date.getTime(); [EOL] boolean done = false; [EOL] final int millisecs = val.get(Calendar.MILLISECOND); [EOL] if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL] time = time - millisecs; [EOL] } [EOL] if (field == Calendar.SECOND) { [EOL] done = true; [EOL] } [EOL] final int seconds = val.get(Calendar.SECOND); [EOL] if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL] time = time - (seconds * 1000L); [EOL] } [EOL] if (field == Calendar.MINUTE) { [EOL] done = true; [EOL] } [EOL] final int minutes = val.get(Calendar.MINUTE); [EOL] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL] time = time - (minutes * 60000L); [EOL] } [EOL] if (date.getTime() != time) { [EOL] date.setTime(time); [EOL] val.setTime(date); [EOL] } [EOL] boolean roundUp = false; [EOL] for (final int[] aField : fields) { [EOL] for (final int element : aField) { [EOL] if (element == field) { [EOL] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL] if (field == DateUtils.SEMI_MONTH) { [EOL] if (val.get(Calendar.DATE) == 1) { [EOL] val.add(Calendar.DATE, 15); [EOL] } else { [EOL] val.add(Calendar.DATE, -15); [EOL] val.add(Calendar.MONTH, 1); [EOL] } [EOL] } else if (field == Calendar.AM_PM) { [EOL] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL] val.add(Calendar.HOUR_OF_DAY, 12); [EOL] } else { [EOL] val.add(Calendar.HOUR_OF_DAY, -12); [EOL] val.add(Calendar.DATE, 1); [EOL] } [EOL] } else { [EOL] val.add(aField[0], 1); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] int offset = 0; [EOL] boolean offsetSet = false; [EOL] switch(field) { [EOL] case DateUtils.SEMI_MONTH: [EOL] if (aField[0] == Calendar.DATE) { [EOL] offset = val.get(Calendar.DATE) - 1; [EOL] if (offset >= 15) { [EOL] offset -= 15; [EOL] } [EOL] roundUp = offset > 7; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] case Calendar.AM_PM: [EOL] if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL] offset = val.get(Calendar.HOUR_OF_DAY); [EOL] if (offset >= 12) { [EOL] offset -= 12; [EOL] } [EOL] roundUp = offset >= 6; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] } [EOL] if (!offsetSet) { [EOL] final int min = val.getActualMinimum(aField[0]); [EOL] final int max = val.getActualMaximum(aField[0]); [EOL] offset = val.get(aField[0]) - min; [EOL] roundUp = offset > ((max - min) / 2); [EOL] } [EOL] if (offset != 0) { [EOL] val.set(aField[0], val.get(aField[0]) - offset); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL] if (calendar == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final long millisPerUnit = getMillisPerUnit(unit); [EOL] long result = 0; [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] case Calendar.MONTH: [EOL] result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] } [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] case Calendar.MONTH: [EOL] case Calendar.DAY_OF_YEAR: [EOL] case Calendar.DATE: [EOL] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL] case Calendar.HOUR_OF_DAY: [EOL] result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL] case Calendar.MINUTE: [EOL] result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL] case Calendar.SECOND: [EOL] result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL] break; [EOL] case Calendar.MILLISECOND: [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL] } [EOL] return result; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }};
public void testUncapitalize_NullInput() { [EOL] String result = StringUtils.uncapitalize(null); [EOL] assertNull(result); [EOL] }
public void testUncapitalize_EmptyString() { [EOL] String result = StringUtils.uncapitalize(""); [EOL] assertEquals("", result); [EOL] }
public void testUncapitalize_SingleChar() { [EOL] String result = StringUtils.uncapitalize("A"); [EOL] assertEquals("a", result); [EOL] }
public void testUncapitalize_MultipleChars() { [EOL] String result = StringUtils.uncapitalize("ABC"); [EOL] assertEquals("aBC", result); [EOL] }
public void testUncapitalize_NullString() { [EOL] String result = StringUtils.uncapitalize(null); [EOL] assertNull(result); [EOL] } [EOL] public void testUncapitalize_EmptyString() { [EOL] String result = StringUtils.uncapitalize(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testUncapitalize_StringWithoutDelimiters() { [EOL] String result = StringUtils.uncapitalize("HELLO WORLD"); [EOL] assertEquals("hELLO WORLD", result); [EOL] } [EOL] public void testUncapitalize_StringWithDelimiters() { [EOL] String result = StringUtils.uncapitalize("HELLO WORLD", ' '); [EOL] assertEquals("hello world", result); [EOL] } [EOL] public void testUncapitalize_StringWithMultipleDelimiters() { [EOL] String result = StringUtils.uncapitalize("HELLO-WORLD", '-', ' '); [EOL] assertEquals("hello-world", result); [EOL] } [EOL] public void testUncapitalize_StringWithNoDelimiters() { [EOL] String result = StringUtils.uncapitalize("HELLO-WORLD", new char[]{}); [EOL] assertEquals("HELLO-WORLD", result); [EOL] } [EOL] public void testUncapitalize_StringWithNullDelimiters() { [EOL] String result = StringUtils.uncapitalize("HELLO-WORLD", (char[]) null); [EOL] assertEquals("HELLO-WORLD", result); [EOL] }
public void testIsDelimiterWithNullDelimiters() { [EOL] char testChar = 'a'; [EOL] boolean result = isDelimiter(testChar, null); [EOL] assertTrue("Character should be considered a delimiter when delimiters are null and it's whitespace", result); [EOL] } [EOL] public void testIsDelimiterWithWhitespaceChar() { [EOL] char testChar = ' '; [EOL] char[] delimiters = new char[]{'a', 'b'}; [EOL] boolean result = isDelimiter(testChar, delimiters); [EOL] assertFalse("Whitespace should not be considered a delimiter when delimiters are specified", result); [EOL] } [EOL] public void testIsDelimiterWithMatchingDelimiter() { [EOL] char testChar = 'a'; [EOL] char[] delimiters = new char[]{'a', 'b'}; [EOL] boolean result = isDelimiter(testChar, delimiters); [EOL] assertTrue("Character should be considered a delimiter when it matches one in the array", result); [EOL] } [EOL] public void testIsDelimiterWithNonMatchingDelimiter() { [EOL] char testChar = 'c'; [EOL] char[] delimiters = new char[]{'a', 'b'}; [EOL] boolean result = isDelimiter(testChar, delimiters); [EOL] assertFalse("Character should not be considered a delimiter when it does not match any in the array", result); [EOL] }
public void testMultiBackgroundInitializerWithExecutorService() { [EOL] ExecutorService executorService = Executors.newSingleThreadExecutor(); [EOL] try { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(executorService); [EOL] assertNotNull(multiBackgroundInitializer); [EOL] } finally { [EOL] executorService.shutdown(); [EOL] } [EOL] }
public void testAddInitializerWithNullName() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(); [EOL] try { [EOL] addInitializer(null, initializer); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Name of child initializer must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerWithNullInitializer() { [EOL] try { [EOL] addInitializer("test", null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Child initializer must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerAfterStart() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(); [EOL] start(); [EOL] try { [EOL] addInitializer("test", initializer); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException ex) { [EOL] assertEquals("addInitializer() must not be called after start()!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerSuccess() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(); [EOL] addInitializer("test", initializer); [EOL] assertTrue(childInitializers.containsKey("test")); [EOL] assertSame(initializer, childInitializers.get("test")); [EOL] }
public void testGetTaskCount_WithNoChildInitializers() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(0); [EOL] assertEquals(1, initializer.getTaskCount()); [EOL] }
public void testGetTaskCount_WithOneChildInitializer() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(0); [EOL] BackgroundInitializer<?> childInitializer = new MockBackgroundInitializer(1); [EOL] initializer.addInitializer("child1", childInitializer); [EOL] assertEquals(2, initializer.getTaskCount()); [EOL] }
public void testGetTaskCount_WithMultipleChildInitializers() { [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(0); [EOL] BackgroundInitializer<?> childInitializer1 = new MockBackgroundInitializer(1); [EOL] BackgroundInitializer<?> childInitializer2 = new MockBackgroundInitializer(2); [EOL] initializer.addInitializer("child1", childInitializer1); [EOL] initializer.addInitializer("child2", childInitializer2); [EOL] assertEquals(4, initializer.getTaskCount()); [EOL] }
public void testInitializeWithNoChildInitializers() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertTrue(results.getResults().isEmpty()); [EOL] assertTrue(results.getExceptionMap().isEmpty()); [EOL] }
public void testInitializeWithChildInitializersNoExceptions() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<String> childInitializer = new BackgroundInitializer<String>() { [EOL] @Override [EOL] protected String initialize() throws Exception { [EOL] return "ChildInitializerResult"; [EOL] } [EOL] }; [EOL] multiBackgroundInitializer.addInitializer("child1", childInitializer); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertEquals("ChildInitializerResult", results.getResult("child1")); [EOL] assertTrue(results.getExceptionMap().isEmpty()); [EOL] }
public void testInitializeWithChildInitializersWithExceptions() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<String> childInitializer = new BackgroundInitializer<String>() { [EOL] @Override [EOL] protected String initialize() throws Exception { [EOL] throw new Exception("ChildInitializerException"); [EOL] } [EOL] }; [EOL] multiBackgroundInitializer.addInitializer("child1", childInitializer); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertNull(results.getResult("child1")); [EOL] assertNotNull(results.getException("child1")); [EOL] }
public void testMultiBackgroundInitializerResultsWithNonNullMaps() { [EOL] Map<String, BackgroundInitializer<?>> inits = new HashMap<>(); [EOL] Map<String, Object> results = new HashMap<>(); [EOL] Map<String, ConcurrentException> excepts = new HashMap<>(); [EOL] MultiBackgroundInitializerResults result = new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] assertSame(inits, result.getInitializers()); [EOL] assertSame(results, result.getResultObjects()); [EOL] assertSame(excepts, result.getExceptions()); [EOL] }
public BackgroundInitializer<?> getInitializer(final String name) { [EOL] return checkName(name); [EOL] }
public void testGetResultObjectWithValidName() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(); [EOL] String validName = "validName"; [EOL] Object expectedObject = new Object(); [EOL] objUnderTest.resultObjects.put(validName, expectedObject); [EOL] Object result = objUnderTest.getResultObject(validName); [EOL] assertEquals(expectedObject, result); [EOL] } [EOL] public void testGetResultObjectWithInvalidName() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(); [EOL] String invalidName = null; [EOL] try { [EOL] objUnderTest.getResultObject(invalidName); [EOL] fail("Should have thrown an exception for null name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testIsException_WithExistingException() { [EOL] String existingExceptionName = "ExistingException"; [EOL] ExceptionUtils exceptionsUtil = new ExceptionUtils(); [EOL] exceptionsUtil.exceptions.put(existingExceptionName, new RuntimeException()); [EOL] boolean result = exceptionsUtil.isException(existingExceptionName); [EOL] assertTrue(result); [EOL] }
public void testIsException_WithNonExistingException() { [EOL] String nonExistingExceptionName = "NonExistingException"; [EOL] ExceptionUtils exceptionsUtil = new ExceptionUtils(); [EOL] boolean result = exceptionsUtil.isException(nonExistingExceptionName); [EOL] assertFalse(result); [EOL] }
public void testIsException_WithNullName() { [EOL] String nullName = null; [EOL] ExceptionUtils exceptionsUtil = new ExceptionUtils(); [EOL] try { [EOL] exceptionsUtil.isException(nullName); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Name cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testGetExceptionWithNullName() { [EOL] try { [EOL] getException(null); [EOL] fail("Should have thrown IllegalArgumentException for null name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetExceptionWithEmptyName() { [EOL] try { [EOL] getException(""); [EOL] fail("Should have thrown IllegalArgumentException for empty name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetExceptionWithNameNotFound() { [EOL] ConcurrentException exception = getException("nonExistingName"); [EOL] assertNull("Should return null for name not found", exception); [EOL] }
public void testGetExceptionWithNameFound() { [EOL] String name = "existingName"; [EOL] ConcurrentException expectedException = new ConcurrentException(); [EOL] exceptions.put(name, expectedException); [EOL] ConcurrentException actualException = getException(name); [EOL] assertSame("Should return the correct exception", expectedException, actualException); [EOL] }
public void testInitializerNames_EmptySet() { [EOL] MyClass instance = new MyClass(); [EOL] Set<String> result = instance.initializerNames(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testInitializerNames_NonEmptySet() { [EOL] MyClass instance = new MyClass(); [EOL] instance.addInitializer("init1", someInitializerObject1); [EOL] instance.addInitializer("init2", someInitializerObject2); [EOL] Set<String> result = instance.initializerNames(); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains("init1")); [EOL] assertTrue(result.contains("init2")); [EOL] }
public void testCheckNameWithExistingInitializer() { [EOL] Map<String, BackgroundInitializer<?>> initializers = new HashMap<>(); [EOL] BackgroundInitializer<?> initializer = new MockBackgroundInitializer(); [EOL] String name = "testInitializer"; [EOL] initializers.put(name, initializer); [EOL] BackgroundInitializer<?> result = checkName(name); [EOL] assertSame("The initializer returned was not the one expected.", initializer, result); [EOL] }
public void testCheckNameWithNonExistingInitializer() { [EOL] Map<String, BackgroundInitializer<?>> initializers = new HashMap<>(); [EOL] String name = "nonExistingInitializer"; [EOL] try { [EOL] checkName(name); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] assertEquals("No child initializer with name " + name, e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithNullInput() { [EOL] Locale result = toLocale(null); [EOL] assertNull(result); [EOL] }
public void testToLocaleWithInvalidFormatContainingHash() { [EOL] try { [EOL] toLocale("en#US"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en#US", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithInvalidFormatShortLength() { [EOL] try { [EOL] toLocale("e"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: e", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndInvalidCountry() { [EOL] try { [EOL] toLocale("_eU"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _eU", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndValidCountry() { [EOL] Locale result = toLocale("_US"); [EOL] assertEquals(new Locale("", "US"), result); [EOL] }
public void testToLocaleWithUnderscoreCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("_US_e"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _US_e", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreCountryAndValidVariant() { [EOL] Locale result = toLocale("_US_variant"); [EOL] assertEquals(new Locale("", "US", "variant"), result); [EOL] }
public void testToLocaleWithInvalidLanguage() { [EOL] try { [EOL] toLocale("E_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: E_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithValidLanguage() { [EOL] Locale result = toLocale("en"); [EOL] assertEquals(new Locale("en"), result); [EOL] }
public void testToLocaleWithLanguageAndInvalidCountry() { [EOL] try { [EOL] toLocale("en_eU"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_eU", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithLanguageCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("en_US_1"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_US_1", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithLanguageCountryAndValidVariant() { [EOL] Locale result = toLocale("en_US_variant"); [EOL] assertEquals(new Locale("en", "US", "variant"), result); [EOL] }
public void testAvailableLocaleSet() { [EOL] Set<Locale> locales = LocaleUtils.availableLocaleSet(); [EOL] assertNotNull("The available locale set should not be null", locales); [EOL] assertFalse("The available locale set should not be empty", locales.isEmpty()); [EOL] }
public static boolean isAvailableLocale(final Locale locale) { [EOL] return availableLocaleList().contains(locale); [EOL] }
public void testClone_NullArray() { [EOL] Object[] array = null; [EOL] Object[] clonedArray = ArrayUtils.clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_NonNullArray() { [EOL] Object[] array = new Object[] {"a", "b", "c"}; [EOL] Object[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testClone_NullArray() { [EOL] boolean[] result = ArrayUtils.clone(null); [EOL] assertNull(result); [EOL] }
public void testClone_EmptyArray() { [EOL] boolean[] emptyArray = new boolean[0]; [EOL] boolean[] result = ArrayUtils.clone(emptyArray); [EOL] assertNotNull(result); [EOL] assertNotSame(emptyArray, result); [EOL] assertEquals(0, result.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] boolean[] nonEmptyArray = {true, false, true}; [EOL] boolean[] result = ArrayUtils.clone(nonEmptyArray); [EOL] assertNotNull(result); [EOL] assertNotSame(nonEmptyArray, result); [EOL] assertEquals(nonEmptyArray.length, result.length); [EOL] for (int i = 0; i < nonEmptyArray.length; i++) { [EOL] assertEquals(nonEmptyArray[i], result[i]); [EOL] } [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] String[] result = StringUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] String[] result = StringUtils.nullToEmpty(emptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] String[] nonEmptyArray = new String[]{"a", "b", "c"}; [EOL] String[] result = StringUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] byte[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] byte[] emptyArray = new byte[0]; [EOL] byte[] result = nullToEmpty(emptyArray); [EOL] assertSame(EMPTY_BYTE_ARRAY, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] byte[] nonEmptyArray = new byte[]{1, 2, 3}; [EOL] byte[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] Integer[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Integer[] emptyArray = new Integer[0]; [EOL] Integer[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Integer[] nonEmptyArray = new Integer[]{1, 2, 3}; [EOL] Integer[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testSubarray_NullArray() { [EOL] int[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_NegativeStartIndex() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int[] result = ArrayUtils.subarray(array, -1, 3); [EOL] assertArrayEquals(new int[]{1, 2, 3}, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int[] result = ArrayUtils.subarray(array, 1, 10); [EOL] assertArrayEquals(new int[]{2, 3, 4, 5}, result); [EOL] } [EOL] public void testSubarray_ZeroLengthResult() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int[] result = ArrayUtils.subarray(array, 3, 3); [EOL] assertArrayEquals(new int[]{}, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new int[]{2, 3, 4}, result); [EOL] }
public void testSubarray_StartIndexGreaterThanEndIndex() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int[] result = ArrayUtils.subarray(array, 4, 2); [EOL] assertArrayEquals(new int[]{}, result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] assertTrue(ArrayUtils.isSameLength(null, null)); [EOL] } [EOL] public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] assertFalse(ArrayUtils.isSameLength(null, new int[]{1, 2, 3})); [EOL] } [EOL] public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] assertFalse(ArrayUtils.isSameLength(new int[]{1, 2, 3}, null)); [EOL] } [EOL] public void testIsSameLength_ArraysDifferentLengths() { [EOL] assertFalse(ArrayUtils.isSameLength(new int[]{1, 2, 3}, new int[]{1, 2})); [EOL] } [EOL] public void testIsSameLength_ArraysSameLength() { [EOL] assertTrue(ArrayUtils.isSameLength(new int[]{1, 2, 3}, new int[]{4, 5, 6})); [EOL] }

public void testIsSameLength_BothArraysNull() { [EOL] char[] array1 = null; [EOL] char[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSameLength_FirstArrayNullSecondNotEmpty() { [EOL] char[] array1 = null; [EOL] char[] array2 = new char[] {'a', 'b'}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_SecondArrayNullFirstNotEmpty() { [EOL] char[] array1 = new char[] {'a', 'b'}; [EOL] char[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_ArraysDifferentLengths() { [EOL] char[] array1 = new char[] {'a'}; [EOL] char[] array2 = new char[] {'a', 'b'}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSameLength_ArraysSameLength() { [EOL] char[] array1 = new char[] {'a', 'b'}; [EOL] char[] array2 = new char[] {'a', 'b'}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final Object[] array = null; [EOL] final Object objectToFind = new Object(); [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return INDEX_NOT_FOUND for null array.", ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final Object[] array = new Object[] {"a", "b", "c"}; [EOL] final Object objectToFind = "b"; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return the index of the object to find when start index is negative.", 1, result); [EOL] }
public void testIndexOf_ObjectToFindIsNull() { [EOL] final Object[] array = new Object[] {"a", null, "c"}; [EOL] final Object objectToFind = null; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return the index of the null element.", 1, result); [EOL] }
public void testIndexOf_ObjectToFindIsNotNull() { [EOL] final Object[] array = new Object[] {"a", "b", "c"}; [EOL] final Object objectToFind = "b"; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return the index of the object to find.", 1, result); [EOL] }
public void testIndexOf_ObjectToFindNotInArray() { [EOL] final Object[] array = new Object[] {"a", "b", "c"}; [EOL] final Object objectToFind = "d"; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return INDEX_NOT_FOUND when the object to find is not in the array.", ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] final Object[] array = new Object[] {"a", "b", "c"}; [EOL] final Object objectToFind = "a"; [EOL] int startIndex = array.length; [EOL] int result = ArrayUtils.indexOf(array, objectToFind, startIndex); [EOL] assertEquals("Should return INDEX_NOT_FOUND when start index is greater than array length.", ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] final int result = ArrayUtils.lastIndexOf(null, "a"); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ObjectNotInArray() { [EOL] Object[] array = new Object[] {"a", "b", "c"}; [EOL] final int result = ArrayUtils.lastIndexOf(array, "d"); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ObjectInArray() { [EOL] Object[] array = new Object[] {"a", "b", "a"}; [EOL] final int result = ArrayUtils.lastIndexOf(array, "a"); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_NullObjectInArray() { [EOL] Object[] array = new Object[] {"a", null, "a"}; [EOL] final int result = ArrayUtils.lastIndexOf(array, null); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_ObjectInArrayWithMaxIndex() { [EOL] Object[] array = new Object[] {"a", "b", "a", "b", "a"}; [EOL] final int result = ArrayUtils.lastIndexOf(array, "a", 3); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] int result = ArrayUtils.lastIndexOf(null, "a", 0); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_StartIndexNegative() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "a", -1); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_StartIndexGreaterThanLength() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "c", 4); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOf_ObjectNotFound() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "d", 2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_ObjectIsNull() { [EOL] String[] array = new String[] {"a", null, "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, null, 2); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testLastIndexOf_ObjectFound() { [EOL] String[] array = new String[] {"a", "b", "c", "b"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "b", 3); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOf_ObjectFoundAtFirstPosition() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "a", 2); [EOL] assertEquals(0, result); [EOL] }

public void testContains_NullArray() { [EOL] boolean result = ArrayUtils.contains(null, "someObject"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_EmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] boolean result = ArrayUtils.contains(array, "someObject"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_ArrayWithoutObject() { [EOL] Object[] array = new Object[] {"one", "two", "three"}; [EOL] boolean result = ArrayUtils.contains(array, "four"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContains_ArrayWithObject() { [EOL] Object[] array = new Object[] {"one", "two", "three"}; [EOL] boolean result = ArrayUtils.contains(array, "two"); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_ArrayWithNull() { [EOL] Object[] array = new Object[] {"one", "two", null}; [EOL] boolean result = ArrayUtils.contains(array, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_ArrayWithObjectAtFirstPosition() { [EOL] Object[] array = new Object[] {"one", "two", "three"}; [EOL] boolean result = ArrayUtils.contains(array, "one"); [EOL] assertTrue(result); [EOL] } [EOL] public void testContains_ArrayWithObjectAtLastPosition() { [EOL] Object[] array = new Object[] {"one", "two", "three"}; [EOL] boolean result = ArrayUtils.contains(array, "three"); [EOL] assertTrue(result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final long[] array = null; [EOL] final int result = ArrayUtils.indexOf(array, 1L, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_StartIndexNegative() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final int result = ArrayUtils.indexOf(array, 1L, -1); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_NoMatch() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final int result = ArrayUtils.indexOf(array, 6L, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_Match() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final int result = ArrayUtils.indexOf(array, 3L, 0); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_MatchAfterStartIndex() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final int result = ArrayUtils.indexOf(array, 3L, 2); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_StartIndexEqualsLength() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final int result = ArrayUtils.indexOf(array, 3L, array.length); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_withValuePresent() { [EOL] long[] array = {1, 2, 3, 2, 1}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_withValueNotPresent() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] int index = ArrayUtils.lastIndexOf(array, 6); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] long[] array = {}; [EOL] int index = ArrayUtils.lastIndexOf(array, 1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withNullArray() { [EOL] long[] array = null; [EOL] int index = ArrayUtils.lastIndexOf(array, 1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] int[] array = null; [EOL] int valueToFind = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_EmptyArray() { [EOL] int[] array = {}; [EOL] int valueToFind = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithoutValue() { [EOL] int[] array = {1, 2, 4, 5}; [EOL] int valueToFind = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithValue() { [EOL] int[] array = {1, 2, 3, 1, 2, 3}; [EOL] int valueToFind = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind); [EOL] assertEquals(5, result); [EOL] }
public void testLastIndexOf_ArrayWithMultipleIdenticalValues() { [EOL] int[] array = {3, 3, 3, 3, 3, 3}; [EOL] int valueToFind = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind); [EOL] assertEquals(5, result); [EOL] }
public void testLastIndexOf_nullArray() { [EOL] final int[] array = null; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 0; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_startIndexLessThanZero() { [EOL] final int[] array = {1, 2, 3, 3, 2, 1}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = -1; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_startIndexGreaterThanArrayLength() { [EOL] final int[] array = {1, 2, 3, 3, 2, 1}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 10; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_valueNotFound() { [EOL] final int[] array = {1, 2, 4, 4, 2, 1}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 5; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_valueFound() { [EOL] final int[] array = {1, 2, 3, 3, 2, 1}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 5; [EOL] final int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testContains_WithNullArray() { [EOL] byte[] array = null; [EOL] byte valueToFind = 0x01; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_WithEmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] byte valueToFind = 0x01; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_WithValuePresent() { [EOL] byte[] array = {0x01, 0x02, 0x03}; [EOL] byte valueToFind = 0x02; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_WithValueNotPresent() { [EOL] byte[] array = {0x01, 0x02, 0x03}; [EOL] byte valueToFind = 0x04; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withArrayContainingValue() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.0; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_withArrayNotContainingValue() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 4.0; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] double tolerance = 0.01; [EOL] boolean result = ArrayUtils.contains(array, valueToFind, tolerance); [EOL] assertFalse(result); [EOL] }
public void testContains_withValuePresent() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.0; [EOL] double tolerance = 0.01; [EOL] boolean result = ArrayUtils.contains(array, valueToFind, tolerance); [EOL] assertTrue(result); [EOL] }
public void testContains_withValueNotPresent() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 4.0; [EOL] double tolerance = 0.01; [EOL] boolean result = ArrayUtils.contains(array, valueToFind, tolerance); [EOL] assertFalse(result); [EOL] }
public void testContains_withTolerance() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double valueToFind = 2.05; [EOL] double tolerance = 0.1; [EOL] boolean result = ArrayUtils.contains(array, valueToFind, tolerance); [EOL] assertTrue(result); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] int result = ArrayUtils.lastIndexOf(null, 1.0f); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_EmptyArray() { [EOL] int result = ArrayUtils.lastIndexOf(new float[0], 1.0f); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithoutMatch() { [EOL] float[] array = new float[] {2.0f, 3.0f, 4.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, 1.0f); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithMatch() { [EOL] float[] array = new float[] {2.0f, 3.0f, 1.0f, 3.0f, 1.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, 1.0f); [EOL] assertEquals(4, result); [EOL] }
public void testLastIndexOf_ArrayWithMatchAtFirstElement() { [EOL] float[] array = new float[] {1.0f, 3.0f, 4.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, 1.0f); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_ArrayWithNaN() { [EOL] float[] array = new float[] {2.0f, Float.NaN, 4.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, Float.NaN); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_ArrayWithPositiveInfinity() { [EOL] float[] array = new float[] {2.0f, Float.POSITIVE_INFINITY, 4.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, Float.POSITIVE_INFINITY); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_ArrayWithNegativeInfinity() { [EOL] float[] array = new float[] {2.0f, Float.NEGATIVE_INFINITY, 4.0f}; [EOL] int result = ArrayUtils.lastIndexOf(array, Float.NEGATIVE_INFINITY); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] float[] array = {}; [EOL] float valueToFind = 1.0f; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_withNegativeStartIndex() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 2.0f; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_withStartIndexGreaterThanArrayLength() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 3.0f; [EOL] int startIndex = 5; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_withValidStartIndex() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 2.0f}; [EOL] float valueToFind = 2.0f; [EOL] int startIndex = 2; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_withValueNotFound() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 4.0f; [EOL] int startIndex = 2; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testContains_withValuePresent() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 2.0f; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_withValueAbsent() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 4.0f; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withEmptyArray() { [EOL] float[] array = {}; [EOL] float valueToFind = 1.0f; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withNullArray() { [EOL] float[] array = null; [EOL] float valueToFind = 1.0f; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testIndexOf_ArrayIsEmpty() { [EOL] boolean[] array = {}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_StartIndexIsNegative() { [EOL] boolean[] array = {false, false, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true, -1); [EOL] assertEquals(2, index); [EOL] }
public void testIndexOf_ValueToFindIsPresent() { [EOL] boolean[] array = {false, false, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(2, index); [EOL] }
public void testIndexOf_ValueToFindIsNotPresent() { [EOL] boolean[] array = {false, false, false, false, false}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.indexOf(array, true, array.length); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_ValidStartIndex() { [EOL] boolean[] array = {false, true, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true, 3); [EOL] assertEquals(4, index); [EOL] }
public void testLastIndexOf_emptyArray() { [EOL] boolean[] array = {}; [EOL] int valueToFind = true; [EOL] int startIndex = 0; [EOL] int expected = -1; [EOL] int actual = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testLastIndexOf_startIndexLessThanZero() { [EOL] boolean[] array = {false, true, true, false}; [EOL] int valueToFind = true; [EOL] int startIndex = -1; [EOL] int expected = -1; [EOL] int actual = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testLastIndexOf_startIndexGreaterThanArrayLength() { [EOL] boolean[] array = {false, true, true, false}; [EOL] int valueToFind = true; [EOL] int startIndex = 5; [EOL] int expected = 2; [EOL] int actual = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testLastIndexOf_valueFound() { [EOL] boolean[] array = {false, true, true, false}; [EOL] int valueToFind = true; [EOL] int startIndex = 2; [EOL] int expected = 2; [EOL] int actual = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testLastIndexOf_valueNotFound() { [EOL] boolean[] array = {false, false, false, false}; [EOL] int valueToFind = true; [EOL] int startIndex = 3; [EOL] int expected = -1; [EOL] int actual = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] char[] result = ArrayUtils.toPrimitive(null, 'a'); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Character[] array = new Character[0]; [EOL] char[] result = ArrayUtils.toPrimitive(array, 'a'); [EOL] assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNullValues() { [EOL] Character[] array = new Character[] { null, null, null }; [EOL] char valueForNull = 'z'; [EOL] char[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] char[] expected = new char[] { valueForNull, valueForNull, valueForNull }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNonNullValues() { [EOL] Character[] array = new Character[] { 'a', 'b', 'c' }; [EOL] char valueForNull = 'z'; // This value is not used because there are no nulls in the array [EOL] char[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] char[] expected = new char[] { 'a', 'b', 'c' }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedArrayValues() { [EOL] Character[] array = new Character[] { 'a', null, 'c' }; [EOL] char valueForNull = 'z'; [EOL] char[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] char[] expected = new char[] { 'a', valueForNull, 'c' }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] int[] result = ArrayUtils.toPrimitive(null, 0); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Integer[] emptyArray = new Integer[0]; [EOL] int[] result = ArrayUtils.toPrimitive(emptyArray, 0); [EOL] assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNullValues() { [EOL] Integer[] arrayWithNulls = new Integer[] { null, null, null }; [EOL] int valueForNull = 1; [EOL] int[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] int[] expected = new int[] { valueForNull, valueForNull, valueForNull }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNonNullValues() { [EOL] Integer[] array = new Integer[] { 2, 3, 4 }; [EOL] int valueForNull = 1; [EOL] int[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] int[] expected = new int[] { 2, 3, 4 }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedValues() { [EOL] Integer[] mixedArray = new Integer[] { 2, null, 4 }; [EOL] int valueForNull = 1; [EOL] int[] result = ArrayUtils.toPrimitive(mixedArray, valueForNull); [EOL] int[] expected = new int[] { 2, valueForNull, 4 }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Boolean[] array = null; [EOL] boolean[] result = ArrayUtils.toPrimitive(array); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyInput() { [EOL] Boolean[] array = new Boolean[0]; [EOL] boolean[] result = ArrayUtils.toPrimitive(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, result); [EOL] }
public void testToPrimitiveWithValidInput() { [EOL] Boolean[] array = new Boolean[] { true, false, true }; [EOL] boolean[] result = ArrayUtils.toPrimitive(array); [EOL] boolean[] expected = new boolean[] { true, false, true }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_BothArgumentsNotNull() { [EOL] Integer[] initialArray = new Integer[]{1, 2, 3}; [EOL] Integer elementToAdd = 4; [EOL] Integer[] resultArray = ArrayUtils.add(initialArray, elementToAdd); [EOL] assertNotNull(resultArray); [EOL] assertEquals(4, resultArray.length); [EOL] assertEquals(Integer.valueOf(4), resultArray[3]); [EOL] }
public void testAdd_ArrayIsNull() { [EOL] Integer[] initialArray = null; [EOL] Integer elementToAdd = 1; [EOL] Integer[] resultArray = ArrayUtils.add(initialArray, elementToAdd); [EOL] assertNotNull(resultArray); [EOL] assertEquals(1, resultArray.length); [EOL] assertEquals(Integer.valueOf(1), resultArray[0]); [EOL] }
public void testAdd_ElementIsNull() { [EOL] Integer[] initialArray = new Integer[]{1, 2, 3}; [EOL] Integer elementToAdd = null; [EOL] Integer[] resultArray = ArrayUtils.add(initialArray, elementToAdd); [EOL] assertNotNull(resultArray); [EOL] assertEquals(4, resultArray.length); [EOL] assertNull(resultArray[3]); [EOL] }
public void testAdd_BothArgumentsNull() { [EOL] try { [EOL] Integer[] resultArray = ArrayUtils.add(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testAddBooleanArrayWithTrueElement() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean elementToAdd = true; [EOL] boolean[] result = ArrayUtils.add(array, elementToAdd); [EOL] boolean[] expected = {true, false, true, true}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testAddBooleanArrayWithFalseElement() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean elementToAdd = false; [EOL] boolean[] result = ArrayUtils.add(array, elementToAdd); [EOL] boolean[] expected = {true, false, true, false}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testAddEmptyBooleanArray() { [EOL] boolean[] array = {}; [EOL] boolean elementToAdd = true; [EOL] boolean[] result = ArrayUtils.add(array, elementToAdd); [EOL] boolean[] expected = {true}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testAddNullBooleanArray() { [EOL] boolean[] array = null; [EOL] boolean elementToAdd = true; [EOL] boolean[] result = ArrayUtils.add(array, elementToAdd); [EOL] boolean[] expected = {true}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddFloatArrayWithElement() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float elementToAdd = 4.0f; [EOL] float[] result = ArrayUtils.add(array, elementToAdd); [EOL] float[] expected = {1.0f, 2.0f, 3.0f, 4.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testAddEmptyFloatArrayWithElement() { [EOL] float[] array = {}; [EOL] float elementToAdd = 1.0f; [EOL] float[] result = ArrayUtils.add(array, elementToAdd); [EOL] float[] expected = {1.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testAddNullFloatArrayWithElement() { [EOL] float[] array = null; [EOL] float elementToAdd = 1.0f; [EOL] float[] result = ArrayUtils.add(array, elementToAdd); [EOL] float[] expected = {1.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddNullArray() { [EOL] long element = 5L; [EOL] long[] result = ArrayUtils.add(null, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0]); [EOL] } [EOL] public void testAddNonNullArray() { [EOL] long[] array = {1L, 2L, 3L}; [EOL] long element = 5L; [EOL] long[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(element, result[3]); [EOL] }
public void testAddShortArrayWithElement() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 4; [EOL] short[] result = ArrayUtils.add(array, elementToAdd); [EOL] assertArrayEquals(new short[]{1, 2, 3, 4}, result); [EOL] }
public void testAddShortArrayWithNull() { [EOL] short[] array = null; [EOL] short elementToAdd = 1; [EOL] short[] result = ArrayUtils.add(array, elementToAdd); [EOL] assertArrayEquals(new short[]{1}, result); [EOL] }
public void testCopyArrayGrow1_NonNullArray() { [EOL] Integer[] originalArray = new Integer[] {1, 2, 3}; [EOL] Integer[] newArray = (Integer[]) copyArrayGrow1(originalArray, Integer.class); [EOL] assertNotNull(newArray); [EOL] assertEquals(4, newArray.length); [EOL] assertNull(newArray[3]); [EOL] } [EOL] public void testCopyArrayGrow1_NullArray() { [EOL] Integer[] newArray = (Integer[]) copyArrayGrow1(null, Integer.class); [EOL] assertNotNull(newArray); [EOL] assertEquals(1, newArray.length); [EOL] assertNull(newArray[0]); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4}; [EOL] Integer elementToRemove = 3; [EOL] Integer[] expectedArray = new Integer[] {1, 2, 4}; [EOL] Integer[] resultArray = ArrayUtils.removeElement(array, elementToRemove); [EOL] assertArrayEquals(expectedArray, resultArray); [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4}; [EOL] Integer elementToRemove = 5; [EOL] Integer[] expectedArray = new Integer[] {1, 2, 3, 4}; [EOL] Integer[] resultArray = ArrayUtils.removeElement(array, elementToRemove); [EOL] assertArrayEquals(expectedArray, resultArray); [EOL] }
public void testRemoveElement_NullArray() { [EOL] Integer[] array = null; [EOL] Integer elementToRemove = 3; [EOL] Integer[] resultArray = ArrayUtils.removeElement(array, elementToRemove); [EOL] assertNull(resultArray); [EOL] }
public void testRemoveElement_NullElement() { [EOL] Integer[] array = new Integer[] {1, 2, 3, null, 4}; [EOL] Integer elementToRemove = null; [EOL] Integer[] expectedArray = new Integer[] {1, 2, 3, 4}; [EOL] Integer[] resultArray = ArrayUtils.removeElement(array, elementToRemove); [EOL] assertArrayEquals(expectedArray, resultArray); [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean element = false; [EOL] boolean[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(new boolean[]{true, true}, result); [EOL] } [EOL] public void testRemoveElement_ArrayContainsElement() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean element = true; [EOL] boolean[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(new boolean[]{false, true}, result); [EOL] } [EOL] public void testRemoveElement_ArrayIsEmpty() { [EOL] boolean[] array = {}; [EOL] boolean element = true; [EOL] boolean[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(new boolean[]{}, result); [EOL] } [EOL] public void testRemoveElement_ArrayIsNull() { [EOL] boolean[] array = null; [EOL] boolean element = true; [EOL] boolean[] result = ArrayUtils.removeElement(array, element); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElement_ElementNotFound() { [EOL] boolean[] array = {false, false, false}; [EOL] boolean element = true; [EOL] boolean[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(new boolean[]{false, false, false}, result); [EOL] }
public void testRemoveAll_NullArray() { [EOL] byte[] result = ArrayUtils.removeAll((byte[]) null, 1, 2); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] byte[] emptyArray = new byte[0]; [EOL] byte[] result = ArrayUtils.removeAll(emptyArray, 1, 2); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testRemoveAll_NoIndex() { [EOL] byte[] array = {1, 2, 3}; [EOL] byte[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_SingleIndex() { [EOL] byte[] array = {1, 2, 3}; [EOL] byte[] result = ArrayUtils.removeAll(array, 1); [EOL] byte[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_MultipleIndices() { [EOL] byte[] array = {1, 2, 3, 4, 5}; [EOL] byte[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] byte[] expected = {1, 3, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_NonExistingIndices() { [EOL] byte[] array = {1, 2, 3}; [EOL] byte[] result = ArrayUtils.removeAll(array, 4, 5); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_DuplicateIndices() { [EOL] byte[] array = {1, 2, 3, 4, 5}; [EOL] byte[] result = ArrayUtils.removeAll(array, 2, 2); [EOL] byte[] expected = {1, 2, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_NegativeIndices() { [EOL] byte[] array = {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1, -2); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElements_NullArray() { [EOL] short[] result = ArrayUtils.removeElements(null, (short) 1, (short) 2); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] short[] array = new short[0]; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 1, (short) 2); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesToRemove() { [EOL] short[] array = {1, 2, 3}; [EOL] short[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoMatch() { [EOL] short[] array = {1, 2, 3}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 4); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_SingleMatch() { [EOL] short[] array = {1, 2, 3}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 2); [EOL] short[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleMatches() { [EOL] short[] array = {1, 2, 3, 2, 2}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 2); [EOL] short[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleValues() { [EOL] short[] array = {1, 2, 3, 4, 2, 3}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 2, (short) 3); [EOL] short[] expected = {1, 4}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleOccurrences() { [EOL] short[] array = {1, 2, 3, 1, 2, 3}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 1, (short) 1); [EOL] short[] expected = {2, 3, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_AllRemoved() { [EOL] short[] array = {1, 1, 1}; [EOL] short[] result = ArrayUtils.removeElements(array, (short) 1); [EOL] short[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_NullArray() { [EOL] long[] result = ArrayUtils.removeAll((long[]) null, 1); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] long[] array = {}; [EOL] long[] result = ArrayUtils.removeAll(array, 1); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_NoIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_ValidIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeAll(array, 1); [EOL] long[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_MultipleIndices() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] long[] expected = {1, 3, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_AllIndices() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.removeAll(array, 0, 1, 2); [EOL] long[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_InvalidIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, 4); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NegativeIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElements_NullArray() { [EOL] float[] result = ArrayUtils.removeElements(null, 1.0f, 2.0f); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] float[] array = {}; [EOL] float[] result = ArrayUtils.removeElements(array, 1.0f, 2.0f); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesToRemove() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoMatch() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 4.0f); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_SingleMatch() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 2.0f); [EOL] float[] expected = {1.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleMatches() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 2.0f, 2.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 2.0f); [EOL] float[] expected = {1.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleValues() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 2.0f, 4.0f); [EOL] float[] expected = {1.0f, 3.0f, 5.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleOccurrences() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 2.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 2.0f, 3.0f); [EOL] float[] expected = {1.0f}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_AllRemoved() { [EOL] float[] array = {2.0f, 2.0f, 2.0f}; [EOL] float[] result = ArrayUtils.removeElements(array, 2.0f); [EOL] float[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_DoubleArrayWithIndices() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] int[] indices = {1, 3}; [EOL] double[] result = ArrayUtils.removeAll(array, indices); [EOL] double[] expected = {1.0, 3.0, 5.0}; [EOL] assertArrayEquals(expected, result, 0.0001); [EOL] }
public void testRemoveAll_DoubleArrayWithNoIndices() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] double[] result = ArrayUtils.removeAll(array); [EOL] double[] expected = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] assertArrayEquals(expected, result, 0.0001); [EOL] }
public void testRemoveAll_DoubleArrayWithAllIndices() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] int[] indices = {0, 1, 2, 3, 4}; [EOL] double[] result = ArrayUtils.removeAll(array, indices); [EOL] double[] expected = {}; [EOL] assertArrayEquals(expected, result, 0.0001); [EOL] }
public void testRemoveAll_DoubleArrayWithInvalidIndices() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] int[] indices = {5, 6}; [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_DoubleArrayWithNullArray() { [EOL] double[] array = null; [EOL] int[] indices = {1, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should have thrown a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemoveAll_DoubleArrayWithEmptyIndices() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] int[] indices = {}; [EOL] double[] result = ArrayUtils.removeAll(array, indices); [EOL] double[] expected = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] assertArrayEquals(expected, result, 0.0001); [EOL] }
public void testRemoveAllWithEmptyIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array); [EOL] assertArrayEquals("Result should be the same as the original array when indices are empty", array, result); [EOL] } [EOL] public void testRemoveAllWithValidIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {1, 3}; [EOL] Integer[] expected = new Integer[] {1, 3, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertArrayEquals("Result should have specific elements removed", expected, result); [EOL] } [EOL] public void testRemoveAllWithDuplicateIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {2, 2}; [EOL] Integer[] expected = new Integer[] {1, 2, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertArrayEquals("Result should handle duplicate indices by removing the element once", expected, result); [EOL] } [EOL] public void testRemoveAllWithOutOfOrderIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {4, 1}; [EOL] Integer[] expected = new Integer[] {1, 3, 4}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertArrayEquals("Result should handle out-of-order indices", expected, result); [EOL] } [EOL] public void testRemoveAllWithInvalidNegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {-1}; [EOL] try { [EOL] removeAll(array, indices); [EOL] fail("Should throw IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithInvalidLargeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {5}; [EOL] try { [EOL] removeAll(array, indices); [EOL] fail("Should throw IndexOutOfBoundsException for index equal to array length"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithNullArray() { [EOL] try { [EOL] removeAll(null, 1); [EOL] fail("Should throw NullPointerException for null array"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithEmptyArray() { [EOL] Integer[] array = new Integer[] {}; [EOL] int[] indices = {0}; [EOL] try { [EOL] removeAll(array, indices); [EOL] fail("Should throw IndexOutOfBoundsException for empty array"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL] if (destClass.isPrimitive()) { [EOL] return getPrimitivePromotionCost(srcClass, destClass); [EOL] } [EOL] float cost = 0.0f; [EOL] while (srcClass != null && !destClass.equals(srcClass)) { [EOL] if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL] cost += 0.25f; [EOL] break; [EOL] } [EOL] cost++; [EOL] srcClass = srcClass.getSuperclass(); [EOL] } [EOL] if (srcClass == null) { [EOL] cost += 1.5f; [EOL] } [EOL] return cost; [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
public void testIsInstance_WithNullType() { [EOL] boolean result = isInstance(new Object(), null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsInstance_WithNullValueAndNonPrimitiveClass() { [EOL] boolean result = isInstance(null, Object.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsInstance_WithNullValueAndPrimitiveClass() { [EOL] boolean result = isInstance(null, int.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsInstance_WithValueAndTypeMatch() { [EOL] boolean result = isInstance("test", String.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsInstance_WithValueAndTypeMismatch() { [EOL] boolean result = isInstance(123, String.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsInstance_WithValueAndGenericType() { [EOL] boolean result = isInstance(new ArrayList<>(), List.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsInstance_WithValueAndPrimitiveType() { [EOL] boolean result = isInstance(123, int.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsInstance_WithValueAndPrimitiveWrapperType() { [EOL] boolean result = isInstance(123, Integer.class); [EOL] assertTrue(result); [EOL] }
public void testGetContextValuesWithMatchingLabel() { [EOL] List<Pair<String, Object>> contextValues = new ArrayList<>(); [EOL] contextValues.add(new ImmutablePair<>("label1", "value1")); [EOL] contextValues.add(new ImmutablePair<>("label2", "value2")); [EOL] contextValues.add(new ImmutablePair<>("label1", "value3")); [EOL] YourClass instance = new YourClass(contextValues); [EOL] List<Object> result = instance.getContextValues("label1"); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains("value1")); [EOL] assertTrue(result.contains("value3")); [EOL] }
public void testGetContextValuesWithNoMatchingLabel() { [EOL] List<Pair<String, Object>> contextValues = new ArrayList<>(); [EOL] contextValues.add(new ImmutablePair<>("label1", "value1")); [EOL] contextValues.add(new ImmutablePair<>("label2", "value2")); [EOL] YourClass instance = new YourClass(contextValues); [EOL] List<Object> result = instance.getContextValues("label3"); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetContextValuesWithNullLabel() { [EOL] List<Pair<String, Object>> contextValues = new ArrayList<>(); [EOL] contextValues.add(new ImmutablePair<>(null, "value1")); [EOL] contextValues.add(new ImmutablePair<>("label2", "value2")); [EOL] YourClass instance = new YourClass(contextValues); [EOL] List<Object> result = instance.getContextValues(null); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains("value1")); [EOL] }
public void testStrBuilderConstructorWithNegativeCapacity() { [EOL] int initialCapacity = -1; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(StrBuilder.CAPACITY, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithZeroCapacity() { [EOL] int initialCapacity = 0; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(StrBuilder.CAPACITY, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithPositiveCapacity() { [EOL] int initialCapacity = 10; [EOL] StrBuilder strBuilder = new StrBuilder(initialCapacity); [EOL] assertEquals(initialCapacity, strBuilder.capacity()); [EOL] }
public void testStrBuilderConstructorWithNull() { [EOL] StrBuilder sb = new StrBuilder(null); [EOL] assertNotNull(sb); [EOL] assertEquals(StrBuilder.CAPACITY, sb.capacity()); [EOL] }
public void testStrBuilderConstructorWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(""); [EOL] assertNotNull(sb); [EOL] assertEquals(StrBuilder.CAPACITY, sb.capacity()); [EOL] }
public void testStrBuilderConstructorWithNonEmptyString() { [EOL] String initialString = "initial"; [EOL] StrBuilder sb = new StrBuilder(initialString); [EOL] assertNotNull(sb); [EOL] assertEquals(initialString.length() + StrBuilder.CAPACITY, sb.capacity()); [EOL] assertEquals(initialString, sb.toString()); [EOL] }
public void testGetNewLineText_NullNewLine() { [EOL] System.setProperty("line.separator", null); [EOL] StringUtils utils = new StringUtils(); [EOL] String result = utils.getNewLineText(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetNewLineText_NonNullNewLine() { [EOL] String expectedNewLine = System.getProperty("line.separator"); [EOL] if (expectedNewLine == null) { [EOL] expectedNewLine = "\n"; // Fallback for environments where line.separator is not set [EOL] } [EOL] StringUtils utils = new StringUtils(); [EOL] String result = utils.getNewLineText(); [EOL] assertEquals(expectedNewLine, result); [EOL] }
public void testSetNewLineTextWithNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNewLineText(null); [EOL] assertNull(sb.getNewLineText()); [EOL] }
public void testSetNewLineTextWithNewLine() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNewLineText("\n"); [EOL] assertEquals("\n", sb.getNewLineText()); [EOL] }
public void testSetNewLineTextWithCarriageReturn() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNewLineText("\r"); [EOL] assertEquals("\r", sb.getNewLineText()); [EOL] }
public void testSetNewLineTextWithCarriageReturnNewLine() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNewLineText("\r\n"); [EOL] assertEquals("\r\n", sb.getNewLineText()); [EOL] }
public void testSetNullTextWithNonNullEmptyString() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(""); [EOL] assertNull(builder.getNullText()); [EOL] }
public void testSetNullTextWithNonNullNonEmptyString() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText("text"); [EOL] assertEquals("text", builder.getNullText()); [EOL] }
public void testSetNullTextWithNull() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(null); [EOL] assertNull(builder.getNullText()); [EOL] }
public void testSetLengthNegative() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] try { [EOL] sb.setLength(-1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSetLengthShorterThanCurrentSize() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.setLength(2); [EOL] assertEquals("ab", sb.toString()); [EOL] }
public void testSetLengthSameAsCurrentSize() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.setLength(3); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testSetLengthLongerThanCurrentSize() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.setLength(5); [EOL] assertEquals("abc\0\0", sb.toString()); [EOL] }
public void testMinimizeCapacity_BufferLargerThanLength() { [EOL] StrBuilder strBuilder = new StrBuilder(10); [EOL] strBuilder.append("abc"); [EOL] strBuilder.minimizeCapacity(); [EOL] assertEquals(3, strBuilder.length()); [EOL] assertEquals(3, strBuilder.capacity()); [EOL] }
public void testMinimizeCapacity_BufferEqualToLength() { [EOL] StrBuilder strBuilder = new StrBuilder(3); [EOL] strBuilder.append("abc"); [EOL] strBuilder.minimizeCapacity(); [EOL] assertEquals(3, strBuilder.length()); [EOL] assertEquals(3, strBuilder.capacity()); [EOL] }
public void testSize_WhenSizeIsZero() { [EOL] ArrayStack<Integer> stack = new ArrayStack<>(); [EOL] int size = stack.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSize_WhenSizeIsNonZero() { [EOL] ArrayStack<Integer> stack = new ArrayStack<>(); [EOL] stack.push(1); [EOL] int size = stack.size(); [EOL] assertEquals(1, size); [EOL] }
public void testGetCharsStartIndexNegative() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(-1, 5, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: -1", e.getMessage()); [EOL] } [EOL] }
public void testGetCharsEndIndexNegative() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(0, -1, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: -1", e.getMessage()); [EOL] } [EOL] }
public void testGetCharsEndIndexGreaterThanLength() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(0, 11, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: 11", e.getMessage()); [EOL] } [EOL] }
public void testGetCharsStartIndexGreaterThanEndIndex() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(5, 4, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: end < start", e.getMessage()); [EOL] } [EOL] }
public void testGetCharsValidIndices() { [EOL] char[] destination = new char[10]; [EOL] getChars(0, 5, destination, 0); [EOL] assertEquals('H', destination[0]); [EOL] assertEquals('e', destination[1]); [EOL] assertEquals('l', destination[2]); [EOL] assertEquals('l', destination[3]); [EOL] assertEquals('o', destination[4]); [EOL] }
public void testAppendNewLine_WithDefaultNewLine() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendNewLine(); [EOL] assertEquals(SystemUtils.LINE_SEPARATOR, builder.toString()); [EOL] } [EOL] public void testAppendNewLine_WithCustomNewLine() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNewLine("\n"); [EOL] builder.appendNewLine(); [EOL] assertEquals("\n", builder.toString()); [EOL] }
public void testAppendlnStringBufferWithValidRange() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("abcdef"); [EOL] builder.appendln(stringBuffer, 1, 3); [EOL] assertEquals("bcd" + System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnStringBufferWithNegativeStartIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("abcdef"); [EOL] try { [EOL] builder.appendln(stringBuffer, -1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendlnStringBufferWithLengthExceedingBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("abcdef"); [EOL] builder.appendln(stringBuffer, 1, 10); [EOL] assertEquals("bcdef" + System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnStringBufferWithStartIndexExceedingBufferLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("abcdef"); [EOL] builder.appendln(stringBuffer, 10, 1); [EOL] assertEquals(System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnStringBufferWithNull() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendln((StringBuffer) null, 0, 10); [EOL] assertEquals(System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnWithCharArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = {'a', 'b', 'c'}; [EOL] sb.appendln(chars); [EOL] assertEquals("abc" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithEmptyCharArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[0]; [EOL] sb.appendln(chars); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithNullCharArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((char[]) null); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithTrue() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(true); [EOL] assertEquals("true" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithFalse() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(false); [EOL] assertEquals("false" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendAllWithNonNullIterable() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] List<String> list = Arrays.asList("a", "b", "c"); [EOL] builder.appendAll(list); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testAppendAllWithNullIterable() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendAll(null); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendAllWithEmptyIterable() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] List<String> list = Collections.emptyList(); [EOL] builder.appendAll(list); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendWithSeparators_NullArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(null, ","); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_EmptyArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(new Object[0], ","); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_NonEmptyArrayNoSeparator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(new Object[]{"a", "b", "c"}, null); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_NonEmptyArrayWithSeparator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(new Object[]{"a", "b", "c"}, ","); [EOL] assertEquals("a,b,c", sb.toString()); [EOL] }
public void testAppendWithSeparators_SingleElementArray() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(new Object[]{"a"}, ","); [EOL] assertEquals("a", sb.toString()); [EOL] }
public void testAppendWithSeparators_NullIterable() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(null, ","); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_EmptyIterable() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(Collections.emptyList(), ","); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_NonEmptyIterable() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(Arrays.asList("a", "b", "c"), ","); [EOL] assertEquals("a,b,c", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_NullSeparator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(Arrays.asList("a", "b", "c"), null); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testAppendWithSeparators_EmptySeparator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendWithSeparators(Arrays.asList("a", "b", "c"), ""); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppendSeparatorWithNonEmptyBuilder() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.appendSeparator(',', 'x'); [EOL] assertEquals("abc,", builder.toString()); [EOL] }
public void testAppendSeparatorWithEmptyBuilder() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendSeparator(',', 'x'); [EOL] assertEquals("x", builder.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_PositiveWidth_NullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft(null, 5, '*'); [EOL] assertEquals("*****", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_PositiveWidth_NonNullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", 5, '*'); [EOL] assertEquals("**abc", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_WidthLessThanObjLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abcdef", 3, '*'); [EOL] assertEquals("def", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_ZeroWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", 0, '*'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadLeft_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadLeft("abc", -1, '*'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_NullArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.insert(1, (char[]) null); [EOL] assertEquals("anullbc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_EmptyArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[0]; [EOL] builder.insert(1, chars); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_ValidArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] builder.insert(1, chars); [EOL] assertEquals("axyzbc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_OutOfBounds() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] try { [EOL] builder.insert(4, chars); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithNullChars() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.insert(0, (char[]) null, 0, 0); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testInsertWithValidOffsetAndLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 1, 2); [EOL] assertEquals("bc", sb.toString()); [EOL] } [EOL] public void testInsertWithInvalidOffset() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, -1, 2); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testInsertWithInvalidLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 1, 5); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testInsertWithOffsetGreaterThanCharsLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 4, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testInsertWithOffsetPlusLengthGreaterThanCharsLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 2, 2); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testInsertWithZeroLength() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] sb.insert(1, chars, 1, 0); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testInsertAtEnd() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] sb.insert(3, chars, 0, 3); [EOL] assertEquals("abcxyz", sb.toString()); [EOL] } [EOL] public void testInsertAtStart() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] sb.insert(0, chars, 0, 3); [EOL] assertEquals("xyzabc", sb.toString()); [EOL] }
public void testInsertBooleanTrue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, true); [EOL] assertEquals("atruebc", sb.toString()); [EOL] assertEquals(7, sb.length()); [EOL] }
public void testInsertBooleanFalse() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, false); [EOL] assertEquals("afalsebc", sb.toString()); [EOL] assertEquals(8, sb.length()); [EOL] }
public void testInsertBooleanAtIndexZero() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, true); [EOL] assertEquals("trueabc", sb.toString()); [EOL] assertEquals(7, sb.length()); [EOL] }
public void testInsertBooleanAtEnd() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, false); [EOL] assertEquals("abcfalse", sb.toString()); [EOL] assertEquals(8, sb.length()); [EOL] }
public void testInsertBooleanOutOfBounds() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, true); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsert_ValidIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, 'x'); [EOL] assertEquals("axbc", sb.toString()); [EOL] } [EOL] public void testInsert_StartIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, 'x'); [EOL] assertEquals("xabc", sb.toString()); [EOL] } [EOL] public void testInsert_EndIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, 'x'); [EOL] assertEquals("abcx", sb.toString()); [EOL] } [EOL] public void testInsert_OutOfBounds() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, 'x'); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }

public void testInsertWithValidIndexAndIntValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, 100); [EOL] assertEquals("a100bc", sb.toString()); [EOL] }
public void testInsertWithStartIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, 200); [EOL] assertEquals("200abc", sb.toString()); [EOL] }
public void testInsertWithEndIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, 300); [EOL] assertEquals("abc300", sb.toString()); [EOL] }
public void testInsertWithNegativeIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(-1, 400); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithIndexGreaterThanSize() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, 500); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithValidIndexAndLongValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, 1234567890L); [EOL] assertEquals("a1234567890bc", sb.toString()); [EOL] }
public void testInsertWithStartIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, 1234567890L); [EOL] assertEquals("1234567890abc", sb.toString()); [EOL] }
public void testInsertWithEndIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, 1234567890L); [EOL] assertEquals("abc1234567890", sb.toString()); [EOL] }
public void testInsertWithNegativeIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(-1, 1234567890L); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithIndexGreaterThanSize() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, 1234567890L); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithValidIndexAndFloatValue() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.insert(1, 2.5f); [EOL] assertEquals("a2.5bc", builder.toString()); [EOL] }
public void testInsertAtStartWithFloatValue() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.insert(0, 3.5f); [EOL] assertEquals("3.5abc", builder.toString()); [EOL] }
public void testInsertAtEndWithFloatValue() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.insert(3, 4.5f); [EOL] assertEquals("abc4.5", builder.toString()); [EOL] }
public void testInsertWithNegativeIndex() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] try { [EOL] builder.insert(-1, 5.5f); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithIndexGreaterThanLength() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] try { [EOL] builder.insert(4, 6.5f); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithValidIndexAndDoubleValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, 2.3); [EOL] assertEquals("a2.3bc", sb.toString()); [EOL] }
public void testInsertAtStartWithDoubleValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, 4.5); [EOL] assertEquals("4.5abc", sb.toString()); [EOL] }
public void testInsertAtEndWithDoubleValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, 6.7); [EOL] assertEquals("abc6.7", sb.toString()); [EOL] }
public void testInsertWithNegativeIndexAndDoubleValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(-1, 8.9); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithIndexGreaterThanSizeAndDoubleValue() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, 10.11); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDeleteWithValidRange() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] builder.delete(1, 3); [EOL] assertEquals("adef", builder.toString()); [EOL] } [EOL] public void testDeleteWithSameStartAndEndIndex() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] builder.delete(2, 2); [EOL] assertEquals("abcdef", builder.toString()); [EOL] } [EOL] public void testDeleteWithEndIndexGreaterThanLength() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] builder.delete(1, 10); [EOL] assertEquals("a", builder.toString()); [EOL] } [EOL] public void testDeleteWithStartIndexNegative() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] try { [EOL] builder.delete(-1, 3); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testDeleteWithEndIndexNegative() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] try { [EOL] builder.delete(1, -1); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testDeleteWithStartIndexGreaterThanLength() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] builder.delete(10, 12); [EOL] assertEquals("abcdef", builder.toString()); [EOL] }
public void testDeleteWithStartIndexGreaterThanEndIndex() { [EOL] StrBuilder builder = new StrBuilder("abcdef"); [EOL] try { [EOL] builder.delete(3, 1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDeleteAll_NoCharFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] strBuilder.deleteAll('d'); [EOL] assertEquals("abc", strBuilder.toString()); [EOL] }
public void testDeleteAll_CharFoundOnce() { [EOL] StrBuilder strBuilder = new StrBuilder("abcd"); [EOL] strBuilder.deleteAll('c'); [EOL] assertEquals("abd", strBuilder.toString()); [EOL] }
public void testDeleteAll_CharFoundMultipleTimes() { [EOL] StrBuilder strBuilder = new StrBuilder("aabbcc"); [EOL] strBuilder.deleteAll('b'); [EOL] assertEquals("aacc", strBuilder.toString()); [EOL] }
public void testDeleteAll_CharFoundAtStart() { [EOL] StrBuilder strBuilder = new StrBuilder("aaabbb"); [EOL] strBuilder.deleteAll('a'); [EOL] assertEquals("bbb", strBuilder.toString()); [EOL] }
public void testDeleteAll_CharFoundAtEnd() { [EOL] StrBuilder strBuilder = new StrBuilder("aaabbb"); [EOL] strBuilder.deleteAll('b'); [EOL] assertEquals("aaa", strBuilder.toString()); [EOL] }
public void testDeleteAll_CharFoundAtStartAndEnd() { [EOL] StrBuilder strBuilder = new StrBuilder("ababa"); [EOL] strBuilder.deleteAll('a'); [EOL] assertEquals("b", strBuilder.toString()); [EOL] }
public void testDeleteAll_EmptyStrBuilder() { [EOL] StrBuilder strBuilder = new StrBuilder(""); [EOL] strBuilder.deleteAll('a'); [EOL] assertEquals("", strBuilder.toString()); [EOL] }
public void testDeleteAll_AllCharsSameAsTarget() { [EOL] StrBuilder strBuilder = new StrBuilder("aaaa"); [EOL] strBuilder.deleteAll('a'); [EOL] assertEquals("", strBuilder.toString()); [EOL] }
public void testDeleteFirst_Null() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.deleteFirst(null); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testDeleteFirst_Empty() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.deleteFirst(""); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testDeleteFirst_NotFound() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.deleteFirst("x"); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testDeleteFirst_Found() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.deleteFirst("bc"); [EOL] assertEquals("aabc", sb.toString()); [EOL] }
public void testSubstring_StartAtBeginning() { [EOL] String str = "abcdef"; [EOL] String substr = str.substring(0); [EOL] assertEquals("abcdef", substr); [EOL] }
public void testSubstring_StartInMiddle() { [EOL] String str = "abcdef"; [EOL] String substr = str.substring(2); [EOL] assertEquals("cdef", substr); [EOL] }
public void testSubstring_StartAtEnd() { [EOL] String str = "abcdef"; [EOL] String substr = str.substring(6); [EOL] assertEquals("", substr); [EOL] }
public void testSubstring_StartAfterEnd() { [EOL] String str = "abcdef"; [EOL] try { [EOL] str.substring(7); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubstring_StartBeforeBeginning() { [EOL] String str = "abcdef"; [EOL] try { [EOL] str.substring(-1); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testLeftString_LengthLessThanZero() { [EOL] String str = "abcdef"; [EOL] String result = str.leftString(-1); [EOL] assertEquals("", result); [EOL] } [EOL] public void testLeftString_LengthEqualToSize() { [EOL] String str = "abcdef"; [EOL] String result = str.leftString(6); [EOL] assertEquals("abcdef", result); [EOL] }
public void testLeftString_LengthGreaterThanSize() { [EOL] String str = "abcdef"; [EOL] String result = str.leftString(10); [EOL] assertEquals("abcdef", result); [EOL] }
public void testLeftString_LengthLessThanSize() { [EOL] String str = "abcdef"; [EOL] String result = str.leftString(3); [EOL] assertEquals("abc", result); [EOL] }
public void testContains_charExists() { [EOL] final char[] buffer = {'a', 'b', 'c'}; [EOL] final int size = buffer.length; [EOL] boolean result = contains('b'); [EOL] assertTrue(result); [EOL] }
public void testContains_charDoesNotExist() { [EOL] final char[] buffer = {'a', 'b', 'c'}; [EOL] final int size = buffer.length; [EOL] boolean result = contains('d'); [EOL] assertFalse(result); [EOL] }
public void testIndexOfChar() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] assertEquals(-1, stringUtils.indexOf('a')); [EOL] assertEquals(0, stringUtils.indexOf('h', 0)); [EOL] assertEquals(2, stringUtils.indexOf('l', 1)); [EOL] assertEquals(-1, stringUtils.indexOf('z', 2)); [EOL] }
public void testIndexOfCharFromStart() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] assertEquals(0, stringUtils.indexOf('h', 0)); [EOL] }
public void testIndexOfCharNotFound() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] assertEquals(-1, stringUtils.indexOf('x')); [EOL] }
public void testIndexOf_CharInBufferFromStart() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final char testChar = 'c'; [EOL] final int startIndex = 0; [EOL] MyClass myClass = new MyClass(testBuffer); [EOL] int result = myClass.indexOf(testChar, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharNotInBuffer() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final char testChar = 'f'; [EOL] final int startIndex = 0; [EOL] MyClass myClass = new MyClass(testBuffer); [EOL] int result = myClass.indexOf(testChar, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_CharInBufferFromMiddle() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final char testChar = 'd'; [EOL] final int startIndex = 2; [EOL] MyClass myClass = new MyClass(testBuffer); [EOL] int result = myClass.indexOf(testChar, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanSize() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final char testChar = 'a'; [EOL] final int startIndex = 10; [EOL] MyClass myClass = new MyClass(testBuffer); [EOL] int result = myClass.indexOf(testChar, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final char testChar = 'a'; [EOL] final int startIndex = -1; [EOL] MyClass myClass = new MyClass(testBuffer); [EOL] int result = myClass.indexOf(testChar, startIndex); [EOL] assertEquals(0, result); [EOL] }
public int indexOf(final String str, int fromIndex) { [EOL] if (str == null) { [EOL] return INDEX_NOT_FOUND; [EOL] } [EOL] return CharSequenceUtils.indexOf(this, str, fromIndex); [EOL] }
public void testIndexOf_NullMatcher() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] int index = strBuilder.indexOf(null, 0); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testIndexOf_InvalidStartIndex() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL] int index = strBuilder.indexOf(matcher, -1); [EOL] assertEquals(0, index); [EOL] } [EOL] public void testIndexOf_StartIndexGreaterThanSize() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL] int index = strBuilder.indexOf(matcher, 4); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testIndexOf_MatcherNotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('d'); [EOL] int index = strBuilder.indexOf(matcher, 0); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testIndexOf_MatcherFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('b'); [EOL] int index = strBuilder.indexOf(matcher, 0); [EOL] assertEquals(1, index); [EOL] }
public int lastIndexOf(final StrMatcher matcher) { [EOL] return lastIndexOf(matcher, size); [EOL] }
public void testLastIndexOf_MatcherNull() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] int index = strBuilder.lastIndexOf(null, 2); [EOL] assertEquals(-1, index); [EOL] } [EOL] public void testLastIndexOf_StartIndexOutOfBounds() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL] int index = strBuilder.lastIndexOf(matcher, 4); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_MatcherNotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('d'); [EOL] int index = strBuilder.lastIndexOf(matcher, 2); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_MatcherFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('b'); [EOL] int index = strBuilder.lastIndexOf(matcher, 2); [EOL] assertEquals(1, index); [EOL] }
public void testLastIndexOf_StartIndexNegative() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL] int index = strBuilder.lastIndexOf(matcher, -1); [EOL] assertEquals(-1, index); [EOL] }
public void testToStringBuilder_Empty() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuilder result = strBuilder.toStringBuilder(); [EOL] assertEquals(0, result.length()); [EOL] }
public void testToStringBuilder_WithContent() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.append("abc"); [EOL] StringBuilder result = strBuilder.toStringBuilder(); [EOL] assertEquals("abc", result.toString()); [EOL] }
public void testValidateRange_StartIndexNegative() { [EOL] try { [EOL] validateRange(-1, 10); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: -1", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidateRange_EndIndexGreaterThanSize() { [EOL] final int size = 5; [EOL] int endIndex = validateRange(0, 10); [EOL] assertEquals(size, endIndex); [EOL] } [EOL] public void testValidateRange_StartIndexGreaterThanEndIndex() { [EOL] try { [EOL] validateRange(5, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("end < start", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidateRange_ValidRange() { [EOL] final int size = 5; [EOL] int endIndex = validateRange(1, 3); [EOL] assertEquals(3, endIndex); [EOL] }
public void testGetDateInstance_Default() { [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] assertEquals(FastDateFormat.SHORT, fdf.getMaxLengthEstimate()); [EOL] } [EOL] public void testGetDateInstance_Locale() { [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.MEDIUM, Locale.US); [EOL] assertNotNull(fdf); [EOL] assertEquals(FastDateFormat.MEDIUM, fdf.getMaxLengthEstimate()); [EOL] } [EOL] public void testGetDateInstance_TimeZone() { [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("GMT")); [EOL] assertNotNull(fdf); [EOL] assertEquals(FastDateFormat.LONG, fdf.getMaxLengthEstimate()); [EOL] } [EOL] public void testGetDateInstance_TimeZoneLocale() { [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.FULL, TimeZone.getTimeZone("GMT"), Locale.US); [EOL] assertNotNull(fdf); [EOL] assertEquals(FastDateFormat.FULL, fdf.getMaxLengthEstimate()); [EOL] }

public static FastDateFormat getDateInstance(final int style, final Locale locale) { [EOL] return cache.getDateInstance(style, null, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=Optional[2L]; [EOL] int FULL=Optional[DateFormat.FULL]; [EOL] int LONG=Optional[DateFormat.LONG]; [EOL] int MEDIUM=Optional[DateFormat.MEDIUM]; [EOL] int SHORT=Optional[DateFormat.SHORT]; [EOL] FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }]
public void testGetDateInstanceWithStyleAndTimeZone() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.LONG, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetDateInstanceWithInvalidStyle() { [EOL] try { [EOL] FastDateFormat.getDateInstance(Integer.MAX_VALUE, TimeZone.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException for invalid date style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateInstanceWithStyleTimeZoneLocale() { [EOL] int style = DateFormat.MEDIUM; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.CANADA; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateInstanceWithStyle() { [EOL] int style = DateFormat.LONG; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style); [EOL] assertNotNull(fdf); [EOL] assertEquals(DateFormat.getDateInstance(style).toPattern(), fdf.getPattern()); [EOL] }
public void testGetDateInstanceWithStyleLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.UK; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateInstanceWithStyleTimeZone() { [EOL] int style = DateFormat.FULL; [EOL] TimeZone timeZone = TimeZone.getTimeZone("CET"); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testEquals_withNonFastDateFormatObject() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Object obj = new Object(); [EOL] assertFalse(fdf.equals(obj)); [EOL] }
public void testEquals_withFastDateFormatObjectDifferentPrinter() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("MM/dd/yyyy"); [EOL] assertFalse(fdf1.equals(fdf2)); [EOL] }
public void testEquals_withFastDateFormatObjectSamePrinter() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] assertTrue(fdf1.equals(fdf2)); [EOL] }
public void testEquals_withNull() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertFalse(fdf.equals(null)); [EOL] }
public int hashCode() { [EOL] return printer.hashCode(); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] } [EOL] };
public void testGetJavaIoTmpDir() { [EOL] File tmpDir = FileUtils.getJavaIoTmpDir(); [EOL] assertNotNull(tmpDir); [EOL] assertTrue(tmpDir.exists()); [EOL] assertEquals(System.getProperty("java.io.tmpdir"), tmpDir.getPath()); [EOL] }
public void testSystemUtilsConstructor() { [EOL] new SystemUtils(); [EOL] }
public void testGetFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The class must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field name must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "CASE_INSENSITIVE_ORDER", false); [EOL] assertNotNull(field); [EOL] assertEquals("CASE_INSENSITIVE_ORDER", field.getName()); [EOL] }
public void testGetFieldWithNonExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "nonExistingField", false); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithPrivateFieldWithoutForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", false); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithPrivateFieldWithForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", true); [EOL] assertNotNull(field); [EOL] assertEquals("privateField", field.getName()); [EOL] }
public void testGetFieldWithAmbiguousField() { [EOL] try { [EOL] FieldUtils.getField(AmbiguousFieldInterface.class, "AMBIGUOUS_FIELD", false); [EOL] fail("Should have thrown IllegalArgumentException for ambiguous field"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Reference to field AMBIGUOUS_FIELD is ambiguous")); [EOL] } [EOL] }
public void testGetDeclaredFieldWithValidClassAndFieldName() throws Exception { [EOL] Field field = ClassUtils.getDeclaredField(String.class, "value"); [EOL] assertNotNull(field); [EOL] assertEquals("value", field.getName()); [EOL] }
public void testGetDeclaredFieldWithNullClass() throws Exception { [EOL] try { [EOL] ClassUtils.getDeclaredField(null, "value"); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDeclaredFieldWithEmptyFieldName() throws Exception { [EOL] try { [EOL] ClassUtils.getDeclaredField(String.class, ""); [EOL] fail("Should have thrown IllegalArgumentException for empty field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDeclaredFieldWithNullFieldName() throws Exception { [EOL] try { [EOL] ClassUtils.getDeclaredField(String.class, null); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAllFieldsListWithNullClass() { [EOL] try { [EOL] Class<?> cls = null; [EOL] ReflectionUtils.getAllFieldsList(cls); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("The class must not be null", iae.getMessage()); [EOL] } [EOL] }
public void testGetAllFieldsListWithValidClass() { [EOL] Class<?> cls = MyClass.class; [EOL] List<Field> fields = ReflectionUtils.getAllFieldsList(cls); [EOL] assertNotNull(fields); [EOL] assertFalse(fields.isEmpty()); [EOL] assertTrue(fields.stream().anyMatch(field -> field.getDeclaringClass() == MyClass.class)); [EOL] }
public void testGetAllFieldsListWithClassHavingNoFields() { [EOL] Class<?> cls = EmptyClass.class; [EOL] List<Field> fields = ReflectionUtils.getAllFieldsList(cls); [EOL] assertNotNull(fields); [EOL] assertTrue(fields.isEmpty()); [EOL] }
public void testGetAllFieldsListWithInheritance() { [EOL] Class<?> cls = ChildClass.class; [EOL] List<Field> fields = ReflectionUtils.getAllFieldsList(cls); [EOL] assertNotNull(fields); [EOL] assertTrue(fields.stream().anyMatch(field -> field.getDeclaringClass() == ChildClass.class)); [EOL] assertTrue(fields.stream().anyMatch(field -> field.getDeclaringClass() == ParentClass.class)); [EOL] }
public void testReadStaticField_NullField_ThrowsIllegalArgumentException() { [EOL] try { [EOL] ReflectionUtils.readStaticField(null, true); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Expected IllegalArgumentException, not IllegalAccessException"); [EOL] } [EOL] }
public void testReadStaticField_NonStaticField_ThrowsIllegalArgumentException() throws NoSuchFieldException { [EOL] class TestClass { [EOL] @SuppressWarnings("unused") [EOL] public int nonStaticField = 0; [EOL] } [EOL] Field nonStaticField = TestClass.class.getDeclaredField("nonStaticField"); [EOL] try { [EOL] ReflectionUtils.readStaticField(nonStaticField, true); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("is not static")); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Expected IllegalArgumentException, not IllegalAccessException"); [EOL] } [EOL] }
public void testReadStaticField_StaticField_ReturnsValue() throws NoSuchFieldException, IllegalAccessException { [EOL] class TestClass { [EOL] public static int staticField = 123; [EOL] } [EOL] Field staticField = TestClass.class.getDeclaredField("staticField"); [EOL] Object result = ReflectionUtils.readStaticField(staticField, true); [EOL] assertEquals(123, result); [EOL] }
public void testReadFieldWithNullField() { [EOL] try { [EOL] FieldUtils.readField(null, new Object(), true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithInaccessibleFieldForcedAccess() throws NoSuchFieldException { [EOL] class TestClass { [EOL] private String privateField = "privateValue"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field privateField = TestClass.class.getDeclaredField("privateField"); [EOL] try { [EOL] Object fieldValue = FieldUtils.readField(privateField, testInstance, true); [EOL] assertEquals("privateValue", fieldValue); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithAccessibleFieldNoForceAccess() throws NoSuchFieldException { [EOL] class TestClass { [EOL] public String publicField = "publicValue"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field publicField = TestClass.class.getField("publicField"); [EOL] try { [EOL] Object fieldValue = FieldUtils.readField(publicField, testInstance, false); [EOL] assertEquals("publicValue", fieldValue); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testWriteStaticField() throws NoSuchFieldException, IllegalAccessException { [EOL] Field field = SomeClass.class.getDeclaredField("STATIC_FIELD_NAME"); [EOL] Object value = "new value"; [EOL] FieldUtils.writeStaticField(field, value); [EOL] assertEquals("new value", SomeClass.STATIC_FIELD_NAME); [EOL] }
public void testWriteStaticField_NullField_ThrowsIllegalArgumentException() { [EOL] try { [EOL] FieldUtils.writeStaticField(null, "value", true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testWriteStaticField_NonStaticField_ThrowsIllegalArgumentException() { [EOL] try { [EOL] Field field = String.class.getDeclaredField("value"); [EOL] FieldUtils.writeStaticField(field, "newValue", true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("is not static")); [EOL] } [EOL] } [EOL] public void testWriteStaticField_ValidField_SetsValue() throws NoSuchFieldException, IllegalAccessException { [EOL] Field field = System.class.getField("out"); [EOL] PrintStream originalOut = System.out; [EOL] try { [EOL] FieldUtils.writeStaticField(field, null, true); [EOL] assertNull(System.out); [EOL] } finally { [EOL] FieldUtils.writeStaticField(field, originalOut, true); [EOL] } [EOL] }
public void testWriteStaticField() throws IllegalAccessException { [EOL] Class<?> cls = SomeClassWithStaticFields.class; [EOL] String fieldName = "staticFieldName"; [EOL] Object newValue = "new value"; [EOL] FieldUtils.writeStaticField(cls, fieldName, newValue); [EOL] assertEquals("new value", SomeClassWithStaticFields.staticFieldName); [EOL] }
public void testWriteStaticFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.writeStaticField(null, "fieldName", "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should have thrown IllegalArgumentException instead of IllegalAccessException"); [EOL] } [EOL] }
public void testWriteStaticFieldWithEmptyFieldName() { [EOL] try { [EOL] FieldUtils.writeStaticField(SomeClassWithStaticFields.class, "", "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should have thrown IllegalArgumentException instead of IllegalAccessException"); [EOL] } [EOL] }
public void testWriteStaticFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.writeStaticField(SomeClassWithStaticFields.class, null, "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should have thrown IllegalArgumentException instead of IllegalAccessException"); [EOL] } [EOL] }
public void testWriteStaticFieldWithExistingFieldAndForceAccess() throws IllegalAccessException { [EOL] final String fieldName = "existingField"; [EOL] final String newValue = "newValue"; [EOL] ClassWithStaticField.writeStaticField(ClassWithStaticField.class, fieldName, newValue, true); [EOL] assertEquals("Field should be updated to new value", newValue, ClassWithStaticField.existingField); [EOL] } [EOL] public void testWriteStaticFieldWithNonExistingField() { [EOL] final String fieldName = "nonExistingField"; [EOL] final String newValue = "newValue"; [EOL] try { [EOL] ClassWithStaticField.writeStaticField(ClassWithStaticField.class, fieldName, newValue, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Exception message should indicate the missing field", [EOL] "Cannot locate field " + fieldName + " on " + ClassWithStaticField.class, e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for non-existing fields"); [EOL] } [EOL] }
public void testWriteStaticFieldWithoutForceAccessAndInaccessibleField() { [EOL] final String fieldName = "privateField"; [EOL] final String newValue = "newValue"; [EOL] try { [EOL] ClassWithStaticField.writeStaticField(ClassWithStaticField.class, fieldName, newValue, false); [EOL] fail("Should have thrown IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testWriteFieldWithNullField() { [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] FieldUtils.writeField(null, new Object(), new Object(), false); [EOL] }); [EOL] assertEquals("The field must not be null", exception.getMessage()); [EOL] }
public void testWriteFieldWithInaccessibleFieldForcedAccess() throws NoSuchFieldException, IllegalAccessException { [EOL] class TestClass { [EOL] private int field; [EOL] } [EOL] TestClass target = new TestClass(); [EOL] Field field = TestClass.class.getDeclaredField("field"); [EOL] FieldUtils.writeField(field, target, 123, true); [EOL] assertEquals(123, target.field); [EOL] }
public void testWriteFieldWithAccessibleFieldNoForceAccess() throws NoSuchFieldException, IllegalAccessException { [EOL] class TestClass { [EOL] public int field; [EOL] } [EOL] TestClass target = new TestClass(); [EOL] Field field = TestClass.class.getField("field"); [EOL] FieldUtils.writeField(field, target, 123, false); [EOL] assertEquals(123, target.field); [EOL] }
public void testAddWithNullString() { [EOL] add(null); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithEmptyString() { [EOL] add(""); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithSingleChar() { [EOL] add("a"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.is('a'))); [EOL] }
public void testAddWithSimpleRange() { [EOL] add("a-c"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] }
public void testAddWithNegatedChar() { [EOL] add("^a"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isNot('a'))); [EOL] }
public void testAddWithNegatedRange() { [EOL] add("^a-c"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isNotIn('a', 'c'))); [EOL] }
public void testAddWithMultipleRanges() { [EOL] add("a-ce-gi-k"); [EOL] assertEquals(3, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isIn('e', 'g'))); [EOL] assertTrue(set.contains(CharRange.isIn('i', 'k'))); [EOL] }
public void testAddWithMixedRangesAndChars() { [EOL] add("a-c^eg"); [EOL] assertEquals(3, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isNot('e'))); [EOL] assertTrue(set.contains(CharRange.is('g'))); [EOL] }
public void testAddWithComplexString() { [EOL] add("a-c^e-gi-k^m-oq"); [EOL] assertEquals(6, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isNot('e'))); [EOL] assertTrue(set.contains(CharRange.isIn('g', 'i'))); [EOL] assertTrue(set.contains(CharRange.isIn('k', 'm'))); [EOL] assertTrue(set.contains(CharRange.isNot('o'))); [EOL] assertTrue(set.contains(CharRange.is('q'))); [EOL] }
public void testGetCharRanges_EmptySet() { [EOL] CharSet charSet = CharSet.getInstance(); [EOL] CharRange[] charRanges = charSet.getCharRanges(); [EOL] assertNotNull(charRanges); [EOL] assertEquals(0, charRanges.length); [EOL] }
public void testGetCharRanges_NonEmptySet() { [EOL] CharSet charSet = CharSet.getInstance("a-c"); [EOL] CharRange[] charRanges = charSet.getCharRanges(); [EOL] assertNotNull(charRanges); [EOL] assertEquals(1, charRanges.length); [EOL] assertEquals(new CharRange('a', 'c'), charRanges[0]); [EOL] }
public void testEquals_SameObject() { [EOL] CharSet cs = CharSet.getInstance("a"); [EOL] assertTrue(cs.equals(cs)); [EOL] }
public void testEquals_DifferentType() { [EOL] CharSet cs = CharSet.getInstance("a"); [EOL] assertFalse(cs.equals(new Object())); [EOL] }
public void testEquals_EqualCharSet() { [EOL] CharSet cs1 = CharSet.getInstance("a"); [EOL] CharSet cs2 = CharSet.getInstance("a"); [EOL] assertTrue(cs1.equals(cs2)); [EOL] }
public void testEquals_NotEqualCharSet() { [EOL] CharSet cs1 = CharSet.getInstance("a"); [EOL] CharSet cs2 = CharSet.getInstance("b"); [EOL] assertFalse(cs1.equals(cs2)); [EOL] }
public void testSetValue_NewValue_ReturnsOldValue() { [EOL] MutablePair<Integer, String> mutablePair = new MutablePair<>(1, "initial"); [EOL] String oldValue = mutablePair.getRight(); [EOL] String newValue = "updated"; [EOL] String result = mutablePair.setValue(newValue); [EOL] assertEquals("initial", result); [EOL] assertEquals("updated", mutablePair.getRight()); [EOL] }
public void testSetValue_NullValue_ReturnsOldValue() { [EOL] MutablePair<Integer, String> mutablePair = new MutablePair<>(1, "initial"); [EOL] String oldValue = mutablePair.getRight(); [EOL] String result = mutablePair.setValue(null); [EOL] assertEquals("initial", result); [EOL] assertNull(mutablePair.getRight()); [EOL] }
public void testOf_withNonNullValues() { [EOL] String left = "leftValue"; [EOL] String right = "rightValue"; [EOL] ImmutablePair<String, String> result = ImmutablePair.of(left, right); [EOL] assertNotNull(result); [EOL] assertEquals(left, result.getLeft()); [EOL] assertEquals(right, result.getRight()); [EOL] }
public void testOf_withNullValues() { [EOL] ImmutablePair<Object, Object> result = ImmutablePair.of(null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLeft()); [EOL] assertNull(result.getRight()); [EOL] }
public void testImmutablePairWithNonNullValues() { [EOL] String left = "left"; [EOL] String right = "right"; [EOL] ImmutablePair<String, String> pair = new ImmutablePair<>(left, right); [EOL] assertEquals(left, pair.left); [EOL] assertEquals(right, pair.right); [EOL] }
public void testImmutablePairWithNullValues() { [EOL] ImmutablePair<Object, Object> pair = new ImmutablePair<>(null, null); [EOL] assertNull(pair.left); [EOL] assertNull(pair.right); [EOL] }
public void testGetLeft() { [EOL] Pair<Integer, String> pair = Pair.of(1, "test"); [EOL] Integer left = pair.getLeft(); [EOL] assertEquals(Integer.valueOf(1), left); [EOL] }
public void testGetRight_ShouldReturnRightValue() { [EOL] Pair<Integer, String> pair = Pair.of(1, "RightValue"); [EOL] String result = pair.getRight(); [EOL] assertEquals("RightValue", result); [EOL] }
public void testIsSupportedWithNullName() { [EOL] boolean result = isSupported(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithUnsupportedName() { [EOL] boolean result = isSupported("unsupported_charset_name"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithSupportedName() { [EOL] boolean result = isSupported("UTF-8"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSupportedWithIllegalCharsetName() { [EOL] boolean result = isSupported("Illegal*Charset//Name"); [EOL] assertFalse(result); [EOL] }
public void testHashCodeBuilderValidInput() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(3, 11); [EOL] assertNotNull(hcb); [EOL] assertEquals(3, hcb.toHashCode()); [EOL] }
public void testHashCodeBuilderInitialValueZero() { [EOL] try { [EOL] new HashCodeBuilder(0, 11); [EOL] fail("Should have thrown IllegalArgumentException for initial value zero"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderInitialValueEven() { [EOL] try { [EOL] new HashCodeBuilder(2, 11); [EOL] fail("Should have thrown IllegalArgumentException for even initial value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderMultiplierValueZero() { [EOL] try { [EOL] new HashCodeBuilder(3, 0); [EOL] fail("Should have thrown IllegalArgumentException for multiplier value zero"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderMultiplierValueEven() { [EOL] try { [EOL] new HashCodeBuilder(3, 2); [EOL] fail("Should have thrown IllegalArgumentException for even multiplier value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testAppendBooleanTrue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(true); [EOL] assertEquals(17 * 37, builder.hashCode()); [EOL] }
public void testAppendBooleanFalse() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(false); [EOL] assertEquals(17 * 37 + 1, builder.hashCode()); [EOL] }
public void testAppendWithNullBooleanArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] boolean[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithEmptyBooleanArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] boolean[] array = new boolean[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithNonEmptyBooleanArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] boolean[] array = new boolean[]{true, false, true}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithNullArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17 * 37, result.toHashCode()); [EOL] }
public void testAppendWithEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = new double[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] int expectedHashCode = calculateExpectedHashCodeForArray(array, 17, 37); [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] } [EOL] private int calculateExpectedHashCodeForArray(double[] array, int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) { [EOL] int total = initialNonZeroOddNumber; [EOL] for (double element : array) { [EOL] long bits = Double.doubleToLongBits(element); [EOL] total = total * multiplierNonZeroOddNumber + (int)(bits ^ (bits >>> 32)); [EOL] } [EOL] return total; [EOL] }
public void testAppendFloatZero() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(0.0f); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(0.0f); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendFloatPositive() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(1.0f); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(1.0f); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendFloatNegative() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(-1.0f); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(-1.0f); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendFloatMaxValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Float.MAX_VALUE); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(Float.MAX_VALUE); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendFloatMinValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Float.MIN_VALUE); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(Float.MIN_VALUE); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendFloatNaN() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Float.NaN); [EOL] int expectedValue = 17 * 37 + Float.floatToIntBits(Float.NaN); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendWithNullArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] long[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17 * 37, result.toHashCode()); [EOL] }
public void testAppendWithEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] long[] array = new long[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] int expectedHashCode = // calculate expected hash code based on the values 1L, 2L, 3L [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] }
public void testAppendWithNull() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) null); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithLongArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithIntArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = {'a', 'b', 'c'}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithByteArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithDoubleArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithFloatArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithBooleanArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithObjectArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object[] array = {new Object(), new Object(), new Object()}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithNonArrayObject() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(obj); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testBuildReturnsCorrectInteger() { [EOL] HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(17, 37); [EOL] int expectedHashCode = hashCodeBuilder.toHashCode(); [EOL] Integer expectedInteger = Integer.valueOf(expectedHashCode); [EOL] Integer result = hashCodeBuilder.build(); [EOL] assertEquals(expectedInteger, result); [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(); [EOL] int expected = instance.toHashCode(); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSerialize_NullOutputStream_ThrowsIllegalArgumentException() { [EOL] Serializable obj = "test"; [EOL] OutputStream outputStream = null; [EOL] try { [EOL] SerializationUtils.serialize(obj, outputStream); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The OutputStream must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testSerialize_ValidOutputStream_SerializesObject() throws IOException { [EOL] Serializable obj = "test"; [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] SerializationUtils.serialize(obj, outputStream); [EOL] ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); [EOL] ObjectInputStream in = new ObjectInputStream(inputStream); [EOL] Object deserializedObj = in.readObject(); [EOL] assertEquals(obj, deserializedObj); [EOL] }
public void testSerialize_IOExceptionOnWrite_ThrowsSerializationException() { [EOL] Serializable obj = "test"; [EOL] OutputStream outputStream = new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] throw new IOException("Test IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] SerializationUtils.serialize(obj, outputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertNotNull(ex.getCause()); [EOL] assertEquals(IOException.class, ex.getCause().getClass()); [EOL] assertEquals("Test IOException", ex.getCause().getMessage()); [EOL] } [EOL] }
public void testSerialize_withValidObject() throws IOException { [EOL] Serializable obj = "Test String"; [EOL] byte[] serializedObject = YourClass.serialize(obj); [EOL] assertNotNull(serializedObject); [EOL] assertTrue(serializedObject.length > 0); [EOL] }
public void testSerialize_withNullObject() { [EOL] Serializable obj = null; [EOL] try { [EOL] YourClass.serialize(obj); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The object must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithNullInputStream() { [EOL] try { [EOL] SerializationUtils.deserialize(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The InputStream must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testDeserializeWithValidInputStream() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(byteArrayInputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenReturn("testString"); [EOL] String result = SerializationUtils.deserialize(byteArrayInputStream); [EOL] assertEquals("testString", result); [EOL] } [EOL] public void testDeserializeWithClassCastException() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(byteArrayInputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassCastException()); [EOL] try { [EOL] SerializationUtils.deserialize(byteArrayInputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassCastException); [EOL] } [EOL] } [EOL] public void testDeserializeWithClassNotFoundException() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(byteArrayInputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassNotFoundException()); [EOL] try { [EOL] SerializationUtils.deserialize(byteArrayInputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassNotFoundException); [EOL] } [EOL] } [EOL] public void testDeserializeWithIOException() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(byteArrayInputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenThrow(new IOException()); [EOL] try { [EOL] SerializationUtils.deserialize(byteArrayInputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof IOException); [EOL] } [EOL] } [EOL] public void testDeserializeWithIOExceptionOnClose() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(byteArrayInputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenReturn("testString"); [EOL] doThrow(new IOException()).when(objectInputStream).close(); [EOL] String result = SerializationUtils.deserialize(byteArrayInputStream); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeWithNullInput() { [EOL] try { [EOL] SerializationUtils.deserialize(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The byte[] must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testDeserializeWithValidInput() throws IOException, ClassNotFoundException { [EOL] String testString = "Test String"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] oos.writeObject(testString); [EOL] oos.close(); [EOL] byte[] objectData = baos.toByteArray(); [EOL] Object result = SerializationUtils.deserialize(objectData); [EOL] assertEquals(testString, result); [EOL] }
protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL] final String name = desc.getName(); [EOL] try { [EOL] return Class.forName(name, false, classLoader); [EOL] } catch (final ClassNotFoundException ex) { [EOL] try { [EOL] return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL] } catch (final ClassNotFoundException cnfe) { [EOL] final Class<?> cls = primitiveTypes.get(name); [EOL] if (cls != null) { [EOL] return cls; [EOL] } else { [EOL] throw cnfe; [EOL] } [EOL] } [EOL] } [EOL] }
public void testToCharWithNullCharacter() { [EOL] char expected = 'a'; [EOL] char actual = StringUtils.toChar(null, expected); [EOL] assertEquals(expected, actual); [EOL] }
public void testToCharWithNonNullCharacter() { [EOL] Character input = 'b'; [EOL] char expected = 'b'; [EOL] char actual = StringUtils.toChar(input, 'a'); [EOL] assertEquals(expected, actual); [EOL] }
public void testToIntValue_ValidNumericChar() { [EOL] char ch = '5'; [EOL] int result = CharUtils.toIntValue(ch); [EOL] assertEquals(5, result); [EOL] }
public void testToIntValue_InvalidNumericChar() { [EOL] try { [EOL] char ch = 'a'; [EOL] CharUtils.toIntValue(ch); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The character a is not in the range '0' - '9'", e.getMessage()); [EOL] } [EOL] }
public void testToIntValue_WithNonNullCharacter() { [EOL] char testChar = 'A'; [EOL] int expected = (int) testChar; [EOL] int actual = StringUtils.toIntValue(testChar); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToIntValue_WithNullCharacter() { [EOL] try { [EOL] StringUtils.toIntValue(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testUnicodeEscapedWithCharLessThan16() { [EOL] char ch = 0x000F; // char value less than 0x10 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u000f", result); [EOL] } [EOL] public void testUnicodeEscapedWithCharLessThan256() { [EOL] char ch = 0x007F; // char value less than 0x100 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u007f", result); [EOL] } [EOL] public void testUnicodeEscapedWithCharLessThan4096() { [EOL] char ch = 0x0456; // char value less than 0x1000 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u0456", result); [EOL] } [EOL] public void testUnicodeEscapedWithCharGreaterThan4095() { [EOL] char ch = 0xABCD; // char value greater than 0x1000 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\uabcd", result); [EOL] }
public void testUnicodeEscapedWithNullCharacter() { [EOL] String result = StringUtils.unicodeEscaped((Character) null); [EOL] assertNull(result); [EOL] }
public void testUnicodeEscapedWithNonNullCharacter() { [EOL] char testChar = 'a'; [EOL] String expected = "\\u0061"; [EOL] String result = StringUtils.unicodeEscaped(testChar); [EOL] assertEquals(expected, result); [EOL] }
public T getMinimum() { [EOL] return minimum; [EOL] }
public void testIsAfterRange_NullRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean result = range.isAfterRange(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAfterRange_After() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(1, 4); [EOL] boolean result = range.isAfterRange(otherRange); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAfterRange_NotAfter() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(6, 15); [EOL] boolean result = range.isAfterRange(otherRange); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAfterRange_EqualRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(5, 10); [EOL] boolean result = range.isAfterRange(otherRange); [EOL] assertFalse(result); [EOL] }
public void testEquals_Reflexive() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertTrue(range.equals(range)); [EOL] }
public void testEquals_Null() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertFalse(range.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertFalse(range.equals(new Object())); [EOL] }
public void testEquals_EqualRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 5); [EOL] assertTrue(range1.equals(range2)); [EOL] }
public void testEquals_NotEqualRanges_DifferentMinimums() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(2, 5); [EOL] assertFalse(range1.equals(range2)); [EOL] }
public void testEquals_NotEqualRanges_DifferentMaximums() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 6); [EOL] assertFalse(range1.equals(range2)); [EOL] }
public void testToStringWithNullObjectAndNullStyle() { [EOL] String result = StringUtils.toString(null, null); [EOL] assertNull(result); [EOL] }
public void testToStringWithNonNullObjectAndNullStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.toString(obj, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith("java.lang.Object@")); [EOL] }
public void testToStringWithNullObjectAndNonNullStyle() { [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] String result = StringUtils.toString(null, style); [EOL] assertEquals("", result); [EOL] }
public void testToStringWithNonNullObjectAndNonNullStyle() { [EOL] Object obj = new Object(); [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] String result = StringUtils.toString(obj, style); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith("java.lang.Object@")); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] mutableLong.subtract(3); [EOL] assertEquals(2, mutableLong.value); [EOL] }
public void testSubtract_NegativeOperand() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] mutableLong.subtract(-3); [EOL] assertEquals(8, mutableLong.value); [EOL] }
public void testSubtract_ZeroOperand() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] mutableLong.subtract(0); [EOL] assertEquals(5, mutableLong.value); [EOL] }
public void testEquals_SameMutableLongValue_ShouldReturnTrue() { [EOL] MutableLong mutableLong1 = new MutableLong(5L); [EOL] MutableLong mutableLong2 = new MutableLong(5L); [EOL] boolean result = mutableLong1.equals(mutableLong2); [EOL] assert result; [EOL] }
public void testEquals_DifferentMutableLongValue_ShouldReturnFalse() { [EOL] MutableLong mutableLong1 = new MutableLong(5L); [EOL] MutableLong mutableLong2 = new MutableLong(10L); [EOL] boolean result = mutableLong1.equals(mutableLong2); [EOL] assert !result; [EOL] }
public void testEquals_NonMutableLongObject_ShouldReturnFalse() { [EOL] MutableLong mutableLong = new MutableLong(5L); [EOL] Object obj = new Object(); [EOL] boolean result = mutableLong.equals(obj); [EOL] assert !result; [EOL] }
public void testEquals_NullObject_ShouldReturnFalse() { [EOL] MutableLong mutableLong = new MutableLong(5L); [EOL] Object obj = null; [EOL] boolean result = mutableLong.equals(obj); [EOL] assert !result; [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableLong first = new MutableLong(1); [EOL] MutableLong second = new MutableLong(2); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_Equal() { [EOL] MutableLong first = new MutableLong(5); [EOL] MutableLong second = new MutableLong(5); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableLong first = new MutableLong(10); [EOL] MutableLong second = new MutableLong(5); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result > 0); [EOL] }
public void testMutableIntConstructor() { [EOL] int testValue = 10; [EOL] MutableInt mutableInt = new MutableInt(testValue); [EOL] assertEquals(testValue, mutableInt.intValue()); [EOL] }
public void testAddWithPositiveOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] Number operand = 10; [EOL] mutableInt.add(operand); [EOL] assertEquals(15, mutableInt.intValue()); [EOL] }
public void testAddWithNegativeOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] Number operand = -10; [EOL] mutableInt.add(operand); [EOL] assertEquals(-5, mutableInt.intValue()); [EOL] }
public void testAddWithZeroOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] Number operand = 0; [EOL] mutableInt.add(operand); [EOL] assertEquals(5, mutableInt.intValue()); [EOL] }
public void testToInteger() { [EOL] MyClass instance = new MyClass(123); [EOL] Integer expected = 123; [EOL] Integer result = instance.toInteger(); [EOL] assertEquals(expected, result); [EOL] }
public void testEquals_SameMutableIntObject() { [EOL] MutableInt mutableInt1 = new MutableInt(5); [EOL] assertTrue(mutableInt1.equals(mutableInt1)); [EOL] }
public void testEquals_DifferentMutableIntObject_SameValue() { [EOL] MutableInt mutableInt1 = new MutableInt(5); [EOL] MutableInt mutableInt2 = new MutableInt(5); [EOL] assertTrue(mutableInt1.equals(mutableInt2)); [EOL] }
public void testEquals_DifferentMutableIntObject_DifferentValue() { [EOL] MutableInt mutableInt1 = new MutableInt(5); [EOL] MutableInt mutableInt2 = new MutableInt(10); [EOL] assertFalse(mutableInt1.equals(mutableInt2)); [EOL] }
public void testEquals_NonMutableIntObject() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] Object obj = new Object(); [EOL] assertFalse(mutableInt.equals(obj)); [EOL] }
public void testEquals_NullObject() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] Object obj = null; [EOL] assertFalse(mutableInt.equals(obj)); [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableInt mutableInt1 = new MutableInt(1); [EOL] MutableInt mutableInt2 = new MutableInt(2); [EOL] int result = mutableInt1.compareTo(mutableInt2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_Equal() { [EOL] MutableInt mutableInt1 = new MutableInt(5); [EOL] MutableInt mutableInt2 = new MutableInt(5); [EOL] int result = mutableInt1.compareTo(mutableInt2); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_GreaterThan() { [EOL] MutableInt mutableInt1 = new MutableInt(10); [EOL] MutableInt mutableInt2 = new MutableInt(5); [EOL] int result = mutableInt1.compareTo(mutableInt2); [EOL] assertEquals(1, result); [EOL] }
public void testEquals_BothObjectsNull() { [EOL] Object object1 = null; [EOL] Object object2 = null; [EOL] boolean result = equals(object1, object2); [EOL] assertTrue(result); [EOL] }
public void testEquals_FirstObjectNull() { [EOL] Object object1 = null; [EOL] Object object2 = new Object(); [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEquals_SecondObjectNull() { [EOL] Object object1 = new Object(); [EOL] Object object2 = null; [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEquals_BothObjectsSame() { [EOL] Object object = new Object(); [EOL] boolean result = equals(object, object); [EOL] assertTrue(result); [EOL] }
public void testEquals_BothObjectsDifferent() { [EOL] Object object1 = new Object(); [EOL] Object object2 = new Object(); [EOL] boolean result = equals(object1, object2); [EOL] assertFalse(result); [EOL] }
public void testEquals_BothObjectsEqual() { [EOL] Object object1 = "test"; [EOL] Object object2 = "test"; [EOL] boolean result = equals(object1, object2); [EOL] assertTrue(result); [EOL] }
public void testIdentityToStringWithNullObject() { [EOL] String result = identityToString(null); [EOL] assertNull(result); [EOL] } [EOL] public void testIdentityToStringWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] String expected = obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)); [EOL] String result = identityToString(obj); [EOL] assertEquals(expected, result); [EOL] }
public void testIdentityToStringWithNullObject() { [EOL] StringBuilder builder = new StringBuilder(); [EOL] try { [EOL] identityToString(builder, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Cannot get the toString of a null identity", e.getMessage()); [EOL] } [EOL] }
public void testIdentityToStringWithNonNullObject() { [EOL] StringBuilder builder = new StringBuilder(); [EOL] Object obj = new Object(); [EOL] identityToString(builder, obj); [EOL] String expected = obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)); [EOL] assertEquals(expected, builder.toString()); [EOL] }
public void testMaxWithAllNullValues() { [EOL] Integer[] values = {null, null, null}; [EOL] Integer result = Lang3.max(values); [EOL] assertNull(result); [EOL] }
public void testMaxWithSomeNullValues() { [EOL] Integer[] values = {null, 1, null}; [EOL] Integer result = Lang3.max(values); [EOL] assertEquals(Integer.valueOf(1), result); [EOL] }
public void testMaxWithNoNullValues() { [EOL] Integer[] values = {1, 3, 2}; [EOL] Integer result = Lang3.max(values); [EOL] assertEquals(Integer.valueOf(3), result); [EOL] }
public void testMaxWithEmptyArray() { [EOL] Integer[] values = {}; [EOL] Integer result = Lang3.max(values); [EOL] assertNull(result); [EOL] }
public void testMaxWithSingleElement() { [EOL] Integer[] values = {1}; [EOL] Integer result = Lang3.max(values); [EOL] assertEquals(Integer.valueOf(1), result); [EOL] }
public void testMaxWithAllElementsEqual() { [EOL] Integer[] values = {2, 2, 2}; [EOL] Integer result = Lang3.max(values); [EOL] assertEquals(Integer.valueOf(2), result); [EOL] }
public void testIsTrueWithTrueExpression() { [EOL] isTrue(true, "The expression must be true", 123L); [EOL] }
public void testIsTrueWithFalseExpression() { [EOL] try { [EOL] isTrue(false, "The expression must be true: %d", 123L); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The expression must be true: 123", e.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithNullChars() { [EOL] try { [EOL] String result = StringUtils.notBlank(null, "The char sequence must not be blank", new Object[]{}); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The char sequence must not be blank", e.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithBlankChars() { [EOL] try { [EOL] String result = StringUtils.notBlank(" ", "The char sequence must not be blank", new Object[]{}); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The char sequence must not be blank", e.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithNonBlankChars() { [EOL] String input = "abc"; [EOL] String result = StringUtils.notBlank(input, "The char sequence must not be blank", new Object[]{}); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testInclusiveBetween_WithinBounds() { [EOL] inclusiveBetween(1, 5, 3, "Value out of bounds: %s", 3); [EOL] } [EOL] public void testInclusiveBetween_AtStart() { [EOL] inclusiveBetween(1, 5, 1, "Value out of bounds: %s", 1); [EOL] } [EOL] public void testInclusiveBetween_AtEnd() { [EOL] inclusiveBetween(1, 5, 5, "Value out of bounds: %s", 5); [EOL] } [EOL] public void testInclusiveBetween_BelowLowerBound() { [EOL] try { [EOL] inclusiveBetween(1, 5, 0, "Value out of bounds: %s", 0); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value out of bounds: 0", e.getMessage()); [EOL] } [EOL] } [EOL] public void testInclusiveBetween_AboveUpperBound() { [EOL] try { [EOL] inclusiveBetween(1, 5, 6, "Value out of bounds: %s", 6); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value out of bounds: 6", e.getMessage()); [EOL] } [EOL] }

public void testExclusiveBetween_WithinRange() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 3; [EOL] String message = "Value must be between %s and %s"; [EOL] Validate.exclusiveBetween(start, end, value, message, start, end); [EOL] }
public void testExclusiveBetween_EqualToStart() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 1; [EOL] String message = "Value must be between %s and %s"; [EOL] try { [EOL] Validate.exclusiveBetween(start, end, value, message, start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value must be between 1 and 5", e.getMessage()); [EOL] } [EOL] }
public void testExclusiveBetween_EqualToEnd() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 5; [EOL] String message = "Value must be between %s and %s"; [EOL] try { [EOL] Validate.exclusiveBetween(start, end, value, message, start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value must be between 1 and 5", e.getMessage()); [EOL] } [EOL] }
public void testExclusiveBetween_BelowRange() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 0; [EOL] String message = "Value must be between %s and %s"; [EOL] try { [EOL] Validate.exclusiveBetween(start, end, value, message, start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value must be between 1 and 5", e.getMessage()); [EOL] } [EOL] }
public void testExclusiveBetween_AboveRange() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 6; [EOL] String message = "Value must be between %s and %s"; [EOL] try { [EOL] Validate.exclusiveBetween(start, end, value, message, start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Value must be between 1 and 5", e.getMessage()); [EOL] } [EOL] }
public void testToString_whenValueIsNotNull_returnsStringValue() { [EOL] MyClass instance = new MyClass(); [EOL] instance.value = "TestValue"; // Set the value to a non-null String [EOL] String result = instance.toString(); [EOL] assertEquals("TestValue", result); [EOL] } [EOL] public void testToString_whenValueIsNull_returnsNullString() { [EOL] MyClass instance = new MyClass(); [EOL] instance.value = null; // Set the value to null [EOL] String result = instance.toString(); [EOL] assertEquals("null", result); [EOL] }
public void testDurationFormatUtilsConstructor() { [EOL] new DurationFormatUtils(); [EOL] }
public void testContainsAnyWithEmptyStringAndEmptySet() { [EOL] boolean result = StringUtils.containsAny("", (String[]) null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithNonEmptyStringAndEmptySet() { [EOL] boolean result = StringUtils.containsAny("abc", (String[]) null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithEmptyStringAndNonEmptySet() { [EOL] boolean result = StringUtils.containsAny("", "a", "b"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithNonEmptyStringAndNonEmptySetNoMatch() { [EOL] boolean result = StringUtils.containsAny("abc", "x", "y"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithNonEmptyStringAndNonEmptySetWithMatch() { [EOL] boolean result = StringUtils.containsAny("abc", "b", "c"); [EOL] assertTrue(result); [EOL] }
public void testGetCause_ThrowableIsNull() { [EOL] Throwable result = ExceptionUtils.getCause(null, null); [EOL] assertNull(result); [EOL] }
public void testGetCause_MethodNamesIsNull() { [EOL] Throwable throwable = new RuntimeException(); [EOL] Throwable result = ExceptionUtils.getCause(throwable, null); [EOL] assertNotNull(result); [EOL] }
public void testGetCause_MethodNamesIsEmpty() { [EOL] Throwable throwable = new RuntimeException(); [EOL] String[] methodNames = {}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); [EOL] }
public void testGetCause_MethodNamesHasNullElement() { [EOL] Throwable throwable = new RuntimeException(); [EOL] String[] methodNames = {null}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); [EOL] }
public void testGetCause_ValidMethodName() { [EOL] Throwable throwable = new Throwable(new RuntimeException()); [EOL] String[] methodNames = {"getCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof RuntimeException); [EOL] }
public void testGetCause_InvalidMethodName() { [EOL] Throwable throwable = new Throwable(new RuntimeException()); [EOL] String[] methodNames = {"invalidMethodName"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz) { [EOL] return indexOf(throwable, clazz, 0, false); [EOL] } [EOL] public ExceptionUtils() { } [EOL] public static String[] getDefaultCauseMethodNames() { [EOL] } [EOL] public static Throwable getCause(final Throwable throwable) { [EOL] } [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL] } [EOL] public static Throwable getRootCause(final Throwable throwable) { [EOL] } [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) { [EOL] } [EOL] public static int getThrowableCount(final Throwable throwable) { [EOL] } [EOL] public static Throwable[] getThrowables(final Throwable throwable) { [EOL] } [EOL] public static List<Throwable> getThrowableList(Throwable throwable) { [EOL] } [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz) { [EOL] return indexOf(throwable, clazz, 0, false); [EOL] } [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL] } [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type) { [EOL] } [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL] } [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL] } [EOL] public static void printRootCauseStackTrace(final Throwable throwable) { [EOL] } [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream) { [EOL] } [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) { [EOL] } [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL] } [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL] } [EOL] public static String getStackTrace(final Throwable throwable) { [EOL] } [EOL] public static String[] getStackFrames(final Throwable throwable) { [EOL] } [EOL] static String[] getStackFrames(final String stackTrace) { [EOL] } [EOL] static List<String> getStackFrameList(final Throwable t) { [EOL] } [EOL] public static String getMessage(final Throwable th) { [EOL] } [EOL] public static String getRootCauseMessage(final Throwable th) { [EOL] } [EOL] String WRAPPED_MARKER = Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES = Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testIndexOfThrowable_ThrowableClass() { [EOL] Throwable throwable = new NullPointerException("Test Exception"); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, NullPointerException.class); [EOL] assertEquals("Index should be 0 for the throwable itself", 0, index); [EOL] }
public void testIndexOfThrowable_ThrowableClassFromIndex() { [EOL] Throwable throwable = new NullPointerException("Test Exception"); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, NullPointerException.class, 0); [EOL] assertEquals("Index should be 0 when fromIndex is 0", 0, index); [EOL] }
public void testIndexOfThrowable_ThrowableClassFromIndex_Negative() { [EOL] Throwable throwable = new NullPointerException("Test Exception"); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, NullPointerException.class, -1); [EOL] assertEquals("Index should be -1 when fromIndex is negative", -1, index); [EOL] }
public void testIndexOfThrowable_ThrowableClassFromIndex_NoMatch() { [EOL] Throwable throwable = new NullPointerException("Test Exception"); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, IllegalArgumentException.class, 0); [EOL] assertEquals("Index should be -1 when there is no match", -1, index); [EOL] }
public void testIndexOfThrowable_ThrowableClassFromIndex_Subclass() { [EOL] Throwable throwable = new RuntimeException(new IllegalArgumentException("Cause")); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, Exception.class, 0); [EOL] assertEquals("Index should be 1 for the cause", 1, index); [EOL] }
public void testIndexOfThrowable_ThrowableClassFromIndex_ValidFromIndex() { [EOL] Throwable throwable = new RuntimeException(new IllegalArgumentException("Cause")); [EOL] int index = ExceptionUtils.indexOfThrowable(throwable, RuntimeException.class, 1); [EOL] assertEquals("Index should be -1 when fromIndex skips the match", -1, index); [EOL] }
public void testIndexOfThrowable_NullThrowable() { [EOL] int index = ExceptionUtils.indexOf(null, Throwable.class, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_NullType() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, null, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_NegativeFromIndex() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Throwable.class, -1, false); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_FromIndexOutOfBounds() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Throwable.class, 100, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_SubclassTrue() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Exception.class, 0, true); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_SubclassFalse() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, RuntimeException.class, 0, false); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_SubclassFalse_NotFound() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Exception.class, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_SubclassTrue_NotFound() { [EOL] Throwable throwable = new IOException(); [EOL] int index = ExceptionUtils.indexOf(throwable, RuntimeException.class, 0, true); [EOL] assertEquals(-1, index); [EOL] }
public void testIncrement_InitialValueZero() { [EOL] MutableInt mutableInt = new MutableInt(); [EOL] mutableInt.increment(); [EOL] assertEquals(1, mutableInt.intValue()); [EOL] }
public void testIncrement_InitialValueNonZero() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.increment(); [EOL] assertEquals(6, mutableInt.intValue()); [EOL] }
public void testSubtractWithPositiveOperand() { [EOL] MutableShort instance = new MutableShort((short) 10); [EOL] instance.subtract(new Short((short) 5)); [EOL] assertEquals((short) 5, instance.shortValue()); [EOL] } [EOL] public void testSubtractWithNegativeOperand() { [EOL] MutableShort instance = new MutableShort((short) 10); [EOL] instance.subtract(new Short((short) -5)); [EOL] assertEquals((short) 15, instance.shortValue()); [EOL] } [EOL] public void testSubtractWithZeroOperand() { [EOL] MutableShort instance = new MutableShort((short) 10); [EOL] instance.subtract(new Short((short) 0)); [EOL] assertEquals((short) 10, instance.shortValue()); [EOL] } [EOL] public void testSubtractWithNullOperand() { [EOL] MutableShort instance = new MutableShort((short) 10); [EOL] try { [EOL] instance.subtract(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testCompareTo_Smaller() { [EOL] MutableShort first = new MutableShort((short) 10); [EOL] MutableShort second = new MutableShort((short) 20); [EOL] int result = first.compareTo(second); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_Equal() { [EOL] MutableShort first = new MutableShort((short) 10); [EOL] MutableShort second = new MutableShort((short) 10); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_Greater() { [EOL] MutableShort first = new MutableShort((short) 20); [EOL] MutableShort second = new MutableShort((short) 10); [EOL] int result = first.compareTo(second); [EOL] assertEquals(1, result); [EOL] }
public void testReflectionCompareWithNulls() { [EOL] int result = ObjectUtils.reflectionCompare(null, null, true); [EOL] assertEquals(0, result); [EOL] }
public void testReflectionCompareWithLeftNull() { [EOL] int result = ObjectUtils.reflectionCompare(null, new Object(), true); [EOL] assertTrue(result < 0); [EOL] }
public void testReflectionCompareWithRightNull() { [EOL] int result = ObjectUtils.reflectionCompare(new Object(), null, true); [EOL] assertTrue(result > 0); [EOL] }
public void testReflectionCompareWithNonTransients() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] int result = ObjectUtils.reflectionCompare(lhs, rhs, false); [EOL] int expected = Integer.compare(System.identityHashCode(lhs), System.identityHashCode(rhs)); [EOL] assertEquals(expected, result); [EOL] }
public void testReflectionCompare_BothObjectsNull_ThrowsNullPointerException() { [EOL] try { [EOL] int result = reflectionCompare(null, null, true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_SameObject_ReturnsZero() { [EOL] Object obj = new Object(); [EOL] int result = reflectionCompare(obj, obj, true, null); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testReflectionCompare_FirstObjectNull_ThrowsNullPointerException() { [EOL] try { [EOL] int result = reflectionCompare(null, new Object(), true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_SecondObjectNull_ThrowsNullPointerException() { [EOL] try { [EOL] int result = reflectionCompare(new Object(), null, true, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_ObjectsNotSameClass_ThrowsClassCastException() { [EOL] try { [EOL] int result = reflectionCompare(new Object(), new String(), true, null); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testReflectionCompare_ObjectsSameClass_ReturnsNonZero() { [EOL] Object lhs = new String("lhs"); [EOL] Object rhs = new String("rhs"); [EOL] int result = reflectionCompare(lhs, rhs, true, null); [EOL] assertNotEquals(0, result); [EOL] } [EOL] public void testReflectionCompare_ObjectsSameClassWithExcludeFields_ReturnsNonZero() { [EOL] Object lhs = new String("lhs"); [EOL] Object rhs = new String("rhs"); [EOL] int result = reflectionCompare(lhs, rhs, true, null, "hashCode"); [EOL] assertNotEquals(0, result); [EOL] } [EOL] public void testReflectionCompare_ObjectsSameClassCompareUntilSuperClass_ReturnsNonZero() { [EOL] Object lhs = new Integer(1); [EOL] Object rhs = new Integer(2); [EOL] int result = reflectionCompare(lhs, rhs, true, Number.class); [EOL] assertNotEquals(0, result); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, null, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LeftObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, new Object(), null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_RightObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(new Object(), null, null); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppend_BothObjectsSame() { [EOL] Object obj = new Object(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(obj, obj, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_WithComparator() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] Comparator<Object> comparator = Comparator.naturalOrder(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(comparator.compare(lhs, rhs), builder.toComparison()); [EOL] }
public void testAppend_WithoutComparator() { [EOL] Comparable<Object> lhs = "a"; [EOL] Comparable<Object> rhs = "b"; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(lhs.compareTo(rhs), builder.toComparison()); [EOL] }
public void testAppend_Arrays() { [EOL] long[] lhsArray = {1L, 2L}; [EOL] long[] rhsArray = {1L, 3L}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_ArraysDifferentTypes() { [EOL] int[] lhsArray = {1, 2}; [EOL] int[] rhsArray = {1, 3}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_booleanEqual() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(true, true); [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] }
public void testAppend_booleanNotEqual_lhsFalse() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(false, true); [EOL] assertEquals(-1, compareToBuilder.toComparison()); [EOL] }
public void testAppend_booleanNotEqual_lhsTrue() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(true, false); [EOL] assertEquals(1, compareToBuilder.toComparison()); [EOL] }
public void testAppend_booleanWithNonZeroComparison() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(true, false); [EOL] compareToBuilder.append(true, true); // This should not affect the comparison since it's already non-zero [EOL] assertEquals(1, compareToBuilder.toComparison()); [EOL] }
public void testAppendBooleanArraysWithEqualArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysFirstArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = null; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysSecondArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysDifferentLengths() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysDifferentContents() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendBooleanArraysSameInstance() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] builder.append(array, array); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysComparisonAlreadySet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {true, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testIsBlank_NullInput() { [EOL] assertTrue(StringUtils.isBlank(null)); [EOL] }
public void testIsBlank_EmptyString() { [EOL] assertTrue(StringUtils.isBlank("")); [EOL] }
public void testIsBlank_OnlyWhitespaces() { [EOL] assertTrue(StringUtils.isBlank("   ")); [EOL] }
public void testIsBlank_NonWhitespaceCharacter() { [EOL] assertFalse(StringUtils.isBlank("a")); [EOL] }
public void testIsBlank_WhitespaceAndNonWhitespaceCharacters() { [EOL] assertFalse(StringUtils.isBlank(" a ")); [EOL] }
public void testIsNotBlank_NullString() { [EOL] boolean result = StringUtils.isNotBlank(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotBlank_EmptyString() { [EOL] boolean result = StringUtils.isNotBlank(""); [EOL] assertFalse(result); [EOL] }
public void testIsNotBlank_WhitespaceString() { [EOL] boolean result = StringUtils.isNotBlank("   "); [EOL] assertFalse(result); [EOL] }
public void testIsNotBlank_NonEmptyString() { [EOL] boolean result = StringUtils.isNotBlank("abc"); [EOL] assertTrue(result); [EOL] }
public void testTrim_NullInput() { [EOL] String result = StringUtils.trim(null); [EOL] assertNull(result); [EOL] }
public void testTrim_EmptyString() { [EOL] String result = StringUtils.trim(""); [EOL] assertEquals("", result); [EOL] }
public void testTrim_OnlyWhitespaces() { [EOL] String result = StringUtils.trim("   "); [EOL] assertEquals("", result); [EOL] }
public void testTrim_LeadingAndTrailingWhitespaces() { [EOL] String result = StringUtils.trim("   abc   "); [EOL] assertEquals("abc", result); [EOL] }
public void testTrim_NoWhitespaces() { [EOL] String result = StringUtils.trim("abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testStrip_NullInput() { [EOL] String result = StringUtils.strip(null); [EOL] assertNull(result); [EOL] }
public void testStrip_EmptyString() { [EOL] String result = StringUtils.strip(""); [EOL] assertEquals("", result); [EOL] }
public void testStrip_OnlyWhitespaces() { [EOL] String result = StringUtils.strip("   "); [EOL] assertEquals("", result); [EOL] }
public void testStrip_NoWhitespaces() { [EOL] String result = StringUtils.strip("abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testStrip_LeadingWhitespaces() { [EOL] String result = StringUtils.strip("   abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testStrip_TrailingWhitespaces() { [EOL] String result = StringUtils.strip("abc   "); [EOL] assertEquals("abc", result); [EOL] }
public void testStrip_LeadingAndTrailingWhitespaces() { [EOL] String result = StringUtils.strip("   abc   "); [EOL] assertEquals("abc", result); [EOL] }
public void testStrip_NullInput_NoStripChars() { [EOL] String result = StringUtils.strip(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testStrip_EmptyInput_NoStripChars() { [EOL] String result = StringUtils.strip("", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStrip_WhitespaceInput_NoStripChars() { [EOL] String result = StringUtils.strip("   ", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStrip_NoStripChars() { [EOL] String result = StringUtils.strip("abc", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStrip_StripSpecificChars() { [EOL] String result = StringUtils.strip("abc", "b"); [EOL] assertEquals("ac", result); [EOL] } [EOL] public void testStrip_StripAllChars() { [EOL] String result = StringUtils.strip("abc", "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStrip_NoCharsToStrip() { [EOL] String result = StringUtils.strip("abc", ""); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStrip_InputOnlyStripChars() { [EOL] String result = StringUtils.strip("aaa", "a"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStrip_MixedInput() { [EOL] String result = StringUtils.strip("abcyx", "xyz"); [EOL] assertEquals("abc", result); [EOL] }
public void testStripStart_NullString() { [EOL] String result = StringUtils.stripStart(null, "abc"); [EOL] assertNull(result); [EOL] } [EOL] public void testStripStart_EmptyString() { [EOL] String result = StringUtils.stripStart("", "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripStart_NoStripChars() { [EOL] String result = StringUtils.stripStart("abc", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_EmptyStripChars() { [EOL] String result = StringUtils.stripStart("abc", ""); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_StripStartChars() { [EOL] String result = StringUtils.stripStart("abcabc", "ab"); [EOL] assertEquals("cabc", result); [EOL] } [EOL] public void testStripStart_NoCharsToStripped() { [EOL] String result = StringUtils.stripStart("abc", "xyz"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_AllCharsStripped() { [EOL] String result = StringUtils.stripStart("abcabc", "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripStart_WhiteSpace() { [EOL] String result = StringUtils.stripStart("   abc", null); [EOL] assertEquals("abc", result); [EOL] }
public void testStripEnd_NullString() { [EOL] String result = StringUtils.stripEnd(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testStripEnd_EmptyString() { [EOL] String result = StringUtils.stripEnd("", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripEnd_NullStripChars() { [EOL] String result = StringUtils.stripEnd("abc  ", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_EmptyStripChars() { [EOL] String result = StringUtils.stripEnd("abc  ", ""); [EOL] assertEquals("abc  ", result); [EOL] } [EOL] public void testStripEnd_RegularUse() { [EOL] String result = StringUtils.stripEnd("abcxyz", "xyz"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_NoStripCharsFound() { [EOL] String result = StringUtils.stripEnd("abcxyz", "def"); [EOL] assertEquals("abcxyz", result); [EOL] } [EOL] public void testStripEnd_AllStripped() { [EOL] String result = StringUtils.stripEnd("abcxyz", "abcxyz"); [EOL] assertEquals("", result); [EOL] }
public void testEquals_BothCharSequencesNull() { [EOL] assertTrue(StringUtils.equals(null, null)); [EOL] }
public void testEquals_FirstCharSequenceNull() { [EOL] assertFalse(StringUtils.equals(null, "abc")); [EOL] }
public void testEquals_SecondCharSequenceNull() { [EOL] assertFalse(StringUtils.equals("abc", null)); [EOL] }
public void testEquals_BothCharSequencesSameObject() { [EOL] CharSequence cs = "abc"; [EOL] assertTrue(StringUtils.equals(cs, cs)); [EOL] }
public void testEquals_BothCharSequencesEqualStrings() { [EOL] assertTrue(StringUtils.equals("abc", "abc")); [EOL] }
public void testEquals_DifferentCharSequences() { [EOL] assertFalse(StringUtils.equals("abc", "abcd")); [EOL] }
public void testEquals_BothCharSequencesCustomImplementation() { [EOL] CharSequence cs1 = new StringBuilder("abc"); [EOL] CharSequence cs2 = new StringBuilder("abc"); [EOL] assertTrue(StringUtils.equals(cs1, cs2)); [EOL] }
public void testIndexOf_NullSeq() { [EOL] int result = StringUtils.indexOf(null, 'a'); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_EmptySeq() { [EOL] int result = StringUtils.indexOf("", 'a'); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ValidSeqCharNotFound() { [EOL] int result = StringUtils.indexOf("abc", 'd'); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ValidSeqCharFound() { [EOL] int result = StringUtils.indexOf("abc", 'b'); [EOL] assertEquals(1, result); [EOL] }
public void testOrdinalIndexOf_NullStr() { [EOL] int result = StringUtils.ordinalIndexOf(null, "a", 1); [EOL] assertEquals(-1, result); [EOL] }
public void testOrdinalIndexOf_NullSearchStr() { [EOL] int result = StringUtils.ordinalIndexOf("a", null, 1); [EOL] assertEquals(-1, result); [EOL] }
public void testOrdinalIndexOf_NegativeOrdinal() { [EOL] int result = StringUtils.ordinalIndexOf("a", "a", -1); [EOL] assertEquals(-1, result); [EOL] }
public void testOrdinalIndexOf_OrdinalOne() { [EOL] int result = StringUtils.ordinalIndexOf("a", "a", 1); [EOL] assertEquals(0, result); [EOL] }
public void testOrdinalIndexOf_OrdinalGreaterThanOne() { [EOL] int result = StringUtils.ordinalIndexOf("aabaabaa", "a", 3); [EOL] assertEquals(4, result); [EOL] }
public void testOrdinalIndexOf_OrdinalNotFound() { [EOL] int result = StringUtils.ordinalIndexOf("aabaabaa", "b", 3); [EOL] assertEquals(-1, result); [EOL] }
public void testOrdinalIndexOf_nullInputs() { [EOL] final int result = ordinalIndexOf(null, null, 1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testOrdinalIndexOf_negativeOrdinal() { [EOL] final int result = ordinalIndexOf("a", "a", -1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testOrdinalIndexOf_emptySearchStr() { [EOL] final int result = ordinalIndexOf("a", "", 1, false); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testOrdinalIndexOf_emptySearchStrLastIndex() { [EOL] final int result = ordinalIndexOf("a", "", 1, true); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testOrdinalIndexOf_nonEmptyStrNotFound() { [EOL] final int result = ordinalIndexOf("a", "b", 1, false); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testOrdinalIndexOf_nonEmptyStrFound() { [EOL] final int result = ordinalIndexOf("ababab", "b", 2, false); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testOrdinalIndexOf_nonEmptyStrFoundLastIndex() { [EOL] final int result = ordinalIndexOf("ababab", "b", 2, true); [EOL] assertEquals(1, result); [EOL] }
public void testOrdinalIndexOf_nonEmptyStrFoundLastIndexReverse() { [EOL] final int result = ordinalIndexOf("ababab", "b", 3, true); [EOL] assertEquals(5, result); [EOL] }
public void testIndexOfIgnoreCase_NullStr() { [EOL] final int result = StringUtils.indexOfIgnoreCase(null, "abc", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_NullSearchStr() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_NegativeStartPos() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "a", -1); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_StartPosGreaterThanEndLimit() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "a", 4); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_EmptySearchStr() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "", 2); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_ValidCase() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abcABCabc", "A", 0); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_ValidCaseWithStartPos() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abcABCabc", "A", 3); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testIndexOfIgnoreCase_NotFound() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abcABCabc", "D", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NullSeq() { [EOL] int result = StringUtils.lastIndexOf(null, "test", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_NullSearchSeq() { [EOL] int result = StringUtils.lastIndexOf("test", null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_ValidInput() { [EOL] int result = StringUtils.lastIndexOf("test", "t", 3); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOf_ValidInputStartPosOutOfBounds() { [EOL] int result = StringUtils.lastIndexOf("test", "t", 10); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOf_EmptySearchSeq() { [EOL] int result = StringUtils.lastIndexOf("test", "", 2); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOf_SearchSeqNotFound() { [EOL] int result = StringUtils.lastIndexOf("test", "x", 2); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testContainsAny_EmptyInput() { [EOL] assertFalse(StringUtils.containsAny(null, 'a', 'b')); [EOL] assertFalse(StringUtils.containsAny("", 'a', 'b')); [EOL] assertFalse(StringUtils.containsAny("abc", (char[]) null)); [EOL] assertFalse(StringUtils.containsAny("abc", new char[0])); [EOL] }
public void testContainsAny_NoMatch() { [EOL] assertFalse(StringUtils.containsAny("abc", 'x', 'y', 'z')); [EOL] }
public void testContainsAny_Match() { [EOL] assertTrue(StringUtils.containsAny("abc", 'a', 'b', 'c')); [EOL] assertTrue(StringUtils.containsAny("abc", 'b')); [EOL] }
public void testContainsAny_SurrogatePairs() { [EOL] assertTrue(StringUtils.containsAny("a\uD83D\uDE00c", '\uD83D', '\uDE00')); [EOL] assertFalse(StringUtils.containsAny("a\uD83D\uDE00c", '\uD83D')); [EOL] assertTrue(StringUtils.containsAny("a\uD83D\uDE00c", '\uDE00')); [EOL] }
public void testContainsAnyWithNullSearchChars() { [EOL] boolean result = StringUtils.containsAny("abc", null); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithEmptySearchChars() { [EOL] boolean result = StringUtils.containsAny("abc", ""); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithNonEmptySearchChars() { [EOL] boolean result = StringUtils.containsAny("abc", "a"); [EOL] assertTrue(result); [EOL] } [EOL] public void testContainsAnyWithNoMatchingSearchChars() { [EOL] boolean result = StringUtils.containsAny("abc", "d"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithNullInput() { [EOL] boolean result = StringUtils.containsAny(null, "a"); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsAnyWithEmptyInput() { [EOL] boolean result = StringUtils.containsAny("", "a"); [EOL] assertFalse(result); [EOL] }
public void testRight_NullString() { [EOL] String result = StringUtils.right(null, 10); [EOL] assertNull(result); [EOL] }
public void testRight_NegativeLength() { [EOL] String result = StringUtils.right("abc", -1); [EOL] assertEquals("", result); [EOL] }
public void testRight_LengthGreaterThanString() { [EOL] String result = StringUtils.right("abc", 5); [EOL] assertEquals("abc", result); [EOL] }
public void testRight_LengthLessThanString() { [EOL] String result = StringUtils.right("abcdef", 3); [EOL] assertEquals("def", result); [EOL] }
public void testSplit_NullString() { [EOL] String[] result = StringUtils.split(null, ','); [EOL] assertNull(result); [EOL] }
public void testSplit_EmptyString() { [EOL] String[] result = StringUtils.split("", ','); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplit_SingleCharSeparator() { [EOL] String[] result = StringUtils.split("a,b,c", ','); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplit_NoSeparator() { [EOL] String[] result = StringUtils.split("abc", ','); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("abc", result[0]); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_NullString() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ",", 2); [EOL] assertNull(result); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_EmptyString() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens("", ",", 2); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_NoMax() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null, -1); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals("de", result[1]); [EOL] assertEquals("fg", result[2]); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_WithMax() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens("ab de fg", null, 2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals("de fg", result[1]); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_WithSeparator() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens("ab--de--fg", "--", 0); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals("de", result[1]); [EOL] assertEquals("fg", result[2]); [EOL] }
public void testSplitByWholeSeparatorPreserveAllTokens_WithSeparatorAndMax() { [EOL] String[] result = StringUtils.splitByWholeSeparatorPreserveAllTokens("ab--de--fg", "--", 2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals("de--fg", result[1]); [EOL] }
public void testSplitByWholeSeparatorWorker_nullString() { [EOL] String[] result = splitByWholeSeparatorWorker(null, ",", 2, true); [EOL] assertNull(result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptyString() { [EOL] String[] result = splitByWholeSeparatorWorker("", ",", 2, true); [EOL] assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_nullSeparator() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", null, 2, true); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptySeparator() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", "", 2, true); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_maxLimit() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", ",", 2, true); [EOL] assertArrayEquals(new String[]{"a", "b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_preserveAllTokens() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,b,c", ",", -1, true); [EOL] assertArrayEquals(new String[]{"a", "", "b", "c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_doNotPreserveAllTokens() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,b,c", ",", -1, false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_noMatchFound() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", ";", 2, true); [EOL] assertArrayEquals(new String[]{"a,b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_emptyMatch() { [EOL] String[] result = splitByWholeSeparatorWorker("a,,b,c", ",", 2, true); [EOL] assertArrayEquals(new String[]{"a", ",b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_maxLimitReached() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c", ",", 1, true); [EOL] assertArrayEquals(new String[]{"a,b,c"}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_separatorAtEnd() { [EOL] String[] result = splitByWholeSeparatorWorker("a,b,c,", ",", -1, true); [EOL] assertArrayEquals(new String[]{"a", "b", "c", ""}, result); [EOL] } [EOL] public void testSplitByWholeSeparatorWorker_separatorAtStart() { [EOL] String[] result = splitByWholeSeparatorWorker(",a,b,c", ",", -1, true); [EOL] assertArrayEquals(new String[]{"", "a", "b", "c"}, result); [EOL] }
public void testSplitPreserveAllTokens_NullInput() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(null); [EOL] assertNull(result); [EOL] }
public void testSplitPreserveAllTokens_EmptyString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(""); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitPreserveAllTokens_WhiteSpace() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(" "); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(" ", result[0]); [EOL] }
public void testSplitPreserveAllTokens_SimpleSplit() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a b c"); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_PreserveTokens() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a  b  c"); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("", result[3]); [EOL] assertEquals("c", result[4]); [EOL] }
public void testSplitWorker_nullString() { [EOL] String[] result = splitWorker(null, ',', false); [EOL] assertNull(result); [EOL] }
public void testSplitWorker_emptyString() { [EOL] String[] result = splitWorker("", ',', false); [EOL] assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL] }
public void testSplitWorker_noPreserveAllTokens_noMatch() { [EOL] String[] result = splitWorker("a b c", 'x', false); [EOL] assertArrayEquals(new String[]{"a b c"}, result); [EOL] }
public void testSplitWorker_noPreserveAllTokens_withMatch() { [EOL] String[] result = splitWorker("a,b,c", ',', false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokens_noMatch() { [EOL] String[] result = splitWorker("a b c", 'x', true); [EOL] assertArrayEquals(new String[]{"a b c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokens_withMatch() { [EOL] String[] result = splitWorker("a,b,c", ',', true); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokens_withMatchAtEnd() { [EOL] String[] result = splitWorker("a,b,c,", ',', true); [EOL] assertArrayEquals(new String[]{"a", "b", "c", ""}, result); [EOL] }
public void testSplitWorker_preserveAllTokens_withMatchAtStart() { [EOL] String[] result = splitWorker(",a,b,c", ',', true); [EOL] assertArrayEquals(new String[]{"", "a", "b", "c"}, result); [EOL] }
public void testSplitWorker_preserveAllTokens_withMultipleMatches() { [EOL] String[] result = splitWorker("a,,b,c", ',', true); [EOL] assertArrayEquals(new String[]{"a", "", "b", "c"}, result); [EOL] }
public void testSplitWorker_noPreserveAllTokens_withMultipleMatches() { [EOL] String[] result = splitWorker("a,,b,c", ',', false); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testJoinIteratorNull() { [EOL] String result = StringUtils.join(null, ','); [EOL] assertNull(result); [EOL] }
public void testJoinIteratorEmpty() { [EOL] List<String> list = Collections.emptyList(); [EOL] String result = StringUtils.join(list.iterator(), ','); [EOL] assertEquals("", result); [EOL] }
public void testJoinIteratorSingleElement() { [EOL] List<String> list = Collections.singletonList("one"); [EOL] String result = StringUtils.join(list.iterator(), ','); [EOL] assertEquals("one", result); [EOL] }
public void testJoinIteratorMultipleElements() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list.iterator(), ','); [EOL] assertEquals("one,two,three", result); [EOL] }
public void testJoinIteratorWithNullElements() { [EOL] List<String> list = Arrays.asList("one", null, "three"); [EOL] String result = StringUtils.join(list.iterator(), ','); [EOL] assertEquals("one,,three", result); [EOL] }
public void testJoinIteratorWithOnlyNullElements() { [EOL] List<String> list = Arrays.asList(null, null); [EOL] String result = StringUtils.join(list.iterator(), ','); [EOL] assertEquals(",", result); [EOL] }
public void testDeleteWhitespace_nullInput() { [EOL] String input = null; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertNull(result); [EOL] }
public void testDeleteWhitespace_emptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("", result); [EOL] }
public void testDeleteWhitespace_noWhitespace() { [EOL] String input = "ABC"; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("ABC", result); [EOL] }
public void testDeleteWhitespace_withLeadingWhitespace() { [EOL] String input = "  ABC"; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("ABC", result); [EOL] }
public void testDeleteWhitespace_withTrailingWhitespace() { [EOL] String input = "ABC  "; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("ABC", result); [EOL] }
public void testDeleteWhitespace_withMiddleWhitespace() { [EOL] String input = "A B C"; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("ABC", result); [EOL] }
public void testDeleteWhitespace_allWhitespace() { [EOL] String input = "   "; [EOL] String result = StringUtils.deleteWhitespace(input); [EOL] assertEquals("", result); [EOL] }
public void testRemoveStartIgnoreCase_NullStr() { [EOL] String result = StringUtils.removeStartIgnoreCase(null, "prefix"); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_NullRemove() { [EOL] String result = StringUtils.removeStartIgnoreCase("test", null); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_EmptyStr() { [EOL] String result = StringUtils.removeStartIgnoreCase("", "prefix"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_EmptyRemove() { [EOL] String result = StringUtils.removeStartIgnoreCase("test", ""); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_NoPrefix() { [EOL] String result = StringUtils.removeStartIgnoreCase("test", "prefix"); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_PrefixNoIgnoreCase() { [EOL] String result = StringUtils.removeStartIgnoreCase("prefixTest", "prefix"); [EOL] assertEquals("Test", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_PrefixIgnoreCase() { [EOL] String result = StringUtils.removeStartIgnoreCase("prefixTest", "Prefix"); [EOL] assertEquals("Test", result); [EOL] } [EOL] public void testRemoveStartIgnoreCase_PrefixOnlyIgnoreCase() { [EOL] String result = StringUtils.removeStartIgnoreCase("Prefix", "prefix"); [EOL] assertEquals("", result); [EOL] }
public void testRemoveEndIgnoreCase_NullStr() { [EOL] String result = StringUtils.removeEndIgnoreCase(null, "remove"); [EOL] assertNull(result); [EOL] }
public void testRemoveEndIgnoreCase_NullRemove() { [EOL] String result = StringUtils.removeEndIgnoreCase("string", null); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEndIgnoreCase_EmptyStr() { [EOL] String result = StringUtils.removeEndIgnoreCase("", "remove"); [EOL] assertEquals("", result); [EOL] }
public void testRemoveEndIgnoreCase_EmptyRemove() { [EOL] String result = StringUtils.removeEndIgnoreCase("string", ""); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEndIgnoreCase_NoMatchCase() { [EOL] String result = StringUtils.removeEndIgnoreCase("string", "noMatch"); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEndIgnoreCase_MatchCase() { [EOL] String result = StringUtils.removeEndIgnoreCase("string", "ing"); [EOL] assertEquals("str", result); [EOL] }
public void testRemoveEndIgnoreCase_MatchCaseIgnoreCase() { [EOL] String result = StringUtils.removeEndIgnoreCase("string", "ING"); [EOL] assertEquals("str", result); [EOL] }
public void testReplaceOnce_NullText() { [EOL] String result = StringUtils.replaceOnce(null, "a", "b"); [EOL] assertNull(result); [EOL] }
public void testReplaceOnce_EmptyText() { [EOL] String result = StringUtils.replaceOnce("", "a", "b"); [EOL] assertEquals("", result); [EOL] }
public void testReplaceOnce_NullSearchString() { [EOL] String result = StringUtils.replaceOnce("any", null, "b"); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceOnce_NullReplacement() { [EOL] String result = StringUtils.replaceOnce("any", "a", null); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceOnce_NonMatchingSearchString() { [EOL] String result = StringUtils.replaceOnce("any", "z", "b"); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceOnce_MatchingSearchString() { [EOL] String result = StringUtils.replaceOnce("any", "a", "b"); [EOL] assertEquals("bny", result); [EOL] }
public void testRemovePattern_NullSource() { [EOL] String result = StringUtils.removePattern(null, "regex"); [EOL] assertNull(result); [EOL] }
public void testRemovePattern_NullRegex() { [EOL] String result = StringUtils.removePattern("source", null); [EOL] assertEquals("source", result); [EOL] }
public void testRemovePattern_EmptyRegex() { [EOL] String result = StringUtils.removePattern("source", ""); [EOL] assertEquals("source", result); [EOL] }
public void testRemovePattern_ValidRegex() { [EOL] String result = StringUtils.removePattern("abcde", "bc"); [EOL] assertEquals("ade", result); [EOL] }
public void testRemovePattern_NoMatchRegex() { [EOL] String result = StringUtils.removePattern("abcde", "xyz"); [EOL] assertEquals("abcde", result); [EOL] }
public void testOverlayNullStr() { [EOL] String result = StringUtils.overlay(null, "overlay", 0, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testOverlayNullOverlay() { [EOL] String result = StringUtils.overlay("string", null, 0, 6); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testOverlayNegativeStart() { [EOL] String result = StringUtils.overlay("string", "overlay", -1, 3); [EOL] assertEquals("overlaying", result); [EOL] } [EOL] public void testOverlayStartGreaterThanLength() { [EOL] String result = StringUtils.overlay("string", "overlay", 10, 3); [EOL] assertEquals("stringoverlay", result); [EOL] } [EOL] public void testOverlayNegativeEnd() { [EOL] String result = StringUtils.overlay("string", "overlay", 1, -1); [EOL] assertEquals("soverlay", result); [EOL] } [EOL] public void testOverlayEndGreaterThanLength() { [EOL] String result = StringUtils.overlay("string", "overlay", 1, 10); [EOL] assertEquals("soverlay", result); [EOL] } [EOL] public void testOverlayStartGreaterThanEnd() { [EOL] String result = StringUtils.overlay("string", "overlay", 3, 1); [EOL] assertEquals("stoverlayring", result); [EOL] } [EOL] public void testOverlayNormal() { [EOL] String result = StringUtils.overlay("string", "overlay", 1, 3); [EOL] assertEquals("soverlaying", result); [EOL] }

public void testRightPad_NullString() { [EOL] assertNull(StringUtils.rightPad(null, 5, " ")); [EOL] } [EOL] public void testRightPad_EmptyPadString() { [EOL] assertEquals("abc  ", StringUtils.rightPad("abc", 5, "")); [EOL] } [EOL] public void testRightPad_PadStringIsSpace() { [EOL] assertEquals("abc  ", StringUtils.rightPad("abc", 5, " ")); [EOL] } [EOL] public void testRightPad_NoPaddingNeeded() { [EOL] assertEquals("abc", StringUtils.rightPad("abc", 3, " ")); [EOL] } [EOL] public void testRightPad_SingleCharPad() { [EOL] assertEquals("abcxx", StringUtils.rightPad("abc", 5, "x")); [EOL] } [EOL] public void testRightPad_PadStringEqualsPadLength() { [EOL] assertEquals("abcxx", StringUtils.rightPad("abc", 5, "xx")); [EOL] } [EOL] public void testRightPad_PadStringLessThanPadLength() { [EOL] assertEquals("abcx", StringUtils.rightPad("abc", 4, "xx")); [EOL] } [EOL] public void testRightPad_PadStringMoreThanPadLength() { [EOL] assertEquals("abcxxxxx", StringUtils.rightPad("abc", 8, "x")); [EOL] }

public void testLeftPad_NullString() { [EOL] String padded = StringUtils.leftPad(null, 5); [EOL] assertNull(padded); [EOL] }
public void testLeftPad_EmptyString() { [EOL] String padded = StringUtils.leftPad("", 5); [EOL] assertEquals("     ", padded); [EOL] }
public void testLeftPad_NoPaddingNeeded() { [EOL] String originalString = "abc"; [EOL] String padded = StringUtils.leftPad(originalString, 3); [EOL] assertEquals("abc", padded); [EOL] }
public void testLeftPad_WithPadding() { [EOL] String originalString = "abc"; [EOL] String padded = StringUtils.leftPad(originalString, 5); [EOL] assertEquals("  abc", padded); [EOL] }
public void testIsAlphanumeric_NullInput() { [EOL] boolean result = StringUtils.isAlphanumeric(null); [EOL] assertFalse(result); [EOL] }
public void testIsAlphanumeric_EmptyString() { [EOL] boolean result = StringUtils.isAlphanumeric(""); [EOL] assertFalse(result); [EOL] }
public void testIsAlphanumeric_AlphanumericString() { [EOL] boolean result = StringUtils.isAlphanumeric("abc123"); [EOL] assertTrue(result); [EOL] }
public void testIsAlphanumeric_NonAlphanumericString() { [EOL] boolean result = StringUtils.isAlphanumeric("abc123!"); [EOL] assertFalse(result); [EOL] }
public void testIsAlphanumeric_Whitespace() { [EOL] boolean result = StringUtils.isAlphanumeric(" "); [EOL] assertFalse(result); [EOL] }
public void testDefaultIfEmpty_givenEmptyString_shouldReturnDefaultString() { [EOL] String input = "";// Empty string [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfEmpty(input, defaultStr); [EOL] assertEquals("default", result); [EOL] }
public void testDefaultIfEmpty_givenNonEmptyString_shouldReturnSameString() { [EOL] String input = "non-empty";// Non-empty string [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfEmpty(input, defaultStr); [EOL] assertEquals("non-empty", result); [EOL] }
public void testDefaultIfEmpty_givenNullInput_shouldReturnDefaultString() { [EOL] String input = null;// Null input [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfEmpty(input, defaultStr); [EOL] assertEquals("default", result); [EOL] }
public void testDefaultIfEmpty_givenNullDefault_shouldReturnInputString() { [EOL] String input = "";// Empty string [EOL] String defaultStr = null;// Null default [EOL] String result = StringUtils.defaultIfEmpty(input, defaultStr); [EOL] assertNull(result); [EOL] }
public void testDefaultIfEmpty_givenBothNull_shouldReturnNull() { [EOL] String input = null;// Null input [EOL] String defaultStr = null;// Null default [EOL] String result = StringUtils.defaultIfEmpty(input, defaultStr); [EOL] assertNull(result); [EOL] }
public void testReverseDelimited_NullInput() { [EOL] String result = StringUtils.reverseDelimited(null, ','); [EOL] assertNull(result); [EOL] }
public void testReverseDelimited_EmptyString() { [EOL] String result = StringUtils.reverseDelimited("", ','); [EOL] assertEquals("", result); [EOL] }
public void testReverseDelimited_SingleCharSeparator() { [EOL] String result = StringUtils.reverseDelimited("a,b,c", ','); [EOL] assertEquals("c,b,a", result); [EOL] }
public void testReverseDelimited_DifferentSeparator() { [EOL] String result = StringUtils.reverseDelimited("a/b/c", '/'); [EOL] assertEquals("c/b/a", result); [EOL] }
public void testReverseDelimited_NoSeparator() { [EOL] String result = StringUtils.reverseDelimited("abc", ','); [EOL] assertEquals("abc", result); [EOL] }
public void testReverseDelimited_SeparatorAtEnd() { [EOL] String result = StringUtils.reverseDelimited("a,b,c,", ','); [EOL] assertEquals("c,b,a,", result); [EOL] }
public void testEndsWithIgnoreCase_BothNull() { [EOL] assertTrue(StringUtils.endsWithIgnoreCase(null, null)); [EOL] } [EOL] public void testEndsWithIgnoreCase_FirstNull() { [EOL] assertFalse(StringUtils.endsWithIgnoreCase(null, "suffix")); [EOL] } [EOL] public void testEndsWithIgnoreCase_SecondNull() { [EOL] assertFalse(StringUtils.endsWithIgnoreCase("str", null)); [EOL] } [EOL] public void testEndsWithIgnoreCase_CaseInsensitiveMatch() { [EOL] assertTrue(StringUtils.endsWithIgnoreCase("testString", "String")); [EOL] } [EOL] public void testEndsWithIgnoreCase_CaseInsensitiveNoMatch() { [EOL] assertFalse(StringUtils.endsWithIgnoreCase("testString", "stringX")); [EOL] } [EOL] public void testEndsWithIgnoreCase_EmptyStrings() { [EOL] assertTrue(StringUtils.endsWithIgnoreCase("", "")); [EOL] } [EOL] public void testEndsWithIgnoreCase_EmptySuffix() { [EOL] assertTrue(StringUtils.endsWithIgnoreCase("str", "")); [EOL] } [EOL] public void testEndsWithIgnoreCase_LongSuffix() { [EOL] assertFalse(StringUtils.endsWithIgnoreCase("str", "longsuffix")); [EOL] }

public void testAppendIfMissingIgnoreCase_NullStr() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase(null, "suffix", "suffixes"); [EOL] assertNull(result); [EOL] }
public void testAppendIfMissingIgnoreCase_EmptyStr() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("", "suffix", "suffixes"); [EOL] assertEquals("suffix", result); [EOL] }
public void testAppendIfMissingIgnoreCase_NoSuffix() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("str", null); [EOL] assertEquals("str", result); [EOL] }
public void testAppendIfMissingIgnoreCase_ExistingSuffix() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("strSuffix", "suffix"); [EOL] assertEquals("strSuffix", result); [EOL] }
public void testAppendIfMissingIgnoreCase_ExistingSuffixIgnoreCase() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("strSUFFIX", "suffix"); [EOL] assertEquals("strSUFFIX", result); [EOL] }
public void testAppendIfMissingIgnoreCase_MissingSuffix() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("str", "suffix"); [EOL] assertEquals("strsuffix", result); [EOL] }
public void testAppendIfMissingIgnoreCase_MultipleSuffixes() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("str", "suffix", "other", "suffixes"); [EOL] assertEquals("strsuffix", result); [EOL] }
public void testAppendIfMissingIgnoreCase_MultipleSuffixesWithExisting() { [EOL] String result = StringUtils.appendIfMissingIgnoreCase("strother", "suffix", "other", "suffixes"); [EOL] assertEquals("strother", result); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(2.0); [EOL] assertEquals(3.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testSubtract_NegativeOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(-3.0); [EOL] assertEquals(8.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testSubtract_ZeroOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(0.0); [EOL] assertEquals(5.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testSubtractWithPositiveOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(new Double(2.0)); [EOL] assertEquals(3.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testSubtractWithNegativeOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(new Double(-3.0)); [EOL] assertEquals(8.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testSubtractWithZeroOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(5.0); [EOL] mutableDouble.subtract(new Double(0.0)); [EOL] assertEquals(5.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testIntValue_Positive() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(5, result); [EOL] }
public void testIntValue_Negative() { [EOL] MutableInt mutableInt = new MutableInt(-5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(-5, result); [EOL] }
public void testIntValue_Zero() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(5L, result); [EOL] }
public void testLongValue_Negative() { [EOL] MutableLong mutableLong = new MutableLong(-5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(-5L, result); [EOL] }
public void testLongValue_Zero() { [EOL] MutableLong mutableLong = new MutableLong(0); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testLookupTranslatorWithNullInput() { [EOL] LookupTranslator lt = new LookupTranslator((CharSequence[][]) null); [EOL] assertTrue("Lookup map should be empty", lt.lookupMap.isEmpty()); [EOL] assertEquals("Shortest should be max value", Integer.MAX_VALUE, lt.shortest); [EOL] assertEquals("Longest should be 0", 0, lt.longest); [EOL] }
public void testLookupTranslatorWithEmptyInput() { [EOL] LookupTranslator lt = new LookupTranslator(new CharSequence[0][]); [EOL] assertTrue("Lookup map should be empty", lt.lookupMap.isEmpty()); [EOL] assertEquals("Shortest should be max value", Integer.MAX_VALUE, lt.shortest); [EOL] assertEquals("Longest should be 0", 0, lt.longest); [EOL] }
public void testLookupTranslatorWithSingleElement() { [EOL] LookupTranslator lt = new LookupTranslator(new CharSequence[][]{{"a", "b"}}); [EOL] assertFalse("Lookup map should not be empty", lt.lookupMap.isEmpty()); [EOL] assertEquals("Shortest should be 1", 1, lt.shortest); [EOL] assertEquals("Longest should be 1", 1, lt.longest); [EOL] }
public void testLookupTranslatorWithMultipleElements() { [EOL] LookupTranslator lt = new LookupTranslator(new CharSequence[][]{{"short", "s"}, {"longest", "l"}}); [EOL] assertFalse("Lookup map should not be empty", lt.lookupMap.isEmpty()); [EOL] assertEquals("Shortest should be 5", 5, lt.shortest); [EOL] assertEquals("Longest should be 7", 7, lt.longest); [EOL] }
public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL] int max = longest; [EOL] if (index + longest > input.length()) { [EOL] max = input.length() - index; [EOL] } [EOL] for (int i = max; i >= shortest; i--) { [EOL] final CharSequence subSeq = input.subSequence(index, index + i); [EOL] final CharSequence result = lookupMap.get(subSeq.toString()); [EOL] if (result != null) { [EOL] out.write(result.toString()); [EOL] return i; [EOL] } [EOL] } [EOL] return 0; [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL] appendCyclicObject(buffer, fieldName, value); [EOL] return; [EOL] } [EOL] register(value); [EOL] try { [EOL] if (value instanceof Collection<?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Collection<?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL] } [EOL] } else if (value instanceof Map<?, ?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL] } [EOL] } else if (value instanceof long[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (long[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (long[]) value); [EOL] } [EOL] } else if (value instanceof int[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (int[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (int[]) value); [EOL] } [EOL] } else if (value instanceof short[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (short[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (short[]) value); [EOL] } [EOL] } else if (value instanceof byte[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (byte[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (byte[]) value); [EOL] } [EOL] } else if (value instanceof char[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (char[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (char[]) value); [EOL] } [EOL] } else if (value instanceof double[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (double[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (double[]) value); [EOL] } [EOL] } else if (value instanceof float[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (float[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (float[]) value); [EOL] } [EOL] } else if (value instanceof boolean[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (boolean[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (boolean[]) value); [EOL] } [EOL] } else if (value.getClass().isArray()) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Object[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (Object[]) value); [EOL] } [EOL] } else { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, value); [EOL] } [EOL] } [EOL] } finally { [EOL] unregister(value); [EOL] } [EOL] }
public void testAppendWithLongValue() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", 123L); [EOL] assertEquals("fieldName=123", buffer.toString()); [EOL] }
public void testAppendWithLongValueAndNullFieldName() { [EOL] ToStringStyle style = new NoFieldNameToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, null, 123L); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendWithLongValueUsingShortPrefixStyle() { [EOL] ToStringStyle style = new ShortPrefixToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", 123L); [EOL] assertEquals("fieldName=123", buffer.toString()); [EOL] }
public void testAppendWithLongValueUsingSimpleToStringStyle() { [EOL] ToStringStyle style = new SimpleToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", 123L); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendWithLongValueUsingMultiLineToStringStyle() { [EOL] ToStringStyle style = new MultiLineToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", 123L); [EOL] assertTrue(buffer.toString().contains("fieldName=123")); [EOL] }
public void testAppendWithByteValue() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", (byte) 123); [EOL] assertEquals("fieldName=123", buffer.toString()); [EOL] }
public void testAppendWithByteValueAndNullFieldName() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, null, (byte) 123); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendWithByteValueUsingNoFieldNameToStringStyle() { [EOL] NoFieldNameToStringStyle style = new NoFieldNameToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", (byte) 123); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendWithByteValueUsingShortPrefixToStringStyle() { [EOL] ShortPrefixToStringStyle style = new ShortPrefixToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", (byte) 123); [EOL] assertTrue(buffer.toString().contains("123")); [EOL] }
public void testAppendWithByteValueUsingSimpleToStringStyle() { [EOL] SimpleToStringStyle style = new SimpleToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", (byte) 123); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendWithByteValueUsingMultiLineToStringStyle() { [EOL] MultiLineToStringStyle style = new MultiLineToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", (byte) 123); [EOL] assertTrue(buffer.toString().contains("123")); [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] appendFieldStart(buffer, fieldName); [EOL] appendDetail(buffer, fieldName, value); [EOL] appendFieldEnd(buffer, fieldName); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected void appendDetailTest() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "testField"; [EOL] float value = 123.45f; [EOL] appendDetail(buffer, fieldName, value); [EOL] assertEquals("123.45", buffer.toString()); [EOL] }

public void testAppendWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] int[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
public void testAppendWithFullDetailTrue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] int[] array = new int[] {1, 2, 3}; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
public void testAppendWithFullDetailFalse() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] int[] array = new int[] {1, 2, 3}; [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
public void testAppendWithFullDetailNull() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] int[] array = new int[] {1, 2, 3}; [EOL] Boolean fullDetail = null; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
public void testAppendWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "Field"; [EOL] double[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "Field"; [EOL] double[] array = new double[] {1.0, 2.0, 3.0}; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithSummaryDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "Field"; [EOL] double[] array = new double[] {1.0, 2.0, 3.0}; [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] appendFieldStart(buffer, fieldName); [EOL] if (array == null) { [EOL] appendNullText(buffer, fieldName); [EOL] } else if (isFullDetail(fullDetail)) { [EOL] appendDetail(buffer, fieldName, array); [EOL] } else { [EOL] appendSummary(buffer, fieldName, array); [EOL] } [EOL] appendFieldEnd(buffer, fieldName); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setUseClassName(final boolean useClassName) { [EOL] this.useClassName = useClassName; [EOL] } [EOL] protected ToStringStyle() { [EOL] } [EOL] DefaultToStringStyle() { [EOL] } [EOL] NoFieldNameToStringStyle() { [EOL] } [EOL] ShortPrefixToStringStyle() { [EOL] } [EOL] SimpleToStringStyle() { [EOL] } [EOL] MultiLineToStringStyle() { [EOL] } [EOL] static Map<Object, Object> getRegistry() { [EOL] } [EOL] static boolean isRegistered(final Object value) { [EOL] } [EOL] static void register(final Object value) { [EOL] } [EOL] static void unregister(final Object value) { [EOL] } [EOL] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] } [EOL] public void appendToString(final StringBuffer buffer, final String toString) { [EOL] } [EOL] public void appendStart(final StringBuffer buffer, final Object object) { [EOL] } [EOL] public void appendEnd(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL] } [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] } [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendContentStart(final StringBuffer buffer) { [EOL] } [EOL] protected void appendContentEnd(final StringBuffer buffer) { [EOL] } [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL] } [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] } [EOL] protected String getShortClassName(final Class<?> cls) { [EOL] } [EOL] protected boolean isUseClassName() { [EOL] } [EOL] protected void setUseClassName(final boolean useClassName) { [EOL] } [EOL] protected boolean isUseShortClassName() { [EOL] } [EOL] protected void setUseShortClassName(final boolean useShortClassName) { [EOL] } [EOL] protected boolean isUseIdentityHashCode() { [EOL] } [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL] } [EOL] protected boolean isUseFieldNames() { [EOL] } [EOL] protected void setUseFieldNames(final boolean useFieldNames) { [EOL] } [EOL] protected boolean isDefaultFullDetail() { [EOL] } [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL] } [EOL] protected boolean isArrayContentDetail() { [EOL] } [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] } [EOL] protected String getArrayStart() { [EOL] } [EOL] protected void setArrayStart(String arrayStart) { [EOL] } [EOL] protected String getArrayEnd() { [EOL] } [EOL] protected void setArrayEnd(String arrayEnd) { [EOL] } [EOL] protected String getArraySeparator() { [EOL] } [EOL] protected void setArraySeparator(String arraySeparator) { [EOL] } [EOL] protected String getContentStart() { [EOL] } [EOL] protected void setContentStart(String contentStart) { [EOL] } [EOL] protected String getContentEnd() { [EOL] } [EOL] protected void setContentEnd(String contentEnd) { [EOL] } [EOL] protected String getFieldNameValueSeparator() { [EOL] } [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL] } [EOL] protected String getFieldSeparator() { [EOL] } [EOL] protected void setFieldSeparator(String fieldSeparator) { [EOL] } [EOL] protected boolean isFieldSeparatorAtStart() { [EOL] } [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] } [EOL] protected boolean isFieldSeparatorAtEnd() { [EOL] } [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL] } [EOL] protected String getNullText() { [EOL] } [EOL] protected void setNullText(String nullText) { [EOL] } [EOL] protected String getSizeStartText() { [EOL] } [EOL] protected void setSizeStartText(String sizeStartText) { [EOL] } [EOL] protected String getSizeEndText() { [EOL] } [EOL] protected void setSizeEndText(String sizeEndText) { [EOL] } [EOL] protected String getSummaryObjectStartText() { [EOL] } [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText) { [EOL] } [EOL] protected String getSummaryObjectEndText() { [EOL] } [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] long serialVersionUID = -2587890625525655916L; [EOL] ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle(); [EOL] ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle(); [EOL] ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle(); [EOL] ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle(); [EOL] ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle(); [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY = new ThreadLocal<WeakHashMap<Object, Object>>(); [EOL] boolean useFieldNames = true; [EOL] boolean useClassName = true; [EOL] boolean useShortClassName = false; [EOL] boolean useIdentityHashCode = true; [EOL] String contentStart = "["; [EOL] String contentEnd = "]"; [EOL] String fieldNameValueSeparator = "="; [EOL] boolean fieldSeparatorAtStart = false; [EOL] boolean fieldSeparatorAtEnd = false; [EOL] String fieldSeparator = ","; [EOL] String arrayStart = "{"; [EOL] String arraySeparator = ","; [EOL] boolean arrayContentDetail = true; [EOL] String arrayEnd = "}";
public void testSetUseShortClassName() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setUseShortClassName(false); [EOL] assertFalse(style.isUseShortClassName()); [EOL] style.setUseShortClassName(true); [EOL] assertTrue(style.isUseShortClassName()); [EOL] }
protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL] this.useIdentityHashCode = useIdentityHashCode; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected you setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetDefaultFullDetail_True() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setDefaultFullDetail(true); [EOL] assertTrue(style.isDefaultFullDetail()); [EOL] }
public void testSetDefaultFullDetail_False() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setDefaultFullDetail(false); [EOL] assertFalse(style.isDefaultFullDetail()); [EOL] }
protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] this.arrayContentDetail = arrayContentDetail; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected String getArrayStart() { [EOL] return arrayStart; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetArrayStartWithNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setArrayStart(null); [EOL] assertEquals("", style.getArrayStart()); [EOL] }
public void testSetArrayStartWithNonNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setArrayStart("<start>"); [EOL] assertEquals("<start>", style.getArrayStart()); [EOL] }
protected String getContentEnd() { [EOL] return contentEnd; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetContentEndWithNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentEnd(null); [EOL] assertEquals("", style.getContentEnd()); [EOL] } [EOL] public void testSetContentEndWithEmptyString() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentEnd(""); [EOL] assertEquals("", style.getContentEnd()); [EOL] } [EOL] public void testSetContentEndWithNonEmptyString() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentEnd("]"); [EOL] assertEquals("]", style.getContentEnd()); [EOL] }
protected String getFieldNameValueSeparator() { [EOL] return fieldNameValueSeparator; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetFieldNameValueSeparatorWithNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldNameValueSeparator(null); [EOL] assertEquals("", style.getFieldNameValueSeparator()); [EOL] }
public void testSetFieldNameValueSeparatorWithNonNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldNameValueSeparator(":"); [EOL] assertEquals(":", style.getFieldNameValueSeparator()); [EOL] }
protected String getNullText() { [EOL] return nullText; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetNullTextWithNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setNullText(null); [EOL] assertEquals("", style.getNullText()); [EOL] } [EOL] public void testSetNullTextWithNonNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setNullText("NULL"); [EOL] assertEquals("NULL", style.getNullText()); [EOL] }
```java [EOL] protected String getSizeStartText() { [EOL] return sizeStartText; [EOL] } [EOL] protected ToStringStyle() { [EOL] } [EOL] DefaultToStringStyle() { [EOL] } [EOL] NoFieldNameToStringStyle() { [EOL] } [EOL] ShortPrefixToStringStyle() { [EOL] } [EOL] SimpleToStringStyle() { [EOL] } [EOL] MultiLineToStringStyle() { [EOL] } [EOL] static Map<Object, Object> getRegistry() { [EOL] } [EOL] static boolean isRegistered(final Object value) { [EOL] } [EOL] static void register(final Object value) { [EOL] } [EOL] static void unregister(final Object value) { [EOL] } [EOL] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] } [EOL] public void appendToString(final StringBuffer buffer, final String toString) { [EOL] } [EOL] public void appendStart(final StringBuffer buffer, final Object object) { [EOL] } [EOL] public void appendEnd(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL] } [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] } [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendContentStart(final StringBuffer buffer) { [EOL] } [EOL] protected void appendContentEnd(final StringBuffer buffer) { [EOL] } [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL] } [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] } [EOL] protected String getShortClassName(final Class<?> cls) { [EOL] } [EOL] protected boolean isUseClassName() { [EOL] } [EOL] protected void setUseClassName(final boolean useClassName) { [EOL] } [EOL] protected boolean isUseShortClassName() { [EOL] } [EOL] protected void setUseShortClassName(final boolean useShortClassName) { [EOL] } [EOL] protected boolean isUseIdentityHashCode() { [EOL] } [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL] } [EOL] protected boolean isUseFieldNames() { [EOL] } [EOL] protected void setUseFieldNames(final boolean useFieldNames) { [EOL] } [EOL] protected boolean isDefaultFullDetail() { [EOL] } [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL] } [EOL] protected boolean isArrayContentDetail() { [EOL] } [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] } [EOL] protected String getArrayStart() { [EOL] } [EOL] protected void setArrayStart(String arrayStart) { [EOL] } [EOL] protected String getArrayEnd() { [EOL] } [EOL] protected void setArrayEnd(String arrayEnd) { [EOL] } [EOL] protected String getArraySeparator() { [EOL] } [EOL] protected void setArraySeparator(String arraySeparator) { [EOL] } [EOL] protected String getContentStart() { [EOL] } [EOL] protected void setContentStart(String contentStart) { [EOL] } [EOL] protected String getContentEnd() { [EOL] } [EOL] protected void setContentEnd(String contentEnd) { [EOL] } [EOL] protected String getFieldNameValueSeparator() { [EOL] } [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL] } [EOL] protected String getFieldSeparator() { [EOL] } [EOL] protected void setFieldSeparator(String fieldSeparator) { [EOL] } [EOL] protected boolean isFieldSeparatorAtStart() { [EOL] } [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] } [EOL] protected boolean isFieldSeparatorAtEnd() { [EOL] } [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL] } [EOL] protected String getNullText() { [EOL] } [EOL] protected void setNullText(String nullText) { [EOL] } [EOL] protected String getSizeStartText() { [EOL] } [EOL] protected void setSizeStartText(String sizeStartText) { [EOL] } [EOL] protected String getSizeEndText() { [EOL] } [EOL] protected void setSizeEndText(String sizeEndText) { [EOL] } [EOL] protected String getSummaryObjectStartText() { [EOL] } [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText) { [EOL] } [EOL] protected String getSummaryObjectEndText() { [EOL] } [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] long serialVersionUID = -2587890625525655916L; [EOL] ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle(); [EOL] ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle(); [EOL] ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle(); [EOL] ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle(); [E
protected void setSizeStartText(String sizeStartText) { [EOL] if (sizeStartText == null) { [EOL] sizeStartText = ""; [EOL] } [EOL] this.sizeStartText = sizeStartText; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testBelow_withNegativeCodepoint() { [EOL] try { [EOL] UnicodeEscaper escaper = UnicodeEscaper.below(-1); [EOL] fail("Expected IllegalArgumentException for negative codepoint"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBelow_withZeroCodepoint() { [EOL] UnicodeEscaper escaper = UnicodeEscaper.below(0); [EOL] assertNotNull(escaper); [EOL] }
public void testBelow_withPositiveCodepoint() { [EOL] UnicodeEscaper escaper = UnicodeEscaper.below(1); [EOL] assertNotNull(escaper); [EOL] }
public void testBetweenWithValidRange() { [EOL] int codepointLow = 50; [EOL] int codepointHigh = 100; [EOL] UnicodeEscaper escaper = UnicodeEscaper.between(codepointLow, codepointHigh); [EOL] assertNotNull(escaper); [EOL] assertTrue(escaper.translate(codepointLow) != null); [EOL] assertTrue(escaper.translate(codepointHigh) != null); [EOL] }
public void testBetweenWithInvertedRange() { [EOL] int codepointLow = 100; [EOL] int codepointHigh = 50; [EOL] try { [EOL] UnicodeEscaper.between(codepointLow, codepointHigh); [EOL] fail("Expected IllegalArgumentException for inverted range"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBetweenWithEqualRange() { [EOL] int codepoint = 75; [EOL] UnicodeEscaper escaper = UnicodeEscaper.between(codepoint, codepoint); [EOL] assertNotNull(escaper); [EOL] assertTrue(escaper.translate(codepoint) != null); [EOL] }
public void testTranslate_CodepointOutsideOfRangeBelow_ReturnsFalse() throws IOException { [EOL] final int codepoint = 0x10; // Below the range [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = true; [EOL] final int below = 0x20; [EOL] final int above = 0x30; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] } [EOL] public void testTranslate_CodepointOutsideOfRangeAbove_ReturnsFalse() throws IOException { [EOL] final int codepoint = 0x40; // Above the range [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = true; [EOL] final int below = 0x20; [EOL] final int above = 0x30; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] } [EOL] public void testTranslate_CodepointWithinRange_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0x25; // Within the range [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = true; [EOL] final int below = 0x20; [EOL] final int above = 0x30; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().startsWith("\\u00")); [EOL] } [EOL] public void testTranslate_CodepointOutsideOfInvertedRange_ReturnsFalse() throws IOException { [EOL] final int codepoint = 0x25; // Within the range, but 'between' is false [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x20; [EOL] final int above = 0x30; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] } [EOL] public void testTranslate_CodepointAbove0xffff_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0x1ffff; // Above 0xffff [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x0; [EOL] final int above = 0x10ffff; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().contains(toUtf16Escape(codepoint))); [EOL] } [EOL] public void testTranslate_CodepointAbove0xfff_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0xafff; // Above 0xfff [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x0; [EOL] final int above = 0xffff; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().startsWith("\\u")); [EOL] } [EOL] public void testTranslate_CodepointAbove0xff_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0x0aff; // Above 0xff [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x0; [EOL] final int above = 0xfff; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().startsWith("\\u0")); [EOL] } [EOL] public void testTranslate_CodepointAbove0xf_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0x00af; // Above 0xf [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x0; [EOL] final int above = 0xff; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().startsWith("\\u00")); [EOL] } [EOL] public void testTranslate_CodepointAtOrBelow0xf_ReturnsTrue() throws IOException { [EOL] final int codepoint = 0x000f; // At or below 0xf [EOL] final Writer out = new StringWriter(); [EOL] final boolean between = false; [EOL] final int below = 0x0; [EOL] final int above = 0xf; [EOL] boolean result = translate(codepoint, out, between, below, above); [EOL] assertTrue(result); [EOL] assertTrue(out.toString().startsWith("\\u000")); [EOL] }
public void testBinaryToHexDigitEmptyArray() { [EOL] try { [EOL] boolean[] src = {}; [EOL] LangUtils.binaryToHexDigit(src, 0); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToHexDigitF() { [EOL] boolean[] src = {true, true, true, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitE() { [EOL] boolean[] src = {false, true, true, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('e', result); [EOL] }
public void testBinaryToHexDigitD() { [EOL] boolean[] src = {true, true, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('d', result); [EOL] }
public void testBinaryToHexDigitC() { [EOL] boolean[] src = {false, true, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('c', result); [EOL] }
public void testBinaryToHexDigitB() { [EOL] boolean[] src = {true, true, false, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('b', result); [EOL] }
public void testBinaryToHexDigitA() { [EOL] boolean[] src = {false, true, false, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('a', result); [EOL] }
public void testBinaryToHexDigit9() { [EOL] boolean[] src = {true, false, false, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('9', result); [EOL] }
public void testBinaryToHexDigit8() { [EOL] boolean[] src = {false, false, false, true}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('8', result); [EOL] }
public void testBinaryToHexDigit7() { [EOL] boolean[] src = {true, true, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('7', result); [EOL] }
public void testBinaryToHexDigit6() { [EOL] boolean[] src = {false, true, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('6', result); [EOL] }
public void testBinaryToHexDigit5() { [EOL] boolean[] src = {true, true, false, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('5', result); [EOL] }
public void testBinaryToHexDigit4() { [EOL] boolean[] src = {false, true, false, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('4', result); [EOL] }
public void testBinaryToHexDigit3() { [EOL] boolean[] src = {true, false, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('3', result); [EOL] }
public void testBinaryToHexDigit2() { [EOL] boolean[] src = {false, false, true, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('2', result); [EOL] }
public void testBinaryToHexDigit1() { [EOL] boolean[] src = {true, false, false, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('1', result); [EOL] }
public void testBinaryToHexDigit0() { [EOL] boolean[] src = {false, false, false, false}; [EOL] char result = LangUtils.binaryToHexDigit(src, 0); [EOL] assertEquals('0', result); [EOL] }
public void testIntToHexDigitMsb0_0() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x0); [EOL] assertEquals('0', result); [EOL] }
public void testIntToHexDigitMsb0_1() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x1); [EOL] assertEquals('8', result); [EOL] }
public void testIntToHexDigitMsb0_2() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x2); [EOL] assertEquals('4', result); [EOL] }
public void testIntToHexDigitMsb0_3() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x3); [EOL] assertEquals('c', result); [EOL] }
public void testIntToHexDigitMsb0_4() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x4); [EOL] assertEquals('2', result); [EOL] }
public void testIntToHexDigitMsb0_5() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x5); [EOL] assertEquals('a', result); [EOL] }
public void testIntToHexDigitMsb0_6() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x6); [EOL] assertEquals('6', result); [EOL] }
public void testIntToHexDigitMsb0_7() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x7); [EOL] assertEquals('e', result); [EOL] }
public void testIntToHexDigitMsb0_8() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x8); [EOL] assertEquals('1', result); [EOL] }
public void testIntToHexDigitMsb0_9() { [EOL] char result = SomeClass.intToHexDigitMsb0(0x9); [EOL] assertEquals('9', result); [EOL] }
public void testIntToHexDigitMsb0_A() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xA); [EOL] assertEquals('5', result); [EOL] }
public void testIntToHexDigitMsb0_B() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xB); [EOL] assertEquals('d', result); [EOL] }
public void testIntToHexDigitMsb0_C() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xC); [EOL] assertEquals('3', result); [EOL] }
public void testIntToHexDigitMsb0_D() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xD); [EOL] assertEquals('b', result); [EOL] }
public void testIntToHexDigitMsb0_E() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xE); [EOL] assertEquals('7', result); [EOL] }
public void testIntToHexDigitMsb0_F() { [EOL] char result = SomeClass.intToHexDigitMsb0(0xF); [EOL] assertEquals('f', result); [EOL] }
public void testIntToHexDigitMsb0_Invalid() { [EOL] try { [EOL] SomeClass.intToHexDigitMsb0(0x10); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL] if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL] return dstInit; [EOL] } [EOL] if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL] throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL] } [EOL] long out = dstInit; [EOL] int shift = 0; [EOL] for (int i = 0; i < nShorts; i++) { [EOL] shift = i * 16 + dstPos; [EOL] final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL] final long mask = 0xffffL << shift; [EOL] out = (out & ~mask) | bits; [EOL] } [EOL] return out; [EOL] }
public void testHexToLong_ZeroLength() { [EOL] long result = SomeClass.hexToLong("0", 0, 0L, 0, 0); [EOL] assertEquals(0L, result); [EOL] } [EOL] public void testHexToLong_IllegalArgumentException() { [EOL] try { [EOL] SomeClass.hexToLong("0123456789ABCDEF", 0, 0L, 0, 17); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testHexToLong_ValidInput() { [EOL] long result = SomeClass.hexToLong("0123456789ABCDEF", 0, 0L, 0, 16); [EOL] assertEquals(0x0123456789ABCDEFL, result); [EOL] } [EOL] public void testHexToLong_ValidInputWithOffset() { [EOL] long result = SomeClass.hexToLong("0123456789ABCDEF", 4, 0L, 0, 12); [EOL] assertEquals(0x56789ABCDEFL, result); [EOL] } [EOL] public void testHexToLong_ValidInputWithDstInit() { [EOL] long result = SomeClass.hexToLong("0123456789ABCDEF", 0, 0xFFFFFFFFFFFFFFFFL, 0, 16); [EOL] assertEquals(0x0123456789ABCDEFL, result); [EOL] } [EOL] public void testHexToLong_ValidInputWithDstPos() { [EOL] long result = SomeClass.hexToLong("0123456789ABCDEF", 0, 0L, 4, 15); [EOL] assertEquals(0x123456789ABCDEF0L, result); [EOL] }

public void testHexToInt_ZeroLength() { [EOL] int result = hexToInt("0", 0, 0, 0, 0); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testHexToInt_IllegalArgumentException() { [EOL] try { [EOL] hexToInt("0", 0, 0, 0, 9); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testHexToInt_SingleHex() { [EOL] int result = hexToInt("1", 0, 0, 0, 1); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testHexToInt_MultipleHex() { [EOL] int result = hexToInt("123", 0, 0, 0, 3); [EOL] assertEquals(0x123, result); [EOL] } [EOL] public void testHexToInt_WithDstInitAndDstPos() { [EOL] int result = hexToInt("123", 0, 0x1000, 4, 3); [EOL] assertEquals(0x12310, result); [EOL] } [EOL] public void testHexToInt_WithSrcPos() { [EOL] int result = hexToInt("0123", 1, 0, 0, 3); [EOL] assertEquals(0x123, result); [EOL] }
public void testBinaryToShortEmptySource() { [EOL] boolean[] src = new boolean[0]; [EOL] int srcPos = 0; [EOL] short dstInit = 0; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] short result = Lang3.binaryToShort(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(dstInit, result); [EOL] }
public void testBinaryToShortNoBools() { [EOL] boolean[] src = {true, false, true}; [EOL] int srcPos = 0; [EOL] short dstInit = 0; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] short result = Lang3.binaryToShort(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(dstInit, result); [EOL] }
public void testBinaryToShortInvalidNBools() { [EOL] boolean[] src = {true, false, true}; [EOL] int srcPos = 0; [EOL] short dstInit = 0; [EOL] int dstPos = 0; [EOL] int nBools = 17; // nBools - 1 + dstPos >= 16 [EOL] try { [EOL] Lang3.binaryToShort(src, srcPos, dstInit, dstPos, nBools); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToShortValidConversion() { [EOL] boolean[] src = {true, false, true, true}; [EOL] int srcPos = 1; [EOL] short dstInit = 0; [EOL] int dstPos = 4; [EOL] int nBools = 3; [EOL] short expected = (short) ((0 | (0 << 4)) | (1 << 5) | (1 << 6)); [EOL] short result = Lang3.binaryToShort(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(expected, result); [EOL] }
public void testLongToByteArray_ZeroBytes() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] result = MyClass.longToByteArray(123456789L, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testLongToByteArray_IllegalArgumentException() { [EOL] byte[] dst = new byte[10]; [EOL] try { [EOL] MyClass.longToByteArray(123456789L, 0, dst, 0, 9); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nBytes-1)*8+srcPos is greather or equal to than 64", e.getMessage()); [EOL] } [EOL] } [EOL] public void testLongToByteArray_ValidInput() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] expected = new byte[10]; [EOL] expected[1] = (byte) (0xff & (123456789L >> 8)); [EOL] expected[2] = (byte) (0xff & (123456789L >> 16)); [EOL] byte[] result = MyClass.longToByteArray(123456789L, 0, dst, 1, 3); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testLongToByteArray_ValidInputWithSrcPos() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] expected = new byte[10]; [EOL] expected[1] = (byte) (0xff & (123456789L >> (1 * 8))); [EOL] expected[2] = (byte) (0xff & (123456789L >> (2 * 8))); [EOL] byte[] result = MyClass.longToByteArray(123456789L, 8, dst, 1, 3); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testShortToByteArray_ZeroBytes() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] result = ArrayUtils.shortToByteArray((short) 0x1234, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testShortToByteArray_IllegalArgumentException() { [EOL] byte[] dst = new byte[10]; [EOL] try { [EOL] ArrayUtils.shortToByteArray((short) 0x1234, 0, dst, 0, 3); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testShortToByteArray_ValidInput() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] expected = new byte[10]; [EOL] expected[1] = 0x34; [EOL] expected[2] = 0x12; [EOL] byte[] result = ArrayUtils.shortToByteArray((short) 0x1234, 0, dst, 1, 2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testShortToByteArray_ValidInputWithOffset() { [EOL] byte[] dst = new byte[10]; [EOL] byte[] expected = new byte[10]; [EOL] expected[3] = 0x12; [EOL] byte[] result = ArrayUtils.shortToByteArray((short) 0x1234, 8, dst, 3, 1); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testByteArrayToUuidWithNullArray() { [EOL] try { [EOL] Utils.byteArrayToUuid(null, 0); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testByteArrayToUuidWithShortArray() { [EOL] try { [EOL] Utils.byteArrayToUuid(new byte[15], 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Need at least 16 bytes for UUID", e.getMessage()); [EOL] } [EOL] } [EOL] public void testByteArrayToUuidWithValidArray() { [EOL] byte[] uuidBytes = new byte[16]; [EOL] for (int i = 0; i < 16; i++) { [EOL] uuidBytes[i] = (byte) i; [EOL] } [EOL] UUID uuid = Utils.byteArrayToUuid(uuidBytes, 0); [EOL] assertNotNull(uuid); [EOL] assertEquals(0x0001020304050607L, uuid.getMostSignificantBits()); [EOL] assertEquals(0x08090a0b0c0d0e0fL, uuid.getLeastSignificantBits()); [EOL] } [EOL] public void testByteArrayToUuidWithValidArrayAndOffset() { [EOL] byte[] uuidBytes = new byte[32]; [EOL] for (int i = 0; i < 32; i++) { [EOL] uuidBytes[i] = (byte) i; [EOL] } [EOL] UUID uuid = Utils.byteArrayToUuid(uuidBytes, 16); [EOL] assertNotNull(uuid); [EOL] assertEquals(0x1011121314151617L, uuid.getMostSignificantBits()); [EOL] assertEquals(0x18191a1b1c1d1e1fL, uuid.getLeastSignificantBits()); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL] return ESCAPE_ECMASCRIPT.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
public static final String unescapeJava(final String input) { [EOL] return UNESCAPE_JAVA.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; [EOL] CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } })];
public static final String unescapeCsv(final String input) { [EOL] return UNESCAPE_CSV.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
