public LowerCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new LowerCaseNamingPolicy()); [EOL] }
public LowerCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new LowerCaseNamingPolicy()); [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { [EOL]     Class<?> rawParentType = null; [EOL]     if (parentType instanceof Class<?>) { [EOL]         rawParentType = (Class<?>) parentType; [EOL]     } else if (parentType instanceof ParameterizedType) { [EOL]         ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; [EOL]         rawParentType = (Class<?>) parentTypeAsPT.getRawType(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Type superClass = rawParentType.getGenericSuperclass(); [EOL]     if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { [EOL]         TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); [EOL]         int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); [EOL]         Type[] actualTypeArguments = null; [EOL]         if (parentType instanceof Class<?>) { [EOL]             actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); [EOL]         } else if (parentType instanceof ParameterizedType) { [EOL]             actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]         return actualTypeArguments[indexOfActualTypeArgument]; [EOL]     } [EOL]     Type searchedType = null; [EOL]     if (superClass != null) { [EOL]         searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); [EOL]     } [EOL]     return searchedType; [EOL] }
private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { [EOL]     Class<?> rawParentType = null; [EOL]     if (parentType instanceof Class<?>) { [EOL]         rawParentType = (Class<?>) parentType; [EOL]     } else if (parentType instanceof ParameterizedType) { [EOL]         ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; [EOL]         rawParentType = (Class<?>) parentTypeAsPT.getRawType(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Type superClass = rawParentType.getGenericSuperclass(); [EOL]     if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { [EOL]         TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); [EOL]         int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); [EOL]         Type[] actualTypeArguments = null; [EOL]         if (parentType instanceof Class<?>) { [EOL]             actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); [EOL]         } else if (parentType instanceof ParameterizedType) { [EOL]             actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]         return actualTypeArguments[indexOfActualTypeArgument]; [EOL]     } [EOL]     Type searchedType = null; [EOL]     if (superClass != null) { [EOL]         searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); [EOL]     } [EOL]     return searchedType; [EOL] }
private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { [EOL]     Class<?> rawParentType = null; [EOL]     if (parentType instanceof Class<?>) { [EOL]         rawParentType = (Class<?>) parentType; [EOL]     } else if (parentType instanceof ParameterizedType) { [EOL]         ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; [EOL]         rawParentType = (Class<?>) parentTypeAsPT.getRawType(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Type superClass = rawParentType.getGenericSuperclass(); [EOL]     if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { [EOL]         TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); [EOL]         int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); [EOL]         Type[] actualTypeArguments = null; [EOL]         if (parentType instanceof Class<?>) { [EOL]             actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); [EOL]         } else if (parentType instanceof ParameterizedType) { [EOL]             actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]         return actualTypeArguments[indexOfActualTypeArgument]; [EOL]     } [EOL]     Type searchedType = null; [EOL]     if (superClass != null) { [EOL]         searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); [EOL]     } [EOL]     return searchedType; [EOL] }
private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { [EOL]     Class<?> rawParentType = null; [EOL]     if (parentType instanceof Class<?>) { [EOL]         rawParentType = (Class<?>) parentType; [EOL]     } else if (parentType instanceof ParameterizedType) { [EOL]         ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; [EOL]         rawParentType = (Class<?>) parentTypeAsPT.getRawType(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Type superClass = rawParentType.getGenericSuperclass(); [EOL]     if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { [EOL]         TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); [EOL]         int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); [EOL]         Type[] actualTypeArguments = null; [EOL]         if (parentType instanceof Class<?>) { [EOL]             actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); [EOL]         } else if (parentType instanceof ParameterizedType) { [EOL]             actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]         return actualTypeArguments[indexOfActualTypeArgument]; [EOL]     } [EOL]     Type searchedType = null; [EOL]     if (superClass != null) { [EOL]         searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); [EOL]     } [EOL]     return searchedType; [EOL] }
private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type) { [EOL]     for (int i = 0; i < types.length; ++i) { [EOL]         if (type.equals(types[i])) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new IllegalStateException("How can the type variable not be present in the class declaration!"); [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair) { [EOL]     JsonElement childElement = getJsonElementForChild(fieldValuePair); [EOL]     addChildAsElement(f, childElement); [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
private boolean isFieldNull(FieldAttributes f, Object obj) { [EOL]     return getFieldValue(f, obj) == null; [EOL] }
private boolean isFieldNull(FieldAttributes f, Object obj) { [EOL]     return getFieldValue(f, obj) == null; [EOL] }
private Object getFieldValue(FieldAttributes f, Object obj) { [EOL]     try { [EOL]         return f.get(obj); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
private Object getFieldValue(FieldAttributes f, Object obj) { [EOL]     try { [EOL]         return f.get(obj); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] }
public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] }
public JsonWriter nullValue() throws IOException { [EOL]     beforeValue(false); [EOL]     out.write("null"); [EOL]     return this; [EOL] }
public JsonWriter value(boolean value) throws IOException { [EOL]     beforeValue(false); [EOL]     out.write(value ? "true" : "false"); [EOL]     return this; [EOL] }
public JsonWriter value(boolean value) throws IOException { [EOL]     beforeValue(false); [EOL]     out.write(value ? "true" : "false"); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(long value) throws IOException { [EOL]     beforeValue(false); [EOL]     out.write(Long.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(long value) throws IOException { [EOL]     beforeValue(false); [EOL]     out.write(Long.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(long value) throws IOException { [EOL]     beforeValue(false); [EOL]     out.write(Long.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeName() throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context == JsonScope.NONEMPTY_OBJECT) { [EOL]         out.write(','); [EOL]     } else if (context != JsonScope.EMPTY_OBJECT) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     newline(); [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) { [EOL]     this.skipSyntheticFields = skipSyntheticFields; [EOL] }
SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) { [EOL]     this.skipSyntheticFields = skipSyntheticFields; [EOL] }
public ModifierBasedExclusionStrategy(int... modifiers) { [EOL]     this.modifiers = new HashSet<Integer>(); [EOL]     if (modifiers != null) { [EOL]         for (int modifier : modifiers) { [EOL]             this.modifiers.add(modifier); [EOL]         } [EOL]     } [EOL] }
public ModifierBasedExclusionStrategy(int... modifiers) { [EOL]     this.modifiers = new HashSet<Integer>(); [EOL]     if (modifiers != null) { [EOL]         for (int modifier : modifiers) { [EOL]             this.modifiers.add(modifier); [EOL]         } [EOL]     } [EOL] }
public ModifierBasedExclusionStrategy(int... modifiers) { [EOL]     this.modifiers = new HashSet<Integer>(); [EOL]     if (modifiers != null) { [EOL]         for (int modifier : modifiers) { [EOL]             this.modifiers.add(modifier); [EOL]         } [EOL]     } [EOL] }
public ModifierBasedExclusionStrategy(int... modifiers) { [EOL]     this.modifiers = new HashSet<Integer>(); [EOL]     if (modifiers != null) { [EOL]         for (int modifier : modifiers) { [EOL]             this.modifiers.add(modifier); [EOL]         } [EOL]     } [EOL] }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
public boolean isLenient() { [EOL]     return lenient; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void skipToEndOfLine() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         char c = buffer[pos++]; [EOL]         if (c == '\r' || c == '\n') { [EOL]             break; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void skipToEndOfLine() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         char c = buffer[pos++]; [EOL]         if (c == '\r' || c == '\n') { [EOL]             break; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void skipToEndOfLine() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         char c = buffer[pos++]; [EOL]         if (c == '\r' || c == '\n') { [EOL]             break; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void skipToEndOfLine() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         char c = buffer[pos++]; [EOL]         if (c == '\r' || c == '\n') { [EOL]             break; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean skipTo(String toFind) throws IOException { [EOL]     outer: for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) { [EOL]         for (int c = 0; c < toFind.length(); c++) { [EOL]             if (buffer[pos + c] != toFind.charAt(c)) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context) { [EOL]     super(json, type, factory, objectConstructor, deserializers, context); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected T constructTarget() { [EOL]     return (T) objectConstructor.construct(targetType); [EOL] }
public void startVisitingObject(Object node) { [EOL] }
private String getFieldName(FieldAttributes f) { [EOL]     FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy(); [EOL]     return namingPolicy.translateName(f); [EOL] }
private String getFieldName(FieldAttributes f) { [EOL]     FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy(); [EOL]     return namingPolicy.translateName(f); [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) { [EOL]     Preconditions.checkNotNull(adaptee); [EOL]     this.adaptee = adaptee; [EOL] }
public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) { [EOL]     Preconditions.checkNotNull(adaptee); [EOL]     this.adaptee = adaptee; [EOL] }
@SuppressWarnings("deprecation") [EOL] public String translateName(FieldAttributes f) { [EOL]     return adaptee.translateName(f.getFieldObject()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public String translateName(FieldAttributes f) { [EOL]     return adaptee.translateName(f.getFieldObject()); [EOL] }
private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> map = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER); [EOL]     map.register(URL.class, URL_TYPE_ADAPTER); [EOL]     map.register(URI.class, URI_TYPE_ADAPTER); [EOL]     map.register(UUID.class, UUUID_TYPE_ADAPTER); [EOL]     map.register(Locale.class, LOCALE_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER); [EOL]     map.register(Date.class, DATE_TYPE_ADAPTER); [EOL]     map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER); [EOL]     map.register(Timestamp.class, DATE_TYPE_ADAPTER); [EOL]     map.register(Time.class, TIME_TYPE_ADAPTER); [EOL]     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER); [EOL]     map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER); [EOL]     map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER); [EOL]     map.register(boolean.class, BOOLEAN_TYPE_ADAPTER); [EOL]     map.register(Byte.class, BYTE_TYPE_ADAPTER); [EOL]     map.register(byte.class, BYTE_TYPE_ADAPTER); [EOL]     map.register(Character.class, CHARACTER_TYPE_ADAPTER); [EOL]     map.register(char.class, CHARACTER_TYPE_ADAPTER); [EOL]     map.register(Integer.class, INTEGER_TYPE_ADAPTER); [EOL]     map.register(int.class, INTEGER_TYPE_ADAPTER); [EOL]     map.register(Number.class, NUMBER_TYPE_ADAPTER); [EOL]     map.register(Short.class, SHORT_TYPE_ADAPTER); [EOL]     map.register(short.class, SHORT_TYPE_ADAPTER); [EOL]     map.register(String.class, STRING_TYPE_ADAPTER); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] }
private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() { [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>(); [EOL]     map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER)); [EOL]     map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER)); [EOL]     map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER)); [EOL]     map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER)); [EOL]     map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER)); [EOL]     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER)); [EOL]     map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER)); [EOL]     map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER)); [EOL]     map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER)); [EOL]     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER)); [EOL]     map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER)); [EOL]     map.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER)); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] }
private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() { [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> map = new ParameterizedTypeHandlerMap<InstanceCreator<?>>(); [EOL]     map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR); [EOL]     map.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR); [EOL]     map.register(Properties.class, PROPERTIES_CREATOR); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return new JsonDeserializerExceptionWrapper(deserializer); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return new JsonDeserializerExceptionWrapper(deserializer); [EOL] }
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() { [EOL]     return getDefaultSerializers(false, LongSerializationPolicy.DEFAULT); [EOL] }
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() { [EOL]     return getDefaultSerializers(false, LongSerializationPolicy.DEFAULT); [EOL] }
DefaultDateTypeAdapter() { [EOL]     this.format = DateFormat.getDateTimeInstance(); [EOL] }
DefaultJavaSqlDateTypeAdapter() { [EOL]     this.format = new SimpleDateFormat("MMM d, yyyy"); [EOL] }
DefaultTimeTypeAdapter() { [EOL]     this.format = new SimpleDateFormat("hh:mm:ss a"); [EOL] }
public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return UUID.fromString(json.getAsString()); [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public Collection createInstance(Type type) { [EOL]     return new LinkedList(); [EOL] }
public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigInteger(); [EOL] }
public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigInteger(); [EOL] }
public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigInteger(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return LongDeserializer.class.getSimpleName(); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsCharacter(); [EOL] }
public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsCharacter(); [EOL] }
public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsCharacter(); [EOL] }
public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public void startVisitingObject(Object node) { [EOL]     throw new JsonParseException("Expecting array but found object: " + node); [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
public JsonArray() { [EOL]     elements = new ArrayList<JsonElement>(); [EOL] }
public void add(JsonElement element) { [EOL]     if (element == null) { [EOL]         element = JsonNull.createJsonNull(); [EOL]     } [EOL]     elements.add(element); [EOL] }
public Iterator<JsonElement> iterator() { [EOL]     return elements.iterator(); [EOL] }
public Iterator<JsonElement> iterator() { [EOL]     return elements.iterator(); [EOL] }
@Override [EOL] public double getAsDouble() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsDouble(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public double getAsDouble() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsDouble(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public double getAsDouble() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsDouble(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public long getAsLong() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsLong(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public long getAsLong() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsLong(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public long getAsLong() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsLong(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public int getAsInt() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsInt(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public int getAsInt() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsInt(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public int getAsInt() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsInt(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) { [EOL]     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value); [EOL]     registerForTypeHierarchy(pair); [EOL] }
public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) { [EOL]     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value); [EOL]     registerForTypeHierarchy(pair); [EOL] }
public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) { [EOL]     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value); [EOL]     registerForTypeHierarchy(pair); [EOL] }
public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first); [EOL]     if (index >= 0) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", pair.first); [EOL]         typeHierarchyList.remove(index); [EOL]     } [EOL]     index = getIndexOfAnOverriddenHandler(pair.first); [EOL]     if (index >= 0) { [EOL]         throw new IllegalArgumentException("The specified type handler for type " + pair.first + " hides the previously registered type hierarchy handler for " + typeHierarchyList.get(index).first + ". Gson does not allow this."); [EOL]     } [EOL]     typeHierarchyList.add(0, pair); [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerIfAbsent(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (!map.containsKey(typeOfT)) { [EOL]         register(typeOfT, value); [EOL]     } [EOL] }
public synchronized void registerIfAbsent(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (!map.containsKey(typeOfT)) { [EOL]         register(typeOfT, value); [EOL]     } [EOL] }
public synchronized void registerIfAbsent(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (!map.containsKey(typeOfT)) { [EOL]         register(typeOfT, value); [EOL]     } [EOL] }
public synchronized T getHandlerFor(Type type) { [EOL]     T handler = map.get(type); [EOL]     if (handler == null) { [EOL]         Class<?> rawClass = TypeUtils.toRawClass(type); [EOL]         if (rawClass != type) { [EOL]             handler = getHandlerFor(rawClass); [EOL]         } [EOL]         if (handler == null) { [EOL]             handler = getHandlerForTypeHierarchy(rawClass); [EOL]         } [EOL]     } [EOL]     return handler; [EOL] }
public synchronized T getHandlerFor(Type type) { [EOL]     T handler = map.get(type); [EOL]     if (handler == null) { [EOL]         Class<?> rawClass = TypeUtils.toRawClass(type); [EOL]         if (rawClass != type) { [EOL]             handler = getHandlerFor(rawClass); [EOL]         } [EOL]         if (handler == null) { [EOL]             handler = getHandlerForTypeHierarchy(rawClass); [EOL]         } [EOL]     } [EOL]     return handler; [EOL] }
public synchronized T getHandlerFor(Type type) { [EOL]     T handler = map.get(type); [EOL]     if (handler == null) { [EOL]         Class<?> rawClass = TypeUtils.toRawClass(type); [EOL]         if (rawClass != type) { [EOL]             handler = getHandlerFor(rawClass); [EOL]         } [EOL]         if (handler == null) { [EOL]             handler = getHandlerForTypeHierarchy(rawClass); [EOL]         } [EOL]     } [EOL]     return handler; [EOL] }
private T getHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         if (entry.first.isAssignableFrom(type)) { [EOL]             return entry.second; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private T getHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         if (entry.first.isAssignableFrom(type)) { [EOL]             return entry.second; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private T getHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         if (entry.first.isAssignableFrom(type)) { [EOL]             return entry.second; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public synchronized boolean hasSpecificHandlerFor(Type type) { [EOL]     return map.containsKey(type); [EOL] }
private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         if (type.equals(typeHierarchyList.get(i).first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         if (type.equals(typeHierarchyList.get(i).first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] }
public JsonElement parse(String json) throws JsonParseException { [EOL]     return parse(new StringReader(json)); [EOL] }
public JsonElement parse(String json) throws JsonParseException { [EOL]     return parse(new StringReader(json)); [EOL] }
public JsonElement parse(String json) throws JsonParseException { [EOL]     return parse(new StringReader(json)); [EOL] }
public JsonElement parse(Reader json) throws JsonParseException { [EOL]     return parse(new JsonReader(json)); [EOL] }
public JsonElement parse(JsonReader json) throws JsonParseException { [EOL]     boolean lenient = json.isLenient(); [EOL]     json.setLenient(true); [EOL]     try { [EOL]         return Streams.parse(json); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         if (e.getCause() instanceof EOFException) { [EOL]             return JsonNull.createJsonNull(); [EOL]         } [EOL]         throw e; [EOL]     } finally { [EOL]         json.setLenient(lenient); [EOL]     } [EOL] }
public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner) { [EOL]     this.rawType = rawType; [EOL]     this.actualTypeArguments = actualTypeArguments; [EOL]     this.owner = owner; [EOL] }
Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) { [EOL]     this.serializationStrategy = serializationStrategy; [EOL]     this.deserializationStrategy = deserializationStrategy; [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL]     this.objectConstructor = objectConstructor; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.deserializers = deserializers; [EOL]     this.generateNonExecutableJson = generateNonExecutableGson; [EOL]     this.htmlSafe = htmlSafe; [EOL]     this.prettyPrinting = prettyPrinting; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) { [EOL]     this.serializationStrategy = serializationStrategy; [EOL]     this.deserializationStrategy = deserializationStrategy; [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL]     this.objectConstructor = objectConstructor; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.deserializers = deserializers; [EOL]     this.generateNonExecutableJson = generateNonExecutableGson; [EOL]     this.htmlSafe = htmlSafe; [EOL]     this.prettyPrinting = prettyPrinting; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) { [EOL]     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
private static ExclusionStrategy createExclusionStrategy(double version) { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY); [EOL]     strategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY); [EOL]     strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY); [EOL]     if (version != VersionConstants.IGNORE_VERSIONS) { [EOL]         strategies.add(new VersionExclusionStrategy(version)); [EOL]     } [EOL]     return new DisjunctionExclusionStrategy(strategies); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(String json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     StringReader reader = new StringReader(json); [EOL]     T target = (T) fromJson(reader, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException { [EOL]     return this.<T>fromJson(new JsonReader(json), typeOfT); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException { [EOL]     return this.<T>fromJson(new JsonReader(json), typeOfT); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException { [EOL]     boolean oldLenient = reader.isLenient(); [EOL]     reader.setLenient(true); [EOL]     try { [EOL]         JsonElement root = Streams.parse(reader); [EOL]         return (T) fromJson(root, typeOfT); [EOL]     } finally { [EOL]         reader.setLenient(oldLenient); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException { [EOL]     boolean oldLenient = reader.isLenient(); [EOL]     reader.setLenient(true); [EOL]     try { [EOL]         JsonElement root = Streams.parse(reader); [EOL]         return (T) fromJson(root, typeOfT); [EOL]     } finally { [EOL]         reader.setLenient(oldLenient); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializationContext context = new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers, objectConstructor); [EOL]     T target = (T) context.deserialize(json, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
@SuppressWarnings("unchecked") [EOL] public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializationContext context = new JsonDeserializationContextDefault(createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers, objectConstructor); [EOL]     T target = (T) context.deserialize(json, typeOfT); [EOL]     return target; [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
private static void add(Map<Class<?>, Class<?>> forward, Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) { [EOL]     forward.put(key, value); [EOL]     backward.put(value, key); [EOL] }
public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies) { [EOL]     if (fieldNamingPolicies == null) { [EOL]         throw new NullPointerException("naming policies can not be null."); [EOL]     } [EOL]     this.fieldPolicies = fieldNamingPolicies; [EOL] }
public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies) { [EOL]     if (fieldNamingPolicies == null) { [EOL]         throw new NullPointerException("naming policies can not be null."); [EOL]     } [EOL]     this.fieldPolicies = fieldNamingPolicies; [EOL] }
public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies) { [EOL]     if (fieldNamingPolicies == null) { [EOL]         throw new NullPointerException("naming policies can not be null."); [EOL]     } [EOL]     this.fieldPolicies = fieldNamingPolicies; [EOL] }
public TypeInfoCollection(Type collectionType) { [EOL]     if (!(collectionType instanceof ParameterizedType)) { [EOL]         throw new IllegalArgumentException("Collection objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL]     TypeInfo rawType = new TypeInfo(collectionType); [EOL]     Preconditions.checkArgument(Collection.class.isAssignableFrom(rawType.getRawClass())); [EOL]     this.collectionType = (ParameterizedType) collectionType; [EOL] }
public TypeInfoCollection(Type collectionType) { [EOL]     if (!(collectionType instanceof ParameterizedType)) { [EOL]         throw new IllegalArgumentException("Collection objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL]     TypeInfo rawType = new TypeInfo(collectionType); [EOL]     Preconditions.checkArgument(Collection.class.isAssignableFrom(rawType.getRawClass())); [EOL]     this.collectionType = (ParameterizedType) collectionType; [EOL] }
public Type getElementType() { [EOL]     return collectionType.getActualTypeArguments()[0]; [EOL] }
public Type getElementType() { [EOL]     return collectionType.getActualTypeArguments()[0]; [EOL] }
public Type getElementType() { [EOL]     return collectionType.getActualTypeArguments()[0]; [EOL] }
public Type getElementType() { [EOL]     return collectionType.getActualTypeArguments()[0]; [EOL] }
JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor) { [EOL]     this.navigatorFactory = navigatorFactory; [EOL]     this.deserializers = deserializers; [EOL]     this.objectConstructor = objectConstructor; [EOL] }
ObjectConstructor getObjectConstructor() { [EOL]     return objectConstructor; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(jsonObject, typeOfT, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }
@SuppressWarnings("unchecked") [EOL] private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(json, typeOfT, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true)); [EOL]     on.accept(visitor); [EOL]     Object target = visitor.getTarget(); [EOL]     return (T) target; [EOL] }
@SuppressWarnings("unchecked") [EOL] private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(json, typeOfT, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true)); [EOL]     on.accept(visitor); [EOL]     Object target = visitor.getTarget(); [EOL]     return (T) target; [EOL] }
public GenericArrayTypeImpl(Type genericComponentType) { [EOL]     this.genericComponentType = genericComponentType; [EOL] }
public GenericArrayTypeImpl(Type genericComponentType) { [EOL]     this.genericComponentType = genericComponentType; [EOL] }
public JsonDeserializationVisitor(JsonElement json, Type targetType, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context) { [EOL]     Preconditions.checkNotNull(json); [EOL]     this.targetType = targetType; [EOL]     this.factory = factory; [EOL]     this.objectConstructor = objectConstructor; [EOL]     this.deserializers = deserializers; [EOL]     this.json = json; [EOL]     this.context = context; [EOL]     this.constructed = false; [EOL] }
public T getTarget() { [EOL]     if (!constructed) { [EOL]         target = constructTarget(); [EOL]         constructed = true; [EOL]     } [EOL]     return target; [EOL] }
public T getTarget() { [EOL]     if (!constructed) { [EOL]         target = constructTarget(); [EOL]         constructed = true; [EOL]     } [EOL]     return target; [EOL] }
public void start(ObjectTypePair node) { [EOL] }
public void end(ObjectTypePair node) { [EOL] }
@SuppressWarnings("unchecked") [EOL] public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]     if (pair == null) { [EOL]         return false; [EOL]     } [EOL]     Object value = invokeCustomDeserializer(json, pair); [EOL]     target = (T) value; [EOL]     constructed = true; [EOL]     return true; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]     if (pair == null) { [EOL]         return false; [EOL]     } [EOL]     Object value = invokeCustomDeserializer(json, pair); [EOL]     target = (T) value; [EOL]     constructed = true; [EOL]     return true; [EOL] }
protected Object invokeCustomDeserializer(JsonElement element, Pair<JsonDeserializer<?>, ObjectTypePair> pair) { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Type objType = pair.second.type; [EOL]     return (pair.first).deserialize(element, objType, context); [EOL] }
protected Object invokeCustomDeserializer(JsonElement element, Pair<JsonDeserializer<?>, ObjectTypePair> pair) { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Type objType = pair.second.type; [EOL]     return (pair.first).deserialize(element, objType, context); [EOL] }
protected Object invokeCustomDeserializer(JsonElement element, Pair<JsonDeserializer<?>, ObjectTypePair> pair) { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Type objType = pair.second.type; [EOL]     return (pair.first).deserialize(element, objType, context); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T construct(Type typeOfT) { [EOL]     InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT); [EOL]     if (creator != null) { [EOL]         return creator.createInstance(typeOfT); [EOL]     } [EOL]     return (T) constructWithNoArgConstructor(typeOfT); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T construct(Type typeOfT) { [EOL]     InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT); [EOL]     if (creator != null) { [EOL]         return creator.createInstance(typeOfT); [EOL]     } [EOL]     return (T) constructWithNoArgConstructor(typeOfT); [EOL] }
private <T> T constructWithNoArgConstructor(Type typeOfT) { [EOL]     try { [EOL]         Constructor<T> constructor = getNoArgsConstructor(typeOfT); [EOL]         if (constructor == null) { [EOL]             throw new RuntimeException(("No-args constructor for " + typeOfT + " does not exist. " + "Register an InstanceCreator with Gson for this type to fix this problem.")); [EOL]         } [EOL]         return constructor.newInstance(); [EOL]     } catch (InstantiationException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } [EOL] }
@SuppressWarnings({ "unchecked", "cast" }) [EOL] private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) { [EOL]     TypeInfo typeInfo = new TypeInfo(typeOfT); [EOL]     Class<T> clazz = (Class<T>) typeInfo.getRawClass(); [EOL]     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors(); [EOL]     AccessibleObject.setAccessible(declaredConstructors, true); [EOL]     for (Constructor<T> constructor : declaredConstructors) { [EOL]         if (constructor.getParameterTypes().length == 0) { [EOL]             return constructor; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public GsonBuilder() { [EOL]     exclusionStrategies.add(Gson.DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY); [EOL]     exclusionStrategies.add(Gson.DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY); [EOL]     ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS; [EOL]     serializeInnerClasses = true; [EOL]     prettyPrinting = false; [EOL]     escapeHtmlChars = true; [EOL]     modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY; [EOL]     excludeFieldsWithoutExposeAnnotation = false; [EOL]     longSerializationPolicy = LongSerializationPolicy.DEFAULT; [EOL]     fieldNamingPolicy = Gson.DEFAULT_NAMING_POLICY; [EOL]     instanceCreators = new ParameterizedTypeHandlerMap<InstanceCreator<?>>(); [EOL]     serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     deserializers = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>(); [EOL]     serializeNulls = false; [EOL]     dateStyle = DateFormat.DEFAULT; [EOL]     timeStyle = DateFormat.DEFAULT; [EOL]     serializeSpecialFloatingPointValues = false; [EOL]     generateNonExecutableJson = false; [EOL] }
public GsonBuilder serializeSpecialFloatingPointValues() { [EOL]     this.serializeSpecialFloatingPointValues = true; [EOL]     return this; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target.toLowerCase(); [EOL] }
public VersionExclusionStrategy(double version) { [EOL]     Preconditions.checkArgument(version >= 0.0D); [EOL]     this.version = version; [EOL] }
public VersionExclusionStrategy(double version) { [EOL]     Preconditions.checkArgument(version >= 0.0D); [EOL]     this.version = version; [EOL] }
public VersionExclusionStrategy(double version) { [EOL]     Preconditions.checkArgument(version >= 0.0D); [EOL]     this.version = version; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class)); [EOL] }
private boolean isValidVersion(Since since, Until until) { [EOL]     return (isValidSince(since) && isValidUntil(until)); [EOL] }
private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public CamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     Preconditions.checkNotNull(separatorString); [EOL]     Preconditions.checkArgument(!"".equals(separatorString)); [EOL]     this.separatorString = separatorString; [EOL] }
public CamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     Preconditions.checkNotNull(separatorString); [EOL]     Preconditions.checkArgument(!"".equals(separatorString)); [EOL]     this.separatorString = separatorString; [EOL] }
public CamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     Preconditions.checkNotNull(separatorString); [EOL]     Preconditions.checkArgument(!"".equals(separatorString)); [EOL]     this.separatorString = separatorString; [EOL] }
public final Class<?> getWrappedClass() { [EOL]     return Primitives.wrap(rawClass); [EOL] }
public final Class<?> getWrappedClass() { [EOL]     return Primitives.wrap(rawClass); [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
private static int getMaxCacheSize() { [EOL]     final int defaultMaxCacheSize = 2000; [EOL]     try { [EOL]         String propertyValue = System.getProperty(MAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize)); [EOL]         return Integer.parseInt(propertyValue); [EOL]     } catch (NumberFormatException e) { [EOL]         return defaultMaxCacheSize; [EOL]     } [EOL] }
private static int getMaxCacheSize() { [EOL]     final int defaultMaxCacheSize = 2000; [EOL]     try { [EOL]         String propertyValue = System.getProperty(MAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize)); [EOL]         return Integer.parseInt(propertyValue); [EOL]     } catch (NumberFormatException e) { [EOL]         return defaultMaxCacheSize; [EOL]     } [EOL] }
private static int getMaxCacheSize() { [EOL]     final int defaultMaxCacheSize = 2000; [EOL]     try { [EOL]         String propertyValue = System.getProperty(MAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize)); [EOL]         return Integer.parseInt(propertyValue); [EOL]     } catch (NumberFormatException e) { [EOL]         return defaultMaxCacheSize; [EOL]     } [EOL] }
public String getName() { [EOL]     return name; [EOL] }
public String getName() { [EOL]     return name; [EOL] }
public <T extends Annotation> T getAnnotation(Class<T> annotation) { [EOL]     return getAnnotationFromArray(getAnnotations(), annotation); [EOL] }
public <T extends Annotation> T getAnnotation(Class<T> annotation) { [EOL]     return getAnnotationFromArray(getAnnotations(), annotation); [EOL] }
public <T extends Annotation> T getAnnotation(Class<T> annotation) { [EOL]     return getAnnotationFromArray(getAnnotations(), annotation); [EOL] }
public Collection<Annotation> getAnnotations() { [EOL]     if (annotations == null) { [EOL]         Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name); [EOL]         annotations = ANNOTATION_CACHE.getElement(key); [EOL]         if (annotations == null) { [EOL]             annotations = Collections.unmodifiableCollection(Arrays.asList(field.getAnnotations())); [EOL]             ANNOTATION_CACHE.addElement(key, annotations); [EOL]         } [EOL]     } [EOL]     return annotations; [EOL] }
public Collection<Annotation> getAnnotations() { [EOL]     if (annotations == null) { [EOL]         Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name); [EOL]         annotations = ANNOTATION_CACHE.getElement(key); [EOL]         if (annotations == null) { [EOL]             annotations = Collections.unmodifiableCollection(Arrays.asList(field.getAnnotations())); [EOL]             ANNOTATION_CACHE.addElement(key, annotations); [EOL]         } [EOL]     } [EOL]     return annotations; [EOL] }
void set(Object instance, Object value) throws IllegalAccessException { [EOL]     field.set(instance, value); [EOL] }
void set(Object instance, Object value) throws IllegalAccessException { [EOL]     field.set(instance, value); [EOL] }
void set(Object instance, Object value) throws IllegalAccessException { [EOL]     field.set(instance, value); [EOL] }
boolean isSynthetic() { [EOL]     return isSynthetic; [EOL] }
boolean isSynthetic() { [EOL]     return isSynthetic; [EOL] }
@Deprecated [EOL] Field getFieldObject() { [EOL]     return field; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] private static <T extends Annotation> T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation) { [EOL]     for (Annotation a : annotations) { [EOL]         if (a.annotationType() == annotation) { [EOL]             return (T) a; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Number number) { [EOL]     setValue(number); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public Number getAsNumber() { [EOL]     return value instanceof String ? stringToNumber((String) value) : (Number) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public Number getAsNumber() { [EOL]     return value instanceof String ? stringToNumber((String) value) : (Number) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public Number getAsNumber() { [EOL]     return value instanceof String ? stringToNumber((String) value) : (Number) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public Number getAsNumber() { [EOL]     return value instanceof String ? stringToNumber((String) value) : (Number) value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public BigInteger getAsBigInteger() { [EOL]     throw new UnsupportedOperationException(); [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public void add(String property, JsonElement value) { [EOL]     Preconditions.checkArgument(property != null); [EOL]     if (value == null) { [EOL]         value = JsonNull.createJsonNull(); [EOL]     } [EOL]     members.put(property, value); [EOL] }
public void add(String property, JsonElement value) { [EOL]     Preconditions.checkArgument(property != null); [EOL]     if (value == null) { [EOL]         value = JsonNull.createJsonNull(); [EOL]     } [EOL]     members.put(property, value); [EOL] }
public void add(String property, JsonElement value) { [EOL]     Preconditions.checkArgument(property != null); [EOL]     if (value == null) { [EOL]         value = JsonNull.createJsonNull(); [EOL]     } [EOL]     members.put(property, value); [EOL] }
public JsonElement remove(String property) { [EOL]     return members.remove(property); [EOL] }
public JsonElement remove(String property) { [EOL]     return members.remove(property); [EOL] }
public boolean has(String memberName) { [EOL]     return members.containsKey(memberName); [EOL] }
public boolean has(String memberName) { [EOL]     return members.containsKey(memberName); [EOL] }
public JsonElement get(String memberName) { [EOL]     if (members.containsKey(memberName)) { [EOL]         JsonElement member = members.get(memberName); [EOL]         return member == null ? JsonNull.createJsonNull() : member; [EOL]     } [EOL]     return null; [EOL] }
public JsonElement get(String memberName) { [EOL]     if (members.containsKey(memberName)) { [EOL]         JsonElement member = members.get(memberName); [EOL]         return member == null ? JsonNull.createJsonNull() : member; [EOL]     } [EOL]     return null; [EOL] }
public JsonElement get(String memberName) { [EOL]     if (members.containsKey(memberName)) { [EOL]         JsonElement member = members.get(memberName); [EOL]         return member == null ? JsonNull.createJsonNull() : member; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
