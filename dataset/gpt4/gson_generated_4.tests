public void startVisitingObject_withNonNullObject_assignsNewJsonObjectToRoot() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.startVisitingObject(new Object()); [EOL] assertNotNull(writer.getAssignedRoot()); [EOL] assertTrue(writer.getAssignedRoot() instanceof JsonObject); [EOL] }
public void testVisitObjectFieldWithNullFieldAndSerializeNullsTrue() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext(); [EOL] context.serializeNulls = true; [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithNonNullField() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext(); [EOL] context.serializeNulls = false; [EOL] when(f.get(obj)).thenReturn(new Object()); // Assuming getFieldValue uses f.get() [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldWithNullFieldAndSerializeNullsFalse() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext(); [EOL] context.serializeNulls = false; [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] }
public void testVisitObjectFieldThrowsCircularReferenceException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonSerializationContext context = new JsonSerializationContext(); [EOL] when(f.get(obj)).thenThrow(new CircularReferenceException()); [EOL] try { [EOL] context.visitObjectField(f, typeOfF, obj); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void testAddChildAsElementWithValidFieldAndElement() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] JsonElement childElement = new JsonPrimitive("testValue"); [EOL] JsonElement root = new JsonObject(); [EOL] FieldNamingStrategy2 namingPolicy = mock(FieldNamingStrategy2.class); [EOL] when(namingPolicy.translateName(f)).thenReturn("translatedName"); [EOL] Gson gson = new GsonBuilder().create(); [EOL] gson.addChildAsElement(f, childElement); [EOL] assertTrue(root.getAsJsonObject().has("translatedName")); [EOL] assertEquals(childElement, root.getAsJsonObject().get("translatedName")); [EOL] }
public void testAddChildAsElementWithNullField() { [EOL] FieldAttributes f = null; [EOL] JsonElement childElement = new JsonPrimitive("testValue"); [EOL] JsonElement root = new JsonObject(); [EOL] Gson gson = new GsonBuilder().create(); [EOL] try { [EOL] gson.addChildAsElement(f, childElement); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAddChildAsElementWithNullElement() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] JsonElement childElement = null; [EOL] JsonElement root = new JsonObject(); [EOL] FieldNamingStrategy2 namingPolicy = mock(FieldNamingStrategy2.class); [EOL] when(namingPolicy.translateName(f)).thenReturn("translatedName"); [EOL] Gson gson = new GsonBuilder().create(); [EOL] gson.addChildAsElement(f, childElement); [EOL] assertTrue(root.getAsJsonObject().has("translatedName")); [EOL] assertNull(root.getAsJsonObject().get("translatedName")); [EOL] }
public void testAddAsArrayElementWithNullObject() { [EOL] ObjectTypePair elementTypePair = new ObjectTypePair(null, null, false); [EOL] JsonArray root = new JsonArray(); [EOL] addAsArrayElement(elementTypePair); // Assuming this method can be accessed or is made accessible for testing [EOL] assertTrue(root.size() == 1); [EOL] assertTrue(root.get(0).isJsonNull()); [EOL] }
public void testAddAsArrayElementWithNonNullObject() { [EOL] JsonElement nonNullElement = new JsonPrimitive("test"); [EOL] ObjectTypePair elementTypePair = new ObjectTypePair(nonNullElement, nonNullElement.getClass(), false); [EOL] JsonArray root = new JsonArray(); [EOL] addAsArrayElement(elementTypePair); // Assuming this method can be accessed or is made accessible for testing [EOL] assertTrue(root.size() == 1); [EOL] assertEquals(nonNullElement, root.get(0)); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndNullField() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(null); [EOL] serializeNulls = true; [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndNonNullFieldWithCustomSerializer() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement customSerializedElement = new JsonObject(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(new Object()); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(customSerializedElement); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndNonNullFieldWithoutCustomSerializer() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenReturn(new Object()); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(null); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithNonJsonObjectRoot() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(false); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerWithIllegalAccessException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenThrow(IllegalAccessException.class); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerWithCircularReferenceException() throws Exception { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] CircularReferenceException circularReferenceException = new CircularReferenceException(); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(f.get(parent)).thenThrow(circularReferenceException); [EOL] when(circularReferenceException.createDetailedException(f)).thenReturn(new JsonIOException("Circular reference")); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected JsonIOException"); [EOL] } catch (JsonIOException e) { [EOL] } [EOL] }
public void testSetLenientTrue() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] assertTrue(jsonReader.isLenient()); [EOL] }
public void testSetLenientFalse() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(false); [EOL] assertFalse(jsonReader.isLenient()); [EOL] }
public void testIsLenientTrue() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] assertTrue(jsonReader.isLenient()); [EOL] }
public void testIsLenientFalse() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(false); [EOL] assertFalse(jsonReader.isLenient()); [EOL] }
public void testSetHtmlSafeTrue() { [EOL] Gson gson = new Gson(); [EOL] gson.setHtmlSafe(true); [EOL] assertTrue(gson.htmlSafe); [EOL] }
public void testSetHtmlSafeFalse() { [EOL] Gson gson = new Gson(); [EOL] gson.setHtmlSafe(false); [EOL] assertFalse(gson.htmlSafe); [EOL] }
public void testIsHtmlSafe_True() { [EOL] Gson gson = new GsonBuilder().disableHtmlEscaping().create(); [EOL] assertFalse(gson.isHtmlSafe()); [EOL] }
public void testIsHtmlSafe_False() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] assertTrue(gson.isHtmlSafe()); [EOL] }
public void testBeginObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] JsonWriter result = writer.beginObject(); [EOL] assertNotNull(result); [EOL] assertEquals(JsonScope.EMPTY_OBJECT, result.peek()); [EOL] }

public void testEndObject_EmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.endObject(); [EOL] assertEquals("{}", writer.toString()); [EOL] } [EOL] public void testEndObject_NonEmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name").value("value"); [EOL] writer.endObject(); [EOL] assertEquals("{\"name\":\"value\"}", writer.toString()); [EOL] } [EOL] public void testEndObject_InvalidState() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.endObject(); [EOL] fail("Should throw IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testShouldSkipField_SyntheticFieldAndSkipEnabled() { [EOL] Excluder excluder = Excluder.DEFAULT.withSkipSyntheticFields(true); [EOL] FieldAttributes syntheticFieldAttributes = mock(FieldAttributes.class); [EOL] when(syntheticFieldAttributes.isSynthetic()).thenReturn(true); [EOL] boolean result = excluder.shouldSkipField(syntheticFieldAttributes); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_SyntheticFieldAndSkipDisabled() { [EOL] Excluder excluder = Excluder.DEFAULT.withSkipSyntheticFields(false); [EOL] FieldAttributes syntheticFieldAttributes = mock(FieldAttributes.class); [EOL] when(syntheticFieldAttributes.isSynthetic()).thenReturn(true); [EOL] boolean result = excluder.shouldSkipField(syntheticFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_NonSyntheticField() { [EOL] Excluder excluder = Excluder.DEFAULT.withSkipSyntheticFields(true); [EOL] FieldAttributes nonSyntheticFieldAttributes = mock(FieldAttributes.class); [EOL] when(nonSyntheticFieldAttributes.isSynthetic()).thenReturn(false); [EOL] boolean result = excluder.shouldSkipField(nonSyntheticFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipFieldWithSkippableModifier() { [EOL] FieldAttributes mockFieldAttributes = Mockito.mock(FieldAttributes.class); [EOL] int[] modifiers = new int[] { Modifier.PUBLIC, Modifier.STATIC }; [EOL] Excluder excluder = new Excluder().withModifiers(modifiers); [EOL] Mockito.when(mockFieldAttributes.hasModifier(Modifier.PUBLIC)).thenReturn(true); [EOL] boolean result = excluder.shouldSkipField(mockFieldAttributes); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipFieldWithNonSkippableModifier() { [EOL] FieldAttributes mockFieldAttributes = Mockito.mock(FieldAttributes.class); [EOL] int[] modifiers = new int[] { Modifier.PUBLIC, Modifier.STATIC }; [EOL] Excluder excluder = new Excluder().withModifiers(modifiers); [EOL] Mockito.when(mockFieldAttributes.hasModifier(Modifier.PRIVATE)).thenReturn(false); [EOL] boolean result = excluder.shouldSkipField(mockFieldAttributes); [EOL] assertFalse(result); [EOL] }
public void testEscapeJsonString_noSpecialCharacters() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("normalString", out); [EOL] assertEquals("normalString", out.toString()); [EOL] }
public void testEscapeJsonString_withNewLine() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\nNewLine", out); [EOL] assertEquals("stringWith\\nNewLine", out.toString()); [EOL] }
public void testEscapeJsonString_withTab() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\tTab", out); [EOL] assertEquals("stringWith\\tTab", out.toString()); [EOL] }
public void testEscapeJsonString_withBackspace() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\bBackspace", out); [EOL] assertEquals("stringWith\\bBackspace", out.toString()); [EOL] }
public void testEscapeJsonString_withFormFeed() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\fFormFeed", out); [EOL] assertEquals("stringWith\\fFormFeed", out.toString()); [EOL] }
public void testEscapeJsonString_withCarriageReturn() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\rCarriageReturn", out); [EOL] assertEquals("stringWith\\rCarriageReturn", out.toString()); [EOL] }
public void testEscapeJsonString_withBackslash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\\Backslash", out); [EOL] assertEquals("stringWith\\\\Backslash", out.toString()); [EOL] }
public void testEscapeJsonString_withForwardSlash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith/ForwardSlash", out); [EOL] assertEquals("stringWith\\/ForwardSlash", out.toString()); [EOL] }
public void testEscapeJsonString_withDoubleQuote() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\"DoubleQuote", out); [EOL] assertEquals("stringWith\\\"DoubleQuote", out.toString()); [EOL] }
public void testEscapeJsonString_withControlCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u0001ControlChar", out); [EOL] assertEquals("stringWith\\u0001ControlChar", out.toString()); [EOL] }
public void testEscapeJsonString_withNonControlCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u007FNonControlChar", out); [EOL] assertEquals("stringWith\\u007FNonControlChar", out.toString()); [EOL] }
public void testAppendHexJavaScriptRepresentationWithNonSupplementaryCodePoint() throws IOException { [EOL] StringBuilder out = new StringBuilder(); [EOL] int codePoint = 'A'; // Code point for 'A' is not a supplementary character [EOL] appendHexJavaScriptRepresentation(codePoint, out); [EOL] assertEquals("\\u0041", out.toString()); [EOL] } [EOL] public void testAppendHexJavaScriptRepresentationWithSupplementaryCodePoint() throws IOException { [EOL] StringBuilder out = new StringBuilder(); [EOL] int codePoint = 0x1D11E; // Code point for musical symbol G clef [EOL] appendHexJavaScriptRepresentation(codePoint, out); [EOL] assertEquals("\\ud834\\udd1e", out.toString()); [EOL] }
public void testHashCode_bothMembersNull() { [EOL] Pair<Object, Object> pair = new Pair<>(null, null); [EOL] int expectedHashCode = 17 * 0 + 17 * 0; [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] }
public void testHashCode_firstMemberNotNull() { [EOL] Pair<Object, Object> pair = new Pair<>("first", null); [EOL] int expectedHashCode = 17 * "first".hashCode() + 17 * 0; [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] }
public void testHashCode_secondMemberNotNull() { [EOL] Pair<Object, Object> pair = new Pair<>(null, "second"); [EOL] int expectedHashCode = 17 * 0 + 17 * "second".hashCode(); [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] }
public void testHashCode_bothMembersNotNull() { [EOL] Pair<Object, Object> pair = new Pair<>("first", "second"); [EOL] int expectedHashCode = 17 * "first".hashCode() + 17 * "second".hashCode(); [EOL] assertEquals(expectedHashCode, pair.hashCode()); [EOL] }
public void testEquals_withNonPairObject() { [EOL] Pair<Integer, String> pair = new Pair<>(1, "test"); [EOL] Object nonPairObject = new Object(); [EOL] boolean result = pair.equals(nonPairObject); [EOL] assertFalse(result); [EOL] } [EOL] public void testEquals_withNull() { [EOL] Pair<Integer, String> pair = new Pair<>(1, "test"); [EOL] boolean result = pair.equals(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testEquals_withDifferentFirst() { [EOL] Pair<Integer, String> pair1 = new Pair<>(1, "test"); [EOL] Pair<Integer, String> pair2 = new Pair<>(2, "test"); [EOL] boolean result = pair1.equals(pair2); [EOL] assertFalse(result); [EOL] } [EOL] public void testEquals_withDifferentSecond() { [EOL] Pair<Integer, String> pair1 = new Pair<>(1, "test"); [EOL] Pair<Integer, String> pair2 = new Pair<>(1, "different"); [EOL] boolean result = pair1.equals(pair2); [EOL] assertFalse(result); [EOL] } [EOL] public void testEquals_withSamePairs() { [EOL] Pair<Integer, String> pair1 = new Pair<>(1, "test"); [EOL] Pair<Integer, String> pair2 = new Pair<>(1, "test"); [EOL] boolean result = pair1.equals(pair2); [EOL] assertTrue(result); [EOL] } [EOL] public void testEquals_withItself() { [EOL] Pair<Integer, String> pair = new Pair<>(1, "test"); [EOL] boolean result = pair.equals(pair); [EOL] assertTrue(result); [EOL] } [EOL] public void testEquals_withBothNull() { [EOL] Pair<Integer, String> pair1 = new Pair<>(null, null); [EOL] Pair<Integer, String> pair2 = new Pair<>(null, null); [EOL] boolean result = pair1.equals(pair2); [EOL] assertTrue(result); [EOL] } [EOL] public void testEquals_withFirstNull() { [EOL] Pair<Integer, String> pair1 = new Pair<>(null, "test"); [EOL] Pair<Integer, String> pair2 = new Pair<>(1, "test"); [EOL] boolean result = pair1.equals(pair2); [EOL] assertFalse(result); [EOL] } [EOL] public void testEquals_withSecondNull() { [EOL] Pair<Integer, String> pair1 = new Pair<>(1, null); [EOL] Pair<Integer, String> pair2 = new Pair<>(1, "test"); [EOL] boolean result = pair1.equals(pair2); [EOL] assertFalse(result); [EOL] }
public void testEqualWithBothNull() { [EOL] boolean result = equal(null, null); [EOL] assertTrue(result); [EOL] }
public void testEqualWithFirstNull() { [EOL] boolean result = equal(null, new Object()); [EOL] assertFalse(result); [EOL] }
public void testEqualWithSecondNull() { [EOL] boolean result = equal(new Object(), null); [EOL] assertFalse(result); [EOL] }
public void testEqualWithDifferentObjects() { [EOL] Object a = new Object(); [EOL] Object b = new Object(); [EOL] boolean result = equal(a, b); [EOL] assertFalse(result); [EOL] }
public void testEqualWithSameObject() { [EOL] Object a = new Object(); [EOL] boolean result = equal(a, a); [EOL] assertTrue(result); [EOL] }
public void testEqualWithEqualObjects() { [EOL] Object a = "test"; [EOL] Object b = "test"; [EOL] boolean result = equal(a, b); [EOL] assertTrue(result); [EOL] }
public void testJsonReaderConstructorWithNullReader() { [EOL] try { [EOL] new JsonReader(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("in == null", e.getMessage()); [EOL] } [EOL] }
public void testJsonReaderConstructorWithNonNullReader() { [EOL] Reader reader = new StringReader("{}"); [EOL] JsonReader jsonReader = new JsonReader(reader); [EOL] assertNotNull(jsonReader); [EOL] }
public void testSetLenientTrue() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.setLenient(true); [EOL] assertTrue(jsonReader.isLenient()); [EOL] } [EOL] public void testSetLenientFalse() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.setLenient(false); [EOL] assertFalse(jsonReader.isLenient()); [EOL] }
public void testBeginArrayWithExpectedToken() throws IOException { [EOL] String json = "[1, 2, 3]"; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] reader.beginArray(); [EOL] assertTrue(reader.hasNext()); [EOL] }
public void testBeginArrayWithUnexpectedToken() { [EOL] String json = "{ \"key\": [1, 2, 3] }"; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] try { [EOL] reader.beginArray(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testBeginArrayWithEmptyReader() { [EOL] String json = ""; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] try { [EOL] reader.beginArray(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testEndArrayWithExpectedEndArrayToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.endArray(); [EOL] } [EOL] public void testEndArrayWithoutExpectedEndArrayToken() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[")); [EOL] try { [EOL] jsonReader.endArray(); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }

public void testBeginObject_ExpectBeginObject() throws IOException { [EOL] String json = "{"; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] reader.beginObject(); [EOL] assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testBeginObject_ExpectIncorrectToken() throws IOException { [EOL] String json = "["; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] try { [EOL] reader.beginObject(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testBeginObject_WithLenientReader() throws IOException { [EOL] String json = "{"; [EOL] JsonReader reader = new JsonReader(new StringReader(json)); [EOL] reader.setLenient(true); [EOL] reader.beginObject(); [EOL] assertTrue(reader.isLenient()); [EOL] assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void endObject() throws IOException { [EOL] expect(JsonToken.END_OBJECT); [EOL] }
private void testExpectWithCorrectToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.beginArray(); // This will set the token to JsonToken.BEGIN_ARRAY [EOL] jsonReader.expect(JsonToken.BEGIN_ARRAY); // Expecting the correct token [EOL] } [EOL] private void testExpectWithIncorrectToken() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.beginArray(); // This will set the token to JsonToken.BEGIN_ARRAY [EOL] try { [EOL] jsonReader.expect(JsonToken.END_ARRAY); // Expecting the incorrect token [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected END_ARRAY but was BEGIN_ARRAY", e.getMessage()); [EOL] } [EOL] } [EOL] private void testExpectWithEndOfDocument() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); // This will set the token to JsonToken.BEGIN_ARRAY [EOL] jsonReader.endArray(); // This will set the token to JsonToken.END_DOCUMENT [EOL] try { [EOL] jsonReader.expect(JsonToken.BEGIN_ARRAY); // Expecting a token when it's the end of the document [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected BEGIN_ARRAY but was END_DOCUMENT", e.getMessage()); [EOL] } [EOL] }
public void testHasNextAtEndObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("}")); [EOL] reader.beginObject(); [EOL] reader.endObject(); [EOL] assertFalse(reader.hasNext()); [EOL] }
public void testHasNextAtEndArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("]")); [EOL] reader.beginArray(); [EOL] reader.endArray(); [EOL] assertFalse(reader.hasNext()); [EOL] }
public void testHasNextNotAtEnd() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[true, false]")); [EOL] reader.beginArray(); [EOL] assertTrue(reader.hasNext()); [EOL] }
public void testQuickPeekEmptyDocumentLenient() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.beginArray(); [EOL] jsonReader.endArray(); [EOL] assertEquals(JsonToken.END_DOCUMENT, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekEmptyDocumentStrict() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.setLenient(false); [EOL] jsonReader.beginArray(); [EOL] jsonReader.endArray(); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] assertEquals(JsonToken.END_ARRAY, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekNonEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[true]")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextBoolean(); [EOL] assertEquals(JsonToken.END_ARRAY, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.END_OBJECT, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekDanglingName() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekNonEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] jsonReader.nextBoolean(); [EOL] assertEquals(JsonToken.END_OBJECT, jsonReader.quickPeek()); [EOL] }
public void testQuickPeekNonEmptyDocument() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekClosed() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.close(); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testQuickPeekDefaultCase() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")) { [EOL] @Override [EOL] private JsonScope peekStack() { [EOL] return null; // Force default case [EOL] } [EOL] }; [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Expected AssertionError"); [EOL] } catch (AssertionError e) { [EOL] } [EOL] }
public void testConsumeNonExecutePrefixWithNonMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("NonMatchingPrefix")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(0, jsonReader.getPos()); [EOL] }
public void testConsumeNonExecutePrefixWithMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'\nActualJson")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(")]}'".length(), jsonReader.getPos()); [EOL] }
public void testConsumeNonExecutePrefixWithPartialPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.setLimit(")]}'".length() - 1); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(0, jsonReader.getPos()); [EOL] }
public void testConsumeNonExecutePrefixWithExactBuffer() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.setLimit(")]}'".length()); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(")]}'".length(), jsonReader.getPos()); [EOL] }
public void testAdvance() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.beginArray(); // Will set the token [EOL] JsonToken tokenBeforeAdvance = jsonReader.peek(); // Should be JsonToken.NUMBER [EOL] JsonToken result = jsonReader.advance(); // Advance should return the current token [EOL] assertEquals(tokenBeforeAdvance, result); // Check if the advance returned the correct token [EOL] JsonToken tokenAfterAdvance = jsonReader.peek(); // Peek after advance, should not be the same as before [EOL] assertNotEquals(tokenBeforeAdvance, tokenAfterAdvance); // Ensure the token has been advanced [EOL] }
public void testNextNameWithValidName() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] reader.beginObject(); [EOL] String name = reader.nextName(); [EOL] assertEquals("name", name); [EOL] }
public void testNextNameWithInvalidToken() { [EOL] JsonReader reader = new JsonReader(new StringReader("[true]")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextName(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNextBooleanTrue() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] boolean result = reader.nextBoolean(); [EOL] assertTrue(result); [EOL] }
public void testNextBooleanFalse() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("false")); [EOL] boolean result = reader.nextBoolean(); [EOL] assertFalse(result); [EOL] }
public void testNextBooleanInvalid() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("notABoolean")); [EOL] try { [EOL] reader.nextBoolean(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Not a boolean: notABoolean", e.getMessage()); [EOL] } [EOL] }
public void testNextBooleanWithIllegalStateException() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"STRING\"")); [EOL] reader.setLenient(true); [EOL] reader.peek(); // to set the token [EOL] try { [EOL] reader.nextBoolean(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected a boolean but was STRING", e.getMessage()); [EOL] } [EOL] }
public void testNextNullWithNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("null")); [EOL] jsonReader.nextNull(); [EOL] }
public void testNextNullWithNonNullValue() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"notnull\"")); [EOL] try { [EOL] jsonReader.nextNull(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Not a null: notnull", e.getMessage()); [EOL] } [EOL] }
public void testNextNullWithIllegalState() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"null\"")); [EOL] try { [EOL] jsonReader.nextNull(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected null but was STRING", e.getMessage()); [EOL] } [EOL] }
public void testNextDoubleWithValidDouble() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("42.0")); [EOL] reader.setLenient(true); [EOL] double result = reader.nextDouble(); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testNextDoubleWithInvalidState() { [EOL] JsonReader reader = new JsonReader(new StringReader("invalid")); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalStateException, not IOException"); [EOL] } [EOL] }
public void testNextDoubleWithOctalNumber() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("042")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testNextDoubleWithNaNAndLenientOff() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("NaN")); [EOL] reader.setLenient(false); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testNextDoubleWithInfiniteAndLenientOff() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("Infinity")); [EOL] reader.setLenient(false); [EOL] try { [EOL] reader.nextDouble(); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testClose() throws IOException { [EOL] StringReader stringReader = new StringReader("{}"); [EOL] JsonReader jsonReader = new JsonReader(stringReader); [EOL] jsonReader.beginObject(); [EOL] jsonReader.close(); [EOL] try { [EOL] jsonReader.peek(); [EOL] fail("Expected IOException"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testConstructorAndClose() throws IOException { [EOL] StringReader stringReader = new StringReader("{}"); [EOL] JsonReader jsonReader = new JsonReader(stringReader); [EOL] jsonReader.close(); [EOL] }
public void testPeekStack_EmptyStack_ThrowsException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] try { [EOL] jsonReader.peekStack(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testPeekStack_NonEmptyStack_ReturnsTopElement() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.beginArray(); // Pushes JsonScope.EMPTY_ARRAY onto the stack [EOL] assertEquals(JsonScope.EMPTY_ARRAY, jsonReader.peekStack()); [EOL] }
private JsonScope pop() { [EOL] return stack.remove(stack.size() - 1); [EOL] }
public void testPush() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); // This should push JsonScope.EMPTY_ARRAY onto the stack [EOL] assertFalse(jsonReader.getStack().isEmpty()); [EOL] assertEquals(JsonScope.EMPTY_ARRAY, jsonReader.peekStack()); [EOL] }
public void testReplaceTopWithValidNewTop() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); // Push JsonScope.EMPTY_ARRAY onto the stack [EOL] jsonReader.replaceTop(JsonScope.NONEMPTY_ARRAY); // Replace top element of the stack [EOL] assertEquals(JsonScope.NONEMPTY_ARRAY, jsonReader.peekStack()); // Assert the top is replaced [EOL] }
public void testReplaceTopWithInvalidNewTop() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] try { [EOL] jsonReader.replaceTop(null); // Try to replace top with null [EOL] fail("Should have thrown NullPointerException"); // Fail if no exception is thrown [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testNextInArrayFirstElement() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.beginArray(); [EOL] JsonToken token = jsonReader.nextInArray(true); [EOL] assertEquals(JsonToken.NUMBER, token); [EOL] assertEquals(1, jsonReader.nextInt()); [EOL] }
public void testNextInArrayNotFirstElementEndArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] JsonToken token = jsonReader.nextInArray(false); [EOL] assertEquals(JsonToken.END_ARRAY, token); [EOL] }
public void testNextInArrayNotFirstElementComma() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,,2]")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextInt(); [EOL] JsonToken token = jsonReader.nextInArray(false); [EOL] assertEquals(JsonToken.NULL, token); [EOL] }
public void testNextInArrayNotFirstElementSemicolon() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1;2]")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextInt(); [EOL] JsonToken token = jsonReader.nextInArray(false); [EOL] assertEquals(JsonToken.NULL, token); [EOL] }
public void testNextInArrayNotFirstElementUnterminated() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextInt(); [EOL] try { [EOL] jsonReader.nextInArray(false); [EOL] fail("Should have thrown IOException for unterminated array"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testNextInArrayFirstElementEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] JsonToken token = jsonReader.nextInArray(true); [EOL] assertEquals(JsonToken.END_ARRAY, token); [EOL] }
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL] if (firstElement) { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] default: [EOL] pos--; [EOL] } [EOL] } else { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] case ';': [EOL] case ',': [EOL] break; [EOL] default: [EOL] throw syntaxError("Unterminated object"); [EOL] } [EOL] } [EOL] int quote = nextNonWhitespace(); [EOL] switch(quote) { [EOL] case '\'': [EOL] checkLenient(); [EOL] case '"': [EOL] name = nextString((char) quote); [EOL] break; [EOL] default: [EOL] checkLenient(); [EOL] pos--; [EOL] name = nextLiteral(); [EOL] if (name.length() == 0) { [EOL] throw syntaxError("Expected name"); [EOL] } [EOL] } [EOL] replaceTop(JsonScope.DANGLING_NAME); [EOL] hasToken = true; [EOL] return token = JsonToken.NAME; [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
public void testNextValueWithBeginObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{")); [EOL] assertEquals(JsonToken.BEGIN_OBJECT, reader.nextValue()); [EOL] }
public void testNextValueWithBeginArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[")); [EOL] assertEquals(JsonToken.BEGIN_ARRAY, reader.nextValue()); [EOL] }
public void testNextValueWithString() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"string\"")); [EOL] assertEquals(JsonToken.STRING, reader.nextValue()); [EOL] }
public void testNextValueWithSingleQuoteStringLenient() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("'string'")); [EOL] reader.setLenient(true); [EOL] assertEquals(JsonToken.STRING, reader.nextValue()); [EOL] }
public void testNextValueWithLiteral() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] assertEquals(JsonToken.BOOLEAN, reader.nextValue()); [EOL] }
public void testFillBufferWithNonEmptyBuffer() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("content")); [EOL] jsonReader.setLenient(true); [EOL] assertTrue(jsonReader.fillBuffer(1)); // Should return true as buffer gets filled [EOL] assertTrue(jsonReader.fillBuffer(jsonReader.buffer.length)); // Test with buffer size [EOL] }
public void testFillBufferWithEmptyBufferAndEOF() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] assertFalse(jsonReader.fillBuffer(1)); // Should return false as EOF is reached [EOL] }
public void testFillBufferWithPartialBufferRead() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("short")); [EOL] jsonReader.setLenient(true); [EOL] assertTrue(jsonReader.fillBuffer(3)); // Should return true as buffer gets partially filled [EOL] assertTrue(jsonReader.fillBuffer(jsonReader.buffer.length)); // Test with buffer size [EOL] }
public void testNextNonWhitespaceWithWhitespaceCharacters() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\t \n \r")); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSlashAndAsteriskComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/* comment */")); [EOL] reader.setLenient(true); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSlashAndSlashComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("// comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithHash() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("# comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithEOFException() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should have thrown EOFException"); [EOL] } catch (EOFException e) { [EOL] } [EOL] }
private void checkLenient() throws IOException { [EOL] if (!lenient) { [EOL] throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON"); [EOL] } [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
private String nextLiteral() throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] switch(c) { [EOL] case '/': [EOL] case '\\': [EOL] case ';': [EOL] case '#': [EOL] case '=': [EOL] checkLenient(); [EOL] case '{': [EOL] case '}': [EOL] case '[': [EOL] case ']': [EOL] case ':': [EOL] case ',': [EOL] case ' ': [EOL] case '\t': [EOL] case '\f': [EOL] case '\r': [EOL] case '\n': [EOL] pos--; [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start); [EOL] } else { [EOL] builder.append(buffer, start, pos - start); [EOL] return builder.toString(); [EOL] } [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] return builder.toString(); [EOL] }
public void testReadLiteralEmpty() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] try { [EOL] jsonReader.readLiteral(); [EOL] fail("Expected IOException for empty literal"); [EOL] } catch (IOException e) { [EOL] assertEquals("Expected literal value", e.getMessage()); [EOL] } [EOL] }
public void testReadLiteralNonEmpty() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("literal")); [EOL] jsonReader.setLenient(true); [EOL] assertEquals(JsonToken.NULL, jsonReader.readLiteral()); [EOL] assertTrue(jsonReader.hasToken); [EOL] assertEquals("literal", jsonReader.value); [EOL] }
private void decodeLiteral() throws IOException { [EOL] if (value.equalsIgnoreCase("null")) { [EOL] token = JsonToken.NULL; [EOL] } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL] token = JsonToken.BOOLEAN; [EOL] } else { [EOL] try { [EOL] Double.parseDouble(value); [EOL] token = JsonToken.NUMBER; [EOL] } catch (NumberFormatException ignored) { [EOL] checkLenient(); [EOL] token = JsonToken.STRING; [EOL] } [EOL] } [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL] return isAnonymousOrLocal(f.getDeclaredClass()); [EOL] }
public void testMalformedJsonExceptionWithMessage() { [EOL] String message = "Malformed JSON exception occurred"; [EOL] MalformedJsonException exception = new MalformedJsonException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] }
public void testGetFieldNamingPolicyReturnsCorrectInstance() { [EOL] Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.IDENTITY).create(); [EOL] FieldNamingStrategy2 actualFieldNamingPolicy = gson.getFieldNamingPolicy(); [EOL] assertNotNull(actualFieldNamingPolicy); [EOL] assertTrue(actualFieldNamingPolicy instanceof FieldNamingPolicy); [EOL] assertEquals(FieldNamingPolicy.IDENTITY, actualFieldNamingPolicy); [EOL] }
public void testDefaultDateTypeAdapterWithValidPattern() { [EOL] String validPattern = "yyyy-MM-dd"; [EOL] DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(validPattern); [EOL] assertNotNull(adapter.format); [EOL] assertEquals(validPattern, adapter.format.toPattern()); [EOL] }
public void testDefaultDateTypeAdapterWithNullPattern() { [EOL] try { [EOL] new DefaultDateTypeAdapter(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testSerializeWithValidDate() { [EOL] Date src = new Date(); [EOL] Type typeOfSrc = Date.class; [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] SimpleDateFormat format = new SimpleDateFormat(); [EOL] MyObjectUnderTest myObjectUnderTest = new MyObjectUnderTest(format); [EOL] JsonElement result = myObjectUnderTest.serialize(src, typeOfSrc, context); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(format.format(src), result.getAsString()); [EOL] }
public void testDeserializeWithNonJsonPrimitive() { [EOL] JsonElement json = new JsonArray(); // Not a JsonPrimitive [EOL] Type typeOfT = java.sql.Date.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("The date should be a string value", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithValidJsonPrimitive() { [EOL] String dateString = "2021-04-08"; [EOL] JsonElement json = new JsonPrimitive(dateString); [EOL] Type typeOfT = java.sql.Date.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); [EOL] try { [EOL] java.sql.Date result = deserialize(json, typeOfT, context); [EOL] java.sql.Date expected = new java.sql.Date(format.parse(dateString).getTime()); [EOL] assertEquals(expected.toString(), result.toString()); [EOL] } catch (ParseException e) { [EOL] fail("ParseException should not be thrown"); [EOL] } [EOL] }
public void testDeserializeWithInvalidJsonPrimitive() { [EOL] JsonElement json = new JsonPrimitive("not a date"); [EOL] Type typeOfT = java.sql.Date.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] } [EOL] }
public void testSerializeWithValidTime() { [EOL] Time src = new Time(System.currentTimeMillis()); [EOL] Type typeOfSrc = Time.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); [EOL] Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").create(); [EOL] JsonElement result = gson.toJsonTree(src, typeOfSrc); [EOL] String expected = format.format(src); [EOL] assertEquals(expected, result.getAsString()); [EOL] }
public void testDeserializeWithJsonNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Collection result = deserialize(json, typeOfT, context); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEmptyJsonArray() { [EOL] JsonElement json = new JsonArray(); [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Collection result = deserialize(json, typeOfT, context); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithNonEmptyJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("element1")); [EOL] jsonArray.add(JsonNull.INSTANCE); [EOL] jsonArray.add(new JsonPrimitive("element2")); [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext() { [EOL] @Override [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL] return (T) json.getAsString(); [EOL] } [EOL] }; [EOL] Collection result = deserialize(jsonArray, typeOfT, context); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.size()); [EOL] Iterator it = result.iterator(); [EOL] assertEquals("element1", it.next()); [EOL] assertNull(it.next()); [EOL] assertEquals("element2", it.next()); [EOL] }
public void testDeserializeWithBigDecimal() { [EOL] JsonElement json = new JsonPrimitive(new BigDecimal("123.456"));// [EOL] Type typeOfT = BigDecimal.class;// [EOL] JsonDeserializationContext context = new JsonDeserializationContext() {// [EOL] @Override// [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {// [EOL] return null;// [EOL] }// [EOL] };// [EOL] BigDecimal result = deserialize(json, typeOfT, context);// [EOL] assertEquals(new BigDecimal("123.456"), result);// [EOL] }
public void testDeserializeWithNotBigDecimal() { [EOL] JsonElement json = new JsonPrimitive("Not a BigDecimal");// [EOL] Type typeOfT = BigDecimal.class;// [EOL] JsonDeserializationContext context = new JsonDeserializationContext() {// [EOL] @Override// [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {// [EOL] return null;// [EOL] }// [EOL] };// [EOL] try {// [EOL] BigDecimal result = deserialize(json, typeOfT, context);// [EOL] fail("Expected JsonParseException");// [EOL] } catch (JsonParseException e) {// [EOL] }// [EOL] }
public void testToString() { [EOL] BigDecimalTypeAdapter adapter = new BigDecimalTypeAdapter(); [EOL] String expected = "BigDecimalTypeAdapter"; [EOL] String actual = adapter.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSerializeWithNullBigInteger() { [EOL] BigInteger src = null; [EOL] Type typeOfSrc = BigInteger.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertNull(result); [EOL] }
public void testSerializeWithNonNullBigInteger() { [EOL] BigInteger src = new BigInteger("123456789"); [EOL] Type typeOfSrc = BigInteger.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123456789", result.getAsString()); [EOL] }
public void testSerializeWithInteger() { [EOL] Number src = 123; [EOL] Type typeOfSrc = Integer.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testSerializeWithDouble() { [EOL] Number src = 123.45; [EOL] Type typeOfSrc = Double.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123.45", result.getAsString()); [EOL] }
public void testSerializeWithLong() { [EOL] Number src = 123L; [EOL] Type typeOfSrc = Long.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testSerializeWithFloat() { [EOL] Number src = 123.45f; [EOL] Type typeOfSrc = Float.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123.45", result.getAsString()); [EOL] }
public void testCircularReferenceExceptionWithNonNullOffendingNode() { [EOL] Object node = new Object(); [EOL] CircularReferenceException exception = new CircularReferenceException(node); [EOL] assertEquals("circular reference error", exception.getMessage()); [EOL] assertSame(node, exception.getOffendingNode()); [EOL] } [EOL] public void testCircularReferenceExceptionWithNullOffendingNode() { [EOL] CircularReferenceException exception = new CircularReferenceException(null); [EOL] assertEquals("circular reference error", exception.getMessage()); [EOL] assertNull(exception.getOffendingNode()); [EOL] }
public void testCreateDetailedExceptionWithOffendingField() { [EOL] FieldAttributes offendingField = mock(FieldAttributes.class); [EOL] when(offendingField.getName()).thenReturn("fieldName"); [EOL] JsonIOException exception = new JsonIOException("Error message"); [EOL] IllegalStateException result = exception.createDetailedException(offendingField); [EOL] assertEquals("Error message\n  Offending field: fieldName\n", result.getMessage()); [EOL] }
public void testCreateDetailedExceptionWithOffendingNode() { [EOL] JsonElement offendingNode = new JsonPrimitive("offendingNodeValue"); [EOL] JsonIOException exception = new JsonIOException("Error message"); [EOL] exception.offendingNode = offendingNode; [EOL] IllegalStateException result = exception.createDetailedException(null); [EOL] assertEquals("Error message\n  Offending object: offendingNodeValue", result.getMessage()); [EOL] }
public void testCreateDetailedExceptionWithBothOffendingFieldAndNode() { [EOL] FieldAttributes offendingField = mock(FieldAttributes.class); [EOL] when(offendingField.getName()).thenReturn("fieldName"); [EOL] JsonElement offendingNode = new JsonPrimitive("offendingNodeValue"); [EOL] JsonIOException exception = new JsonIOException("Error message"); [EOL] exception.offendingNode = offendingNode; [EOL] IllegalStateException result = exception.createDetailedException(offendingField); [EOL] assertEquals("Error message\n  Offending field: fieldName\n  Offending object: offendingNodeValue", result.getMessage()); [EOL] }
public void testCreateDetailedExceptionWithNoOffendingFieldOrNode() { [EOL] JsonIOException exception = new JsonIOException("Error message"); [EOL] IllegalStateException result = exception.createDetailedException(null); [EOL] assertEquals("Error message", result.getMessage()); [EOL] }
protected TypeToken() { [EOL] this.type = getSuperclassTypeParameter(getClass()); [EOL] this.rawType = (Class<? super T>) getRawType(type); [EOL] }
public void testGetSuperclassTypeParameterWithParameterizedType() { [EOL] class ParameterizedSubclass extends TypeToken<List<String>> {} [EOL] Type result = Gson.getSuperclassTypeParameter(ParameterizedSubclass.class); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedType = (ParameterizedType) result; [EOL] assertEquals(String.class, parameterizedType.getActualTypeArguments()[0]); [EOL] }
public void testGetSuperclassTypeParameterWithNonParameterizedType() { [EOL] try { [EOL] Gson.getSuperclassTypeParameter(String.class); [EOL] fail("RuntimeException expected"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Missing type parameter.", e.getMessage()); [EOL] } [EOL] }
public void testGetRawTypeWithClass() { [EOL] Class<?> result = getRawType(String.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetRawTypeWithParameterizedType() { [EOL] Type type = new TypeToken<Map<String, String>>(){}.getType(); [EOL] Class<?> result = getRawType(type); [EOL] assertEquals(Map.class, result); [EOL] }
public void testGetRawTypeWithGenericArrayType() { [EOL] Type type = new TypeToken<List<String>[]>(){}.getType(); [EOL] Class<?> result = getRawType(type); [EOL] assertTrue(result.isArray()); [EOL] assertEquals(List[].class, result); [EOL] }
public void testGetRawTypeWithUnexpectedType() { [EOL] Type type = new TypeToken<Void>(){}.getType(); [EOL] try { [EOL] getRawType(type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] Type expected = /* some type */; [EOL] instance.setType(expected); [EOL] Type result = instance.getType(); [EOL] assertEquals(expected, result); [EOL] }
public void testTypeInfoMapWithPropertiesClass() { [EOL] Type mapType = Properties.class; [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(String.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithParameterizedType() { [EOL] Type mapType = new TypeToken<Map<String, Integer>>(){}.getType(); [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(Integer.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithInvalidType() { [EOL] Type mapType = String.class; [EOL] try { [EOL] new TypeInfoMap(mapType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteNullElementWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, true, writer); [EOL] verify(writer).nullValue(); [EOL] }
public void testWriteNullElementWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, false, writer); [EOL] verify(writer, never()).nullValue(); [EOL] }
public void testWriteJsonPrimitiveNumber() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(10); [EOL] write(element, true, writer); [EOL] verify(writer).value(10); [EOL] }
public void testWriteJsonPrimitiveBoolean() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(true); [EOL] write(element, true, writer); [EOL] verify(writer).value(true); [EOL] }
public void testWriteJsonPrimitiveString() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] write(element, true, writer); [EOL] verify(writer).value("test"); [EOL] }
public void testWriteJsonArray() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add("string"); [EOL] JsonElement element = jsonArray; [EOL] write(element, true, writer); [EOL] verify(writer).beginArray(); [EOL] verify(writer).value(1); [EOL] verify(writer).value("string"); [EOL] verify(writer).endArray(); [EOL] }
public void testWriteJsonObject() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key1", 1); [EOL] jsonObject.addProperty("key2", "value2"); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).value(1); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value("value2"); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueAndSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, false, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer, never()).name("key1"); [EOL] verify(writer, never()).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteIllegalArgument() { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = mock(JsonElement.class); [EOL] when(element.isJsonNull()).thenReturn(false); [EOL] when(element.isJsonPrimitive()).thenReturn(false); [EOL] when(element.isJsonArray()).thenReturn(false); [EOL] when(element.isJsonObject()).thenReturn(false); [EOL] try { [EOL] write(element, true, writer); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testCheckArgumentTrueCondition() { [EOL] Gson.checkArgument(true); [EOL] }
public void testCheckArgumentFalseCondition() { [EOL] try { [EOL] Gson.checkArgument(false); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("condition failed: false", e.getMessage()); [EOL] } [EOL] }
public void testCheckStateTrueCondition() { [EOL] Gson.checkState(true); [EOL] }
public void testCheckStateFalseCondition() { [EOL] try { [EOL] Gson.checkState(false); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("condition failed: false", e.getMessage()); [EOL] } [EOL] }
public void testGetAsBigInteger_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new BigInteger("123456789")); [EOL] BigInteger result = jsonArray.getAsBigInteger(); [EOL] assertEquals(new BigInteger("123456789"), result); [EOL] }
public void testGetAsBigInteger_MultipleElements() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new BigInteger("123456789")); [EOL] jsonArray.add(new BigInteger("987654321")); [EOL] try { [EOL] jsonArray.getAsBigInteger(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testJsonStreamParserWithValidReader() { [EOL] Reader reader = new StringReader("{\"key\":\"value\"}"); [EOL] JsonStreamParser parser = new JsonStreamParser(reader); [EOL] assertTrue(parser.hasNext()); [EOL] }
public void testJsonStreamParserWithNullReader() { [EOL] try { [EOL] JsonStreamParser parser = new JsonStreamParser(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRegisterWithModifiableMap() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value = "testValue"; [EOL] CustomTypeAdapterMap map = new CustomTypeAdapterMap(true); [EOL] map.register(typeOfT, value); [EOL] assertEquals(value, map.getAdapter(typeOfT)); [EOL] }
public void testRegisterWithUnmodifiableMap() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value = "testValue"; [EOL] CustomTypeAdapterMap map = new CustomTypeAdapterMap(false); [EOL] try { [EOL] map.register(typeOfT, value); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Attempted to modify an unmodifiable map.", e.getMessage()); [EOL] } [EOL] }
public void testRegisterOverridingExistingHandler() { [EOL] Type typeOfT = new TypeToken<String>() {}.getType(); [EOL] String value1 = "testValue1"; [EOL] String value2 = "testValue2"; [EOL] CustomTypeAdapterMap map = new CustomTypeAdapterMap(true); [EOL] map.register(typeOfT, value1); [EOL] map.register(typeOfT, value2); [EOL] assertEquals(value2, map.getAdapter(typeOfT)); [EOL] }
public void testMakeUnmodifiable() { [EOL] MyClass instance = new MyClass(); [EOL] instance.makeUnmodifiable(); [EOL] assertFalse(instance.modifiable); [EOL] }
public void testToRawClassWithClassType() { [EOL] Class<?> expected = String.class; [EOL] Class<?> actual = YourClass.toRawClass(String.class); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithParameterizedType() { [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] Class<?> expected = List.class; [EOL] Class<?> actual = YourClass.toRawClass(type); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithGenericArrayType() { [EOL] Type type = new TypeToken<List<String>[]>() {}.getType(); [EOL] Class<?> expected = List[].class; [EOL] Class<?> actual = YourClass.toRawClass(type); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithWildcardType() { [EOL] Type type = new TypeToken<?>(){ }.getType(); [EOL] Class<?> expected = Object.class; // Assuming the upper bound is Object for wildcard type [EOL] Class<?> actual = YourClass.toRawClass(type); [EOL] assertEquals(expected, actual); [EOL] }
public void testToRawClassWithInvalidType() { [EOL] Type type = new TypeToken<Map.Entry<String, String>>() {}.getType(); [EOL] try { [EOL] YourClass.toRawClass(type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTranslateNameWithNonNullFieldAttributes() { [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] when(fieldAttributes.getName()).thenReturn("fieldName"); [EOL] when(fieldAttributes.getDeclaredType()).thenReturn(String.class); [EOL] when(fieldAttributes.getAnnotations()).thenReturn(new Annotation[0]); [EOL] Gson gson = new Gson(); [EOL] String translatedName = gson.translateName(fieldAttributes); [EOL] assertNotNull(translatedName); [EOL] assertEquals("fieldName", translatedName); [EOL] }
public void testTranslateNameWithNullFieldAttributes() { [EOL] try { [EOL] Gson gson = new Gson(); [EOL] gson.translateName(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testGsonDefaultConstructor() { [EOL] Gson gson = new Gson(); [EOL] assertNotNull(gson); [EOL] }
public void testGsonFullConstructor() { [EOL] ExclusionStrategy serializationStrategy = DEFAULT_EXCLUSION_STRATEGY; [EOL] ExclusionStrategy deserializationStrategy = DEFAULT_EXCLUSION_STRATEGY; [EOL] FieldNamingStrategy2 fieldNamingPolicy = DEFAULT_NAMING_POLICY; [EOL] MappedObjectConstructor objectConstructor = new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL] boolean serializeNulls = false; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = DefaultTypeAdapters.getDefaultSerializers(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = DefaultTypeAdapters.getDefaultDeserializers(); [EOL] boolean generateNonExecutableGson = DEFAULT_JSON_NON_EXECUTABLE; [EOL] boolean htmlSafe = true; [EOL] boolean prettyPrinting = false; [EOL] Gson gson = new Gson(serializationStrategy, deserializationStrategy, fieldNamingPolicy, objectConstructor, serializeNulls, serializers, deserializers, generateNonExecutableGson, htmlSafe, prettyPrinting); [EOL] assertNotNull(gson); [EOL] }

public void testFromJsonWithJsonElementAndClass() throws JsonParseException { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = new JsonPrimitive("testString"); [EOL] String result = gson.fromJson(jsonElement, String.class); [EOL] assertEquals("testString", result); [EOL] }
public void testFromJsonWithJsonElementAndClassCastException() { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = new JsonPrimitive("testString"); [EOL] try { [EOL] Integer result = gson.fromJson(jsonElement, Integer.class); [EOL] fail("Expected JsonParseException due to type mismatch"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonWithJsonElementAndPrimitiveClass() throws JsonParseException { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = new JsonPrimitive(10); [EOL] int result = gson.fromJson(jsonElement, int.class); [EOL] assertEquals(10, result); [EOL] }
public void testIsWrapperType_withWrapperClass() { [EOL] assertTrue(JsonUtils.isWrapperType(Integer.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Double.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Float.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Long.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Short.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Byte.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Boolean.class)); [EOL] assertTrue(JsonUtils.isWrapperType(Character.class)); [EOL] } [EOL] public void testIsWrapperType_withPrimitiveClass() { [EOL] assertFalse(JsonUtils.isWrapperType(int.class)); [EOL] assertFalse(JsonUtils.isWrapperType(double.class)); [EOL] assertFalse(JsonUtils.isWrapperType(float.class)); [EOL] assertFalse(JsonUtils.isWrapperType(long.class)); [EOL] assertFalse(JsonUtils.isWrapperType(short.class)); [EOL] assertFalse(JsonUtils.isWrapperType(byte.class)); [EOL] assertFalse(JsonUtils.isWrapperType(boolean.class)); [EOL] assertFalse(JsonUtils.isWrapperType(char.class)); [EOL] } [EOL] public void testIsWrapperType_withNonWrapperClass() { [EOL] assertFalse(JsonUtils.isWrapperType(String.class)); [EOL] assertFalse(JsonUtils.isWrapperType(Object.class)); [EOL] } [EOL] public void testIsWrapperType_withNull() { [EOL] try { [EOL] JsonUtils.isWrapperType(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testDeserializeWithJsonParseException() { [EOL] JsonElement json = new JsonElementMock(); // Replace with actual JsonElement implementation [EOL] Type typeOfT = new TypeToken<String>(){}.getType(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextMock(); // Replace with actual context [EOL] JsonDeserializer<T> delegate = new JsonDeserializerMockThatThrowsJsonParseException(); // Replace with mock that throws JsonParseException [EOL] try { [EOL] delegate.deserialize(json, typeOfT, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithGenericException() { [EOL] JsonElement json = new JsonElementMock(); // Replace with actual JsonElement implementation [EOL] Type typeOfT = new TypeToken<String>(){}.getType(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextMock(); // Replace with actual context [EOL] JsonDeserializer<T> delegate = new JsonDeserializerMockThatThrowsGenericException(); // Replace with mock that throws generic Exception [EOL] try { [EOL] delegate.deserialize(json, typeOfT, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] String expectedMessage = "The JsonDeserializer " + delegate.toString() + " failed to deserialized json object " + json.toString() + " given the type " + typeOfT.toString(); [EOL] assertEquals(expectedMessage, e.getMessage()); [EOL] } [EOL] }
public void testJsonParseExceptionWithMessageAndCause() { [EOL] String expectedMessage = "Test message"; [EOL] Throwable expectedCause = new Exception("Cause"); [EOL] JsonParseException exception = new JsonParseException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL] return false; [EOL] }
public void testModifyFirstLetterNamingPolicyWithNonNullModifier() { [EOL] LetterModifier mockModifier = mock(LetterModifier.class); [EOL] ModifyFirstLetterNamingPolicy namingPolicy = new ModifyFirstLetterNamingPolicy(mockModifier); [EOL] assertNotNull(namingPolicy); [EOL] }
public void testModifyFirstLetterNamingPolicyWithNullModifier() { [EOL] try { [EOL] new ModifyFirstLetterNamingPolicy(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("modifier must not be null", e.getMessage()); [EOL] } [EOL] }
public void testTranslateNameWithNonLetterAtStart() { [EOL] String target = "123name"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("123name", result); [EOL] }
public void testTranslateNameWithUpperCaseFirstLetter() { [EOL] String target = "Name"; [EOL] Type fieldType = null; [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] letterModifier = LetterModifier.UPPER; // Assuming letterModifier is a field of the class [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("Name", result); [EOL] }
public void testTranslateNameWithLowerCaseFirstLetterAndUpperCaseModifier() { [EOL] String target = "name"; [EOL] Type fieldType = null; [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] letterModifier = LetterModifier.UPPER; [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("Name", result); [EOL] }
public void testTranslateNameWithUpperCaseFirstLetterAndLowerCaseModifier() { [EOL] String target = "Name"; [EOL] Type fieldType = null; [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] letterModifier = LetterModifier.LOWER; [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("name", result); [EOL] }
public void testTranslateNameAllNonLetters() { [EOL] String target = "123456"; [EOL] Type fieldType = null; [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("123456", result); [EOL] }
public void testModifyStringWithValidIndex() { [EOL] String result = modifyString('a', "example", 1); [EOL] assertEquals("aample", result); [EOL] }
public void testModifyStringWithIndexEqualToLength() { [EOL] String result = modifyString('b', "example", 7); [EOL] assertEquals("b", result); [EOL] }
public void testModifyStringWithIndexGreaterThanLength() { [EOL] String result = modifyString('c', "example", 8); [EOL] assertEquals("c", result); [EOL] }
public void testModifyStringWithEmptyString() { [EOL] String result = modifyString('d', "", 0); [EOL] assertEquals("d", result); [EOL] }
public void testMappedObjectConstructorWithNonNullInstanceCreators() { [EOL] ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators = new ParameterizedTypeHandlerMap<>(); [EOL] MappedObjectConstructor constructor = new MappedObjectConstructor(instanceCreators); [EOL] assertNotNull(constructor); [EOL] }
public void testMappedObjectConstructorWithNullInstanceCreators() { [EOL] MappedObjectConstructor constructor = new MappedObjectConstructor(null); [EOL] assertNotNull(constructor); [EOL] }
public void testAcceptWithExclusionStrategySkippingClass() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(true); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, never()).visitUsingCustomHandler(objTypePair); [EOL] verify(visitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithCustomHandler() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(true); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, times(1)).visitUsingCustomHandler(objTypePair); [EOL] verify(visitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithNullObjectAndTarget() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] when(visitor.getTarget()).thenReturn(null); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithArray() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object[0], Object[].class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(Object[].class); [EOL] when(typeInfo.isArray()).thenReturn(true); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, times(1)).visitArray(any(), any(Class.class)); [EOL] }
public void testAcceptWithPrimitiveOrString() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair("test", String.class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(String.class); [EOL] when(typeInfo.getActualType()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, times(1)).visitPrimitive(any()); [EOL] }
public void testAcceptWithObjectNavigation() { [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] Visitor visitor = mock(Visitor.class); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] when(typeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(typeInfo.getActualType()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] objTypePair.accept(visitor); [EOL] verify(visitor, times(1)).startVisitingObject(any()); [EOL] verify(visitor, times(1)).end(objTypePair); [EOL] }
public void testNavigateClassFieldsWithSkippedFields() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(true); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithNonSkippedFields() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, atLeastOnce()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithArrayField() { [EOL] Object obj = new Object[] { new Object() }; [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] when(typeInfo.isArray()).thenReturn(true); [EOL] TypeInfoFactory.setTypeInfoForField(typeInfo); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, atLeastOnce()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithObjectField() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] when(exclusionStrategy.shouldSkipField(any(FieldAttributes.class))).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] TypeInfo typeInfo = mock(TypeInfo.class); [EOL] when(typeInfo.isArray()).thenReturn(false); [EOL] TypeInfoFactory.setTypeInfoForField(typeInfo); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, atLeastOnce()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testSerializeNulls() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.serializeNulls(); [EOL] assertNotNull(returnedBuilder); [EOL] assertTrue(returnedBuilder.serializeNulls); [EOL] }
public void testSetExclusionStrategiesWithEmptyArray() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setExclusionStrategies(new ExclusionStrategy[]{}); [EOL] } [EOL] public void testSetExclusionStrategiesWithSingleStrategy() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] ExclusionStrategy mockStrategy = mock(ExclusionStrategy.class); [EOL] builder.setExclusionStrategies(mockStrategy); [EOL] } [EOL] public void testSetExclusionStrategiesWithMultipleStrategies() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] ExclusionStrategy mockStrategy1 = mock(ExclusionStrategy.class); [EOL] ExclusionStrategy mockStrategy2 = mock(ExclusionStrategy.class); [EOL] builder.setExclusionStrategies(mockStrategy1, mockStrategy2); [EOL] }
public void testIsPrimitive_withPrimitiveType() { [EOL] TypeToken<Integer> typeToken = TypeToken.get(int.class); [EOL] boolean result = typeToken.isPrimitive(); [EOL] assertTrue(result); [EOL] }
public void testIsPrimitive_withWrapperType() { [EOL] TypeToken<Integer> typeToken = TypeToken.get(Integer.class); [EOL] boolean result = typeToken.isPrimitive(); [EOL] assertTrue(result); [EOL] }
public void testIsPrimitive_withNonPrimitiveType() { [EOL] TypeToken<String> typeToken = TypeToken.get(String.class); [EOL] boolean result = typeToken.isPrimitive(); [EOL] assertFalse(result); [EOL] }
public void testContains_withNullObject() { [EOL] ObjectTypePair obj = null; [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.contains(obj); [EOL] assertFalse(result); [EOL] }
public void testContains_withObjectNotInStack() { [EOL] ObjectTypePair obj = new ObjectTypePair(someObject, someType); [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.contains(obj); [EOL] assertFalse(result); [EOL] }
public void testContains_withObjectInStack() { [EOL] ObjectTypePair obj = new ObjectTypePair(someObject, someType); [EOL] SomeClass instance = new SomeClass(); [EOL] instance.addToStack(obj); // Assuming there is a method to add to the stack [EOL] boolean result = instance.contains(obj); [EOL] assertTrue(result); [EOL] }
public void testFieldAttributesWithValidInput() { [EOL] Class<?> declaringClass = SampleClass.class; [EOL] Field field = declaringClass.getDeclaredFields()[0]; [EOL] FieldAttributes fieldAttributes = new FieldAttributes(declaringClass, field); [EOL] assertEquals(declaringClass, fieldAttributes.getDeclaringClass()); [EOL] assertEquals(field.getName(), fieldAttributes.getName()); [EOL] assertEquals(field.getType(), fieldAttributes.getDeclaredType()); [EOL] assertEquals(field.isSynthetic(), fieldAttributes.isSynthetic()); [EOL] assertEquals(field.getModifiers(), fieldAttributes.getModifiers()); [EOL] }
public void testFieldAttributesWithNullDeclaringClass() { [EOL] try { [EOL] new FieldAttributes(null, SampleClass.class.getDeclaredFields()[0]); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFieldAttributesWithNullField() { [EOL] try { [EOL] new FieldAttributes(SampleClass.class, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetWithValidInstance() throws IllegalAccessException { [EOL] Field field = MyClass.class.getDeclaredField("existingField"); [EOL] field.setAccessible(true); [EOL] ObjectAccessor accessor = new ObjectAccessor(field); [EOL] MyClass instance = new MyClass(); [EOL] Object expected = instance.existingField; [EOL] Object result = accessor.get(instance); [EOL] assertEquals(expected, result); [EOL] }
public void testGetWithNullInstance() { [EOL] Field field = MyClass.class.getDeclaredField("existingField"); [EOL] field.setAccessible(true); [EOL] ObjectAccessor accessor = new ObjectAccessor(field); [EOL] try { [EOL] accessor.get(null); [EOL] fail("Expected IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testGetWithInaccessibleField() throws NoSuchFieldException { [EOL] Field field = MyClass.class.getDeclaredField("privateField"); [EOL] ObjectAccessor accessor = new ObjectAccessor(field); [EOL] MyClass instance = new MyClass(); [EOL] try { [EOL] accessor.get(instance); [EOL] fail("Expected IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] Character testChar = 'a'; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(testChar); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals(testChar.toString(), jsonPrimitive.getAsString()); [EOL] assertEquals((Object)testChar, jsonPrimitive.getAsCharacter()); [EOL] }
public void testJsonPrimitiveWithBoolean() { [EOL] Boolean testBool = true; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(testBool); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertEquals(testBool, jsonPrimitive.getAsBooleanWrapper()); [EOL] assertEquals((boolean)testBool, jsonPrimitive.getAsBoolean()); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] Number testNumber = 42; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(testNumber); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] assertEquals(testNumber, jsonPrimitive.getAsNumber()); [EOL] assertEquals(testNumber.doubleValue(), jsonPrimitive.getAsDouble(), 0); [EOL] assertEquals(testNumber.longValue(), jsonPrimitive.getAsLong()); [EOL] assertEquals(testNumber.intValue(), jsonPrimitive.getAsInt()); [EOL] assertEquals(testNumber.floatValue(), jsonPrimitive.getAsFloat(), 0); [EOL] assertEquals(testNumber.shortValue(), jsonPrimitive.getAsShort()); [EOL] assertEquals(testNumber.byteValue(), jsonPrimitive.getAsByte()); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] String testString = "test"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(testString); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals(testString, jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithNull() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((String) null); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] }
public void testJsonPrimitiveHashCodeAndEquals() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitive3 = new JsonPrimitive(43); [EOL] assertEquals(jsonPrimitive1.hashCode(), jsonPrimitive2.hashCode()); [EOL] assertNotEquals(jsonPrimitive1.hashCode(), jsonPrimitive3.hashCode()); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive3)); [EOL] assertFalse(jsonPrimitive1.equals(null)); [EOL] assertFalse(jsonPrimitive1.equals(new Object())); [EOL] }
public void testJsonPrimitiveWithDifferentTypes() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive("42"); [EOL] JsonPrimitive jsonPrimitiveBool = new JsonPrimitive(true); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitiveInt)); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitiveString)); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitiveBool)); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitiveInt)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitiveString)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitiveBool)); [EOL] }
public void testJsonPrimitiveWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] assertEquals(10, jsonPrimitive.getAsNumber().intValue()); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals("test", jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertEquals('a', jsonPrimitive.getAsCharacter()); [EOL] }
public void testJsonPrimitiveWithObjectBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) Boolean.TRUE); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] }
public void testJsonPrimitiveWithObjectNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) Integer.valueOf(10)); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] assertEquals(10, jsonPrimitive.getAsNumber().intValue()); [EOL] }
public void testJsonPrimitiveWithObjectString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) "test"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals("test", jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithObjectCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) Character.valueOf('a')); [EOL] assertEquals('a', jsonPrimitive.getAsCharacter()); [EOL] }
public void testEquals() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive("test"); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive("test"); [EOL] JsonPrimitive jsonPrimitive3 = new JsonPrimitive("different"); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive3)); [EOL] }
public void testHashCode() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive("test"); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive("test"); [EOL] assertEquals(jsonPrimitive1.hashCode(), jsonPrimitive2.hashCode()); [EOL] }
public void testIsIntegral() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] }
public void testIsFloatingPoint() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] }
public void testSetValueWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] jsonPrimitive.setValue('b'); [EOL] assertEquals("b", jsonPrimitive.getAsString()); [EOL] }
public void testSetValueWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] jsonPrimitive.setValue(20); [EOL] assertEquals(20, jsonPrimitive.getAsNumber()); [EOL] }
public void testSetValueWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] jsonPrimitive.setValue("newTest"); [EOL] assertEquals("newTest", jsonPrimitive.getAsString()); [EOL] }
public void testSetValueWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] jsonPrimitive.setValue(false); [EOL] assertEquals(false, jsonPrimitive.getAsBoolean()); [EOL] }
public void testSetValueWithNull() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) null); [EOL] try { [EOL] jsonPrimitive.setValue(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testSetValueWithUnsupportedType() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] try { [EOL] jsonPrimitive.setValue(new Object()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testIsStringWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] }
public void testIsStringWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] }
public void testIsStringWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] }
public void testIsStringWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] }
public void testGetAsCharacter_onString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("a"); [EOL] char result = jsonPrimitive.getAsCharacter(); [EOL] assertEquals('a', result); [EOL] } [EOL] public void testGetAsCharacter_onEmptyString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(""); [EOL] try { [EOL] jsonPrimitive.getAsCharacter(); [EOL] fail("Expected an exception due to empty string"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetAsCharacter_onNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(1); [EOL] try { [EOL] jsonPrimitive.getAsCharacter(); [EOL] fail("Expected an exception because a number cannot be converted to a character"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testJsonPrimitive_withBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] } [EOL] public void testJsonPrimitive_withNullBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Boolean) null); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] try { [EOL] jsonPrimitive.getAsBoolean(); [EOL] fail("Expected an exception because the boolean value is null"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testJsonPrimitive_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] assertEquals(10, jsonPrimitive.getAsNumber().intValue()); [EOL] } [EOL] public void testJsonPrimitive_withStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10"); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] try { [EOL] jsonPrimitive.getAsNumber(); [EOL] fail("Expected an exception because the string is not a number"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testJsonPrimitive_withString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals("test", jsonPrimitive.getAsString()); [EOL] } [EOL] public void testJsonPrimitive_withNumberAsString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] assertEquals("10", jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitive_withCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] assertEquals('a', jsonPrimitive.getAsCharacter()); [EOL] }
public void testJsonPrimitive_withNull() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) null); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] assertFalse(jsonPrimitive.isString()); [EOL] try { [EOL] jsonPrimitive.getAsCharacter(); [EOL] fail("Expected an exception because the value is null"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testToStringWithString() throws IOException { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("testString"); [EOL] StringBuilder sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(); [EOL] jsonPrimitive.toString(sb, escaper); [EOL] assertEquals("\"testString\"", sb.toString()); [EOL] }
public void testToStringWithBoolean() throws IOException { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] StringBuilder sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(); [EOL] jsonPrimitive.toString(sb, escaper); [EOL] assertEquals("true", sb.toString()); [EOL] }
public void testToStringWithNumber() throws IOException { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] StringBuilder sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(); [EOL] jsonPrimitive.toString(sb, escaper); [EOL] assertEquals("123", sb.toString()); [EOL] }
public void testToStringWithCharacter() throws IOException { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('c'); [EOL] StringBuilder sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(); [EOL] jsonPrimitive.toString(sb, escaper); [EOL] assertEquals("\"c\"", sb.toString()); [EOL] }
public void testHashCode_withNullValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((String) null); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(31, result); [EOL] }
public void testHashCode_withIntegralValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] int result = jsonPrimitive.hashCode(); [EOL] long value = jsonPrimitive.getAsNumber().longValue(); [EOL] int expected = (int) (value ^ (value >>> 32)); [EOL] assertEquals(expected, result); [EOL] }
public void testHashCode_withFloatingPointValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(123.456); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] int result = jsonPrimitive.hashCode(); [EOL] long value = Double.doubleToLongBits(jsonPrimitive.getAsNumber().doubleValue()); [EOL] int expected = (int) (value ^ (value >>> 32)); [EOL] assertEquals(expected, result); [EOL] }
public void testHashCode_withStringValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals("test".hashCode(), result); [EOL] }
public void testHashCode_withBooleanValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(Boolean.TRUE.hashCode(), result); [EOL] }
public void testHashCode_withCharacterValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] int result = jsonPrimitive.hashCode(); [EOL] assertEquals(Character.valueOf('a').hashCode(), result); [EOL] }
public void testEquals_Reflexive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.equals(jsonPrimitive)); [EOL] }
public void testEquals_Symmetric() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] assertTrue(jsonPrimitive2.equals(jsonPrimitive1)); [EOL] }
public void testEquals_Null() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] Object obj = new Object(); [EOL] assertFalse(jsonPrimitive.equals(obj)); [EOL] }
public void testEquals_DifferentValue() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(20); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_IntegralNumber() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10L); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_FloatingPointNumber() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10.0d); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10.0f); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_DifferentTypes() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive("10"); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testEquals_NullValue() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive((Number) null); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive((Number) null); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
private static boolean isFloatingPoint(JsonPrimitive primitive) { [EOL] if (primitive.value instanceof Number) { [EOL] Number number = (Number) primitive.value; [EOL] return number instanceof BigDecimal || number instanceof Double || number instanceof Float; [EOL] } [EOL] return false; [EOL] } [EOL] public JsonPrimitive(Boolean bool); [EOL] public JsonPrimitive(Number number); [EOL] public JsonPrimitive(String string); [EOL] public JsonPrimitive(Character c); [EOL] JsonPrimitive(Object primitive); [EOL] void setValue(Object primitive); [EOL] public boolean isBoolean(); [EOL] Boolean getAsBooleanWrapper(); [EOL] public boolean getAsBoolean(); [EOL] public boolean isNumber(); [EOL] public Number getAsNumber(); [EOL] static Number stringToNumber(String value); [EOL] public boolean isString(); [EOL] public String getAsString(); [EOL] public double getAsDouble(); [EOL] public BigDecimal getAsBigDecimal(); [EOL] public BigInteger getAsBigInteger(); [EOL] public float getAsFloat(); [EOL] public long getAsLong(); [EOL] public short getAsShort(); [EOL] public int getAsInt(); [EOL] public byte getAsByte(); [EOL] public char getAsCharacter(); [EOL] Object getAsObject(); [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException; [EOL] private static boolean isPrimitiveOrString(Object target); [EOL] public int hashCode(); [EOL] public boolean equals(Object obj); [EOL] private static boolean isIntegral(JsonPrimitive primitive); [EOL] private static boolean isFloatingPoint(JsonPrimitive primitive); [EOL] Class<?>[] PRIMITIVE_TYPES= { int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };
public JsonElement serialize(Long value) { [EOL] return strategy.serialize(value); [EOL] }
public void testSerializeWithNullValue() { [EOL] JsonElement result = serialize(null); [EOL] assertEquals(JsonNull.INSTANCE, result); [EOL] }
public void testSerializeWithPositiveLongValue() { [EOL] Long value = 123L; [EOL] JsonElement result = serialize(value); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testSerializeWithNegativeLongValue() { [EOL] Long value = -456L; [EOL] JsonElement result = serialize(value); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("-456", result.getAsString()); [EOL] }
public void testSerializeWithZeroLongValue() { [EOL] Long value = 0L; [EOL] JsonElement result = serialize(value); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("0", result.getAsString()); [EOL] }
void setObject(Object obj) { [EOL] this.obj = obj; [EOL] }
public void testGetMatchingHandlerWithNonNullObjectAndPreserveTypeFalse() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] SomeType obj = new SomeType(); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(obj, SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertNotNull(result.second); [EOL] }
public void testGetMatchingHandlerWithNonNullObjectAndPreserveTypeTrue() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] SomeType obj = new SomeType(); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(obj, SomeType.class, true); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertSame(objectTypePair, result.second); [EOL] }
public void testGetMatchingHandlerWithNullObject() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(null, SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertSame(objectTypePair, result.second); [EOL] }
public void testGetMatchingHandlerWithNoRegisteredHandler() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(new SomeType(), SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNull(result); [EOL] }
public void testToMoreSpecificTypeWithPreserveType() { [EOL] ObjectTypePair original = new ObjectTypePair(null, Object.class, true); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair due to preserveType being true", original, result); [EOL] } [EOL] public void testToMoreSpecificTypeWithNullObject() { [EOL] ObjectTypePair original = new ObjectTypePair(null, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair due to obj being null", original, result); [EOL] }
public void testToMoreSpecificTypeWithSameType() { [EOL] Object obj = new Object(); [EOL] ObjectTypePair original = new ObjectTypePair(obj, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair because actualType is the same as type", original, result); [EOL] }
public void testToMoreSpecificTypeWithMoreSpecificType() { [EOL] String obj = "test"; [EOL] ObjectTypePair original = new ObjectTypePair(obj, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertNotSame("Expected a different ObjectTypePair because actualType is more specific than type", original, result); [EOL] assertEquals("Expected actualType to be String.class", String.class, result.getType()); [EOL] }
public void testGetActualTypeIfMoreSpecificWithNonAssignableClass() { [EOL] Type type = String.class; [EOL] Class<?> actualClass = Integer.class; [EOL] Type result = getActualTypeIfMoreSpecific(type, actualClass); [EOL] assertSame("Expected the same type as the input type when actualClass is not assignable to type", type, result); [EOL] } [EOL] public void testGetActualTypeIfMoreSpecificWithAssignableClass() { [EOL] Type type = Number.class; [EOL] Class<?> actualClass = Integer.class; [EOL] Type result = getActualTypeIfMoreSpecific(type, actualClass); [EOL] assertSame("Expected actualClass when it is assignable to type", actualClass, result); [EOL] } [EOL] public void testGetActualTypeIfMoreSpecificWithTypeEqualsObjectClass() { [EOL] Type type = Object.class; [EOL] Class<?> actualClass = Integer.class; [EOL] Type result = getActualTypeIfMoreSpecific(type, actualClass); [EOL] assertSame("Expected actualClass when type is Object.class", actualClass, result); [EOL] } [EOL] public void testGetActualTypeIfMoreSpecificWithNonClassType() { [EOL] Type type = new Type() {}; [EOL] Class<?> actualClass = Integer.class; [EOL] Type result = getActualTypeIfMoreSpecific(type, actualClass); [EOL] assertSame("Expected the same type as the input type when type is not a Class instance", type, result); [EOL] }
public void testJsonObjectConstructor() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] assertNotNull(jsonObject); [EOL] assertTrue(jsonObject.isJsonObject()); [EOL] assertEquals(0, jsonObject.size()); [EOL] }
public void testAddPropertyWithNullNumber() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("age", (Number) null); [EOL] assertTrue(jsonObject.has("age")); [EOL] JsonElement element = jsonObject.get("age"); [EOL] assertTrue(element.isJsonNull()); [EOL] }
public void testAddPropertyWithInteger() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("age", 25); [EOL] assertTrue(jsonObject.has("age")); [EOL] JsonElement element = jsonObject.get("age"); [EOL] assertTrue(element.isJsonPrimitive()); [EOL] assertEquals(25, element.getAsInt()); [EOL] }
public void testAddPropertyWithDouble() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("height", 175.5); [EOL] assertTrue(jsonObject.has("height")); [EOL] JsonElement element = jsonObject.get("height"); [EOL] assertTrue(element.isJsonPrimitive()); [EOL] assertEquals(175.5, element.getAsDouble(), 0.0); [EOL] }
public void testAddPropertyWithTrue() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("testKey", Boolean.TRUE); [EOL] assertTrue(jsonObject.get("testKey").getAsBoolean()); [EOL] }
public void testAddPropertyWithFalse() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("testKey", Boolean.FALSE); [EOL] assertFalse(jsonObject.get("testKey").getAsBoolean()); [EOL] }
public void testAddPropertyWithNull() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("testKey", (Boolean) null); [EOL] assertTrue(jsonObject.get("testKey").isJsonNull()); [EOL] }
public void testCreateJsonElementWithNullValue() { [EOL] JsonElement result = createJsonElement(null); [EOL] assertTrue(result instanceof JsonNull); [EOL] }
public void testCreateJsonElementWithNonNullValue() { [EOL] JsonElement result = createJsonElement("testString"); [EOL] assertTrue(result instanceof JsonPrimitive); [EOL] assertEquals("testString", ((JsonPrimitive) result).getAsString()); [EOL] }
public void testEntrySet_whenMembersAreEmpty() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] Set<Map.Entry<String, JsonElement>> entries = jsonObject.entrySet(); [EOL] assertTrue(entries.isEmpty()); [EOL] }
public void testEntrySet_whenMembersAreNotEmpty() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", new JsonPrimitive("value1")); [EOL] jsonObject.add("key2", new JsonPrimitive("value2")); [EOL] Set<Map.Entry<String, JsonElement>> entries = jsonObject.entrySet(); [EOL] assertEquals(2, entries.size()); [EOL] }
public void testTranslateNameWithEmptyString() { [EOL] String result = translateName("", null, null); [EOL] assertEquals("", result); [EOL] }
public void testTranslateNameWithLowerCase() { [EOL] String result = translateName("lowercase", null, null); [EOL] assertEquals("LOWERCASE", result); [EOL] }
public void testTranslateNameWithMixedCase() { [EOL] String result = translateName("MixedCase", null, null); [EOL] assertEquals("MIXEDCASE", result); [EOL] }
public void testTranslateNameWithUpperCase() { [EOL] String result = translateName("UPPERCASE", null, null); [EOL] assertEquals("UPPERCASE", result); [EOL] }
