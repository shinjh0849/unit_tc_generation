public void testGzipCompressorOutputStreamWithValidStream() throws IOException { [EOL] ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); [EOL] GzipCompressorOutputStream gzipCompressorOutputStream = new GzipCompressorOutputStream(byteArrayOutputStream); [EOL] assertNotNull(gzipCompressorOutputStream); [EOL] }
public void testGzipCompressorOutputStreamWithNullStream() { [EOL] try { [EOL] GzipCompressorOutputStream gzipCompressorOutputStream = new GzipCompressorOutputStream(null); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("Output stream cannot be null", e.getMessage()); [EOL] } [EOL] }
public void write_singleByte() throws IOException { [EOL] ByteArrayOutputStream outContent = new ByteArrayOutputStream(); [EOL] Compress compress = new Compress(outContent); [EOL] compress.write(97); // ASCII code for 'a' [EOL] assertArrayEquals(new byte[]{(byte) 97}, outContent.toByteArray()); [EOL] }
public void close() throws IOException { [EOL] out.close(); [EOL] }
public void testCloneSuccessful() throws Exception { [EOL] Compress compressInstance = new Compress(); [EOL] Object clonedInstance = compressInstance.clone(); [EOL] assertNotNull(clonedInstance); [EOL] assertNotSame(compressInstance, clonedInstance); [EOL] assertEquals(compressInstance.getClass(), clonedInstance.getClass()); [EOL] }
public void testCloneThrowsRuntimeException() { [EOL] Compress compressInstance = new Compress() { [EOL] public Object clone() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException("Clone not supported"); [EOL] } [EOL] }; [EOL] try { [EOL] compressInstance.clone(); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException re) { [EOL] assertEquals(CloneNotSupportedException.class, re.getCause().getClass()); [EOL] } [EOL] }
public void testZipShortConstructor_ValidValue() { [EOL] int expectedValue = 100; [EOL] ZipShort zipShort = new ZipShort(expectedValue); [EOL] assertEquals(expectedValue, zipShort.getValue()); [EOL] }
public void testGetBytesWithZeroValue() { [EOL] Compress compress = new Compress(0); [EOL] byte[] result = compress.getBytes(); [EOL] assertEquals(0, result[0]); [EOL] assertEquals(0, result[1]); [EOL] } [EOL] public void testGetBytesWithMaxByteValue() { [EOL] Compress compress = new Compress(0xFF); [EOL] byte[] result = compress.getBytes(); [EOL] assertEquals((byte) 0xFF, result[0]); [EOL] assertEquals(0, result[1]); [EOL] } [EOL] public void testGetBytesWithMaxValue() { [EOL] Compress compress = new Compress(0xFFFF); [EOL] byte[] result = compress.getBytes(); [EOL] assertEquals((byte) 0xFF, result[0]); [EOL] assertEquals((byte) 0xFF, result[1]); [EOL] }
public void testCreateArchiveInputStreamWithNullArchiverName() { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] try { [EOL] createArchiveInputStream(null, in); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Archivername must not be null.", iae.getMessage()); [EOL] } catch (ArchiveException ae) { [EOL] fail("Expected an IllegalArgumentException, not an ArchiveException"); [EOL] } [EOL] }
public void testCreateArchiveInputStreamWithNullInputStream() { [EOL] try { [EOL] createArchiveInputStream("zip", null); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("Archivername must not be null.", iae.getMessage()); [EOL] } catch (ArchiveException ae) { [EOL] fail("Expected an IllegalArgumentException, not an ArchiveException"); [EOL] } [EOL] }
public void testCreateArchiveInputStreamForAr() throws ArchiveException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ArchiveInputStream ais = createArchiveInputStream("ar", in); [EOL] assertTrue(ais instanceof ArArchiveInputStream); [EOL] }
public void testCreateArchiveInputStreamForZip() throws ArchiveException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ArchiveInputStream ais = createArchiveInputStream("zip", in); [EOL] assertTrue(ais instanceof ZipArchiveInputStream); [EOL] }
public void testCreateArchiveInputStreamForTar() throws ArchiveException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ArchiveInputStream ais = createArchiveInputStream("tar", in); [EOL] assertTrue(ais instanceof TarArchiveInputStream); [EOL] }
public void testCreateArchiveInputStreamForJar() throws ArchiveException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ArchiveInputStream ais = createArchiveInputStream("jar", in); [EOL] assertTrue(ais instanceof JarArchiveInputStream); [EOL] }
public void testCreateArchiveInputStreamForCpio() throws ArchiveException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] ArchiveInputStream ais = createArchiveInputStream("cpio", in); [EOL] assertTrue(ais instanceof CpioArchiveInputStream); [EOL] }
public void testCreateArchiveInputStreamForUnknownArchiver() { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] try { [EOL] createArchiveInputStream("unknown", in); [EOL] fail("Expected an ArchiveException to be thrown"); [EOL] } catch (ArchiveException ae) { [EOL] assertEquals("Archiver: unknown not found.", ae.getMessage()); [EOL] } [EOL] }
public void testZipFileConstructorSuccess() throws IOException { [EOL] File tempFile = createTempFile(); // Assume createTempFile() creates a temporary file [EOL] String encoding = "UTF-8"; [EOL] boolean useUnicodeExtraFields = true; [EOL] ZipFile zipFile = null; [EOL] try { [EOL] zipFile = new ZipFile(tempFile, encoding, useUnicodeExtraFields); [EOL] assertNotNull(zipFile); [EOL] assertEquals(encoding, zipFile.getEncoding()); [EOL] assertEquals(useUnicodeExtraFields, zipFile.isUseUnicodeExtraFields()); [EOL] } finally { [EOL] if (zipFile != null) { [EOL] zipFile.close(); [EOL] } [EOL] tempFile.delete(); [EOL] } [EOL] }
public void testZipFileConstructorFailure() { [EOL] File tempFile = createTempFile(); // Assume createTempFile() creates a temporary file [EOL] tempFile.delete(); // Delete the file to cause an IOException [EOL] String encoding = "UTF-8"; [EOL] boolean useUnicodeExtraFields = true; [EOL] try { [EOL] new ZipFile(tempFile, encoding, useUnicodeExtraFields); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void close() throws IOException { [EOL] archive.close(); [EOL] }
public void testCloseQuietlyWithNonNullZipFile() throws IOException { [EOL] ZipFile zipfile = mock(ZipFile.class); [EOL] Compress.closeQuietly(zipfile); [EOL] verify(zipfile).close(); [EOL] }
public void testCloseQuietlyWithNullZipFile() { [EOL] ZipFile zipfile = null; [EOL] Compress.closeQuietly(zipfile); [EOL] }
public void testGetEntries_Empty() { [EOL] Compress compress = new Compress(); [EOL] Enumeration entries = compress.getEntries(); [EOL] assertFalse(entries.hasMoreElements()); [EOL] }
public void testGetEntries_NonEmpty() { [EOL] Compress compress = new Compress(); [EOL] compress.entries.put("key", "value"); // Assuming there's a way to add entries to the 'entries' field. [EOL] Enumeration entries = compress.getEntries(); [EOL] assertTrue(entries.hasMoreElements()); [EOL] assertEquals("key", entries.nextElement()); [EOL] }
private Map populateFromCentralDirectory() throws IOException { [EOL] HashMap noEFS = new HashMap(); [EOL] positionAtCentralDirectory(); [EOL] byte[] cfh = new byte[CFH_LEN]; [EOL] byte[] signatureBytes = new byte[WORD]; [EOL] archive.readFully(signatureBytes); [EOL] long sig = ZipLong.getValue(signatureBytes); [EOL] final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL] if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL] throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL] } [EOL] while (sig == cfhSig) { [EOL] archive.readFully(cfh); [EOL] int off = 0; [EOL] ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL] int versionMadeBy = ZipShort.getValue(cfh, off); [EOL] off += SHORT; [EOL] ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL] off += SHORT; [EOL] final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL] final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL] final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL] off += SHORT; [EOL] ze.setMethod(ZipShort.getValue(cfh, off)); [EOL] off += SHORT; [EOL] long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL] ze.setTime(time); [EOL] off += WORD; [EOL] ze.setCrc(ZipLong.getValue(cfh, off)); [EOL] off += WORD; [EOL] ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL] off += WORD; [EOL] ze.setSize(ZipLong.getValue(cfh, off)); [EOL] off += WORD; [EOL] int fileNameLen = ZipShort.getValue(cfh, off); [EOL] off += SHORT; [EOL] int extraLen = ZipShort.getValue(cfh, off); [EOL] off += SHORT; [EOL] int commentLen = ZipShort.getValue(cfh, off); [EOL] off += SHORT; [EOL] off += SHORT; [EOL] ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL] off += SHORT; [EOL] ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL] off += WORD; [EOL] byte[] fileName = new byte[fileNameLen]; [EOL] archive.readFully(fileName); [EOL] ze.setName(entryEncoding.decode(fileName)); [EOL] OffsetEntry offset = new OffsetEntry(); [EOL] offset.headerOffset = ZipLong.getValue(cfh, off); [EOL] entries.put(ze, offset); [EOL] nameMap.put(ze.getName(), ze); [EOL] byte[] cdExtraData = new byte[extraLen]; [EOL] archive.readFully(cdExtraData); [EOL] ze.setCentralDirectoryExtra(cdExtraData); [EOL] byte[] comment = new byte[commentLen]; [EOL] archive.readFully(comment); [EOL] ze.setComment(entryEncoding.decode(comment)); [EOL] archive.readFully(signatureBytes); [EOL] sig = ZipLong.getValue(signatureBytes); [EOL] if (!hasEFS && useUnicodeExtraFields) { [EOL] noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL] } [EOL] } [EOL] return noEFS; [EOL] }
public void testPositionAtCentralDirectoryWithValidArchive() throws IOException { [EOL] RandomAccessFile archive = createMockArchiveWithEOCD(); [EOL] positionAtCentralDirectory(); [EOL] long expectedPosition = ...; // calculate the expected position based on the mock [EOL] assertEquals(expectedPosition, archive.getFilePointer()); [EOL] } [EOL] public void testPositionAtCentralDirectoryWithNoEOCD() throws IOException { [EOL] RandomAccessFile archive = createMockArchiveWithoutEOCD(); [EOL] try { [EOL] positionAtCentralDirectory(); [EOL] fail("Expected a ZipException to be thrown"); [EOL] } catch (ZipException e) { [EOL] assertEquals("archive is not a ZIP archive", e.getMessage()); [EOL] } [EOL] }
private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL] Enumeration e = getEntries(); [EOL] while (e.hasMoreElements()) { [EOL] ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL] OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL] long offset = offsetEntry.headerOffset; [EOL] archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL] byte[] b = new byte[SHORT]; [EOL] archive.readFully(b); [EOL] int fileNameLen = ZipShort.getValue(b); [EOL] archive.readFully(b); [EOL] int extraFieldLen = ZipShort.getValue(b); [EOL] int lenToSkip = fileNameLen; [EOL] while (lenToSkip > 0) { [EOL] int skipped = archive.skipBytes(lenToSkip); [EOL] if (skipped <= 0) { [EOL] throw new RuntimeException("failed to skip file name in local file header"); [EOL] } [EOL] lenToSkip -= skipped; [EOL] } [EOL] byte[] localExtraData = new byte[extraFieldLen]; [EOL] archive.readFully(localExtraData); [EOL] ze.setExtra(localExtraData); [EOL] offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL] if (entriesWithoutEFS.containsKey(ze)) { [EOL] setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL] } [EOL] } [EOL] }
public void testAbstractUnicodeExtraFieldInstantiation() { [EOL] AbstractUnicodeExtraField field = new AbstractUnicodeExtraField(); [EOL] assertNotNull(field); [EOL] }
public void testAbstractUnicodeExtraFieldWithValidInput() { [EOL] String text = "test"; [EOL] byte[] bytes = new byte[] { 0x01, 0x02, 0x03, 0x04 }; [EOL] int off = 0; [EOL] int len = bytes.length; [EOL] AbstractUnicodeExtraField field = new AbstractUnicodeExtraField(text, bytes, off, len); [EOL] assertEquals(0x0D6D7A4A, field.nameCRC32); [EOL] assertArrayEquals(text.getBytes(StandardCharsets.UTF_8), field.unicodeName); [EOL] }
public void testAbstractUnicodeExtraFieldWithOffset() { [EOL] String text = "test"; [EOL] byte[] bytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 }; [EOL] int off = 1; [EOL] int len = 4; [EOL] AbstractUnicodeExtraField field = new AbstractUnicodeExtraField(text, bytes, off, len); [EOL] assertEquals(0x0D6D7A4A, field.nameCRC32); [EOL] assertArrayEquals(text.getBytes(StandardCharsets.UTF_8), field.unicodeName); [EOL] }
public void testAbstractUnicodeExtraFieldWithPartialArray() { [EOL] String text = "test"; [EOL] byte[] bytes = new byte[] { 0x01, 0x02, 0x03, 0x04 }; [EOL] int off = 1; [EOL] int len = 2; [EOL] AbstractUnicodeExtraField field = new AbstractUnicodeExtraField(text, bytes, off, len); [EOL] CRC32 crc32 = new CRC32(); [EOL] crc32.update(bytes, off, len); [EOL] assertEquals(crc32.getValue(), field.nameCRC32); [EOL] assertArrayEquals(text.getBytes(StandardCharsets.UTF_8), field.unicodeName); [EOL] }
public void testAssembleDataWithNullUnicodeName() { [EOL] this.unicodeName = null; [EOL] assembleData(); [EOL] assertNull(data); [EOL] }
public void testAssembleDataWithNonNullUnicodeName() { [EOL] this.unicodeName = "TestName".getBytes(); [EOL] this.nameCRC32 = 123456789L; // Example CRC32 value [EOL] assembleData(); [EOL] assertNotNull(data); [EOL] assertEquals(0x01, data[0]); [EOL] assertArrayEquals(ZipLong.getBytes(nameCRC32), Arrays.copyOfRange(data, 1, 5)); [EOL] assertArrayEquals(unicodeName, Arrays.copyOfRange(data, 5, 5 + unicodeName.length)); [EOL] }
public void testGetNameCRC32() { [EOL] Compress compress = new Compress(); [EOL] long expectedCRC32 = 123456789L; // Example CRC32 value [EOL] compress.nameCRC32 = expectedCRC32; // Assuming there's a way to set this, either through a constructor or a setter method [EOL] long actualCRC32 = compress.getNameCRC32(); [EOL] assertEquals(expectedCRC32, actualCRC32); [EOL] }
public byte[] testGetUnicodeNameNonNull() { [EOL] Compress compressInstance = new Compress(); [EOL] byte[] expected = new byte[]{0x00, 0x63}; [EOL] compressInstance.unicodeName = expected; [EOL] byte[] actual = compressInstance.getUnicodeName(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testGetCentralDirectoryData_WithDataNotNull() { [EOL] Compress compress = new Compress(); [EOL] byte[] expectedData = new byte[] {1, 2, 3, 4}; [EOL] compress.data = expectedData; [EOL] byte[] actualData = compress.getCentralDirectoryData(); [EOL] assertArrayEquals(expectedData, actualData); [EOL] }
public void testGetCentralDirectoryData_WithDataNull() { [EOL] Compress compress = new Compress(); [EOL] compress.data = null; [EOL] compress.assembleData = () -> compress.data = new byte[] {5, 6, 7, 8}; [EOL] byte[] actualData = compress.getCentralDirectoryData(); [EOL] assertNotNull(actualData); [EOL] assertTrue(actualData.length > 0); [EOL] }
public void testGetCentralDirectoryLengthWithDataNotNull() { [EOL] Compress compress = new Compress(); [EOL] compress.assembleData(); [EOL] ZipShort result = compress.getCentralDirectoryLength(); [EOL] assertNotNull(result); [EOL] assertTrue(result.getValue() > 0); [EOL] }
public void testGetCentralDirectoryLengthWithDataNull() { [EOL] Compress compress = new Compress(); [EOL] ZipShort result = compress.getCentralDirectoryLength(); [EOL] assertNotNull(result); [EOL] assertTrue(result.getValue() > 0); [EOL] }
public byte[] getLocalFileDataData() { [EOL] return getCentralDirectoryData(); [EOL] }
public void testGetLocalFileDataLength() { [EOL] ZipShort expected = new ZipShort(10); // Assuming ZipShort is a class with a constructor that takes an int [EOL] ZipEntry entry = new ZipEntry("test.zip"); // Assuming ZipEntry is a class with a method setCentralDirectoryLength [EOL] entry.setCentralDirectoryLength(expected); [EOL] assertEquals(expected, entry.getLocalFileDataLength()); [EOL] }
public void testParseFromLocalFileData_InvalidLength() { [EOL] byte[] buffer = new byte[10]; [EOL] int offset = 0; [EOL] int length = 4; // less than the required 5 bytes [EOL] try { [EOL] parseFromLocalFileData(buffer, offset, length); [EOL] fail("Should have thrown a ZipException due to invalid length"); [EOL] } catch (ZipException e) { [EOL] assertEquals("UniCode path extra data must have at least 5 bytes.", e.getMessage()); [EOL] } [EOL] }
public void testParseFromLocalFileData_UnsupportedVersion() { [EOL] byte[] buffer = {0x02, 0x00, 0x00, 0x00, 0x00, 0x00}; // version not equal to 0x01 [EOL] int offset = 0; [EOL] int length = 6; [EOL] try { [EOL] parseFromLocalFileData(buffer, offset, length); [EOL] fail("Should have thrown a ZipException due to unsupported version"); [EOL] } catch (ZipException e) { [EOL] assertTrue(e.getMessage().contains("Unsupported version [")); [EOL] } [EOL] }
public void testParseFromLocalFileData_ValidData() { [EOL] byte[] buffer = {0x01, 0x00, 0x00, 0x00, 0x00, 'a', 'b', 'c', 'd', 'e'}; // version is 0x01 [EOL] int offset = 0; [EOL] int length = 10; [EOL] try { [EOL] parseFromLocalFileData(buffer, offset, length); [EOL] } catch (ZipException e) { [EOL] fail("Should not have thrown a ZipException with valid data"); [EOL] } [EOL] }
public void testParseFromCentralDirectoryData_ValidInput() throws ZipException { [EOL] byte[] buffer = new byte[] { /* valid central directory data bytes */ }; [EOL] int offset = 0; [EOL] int length = buffer.length; [EOL] parseFromCentralDirectoryData(buffer, offset, length); [EOL] }
public void testParseFromCentralDirectoryData_InvalidInput() throws ZipException { [EOL] byte[] buffer = new byte[] { /* invalid central directory data bytes */ }; [EOL] int offset = 0; [EOL] int length = buffer.length; [EOL] try { [EOL] parseFromCentralDirectoryData(buffer, offset, length); [EOL] fail("Expected a ZipException to be thrown"); [EOL] } catch (ZipException e) { [EOL] } [EOL] }
public void testRemoveExtraField_WithNullExtraFields() { [EOL] Compress compress = new Compress(); [EOL] ZipShort type = new ZipShort(1); [EOL] try { [EOL] compress.removeExtraField(type); [EOL] fail("Should have thrown NoSuchElementException"); [EOL] } catch (java.util.NoSuchElementException expected) { [EOL] } [EOL] }
public void testRemoveExtraField_WithNonExistingType() { [EOL] Compress compress = new Compress(); [EOL] compress.setExtraFields(new HashMap<ZipShort, ExtraField>()); [EOL] ZipShort type = new ZipShort(1); [EOL] try { [EOL] compress.removeExtraField(type); [EOL] fail("Should have thrown NoSuchElementException"); [EOL] } catch (java.util.NoSuchElementException expected) { [EOL] } [EOL] }
public void testRemoveExtraField_WithExistingType() { [EOL] Compress compress = new Compress(); [EOL] ZipShort type = new ZipShort(1); [EOL] ExtraField extraField = new ExtraField(); [EOL] Map<ZipShort, ExtraField> extraFields = new HashMap<>(); [EOL] extraFields.put(type, extraField); [EOL] compress.setExtraFields(extraFields); [EOL] compress.removeExtraField(type); [EOL] assertFalse(compress.getExtraFields().containsKey(type)); [EOL] }
public void testFallbackZipEncodingWithNull() { [EOL] FallbackZipEncoding encoding = new FallbackZipEncoding(null); [EOL] assertNull(encoding.charset); [EOL] }
public void testFallbackZipEncodingWithEmptyString() { [EOL] FallbackZipEncoding encoding = new FallbackZipEncoding(""); [EOL] assertEquals("", encoding.charset); [EOL] }
public void testFallbackZipEncodingWithValidCharset() { [EOL] FallbackZipEncoding encoding = new FallbackZipEncoding("UTF-8"); [EOL] assertEquals("UTF-8", encoding.charset); [EOL] }
public void testAdjustToLongWithNegativeInput() { [EOL] int negativeInput = -1; [EOL] long expected = 2 * ((long) Integer.MAX_VALUE) + 2 - 1; [EOL] long result = compress.adjustToLong(negativeInput); [EOL] assertEquals(expected, result); [EOL] }
public void testAdjustToLongWithPositiveInput() { [EOL] int positiveInput = 1; [EOL] long expected = 1; [EOL] long result = compress.adjustToLong(positiveInput); [EOL] assertEquals(expected, result); [EOL] }
public void testAdjustToLongWithZeroInput() { [EOL] int zeroInput = 0; [EOL] long expected = 0; [EOL] long result = compress.adjustToLong(zeroInput); [EOL] assertEquals(expected, result); [EOL] }
public void testAdjustToLongWithMaxIntInput() { [EOL] int maxIntInput = Integer.MAX_VALUE; [EOL] long expected = Integer.MAX_VALUE; [EOL] long result = compress.adjustToLong(maxIntInput); [EOL] assertEquals(expected, result); [EOL] }
public void testAdjustToLongWithMinIntInput() { [EOL] int minIntInput = Integer.MIN_VALUE; [EOL] long expected = 2 * ((long) Integer.MAX_VALUE) + 2 + Integer.MIN_VALUE; [EOL] long result = compress.adjustToLong(minIntInput); [EOL] assertEquals(expected, result); [EOL] }
public void testSetHeaderIdWithNull() { [EOL] ExtraFieldUtils extraFieldUtils = new ExtraFieldUtils(); [EOL] extraFieldUtils.setHeaderId(null); [EOL] assertNull(extraFieldUtils.getHeaderId()); [EOL] }
public void testSetHeaderIdWithNonNull() { [EOL] ExtraFieldUtils extraFieldUtils = new ExtraFieldUtils(); [EOL] ZipShort headerId = new ZipShort(0x0001); [EOL] extraFieldUtils.setHeaderId(headerId); [EOL] assertEquals(headerId, extraFieldUtils.getHeaderId()); [EOL] }
public void testGetHeaderId() { [EOL] Compress compress = new Compress(); [EOL] ZipShort expected = new ZipShort(0x0201); [EOL] compress.setHeaderId(expected); [EOL] ZipShort actual = compress.getHeaderId(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetLocalFileDataData_NullData() { [EOL] Compress compress = new Compress(); [EOL] compress.setLocalFileDataData(null); [EOL] assertNull("localData should be null", compress.getLocalData()); [EOL] }
public void testSetLocalFileDataData_NonNullData() { [EOL] Compress compress = new Compress(); [EOL] byte[] testData = new byte[] {1, 2, 3, 4}; [EOL] compress.setLocalFileDataData(testData); [EOL] assertArrayEquals("localData should match testData", testData, compress.getLocalData()); [EOL] }
public void testGetLocalFileDataLengthEmptyData() { [EOL] ZipEntry entry = new ZipEntry(); [EOL] entry.localData = new byte[0]; [EOL] ZipShort result = entry.getLocalFileDataLength(); [EOL] assertEquals(0, result.getValue()); [EOL] }
public void testGetLocalFileDataLengthWithData() { [EOL] ZipEntry entry = new ZipEntry(); [EOL] entry.localData = new byte[]{1, 2, 3, 4}; [EOL] ZipShort result = entry.getLocalFileDataLength(); [EOL] assertEquals(4, result.getValue()); [EOL] }
public byte[] testGetLocalFileDataData_NullLocalData() { [EOL] Compress compress = new Compress(); [EOL] compress.localData = null; [EOL] byte[] result = compress.getLocalFileDataData(); [EOL] assertNull(result); [EOL] }
public byte[] testGetLocalFileDataData_NonNullLocalData() { [EOL] Compress compress = new Compress(); [EOL] compress.localData = new byte[] {1, 2, 3}; [EOL] byte[] result = compress.getLocalFileDataData(); [EOL] assertArrayEquals(new byte[] {1, 2, 3}, result); [EOL] }
public void testCopyWithNonNullInput() { [EOL] byte[] input = new byte[] {1, 2, 3}; [EOL] byte[] result = copy(input); [EOL] assertNotNull(result); [EOL] assertNotSame(input, result); [EOL] assertArrayEquals(input, result); [EOL] } [EOL] public void testCopyWithNullInput() { [EOL] byte[] result = copy(null); [EOL] assertNull(result); [EOL] }
public void testGzipCompressorInputStreamWithValidStream() throws IOException { [EOL] ByteArrayInputStream input = new ByteArrayInputStream(new byte[]{31, -117, 8, 0, 0, 0, 0, 0, 0, 0}); [EOL] GzipCompressorInputStream gzipCompressorInputStream = new GzipCompressorInputStream(input); [EOL] assertNotNull(gzipCompressorInputStream); [EOL] }
public void testGzipCompressorInputStreamWithNullStream() { [EOL] try { [EOL] GzipCompressorInputStream gzipCompressorInputStream = new GzipCompressorInputStream(null); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals(e.getMessage(), "inputStream must not be null"); [EOL] } [EOL] }
public int read() throws IOException { [EOL] return in.read(); [EOL] }
public void testGetHeaderId() { [EOL] MyClass instance = new MyClass(); [EOL] ZipShort result = instance.getHeaderId(); [EOL] assertEquals(MyClass.HEADER_ID, result); [EOL] }
public void testGetCentralDirectoryLength() { [EOL] ZipShort expected = new ZipShort(10); [EOL] ZipShort actual = getCentralDirectoryLength(); [EOL] assertEquals(expected.getValue(), actual.getValue()); [EOL] }
public byte[] getCentralDirectoryData() { [EOL] return getLocalFileDataData(); [EOL] }
public void testSimpleEncodingHolderConstructor() { [EOL] char[] highChars = new char[] {'a', 'b', 'c'}; [EOL] SimpleEncodingHolder holder = new SimpleEncodingHolder(highChars); [EOL] assertNotNull(holder.getEncoding()); [EOL] }
public void testGrowBuffer() { [EOL] ByteBuffer buffer = ByteBuffer.allocate(10); [EOL] int newCapacity = 20; [EOL] ByteBuffer newBuffer = SimpleEncodingHolder.growBuffer(buffer, newCapacity); [EOL] assertEquals(newCapacity, newBuffer.capacity()); [EOL] }
public void testAppendSurrogate() { [EOL] ByteBuffer bb = ByteBuffer.allocate(10); [EOL] char c = 'a'; [EOL] SimpleEncodingHolder.appendSurrogate(bb, c); [EOL] assertEquals(1, bb.position()); [EOL] }
public void testGetZipEncodingUTF8() { [EOL] String encoding = "UTF-8"; [EOL] ZipEncoding zipEncoding = SimpleEncodingHolder.getZipEncoding(encoding); [EOL] assertTrue(SimpleEncodingHolder.isUTF8(encoding)); [EOL] assertNotNull(zipEncoding); [EOL] }
public void testGetZipEncodingNonUTF8() { [EOL] String encoding = "Cp1252"; [EOL] ZipEncoding zipEncoding = SimpleEncodingHolder.getZipEncoding(encoding); [EOL] assertFalse(SimpleEncodingHolder.isUTF8(encoding)); [EOL] assertNotNull(zipEncoding); [EOL] }
public void testGetEncoding_NotInitialized() { [EOL] SimpleEncodingHolder holder = new SimpleEncodingHolder(new char[] {'a', 'b', 'c'}); [EOL] Simple8BitZipEncoding result = holder.getEncoding(); [EOL] assertNotNull(result); [EOL] }
public void testGetEncoding_AlreadyInitialized() { [EOL] SimpleEncodingHolder holder = new SimpleEncodingHolder(new char[] {'a', 'b', 'c'}); [EOL] Simple8BitZipEncoding firstCallResult = holder.getEncoding(); [EOL] Simple8BitZipEncoding secondCallResult = holder.getEncoding(); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public void testJarArchiveEntryWithName() { [EOL] String name = "testEntry.jar"; [EOL] JarArchiveEntry entry = new JarArchiveEntry(name); [EOL] assertEquals(name, entry.getName()); [EOL] }
public void testRegisterWithValidClass() { [EOL] Class<?> validClass = ValidZipExtraFieldImplementation.class; // Assume this class implements ZipExtraField and has a public no-arg constructor [EOL] Compress.register(validClass); [EOL] Map<ZipShort, Class<?>> implementations = getImplementationsMap(); // Assume this method retrieves the map from the Compress class [EOL] assertTrue(implementations.containsKey(new ZipShort(validClass.newInstance().getHeaderId()))); [EOL] }
public void testRegisterWithClassCastException() { [EOL] Class<?> invalidClass = Object.class; // Object does not implement ZipExtraField [EOL] try { [EOL] Compress.register(invalidClass); [EOL] fail("Expected a RuntimeException due to ClassCastException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals(invalidClass + " doesn't implement ZipExtraField", e.getMessage()); [EOL] } [EOL] }
public void testRegisterWithInstantiationException() { [EOL] Class<?> abstractClass = AbstractZipExtraFieldImplementation.class; // Assume this class is abstract and implements ZipExtraField [EOL] try { [EOL] Compress.register(abstractClass); [EOL] fail("Expected a RuntimeException due to InstantiationException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals(abstractClass + " is not a concrete class", e.getMessage()); [EOL] } [EOL] }
public void testRegisterWithIllegalAccessException() { [EOL] Class<?> privateConstructorClass = PrivateConstructorZipExtraFieldImplementation.class; // Assume this class implements ZipExtraField and has a private no-arg constructor [EOL] try { [EOL] Compress.register(privateConstructorClass); [EOL] fail("Expected a RuntimeException due to IllegalAccessException"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals(privateConstructorClass + "'s no-arg constructor is not public", e.getMessage()); [EOL] } [EOL] }
public void testMergeLocalFileDataDataWithEmptyArray() { [EOL] ZipExtraField[] data = new ZipExtraField[0]; [EOL] byte[] result = Compress.mergeLocalFileDataData(data); [EOL] assertEquals(0, result.length); [EOL] }
public void testMergeLocalFileDataDataWithSingleElement() { [EOL] ZipExtraField[] data = new ZipExtraField[1]; [EOL] data[0] = new SimpleZipExtraField((byte) 1, (byte) 2); [EOL] byte[] result = Compress.mergeLocalFileDataData(data); [EOL] assertEquals(WORD + 4, result.length); // Assuming WORD is a constant that we know the value of [EOL] }
public void testMergeLocalFileDataDataWithMultipleElements() { [EOL] ZipExtraField[] data = new ZipExtraField[2]; [EOL] data[0] = new SimpleZipExtraField((byte) 1, (byte) 2); [EOL] data[1] = new SimpleZipExtraField((byte) 3, (byte) 4); [EOL] byte[] result = Compress.mergeLocalFileDataData(data); [EOL] assertEquals(2 * WORD + 8, result.length); // Assuming WORD is a constant that we know the value of [EOL] }
public void testMergeCentralDirectoryDataWithEmptyArray() { [EOL] ZipExtraField[] data = new ZipExtraField[0]; [EOL] byte[] result = Compress.mergeCentralDirectoryData(data); [EOL] assertEquals(0, result.length); [EOL] }
public void testMergeCentralDirectoryDataWithSingleElement() { [EOL] ZipExtraField[] data = new ZipExtraField[1]; [EOL] data[0] = new SimpleZipExtraField((short) 1, new byte[]{1, 2}); [EOL] byte[] result = Compress.mergeCentralDirectoryData(data); [EOL] assertEquals(4, result.length); // WORD * data.length + data[0].length [EOL] assertArrayEquals(new byte[]{0, 1, 0, 2}, result); [EOL] }
public void testMergeCentralDirectoryDataWithMultipleElements() { [EOL] ZipExtraField[] data = new ZipExtraField[2]; [EOL] data[0] = new SimpleZipExtraField((short) 1, new byte[]{1, 2}); [EOL] data[1] = new SimpleZipExtraField((short) 2, new byte[]{3, 4, 5, 6}); [EOL] byte[] result = Compress.mergeCentralDirectoryData(data); [EOL] assertEquals(10, result.length); // WORD * data.length + data[0].length + data[1].length [EOL] assertArrayEquals(new byte[]{0, 1, 0, 2, 0, 2, 0, 4, 3, 4, 5, 6}, result); [EOL] }
public void testSimple8BitCharConstructor() { [EOL] byte expectedCode = 0x61; // ASCII code for 'a' [EOL] char expectedUnicode = 'a'; [EOL] Simple8BitChar simple8BitChar = new Simple8BitChar(expectedCode, expectedUnicode); [EOL] assertEquals(expectedCode, simple8BitChar.code); [EOL] assertEquals(expectedUnicode, simple8BitChar.unicode); [EOL] }
public void testCompareTo_SameObject() { [EOL] Simple8BitChar char1 = new Simple8BitChar('a'); [EOL] int result = char1.compareTo(char1); [EOL] assert result == 0; [EOL] }
public void testCompareTo_LessThan() { [EOL] Simple8BitChar char1 = new Simple8BitChar('a'); [EOL] Simple8BitChar char2 = new Simple8BitChar('b'); [EOL] int result = char1.compareTo(char2); [EOL] assert result < 0; [EOL] }
public void testCompareTo_GreaterThan() { [EOL] Simple8BitChar char1 = new Simple8BitChar('b'); [EOL] Simple8BitChar char2 = new Simple8BitChar('a'); [EOL] int result = char1.compareTo(char2); [EOL] assert result > 0; [EOL] }
public void testSimple8BitZipEncodingWithEmptyHighChars() { [EOL] char[] highChars = new char[0]; [EOL] Simple8BitZipEncoding encoding = new Simple8BitZipEncoding(highChars); [EOL] assertNotNull(encoding); [EOL] assertEquals(0, encoding.getHighChars().length); [EOL] assertTrue(encoding.getReverseMapping().isEmpty()); [EOL] }
public void testSimple8BitZipEncodingWithSingleHighChar() { [EOL] char[] highChars = new char[]{'A'}; [EOL] Simple8BitZipEncoding encoding = new Simple8BitZipEncoding(highChars); [EOL] assertNotNull(encoding); [EOL] assertEquals(1, encoding.getHighChars().length); [EOL] assertEquals('A', encoding.getHighChars()[0]); [EOL] assertEquals(1, encoding.getReverseMapping().size()); [EOL] assertEquals(128, encoding.getReverseMapping().get(0).getCode()); [EOL] assertEquals('A', encoding.getReverseMapping().get(0).getChar()); [EOL] }
public void testSimple8BitZipEncodingWithMultipleHighChars() { [EOL] char[] highChars = new char[]{'A', 'B', 'C'}; [EOL] Simple8BitZipEncoding encoding = new Simple8BitZipEncoding(highChars); [EOL] assertNotNull(encoding); [EOL] assertEquals(3, encoding.getHighChars().length); [EOL] assertEquals('A', encoding.getHighChars()[0]); [EOL] assertEquals('B', encoding.getHighChars()[1]); [EOL] assertEquals('C', encoding.getHighChars()[2]); [EOL] assertEquals(3, encoding.getReverseMapping().size()); [EOL] assertEquals(128, encoding.getReverseMapping().get(0).getCode()); [EOL] assertEquals('A', encoding.getReverseMapping().get(0).getChar()); [EOL] assertEquals(129, encoding.getReverseMapping().get(1).getCode()); [EOL] assertEquals('B', encoding.getReverseMapping().get(1).getChar()); [EOL] assertEquals(130, encoding.getReverseMapping().get(2).getCode()); [EOL] assertEquals('C', encoding.getReverseMapping().get(2).getChar()); [EOL] }
public void testDecodeBytePositive() { [EOL] Compress compressor = new Compress(); [EOL] byte input = 65; // ASCII for 'A' [EOL] char expected = 'A'; [EOL] char result = compressor.decodeByte(input); [EOL] assertEquals(expected, result); [EOL] }
public void testDecodeByteNegative() { [EOL] Compress compressor = new Compress(); [EOL] byte input = -1; // Assuming highChars[-128] = 'ÿ' [EOL] char expected = 'ÿ'; [EOL] char result = compressor.decodeByte(input); [EOL] assertEquals(expected, result); [EOL] }
public void testCanEncodeChar_ValidAscii() { [EOL] Compress compressor = new Compress(); [EOL] boolean result = compressor.canEncodeChar('A'); [EOL] assert result == true; [EOL] } [EOL] public void testCanEncodeChar_InvalidAscii() { [EOL] Compress compressor = new Compress(); [EOL] boolean result = compressor.canEncodeChar((char) 128); [EOL] assert result == false; [EOL] } [EOL] public void testCanEncodeChar_ValidHighChar() { [EOL] Compress compressor = new Compress() { [EOL] @Override [EOL] public Simple8BitChar encodeHighChar(char c) { [EOL] return new Simple8BitChar(); // Assuming Simple8BitChar is a valid return type for high chars [EOL] } [EOL] }; [EOL] boolean result = compressor.canEncodeChar((char) 129); [EOL] assert result == true; [EOL] } [EOL] public void testCanEncodeChar_InvalidHighChar() { [EOL] Compress compressor = new Compress() { [EOL] @Override [EOL] public Simple8BitChar encodeHighChar(char c) { [EOL] return null; [EOL] } [EOL] }; [EOL] boolean result = compressor.canEncodeChar((char) 129); [EOL] assert result == false; [EOL] }
public void testPushEncodedChar_ValidAscii() { [EOL] ByteBuffer bb = ByteBuffer.allocate(10); [EOL] char c = 'A'; // ASCII value of 'A' is 65, which is within the valid range [EOL] boolean result = pushEncodedChar(bb, c); [EOL] assertTrue(result); [EOL] assertEquals(1, bb.position()); [EOL] assertEquals((byte) 'A', bb.get(0)); [EOL] } [EOL] public void testPushEncodedChar_InvalidChar() { [EOL] ByteBuffer bb = ByteBuffer.allocate(10); [EOL] char c = '\u0800'; // This is a char value that is not within the ASCII range and assumed not encodable [EOL] boolean result = pushEncodedChar(bb, c); [EOL] assertFalse(result); [EOL] assertEquals(0, bb.position()); [EOL] }
public void testPushEncodedChar_ValidNonAscii() { [EOL] ByteBuffer bb = ByteBuffer.allocate(10); [EOL] char c = '\u00A9'; // This is a char value that is not within the ASCII range but assumed to be encodable [EOL] Simple8BitChar encodedChar = new Simple8BitChar(); // Assuming this is a valid encoded char [EOL] encodedChar.code = (byte) 0xA9; [EOL] when(this.encodeHighChar(c)).thenReturn(encodedChar); [EOL] boolean result = pushEncodedChar(bb, c); [EOL] assertTrue(result); [EOL] assertEquals(1, bb.position()); [EOL] assertEquals((byte) 0xA9, bb.get(0)); [EOL] }
private Simple8BitChar encodeHighChar(char c) { [EOL] int i0 = 0; [EOL] int i1 = this.reverseMapping.size(); [EOL] while (i1 > i0) { [EOL] int i = i0 + (i1 - i0) / 2; [EOL] Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL] if (m.unicode == c) { [EOL] return m; [EOL] } [EOL] if (m.unicode < c) { [EOL] i0 = i + 1; [EOL] } else { [EOL] i1 = i; [EOL] } [EOL] } [EOL] if (i0 >= this.reverseMapping.size()) { [EOL] return null; [EOL] } [EOL] Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL] if (r.unicode != c) { [EOL] return null; [EOL] } [EOL] return r; [EOL] }
public void testCanEncodeWithEmptyString() { [EOL] Compress compressor = new Compress(); [EOL] boolean result = compressor.canEncode(""); [EOL] assertTrue(result); [EOL] }
public void testCanEncodeWithEncodableString() { [EOL] Compress compressor = new Compress(); [EOL] boolean result = compressor.canEncode("encodableString"); [EOL] assertTrue(result); [EOL] }
public void testCanEncodeWithUnencodableString() { [EOL] Compress compressor = new Compress(); [EOL] boolean result = compressor.canEncode("unencodableString!"); [EOL] assertFalse(result); [EOL] }
public void testEncodeEmptyString() { [EOL] ByteBuffer result = encode(""); [EOL] assertEquals(6, result.capacity()); [EOL] assertEquals(0, result.limit()); [EOL] }
public void testEncodeStringWithoutSurrogates() { [EOL] String input = "Test"; [EOL] ByteBuffer result = encode(input); [EOL] assertEquals(input.length() + 6 + (input.length() + 1) / 2, result.capacity()); [EOL] assertEquals(input.length(), result.limit()); [EOL] for (int i = 0; i < input.length(); i++) { [EOL] assertEquals(input.charAt(i), result.get(i)); [EOL] } [EOL] }
public void testEncodeStringWithSurrogates() { [EOL] String input = "Test\uD83D\uDE00"; // String with surrogate pair [EOL] ByteBuffer result = encode(input); [EOL] assertTrue(result.capacity() >= input.length() + 6 + (input.length() + 1) / 2); [EOL] assertEquals(input.length() + 2, result.limit()); // surrogate pair takes an extra space [EOL] for (int i = 0; i < input.length(); i++) { [EOL] if (Character.isHighSurrogate(input.charAt(i))) { [EOL] i++; // Skip the low surrogate [EOL] } else { [EOL] assertEquals(input.charAt(i), result.get()); [EOL] } [EOL] } [EOL] }
public void testDecodeWithEmptyArray() throws IOException { [EOL] byte[] data = new byte[0]; [EOL] String result = decode(data); [EOL] assertEquals("", result); [EOL] }
public void testDecodeWithNonEmptyArray() throws IOException { [EOL] byte[] data = new byte[]{0x61, 0x62, 0x63}; // assuming decodeByte method decodes to 'a', 'b', 'c' [EOL] String result = decode(data); [EOL] assertEquals("abc", result); [EOL] }
public void testGetNextArEntryWithInvalidHeader() throws IOException { [EOL] ByteArrayInputStream input = new ByteArrayInputStream("invalid_header".getBytes()); [EOL] ArArchiveInputStream arInput = new ArArchiveInputStream(input); [EOL] try { [EOL] arInput.getNextArEntry(); [EOL] fail("Should have thrown IOException due to invalid header"); [EOL] } catch (IOException e) { [EOL] assertEquals("invalid header invalid_header", e.getMessage()); [EOL] } [EOL] }
public void testGetNextArEntryWithNoAvailableInput() throws IOException { [EOL] ByteArrayInputStream input = new ByteArrayInputStream("!<arch>\n".getBytes()); [EOL] ArArchiveInputStream arInput = new ArArchiveInputStream(input); [EOL] ArArchiveEntry entry = arInput.getNextArEntry(); [EOL] assertNull("Should return null when no more entries are available", entry); [EOL] }
public void testGetNextArEntryWithProperHeaderAndEntry() throws IOException { [EOL] String header = "!<arch>\n"; [EOL] String entryHeader = "file.txt/           0           0     0     0     100644  12        `\012"; [EOL] String content = "Hello World!"; [EOL] ByteArrayOutputStream buffer = new ByteArrayOutputStream(); [EOL] buffer.write(header.getBytes()); [EOL] buffer.write(entryHeader.getBytes()); [EOL] buffer.write(content.getBytes()); [EOL] ByteArrayInputStream input = new ByteArrayInputStream(buffer.toByteArray()); [EOL] ArArchiveInputStream arInput = new ArArchiveInputStream(input); [EOL] ArArchiveEntry entry = arInput.getNextArEntry(); [EOL] assertNotNull("Should return an entry when available", entry); [EOL] assertEquals("file.txt", entry.getName()); [EOL] assertEquals(12, entry.getLength()); [EOL] }
public void testGetNextArEntryWithOddOffset() throws IOException { [EOL] String header = "!<arch>\n"; [EOL] String entryHeader = "file.txt/           0           0     0     0     100644  11        `\012"; [EOL] String content = "Hello World"; [EOL] ByteArrayOutputStream buffer = new ByteArrayOutputStream(); [EOL] buffer.write(header.getBytes()); [EOL] buffer.write(entryHeader.getBytes()); [EOL] buffer.write(content.getBytes()); [EOL] buffer.write(' '); [EOL] ByteArrayInputStream input = new ByteArrayInputStream(buffer.toByteArray()); [EOL] ArArchiveInputStream arInput = new ArArchiveInputStream(input); [EOL] arInput.getNextArEntry(); // Read first entry to make the offset odd [EOL] ArArchiveEntry entry = arInput.getNextArEntry(); [EOL] assertNotNull("Should return an entry even with an odd offset", entry); [EOL] assertEquals("file.txt", entry.getName()); [EOL] assertEquals(11, entry.getLength()); [EOL] }
public ArchiveEntry getNextEntry() throws IOException { [EOL] return getNextArEntry(); [EOL] }
public void testReadWithValidInput() throws IOException { [EOL] Compress compress = new Compress(); [EOL] byte[] buffer = new byte[10]; [EOL] int bytesRead = compress.read(buffer); [EOL] assertEquals(10, bytesRead); [EOL] assertEquals(10, compress.getOffset()); [EOL] }
public void testReadWithEmptyBuffer() throws IOException { [EOL] Compress compress = new Compress(); [EOL] byte[] buffer = new byte[0]; [EOL] int bytesRead = compress.read(buffer); [EOL] assertEquals(0, bytesRead); [EOL] assertEquals(0, compress.getOffset()); [EOL] }
public void testReadWithNullBuffer() throws IOException { [EOL] Compress compress = new Compress(); [EOL] byte[] buffer = null; [EOL] try { [EOL] compress.read(buffer); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReadWithValidInput() throws IOException { [EOL] byte[] buffer = new byte[10]; [EOL] ByteArrayInputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}); [EOL] Compress compress = new Compress(in); [EOL] int bytesRead = compress.read(buffer, 0, buffer.length); [EOL] assertEquals(10, bytesRead); [EOL] assertEquals(0, compress.getOffset()); [EOL] }
public void testReadWithPartialBufferRead() throws IOException { [EOL] byte[] buffer = new byte[10]; [EOL] ByteArrayInputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] Compress compress = new Compress(in); [EOL] int bytesRead = compress.read(buffer, 0, 5); [EOL] assertEquals(5, bytesRead); [EOL] assertEquals(0, compress.getOffset()); [EOL] }
public void testReadWithOffset() throws IOException { [EOL] byte[] buffer = new byte[10]; [EOL] ByteArrayInputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}); [EOL] Compress compress = new Compress(in); [EOL] int bytesRead = compress.read(buffer, 2, 5); [EOL] assertEquals(5, bytesRead); [EOL] assertEquals(2, compress.getOffset()); [EOL] }
public void testReadAtEndOfStream() throws IOException { [EOL] byte[] buffer = new byte[10]; [EOL] ByteArrayInputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3}); [EOL] Compress compress = new Compress(in); [EOL] int bytesRead = compress.read(buffer, 0, buffer.length); [EOL] assertEquals(3, bytesRead); [EOL] compress.read(buffer, 0, buffer.length); [EOL] bytesRead = compress.read(buffer, 0, buffer.length); [EOL] assertEquals(-1, bytesRead); [EOL] assertEquals(0, compress.getOffset()); [EOL] }
public void testCreateCompressorInputStreamWithNullName() { [EOL] InputStream dummyStream = new ByteArrayInputStream(new byte[0]); [EOL] try { [EOL] createCompressorInputStream(null, dummyStream); [EOL] fail("Should have thrown IllegalArgumentException for null compressor name."); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Compressor name and stream must not be null.", e.getMessage()); [EOL] } catch (CompressorException e) { [EOL] fail("Expected IllegalArgumentException, not CompressorException."); [EOL] } [EOL] }
public void testCreateCompressorInputStreamWithNullStream() { [EOL] try { [EOL] createCompressorInputStream("gz", null); [EOL] fail("Should have thrown IllegalArgumentException for null input stream."); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Compressor name and stream must not be null.", e.getMessage()); [EOL] } catch (CompressorException e) { [EOL] fail("Expected IllegalArgumentException, not CompressorException."); [EOL] } [EOL] }
public void testCreateCompressorInputStreamForGzip() throws CompressorException { [EOL] InputStream dummyStream = new ByteArrayInputStream(new byte[0]); [EOL] CompressorInputStream compressorInputStream = createCompressorInputStream("gz", dummyStream); [EOL] assertTrue(compressorInputStream instanceof GzipCompressorInputStream); [EOL] }
public void testCreateCompressorInputStreamForBzip2() throws CompressorException { [EOL] InputStream dummyStream = new ByteArrayInputStream(new byte[0]); [EOL] CompressorInputStream compressorInputStream = createCompressorInputStream("bzip2", dummyStream); [EOL] assertTrue(compressorInputStream instanceof BZip2CompressorInputStream); [EOL] }
public void testCreateCompressorInputStreamWithUnknownCompressor() { [EOL] InputStream dummyStream = new ByteArrayInputStream(new byte[0]); [EOL] try { [EOL] createCompressorInputStream("unknown", dummyStream); [EOL] fail("Should have thrown CompressorException for unknown compressor."); [EOL] } catch (CompressorException e) { [EOL] assertEquals("Compressor: unknown not found.", e.getMessage()); [EOL] } [EOL] }
public void testCreateCompressorInputStreamIOException() { [EOL] InputStream dummyStream = new InputStream() { [EOL] @Override [EOL] public int read() throws IOException { [EOL] throw new IOException("Dummy IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] createCompressorInputStream("gz", dummyStream); [EOL] fail("Should have thrown CompressorException due to IOException."); [EOL] } catch (CompressorException e) { [EOL] assertEquals("Could not create CompressorInputStream", e.getMessage()); [EOL] assertNotNull(e.getCause()); [EOL] assertEquals(IOException.class, e.getCause().getClass()); [EOL] assertEquals("Dummy IOException", e.getCause().getMessage()); [EOL] } [EOL] }
public void testCreateCompressorOutputStreamWithNullName() { [EOL] OutputStream dummyOut = new ByteArrayOutputStream(); [EOL] try { [EOL] createCompressorOutputStream(null, dummyOut); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Compressor name and stream must not be null.", e.getMessage()); [EOL] } catch (CompressorException e) { [EOL] fail("Expected IllegalArgumentException, not CompressorException"); [EOL] } [EOL] }
public void testCreateCompressorOutputStreamWithNullOutputStream() { [EOL] try { [EOL] createCompressorOutputStream("gz", null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Compressor name and stream must not be null.", e.getMessage()); [EOL] } catch (CompressorException e) { [EOL] fail("Expected IllegalArgumentException, not CompressorException"); [EOL] } [EOL] }
public void testCreateCompressorOutputStreamWithGzip() throws CompressorException { [EOL] OutputStream dummyOut = new ByteArrayOutputStream(); [EOL] CompressorOutputStream cos = createCompressorOutputStream("gz", dummyOut); [EOL] assertTrue(cos instanceof GzipCompressorOutputStream); [EOL] }
public void testCreateCompressorOutputStreamWithBzip2() throws CompressorException { [EOL] OutputStream dummyOut = new ByteArrayOutputStream(); [EOL] CompressorOutputStream cos = createCompressorOutputStream("bzip2", dummyOut); [EOL] assertTrue(cos instanceof BZip2CompressorOutputStream); [EOL] }
public void testCreateCompressorOutputStreamWithUnknownCompressor() { [EOL] OutputStream dummyOut = new ByteArrayOutputStream(); [EOL] try { [EOL] createCompressorOutputStream("unknown", dummyOut); [EOL] fail("Should have thrown CompressorException"); [EOL] } catch (CompressorException e) { [EOL] assertEquals("Compressor: unknown not found.", e.getMessage()); [EOL] } [EOL] }
public void testUnicodePathExtraFieldConstructor() { [EOL] new UnicodePathExtraField(); [EOL] }
public void testUnicodePathExtraFieldWithValidInput() { [EOL] String text = "testText"; [EOL] byte[] bytes = new byte[] {0x01, 0x02, 0x03, 0x04}; [EOL] int off = 0; [EOL] int len = bytes.length; [EOL] UnicodePathExtraField field = new UnicodePathExtraField(text, bytes, off, len); [EOL] assertNotNull(field); [EOL] }
public void testUnicodePathExtraFieldWithSubArray() { [EOL] String text = "testText"; [EOL] byte[] bytes = new byte[] {0x01, 0x02, 0x03, 0x04, 0x05}; [EOL] int off = 1; [EOL] int len = 3; [EOL] UnicodePathExtraField field = new UnicodePathExtraField(text, bytes, off, len); [EOL] assertNotNull(field); [EOL] byte[] fieldData = field.getData(); [EOL] assertEquals(bytes[off], fieldData[0]); [EOL] assertEquals(len, fieldData.length); [EOL] }
public void testGetHeaderId() { [EOL] Compress compress = new Compress(); [EOL] ZipShort result = compress.getHeaderId(); [EOL] assertEquals(UPATH_ID, result); [EOL] }
