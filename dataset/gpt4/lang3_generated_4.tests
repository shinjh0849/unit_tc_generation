public void testNegate_WhenBoolIsNull() { [EOL] Boolean result = BooleanUtils.negate(null); [EOL] assertNull(result); [EOL] }
public void testNegate_WhenBoolIsTrue() { [EOL] Boolean result = BooleanUtils.negate(Boolean.TRUE); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testNegate_WhenBoolIsFalse() { [EOL] Boolean result = BooleanUtils.negate(Boolean.FALSE); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBooleanObject_Zero() { [EOL] Boolean result = toBooleanObject(0); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_NonZero() { [EOL] Boolean result = toBooleanObject(1); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBoolean_ValueIsNullTrueValueIsNull() { [EOL] assertTrue(StringUtils.toBoolean(null, null, Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueIsNullFalseValueIsNull() { [EOL] assertFalse(StringUtils.toBoolean(null, Integer.valueOf(1), null)); [EOL] } [EOL] public void testToBoolean_ValueEqualsTrueValue() { [EOL] assertTrue(StringUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueEqualsFalseValue() { [EOL] assertFalse(StringUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_IllegalArgumentException() { [EOL] try { [EOL] StringUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToBooleanObjectTrue() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = trueValue; [EOL] Boolean result = BooleanUtils.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBooleanObjectFalse() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = falseValue; [EOL] Boolean result = BooleanUtils.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testToBooleanObjectNull() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = nullValue; [EOL] Boolean result = BooleanUtils.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertNull(result); [EOL] }
public void testToBooleanObjectIllegalArgumentException() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = 2; [EOL] try { [EOL] BooleanUtils.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToIntegerObject_WithNull() { [EOL] Integer result = toIntegerObject(null); [EOL] assertNull(result); [EOL] } [EOL] public void testToIntegerObject_WithTrue() { [EOL] Integer result = toIntegerObject(true); [EOL] assertEquals(NumberUtils.INTEGER_ONE, result); [EOL] } [EOL] public void testToIntegerObject_WithFalse() { [EOL] Integer result = toIntegerObject(false); [EOL] assertEquals(NumberUtils.INTEGER_ZERO, result); [EOL] }
public void testToIntegerTrue() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int result = StringUtils.toInteger(true, trueValue, falseValue); [EOL] assertEquals(trueValue, result); [EOL] } [EOL] public void testToIntegerFalse() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int result = StringUtils.toInteger(false, trueValue, falseValue); [EOL] assertEquals(falseValue, result); [EOL] }
public void testToBooleanObject_TrueString() { [EOL] Boolean result = toBooleanObject("true"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_NullString() { [EOL] Boolean result = toBooleanObject(null); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_SingleCharY() { [EOL] Boolean result = toBooleanObject("y"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_SingleCharN() { [EOL] Boolean result = toBooleanObject("n"); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_SingleCharT() { [EOL] Boolean result = toBooleanObject("t"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_SingleCharF() { [EOL] Boolean result = toBooleanObject("f"); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_SingleCharUnrecognized() { [EOL] Boolean result = toBooleanObject("x"); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_TwoCharOn() { [EOL] Boolean result = toBooleanObject("on"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_TwoCharNo() { [EOL] Boolean result = toBooleanObject("no"); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_TwoCharUnrecognized() { [EOL] Boolean result = toBooleanObject("ab"); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_ThreeCharYes() { [EOL] Boolean result = toBooleanObject("yes"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_ThreeCharOff() { [EOL] Boolean result = toBooleanObject("off"); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_ThreeCharUnrecognized() { [EOL] Boolean result = toBooleanObject("abc"); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_FourCharTrue() { [EOL] Boolean result = toBooleanObject("true"); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testToBooleanObject_FourCharUnrecognized() { [EOL] Boolean result = toBooleanObject("abcd"); [EOL] assertNull(result); [EOL] }
public void testToBooleanObject_FiveCharFalse() { [EOL] Boolean result = toBooleanObject("false"); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testToBooleanObject_FiveCharUnrecognized() { [EOL] Boolean result = toBooleanObject("abcde"); [EOL] assertNull(result); [EOL] }
public void testToBooleanWithTrueString() { [EOL] assertTrue(StringUtils.toBoolean("true")); [EOL] } [EOL] public void testToBooleanWithFalseString() { [EOL] assertFalse(StringUtils.toBoolean("false")); [EOL] } [EOL] public void testToBooleanWithNull() { [EOL] assertFalse(StringUtils.toBoolean(null)); [EOL] } [EOL] public void testToBooleanWithYesString() { [EOL] assertTrue(StringUtils.toBoolean("yes")); [EOL] } [EOL] public void testToBooleanWithNoString() { [EOL] assertFalse(StringUtils.toBoolean("no")); [EOL] } [EOL] public void testToBooleanWithOnString() { [EOL] assertTrue(StringUtils.toBoolean("on")); [EOL] } [EOL] public void testToBooleanWithOffString() { [EOL] assertFalse(StringUtils.toBoolean("off")); [EOL] } [EOL] public void testToBooleanWithRandomString() { [EOL] assertFalse(StringUtils.toBoolean("randomString")); [EOL] }
public void testToStringTrueFalse_WhenBoolIsTrue() { [EOL] boolean bool = true; [EOL] String result = StringUtils.toStringTrueFalse(bool); [EOL] assertEquals("true", result); [EOL] } [EOL] public void testToStringTrueFalse_WhenBoolIsFalse() { [EOL] boolean bool = false; [EOL] String result = StringUtils.toStringTrueFalse(bool); [EOL] assertEquals("false", result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The Array must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Array is empty", e.getMessage()); [EOL] } [EOL] }
public void testAnd_AllTrue_ReturnsTrue() { [EOL] boolean result = Lang3.and(new boolean[]{true, true, true}); [EOL] assertTrue(result); [EOL] }
public void testAnd_OneFalse_ReturnsFalse() { [EOL] boolean result = Lang3.and(new boolean[]{true, false, true}); [EOL] assertFalse(result); [EOL] }
public void testAnd_AllFalse_ReturnsFalse() { [EOL] boolean result = Lang3.and(new boolean[]{false, false, false}); [EOL] assertFalse(result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_AllTrue_ReturnsTrue() { [EOL] Boolean result = MyClass.and(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testAnd_AllFalse_ReturnsFalse() { [EOL] Boolean result = MyClass.and(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testAnd_Mixed_ReturnsFalse() { [EOL] Boolean result = MyClass.and(new Boolean[]{true, false, true}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.xor(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.xor(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_SingleTrue_ReturnsTrue() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true}); [EOL] assertTrue(result); [EOL] }
public void testXor_SingleFalse_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{false}); [EOL] assertFalse(result); [EOL] }
public void testXor_MultipleTrue_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true, true}); [EOL] assertFalse(result); [EOL] }
public void testXor_OneTrueOneFalse_ReturnsTrue() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true, false}); [EOL] assertTrue(result); [EOL] }
public void testXor_MultipleFalse_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{false, false}); [EOL] assertFalse(result); [EOL] }
public void testInvokeExactMethodWithNullArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeExactMethod(object, methodName, (Object[]) null); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeExactMethodWithEmptyArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeExactMethod(object, methodName); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeExactMethodWithValidArgs() throws Exception { [EOL] final String methodName = "equals"; [EOL] final Object object = new Object(); [EOL] final Object[] args = new Object[]{object}; [EOL] Object result = invokeExactMethod(object, methodName, args); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testInvokeExactMethodWithInvalidMethodName() { [EOL] final String methodName = "nonExistentMethod"; [EOL] final Object object = new Object(); [EOL] try { [EOL] invokeExactMethod(object, methodName); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getName()); [EOL] } [EOL] }
public void testInvokeExactMethodWithInvalidArgs() { [EOL] final String methodName = "equals"; [EOL] final Object object = new Object(); [EOL] final Object[] args = new Object[]{new Object()}; [EOL] try { [EOL] invokeExactMethod(object, methodName, args); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected IllegalArgumentException, but got " + e.getClass().getName()); [EOL] } [EOL] }
public void testInvokeExactMethodWithNullArgsAndTypes() throws Exception { [EOL] Object object = new MyClass(); [EOL] String methodName = "myMethod"; [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] Object result = invokeExactMethod(object, methodName, args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("Expected result from myMethod", "myMethodResult", result); [EOL] }
public void testInvokeExactMethodWithNonNullArgsAndTypes() throws Exception { [EOL] Object object = new MyClass(); [EOL] String methodName = "myMethod"; [EOL] Object[] args = new Object[]{"arg1", "arg2"}; [EOL] Class<?>[] parameterTypes = new Class<?>[]{String.class, String.class}; [EOL] Object result = invokeExactMethod(object, methodName, args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("Expected result from myMethod with args", "myMethodResultWithArgs", result); [EOL] }
public void testInvokeExactMethodNoSuchMethod() { [EOL] Object object = new MyClass(); [EOL] String methodName = "nonExistentMethod"; [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] try { [EOL] invokeExactMethod(object, methodName, args, parameterTypes); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testGetAccessibleMethod_ValidMethod() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "indexOf", int.class); [EOL] assertNotNull(method); [EOL] assertEquals("indexOf", method.getName()); [EOL] assertEquals(1, method.getParameterTypes().length); [EOL] assertEquals(int.class, method.getParameterTypes()[0]); [EOL] }
public void testGetAccessibleMethod_InValidMethod() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "nonExistentMethod"); [EOL] assertNull(method); [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL] if (str == null) { [EOL] return null; [EOL] } [EOL] if (StringUtils.isBlank(str)) { [EOL] throw new NumberFormatException("A blank string is not a valid number"); [EOL] } [EOL] final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL] int pfxLen = 0; [EOL] for (final String pfx : hex_prefixes) { [EOL] if (str.startsWith(pfx)) { [EOL] pfxLen += pfx.length(); [EOL] break; [EOL] } [EOL] } [EOL] if (pfxLen > 0) { [EOL] char firstSigDigit = 0; [EOL] for (int i = pfxLen; i < str.length(); i++) { [EOL] firstSigDigit = str.charAt(i); [EOL] if (firstSigDigit == '0') { [EOL] pfxLen++; [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] final int hexDigits = str.length() - pfxLen; [EOL] if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL] return createBigInteger(str); [EOL] } [EOL] if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL] return createLong(str); [EOL] } [EOL] return createInteger(str); [EOL] } [EOL] final char lastChar = str.charAt(str.length() - 1); [EOL] String mant; [EOL] String dec; [EOL] String exp; [EOL] final int decPos = str.indexOf('.'); [EOL] final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL] int numDecimals = 0; [EOL] if (decPos > -1) { [EOL] if (expPos > -1) { [EOL] if (expPos < decPos || expPos > str.length()) { [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] dec = str.substring(decPos + 1, expPos); [EOL] } else { [EOL] dec = str.substring(decPos + 1); [EOL] } [EOL] mant = str.substring(0, decPos); [EOL] numDecimals = dec.length(); [EOL] } else { [EOL] if (expPos > -1) { [EOL] if (expPos > str.length()) { [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] mant = str.substring(0, expPos); [EOL] } else { [EOL] mant = str; [EOL] } [EOL] dec = null; [EOL] } [EOL] if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL] if (expPos > -1 && expPos < str.length() - 1) { [EOL] exp = str.substring(expPos + 1, str.length() - 1); [EOL] } else { [EOL] exp = null; [EOL] } [EOL] final String numeric = str.substring(0, str.length() - 1); [EOL] final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL] switch(lastChar) { [EOL] case 'l': [EOL] case 'L': [EOL] if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL] try { [EOL] return createLong(numeric); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigInteger(numeric); [EOL] } [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] case 'f': [EOL] case 'F': [EOL] try { [EOL] final Float f = NumberUtils.createFloat(numeric); [EOL] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL] return f; [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] case 'd': [EOL] case 'D': [EOL] try { [EOL] final Double d = NumberUtils.createDouble(numeric); [EOL] if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL] return d; [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] return createBigDecimal(numeric); [EOL] } catch (final NumberFormatException e) { [EOL] } [EOL] default: [EOL] throw new NumberFormatException(str + " is not a valid number."); [EOL] } [EOL] } [EOL] if (expPos > -1 && expPos < str.length() - 1) { [EOL] exp = str.substring(expPos + 1, str.length()); [EOL] } else { [EOL] exp = null; [EOL] } [EOL] if (dec == null and exp == null) { [EOL] try { [EOL] return createInteger(str); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] return createLong(str); [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigInteger(str); [EOL] } [EOL] final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL] try { [EOL] if (numDecimals <= 7) { [EOL] final Float f = createFloat(str); [EOL] if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL] return f; [EOL] } [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] try { [EOL] if (numDecimals <= 16) { [EOL] final Double d = createDouble(str); [EOL] if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL] return d; [EOL] } [EOL] } [EOL] } catch (final NumberFormatException nfe) { [EOL] } [EOL] return createBigDecimal(str); [EOL] }
public void testCreateLongWithNull() { [EOL] Long result = createLong(null); [EOL] assertNull(result); [EOL] }
public void testCreateLongWithValidNumberString() { [EOL] Long expected = 123L; [EOL] Long result = createLong("123"); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateLongWithHexNumberString() { [EOL] Long expected = 0x1FL; [EOL] Long result = createLong("0x1F"); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateLongWithOctalNumberString() { [EOL] Long expected = 017L; [EOL] Long result = createLong("017"); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateLongWithInvalidNumberString() { [EOL] try { [EOL] createLong("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMinWithSingleElementArray() { [EOL] long[] array = {5}; [EOL] long result = min(array); [EOL] assertEquals(5, result); [EOL] }
public void testMinWithMultipleElementsArray() { [EOL] long[] array = {10, 3, 7, 50, -1}; [EOL] long result = min(array); [EOL] assertEquals(-1, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] long[] array = {2, 2, 2, 2, 2}; [EOL] long result = min(array); [EOL] assertEquals(2, result); [EOL] }
public void testMinWithNegativeElementsArray() { [EOL] long[] array = {-10, -3, -7, -50, -1}; [EOL] long result = min(array); [EOL] assertEquals(-50, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] short[] array = {5}; [EOL] short result = min(array); [EOL] assertEquals(5, result); [EOL] }
public void testMinWithMultipleElementsArray() { [EOL] short[] array = {10, 3, 6, 1, 4}; [EOL] short result = min(array); [EOL] assertEquals(1, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] short[] array = {2, 2, 2, 2, 2}; [EOL] short result = min(array); [EOL] assertEquals(2, result); [EOL] }
public void testMinWithValidArray() { [EOL] double[] array = {1.0, 2.0, 0.5, 3.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals(0.5, result, 0.0); [EOL] }
public void testMinWithNaN() { [EOL] double[] array = {1.0, Double.NaN, 0.5, 3.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals(Double.NaN, result, 0.0); [EOL] }
public void testMinWithSingleElement() { [EOL] double[] array = {2.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals(2.0, result, 0.0); [EOL] }
public void testMinWithEmptyArray() { [EOL] try { [EOL] double[] array = {}; [EOL] ArrayUtils.min(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithNonEmptyArray() { [EOL] byte[] array = {1, 3, 7, 5}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(7, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] byte[] array = {42}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(42, result); [EOL] }
public void testMaxWithAllEqualElementsArray() { [EOL] byte[] array = {2, 2, 2, 2}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(2, result); [EOL] }
public void testMaxWithNegativeValues() { [EOL] byte[] array = {-5, -1, -3}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(-1, result); [EOL] }
public void testMaxWithMixedValues() { [EOL] byte[] array = {-5, 0, 5, 3}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithValidArray() { [EOL] double[] array = {1.0, 3.0, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(3.0, result, 0.01); [EOL] }
public void testMaxWithFirstElementMax() { [EOL] double[] array = {3.0, 1.0, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(3.0, result, 0.01); [EOL] }
public void testMaxWithLastElementMax() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(3.0, result, 0.01); [EOL] }
public void testMaxWithAllElementsEqual() { [EOL] double[] array = {2.0, 2.0, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(2.0, result, 0.01); [EOL] }
public void testMaxWithNaN() { [EOL] double[] array = {1.0, Double.NaN, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testMaxWithEmptyArray() { [EOL] double[] array = {}; [EOL] try { [EOL] ArrayUtils.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithNullArray() { [EOL] double[] array = null; [EOL] try { [EOL] ArrayUtils.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithValidArray() { [EOL] float[] array = {1.0f, 3.0f, 2.0f}; [EOL] float result = ClassName.max(array); [EOL] assertEquals(3.0f, result); [EOL] }
public void testMaxWithNaN() { [EOL] float[] array = {1.0f, Float.NaN, 2.0f}; [EOL] float result = ClassName.max(array); [EOL] assertTrue(Float.isNaN(result)); [EOL] }
public void testMaxWithEmptyArray() { [EOL] float[] array = {}; [EOL] try { [EOL] ClassName.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithSingleElementArray() { [EOL] float[] array = {42.0f}; [EOL] float result = ClassName.max(array); [EOL] assertEquals(42.0f, result); [EOL] }
public void testMinWithDistinctValues() { [EOL] double a = 1.0; [EOL] double b = 2.0; [EOL] double c = 3.0; [EOL] double result = YourClass.min(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMinWithFirstTwoValuesEqual() { [EOL] double a = 2.0; [EOL] double b = 2.0; [EOL] double c = 3.0; [EOL] double result = YourClass.min(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMinWithLastTwoValuesEqual() { [EOL] double a = 1.0; [EOL] double b = 3.0; [EOL] double c = 3.0; [EOL] double result = YourClass.min(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMinWithAllValuesEqual() { [EOL] double a = 2.0; [EOL] double b = 2.0; [EOL] double c = 2.0; [EOL] double result = YourClass.min(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMinWithNegativeValues() { [EOL] double a = -1.0; [EOL] double b = -2.0; [EOL] double c = -3.0; [EOL] double result = YourClass.min(a, b, c); [EOL] assertEquals(c, result, 0.0); [EOL] }
public void testMinWithDistinctValues() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float c = 3.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMinWithFirstTwoValuesEqual() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float c = 3.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMinWithLastTwoValuesEqual() { [EOL] float a = 3.0f; [EOL] float b = 1.0f; [EOL] float c = 1.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testMinWithAllValuesEqual() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float c = 2.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testMinWithNegativeValues() { [EOL] float a = -1.0f; [EOL] float b = -2.0f; [EOL] float c = -3.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testTranslateWithBackslashAndDigit() throws IOException { [EOL] CharSequence input = "\\123"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Should translate octal to character", 83, out.toString().charAt(0)); [EOL] assertEquals("Should return number of chars processed", 4, result); [EOL] }
public void testTranslateWithBackslashNotFollowedByDigit() throws IOException { [EOL] CharSequence input = "\\a"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Should not translate and return 0", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateWithBackslashAtEnd() throws IOException { [EOL] CharSequence input = "\\"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Should not translate and return 0", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateWithBackslashFollowedByNonOctal() throws IOException { [EOL] CharSequence input = "\\9"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Should not translate and return 0", 0, result); [EOL] assertEquals("Output should be empty", "", out.toString()); [EOL] }
public void testTranslateWithBackslashFollowedByLargeOctal() throws IOException { [EOL] CharSequence input = "\\7777"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Should translate only valid octal part", 255, out.toString().charAt(0)); [EOL] assertEquals("Should return number of chars processed for valid octal", 4, result); [EOL] }
public void testGetValue_PositiveShiftCount() { [EOL] final int holder = 0b01010000; // Arbitrary value with some bits set [EOL] final int shiftCount = 2; // Positive shift count [EOL] BitField bitField = new BitField(shiftCount); [EOL] int expectedValue = 0b01010000 >> shiftCount; [EOL] int actualValue = bitField.getValue(holder); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValue_NegativeShiftCount() { [EOL] final int holder = 0b01010000; // Arbitrary value with some bits set [EOL] final int shiftCount = -2; // Negative shift count [EOL] BitField bitField = new BitField(shiftCount); [EOL] int expectedValue = 0b01010000 >> shiftCount; [EOL] int actualValue = bitField.getValue(holder); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValue_ZeroShiftCount() { [EOL] final int holder = 0b01010000; // Arbitrary value with some bits set [EOL] final int shiftCount = 0; // Zero shift count [EOL] BitField bitField = new BitField(shiftCount); [EOL] int expectedValue = 0b01010000 >> shiftCount; [EOL] int actualValue = bitField.getValue(holder); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValue_MaxIntShiftCount() { [EOL] final int holder = 0b01010000; // Arbitrary value with some bits set [EOL] final int shiftCount = 31; // Maximum shift count for int [EOL] BitField bitField = new BitField(shiftCount); [EOL] int expectedValue = 0b01010000 >> shiftCount; [EOL] int actualValue = bitField.getValue(holder); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValue_MinIntShiftCount() { [EOL] final int holder = 0b01010000; // Arbitrary value with some bits set [EOL] final int shiftCount = -31; // Minimum shift count for int [EOL] BitField bitField = new BitField(shiftCount); [EOL] int expectedValue = 0b01010000 >> shiftCount; [EOL] int actualValue = bitField.getValue(holder); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testSetValueWithZeroHolderAndZeroValue() { [EOL] final int holder = 0; [EOL] final int value = 0; [EOL] final int result = setValue(holder, value); [EOL] assertEquals(0, result); [EOL] }
public void testSetValueWithZeroHolderAndMaxValue() { [EOL] final int holder = 0; [EOL] final int value = Integer.MAX_VALUE; [EOL] final int result = setValue(holder, value); [EOL] assertEquals(value & _mask, result); [EOL] }
public void testSetValueWithMaxHolderAndZeroValue() { [EOL] final int holder = Integer.MAX_VALUE; [EOL] final int value = 0; [EOL] final int result = setValue(holder, value); [EOL] assertEquals(holder & ~_mask, result); [EOL] }
public void testSetValueWithMaxHolderAndMaxValue() { [EOL] final int holder = Integer.MAX_VALUE; [EOL] final int value = Integer.MAX_VALUE; [EOL] final int result = setValue(holder, value); [EOL] assertEquals((holder & ~_mask) | ((value << _shift_count) & _mask), result); [EOL] }
public void testAddEventListenerWithValidMethod() { [EOL] Object eventSource = new EventSource(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] } [EOL] public void testAddEventListenerWithNoSuchMethod() { [EOL] Object eventSource = new Object(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("Expected IllegalArgumentException due to no such method"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAddEventListenerWithIllegalAccess() { [EOL] Object eventSource = new PrivateEventSource(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("Expected IllegalArgumentException due to illegal access"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAddEventListenerWithInvocationTargetException() { [EOL] Object eventSource = new EventSourceWithException(); [EOL] EventListener listener = new EventListenerImpl(); [EOL] try { [EOL] EventUtils.addEventListener(eventSource, EventListener.class, listener); [EOL] fail("Expected RuntimeException due to invocation target exception"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }

public void testInvokeWithEmptyEventTypes() throws Throwable { [EOL] EventInvoker invoker = new EventInvoker(new Object(), Collections.emptySet()); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = invoker.invoke(null, method, null); [EOL] assertNull(result); [EOL] }
public void testInvokeWithEventTypesNotContainingMethod() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("someOtherMethod"); [EOL] EventInvoker invoker = new EventInvoker(new Object(), eventTypes); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = invoker.invoke(null, method, null); [EOL] assertNull(result); [EOL] }
public void testInvokeWithMatchingMethodAndParameters() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("toString"); [EOL] Object target = new Object(); [EOL] EventInvoker invoker = new EventInvoker(target, eventTypes); [EOL] Method method = Object.class.getMethod("toString"); [EOL] Object result = invoker.invoke(null, method, null); [EOL] assertEquals(target.toString(), result); [EOL] }
public void testInvokeWithMatchingMethodWithoutParameters() throws Throwable { [EOL] Set<String> eventTypes = new HashSet<>(); [EOL] eventTypes.add("hashCode"); [EOL] Object target = new Object(); [EOL] EventInvoker invoker = new EventInvoker(target, eventTypes); [EOL] Method method = Object.class.getMethod("hashCode"); [EOL] Object result = invoker.invoke(null, method, new Object[0]); [EOL] assertEquals(target.hashCode(), result); [EOL] }
@Override [EOL] public final void applyPattern(final String pattern) { [EOL] if (registry == null) { [EOL] super.applyPattern(pattern); [EOL] toPattern = super.toPattern(); [EOL] return; [EOL] } [EOL] final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL] final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL] final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] final char[] c = pattern.toCharArray(); [EOL] int fmtCount = 0; [EOL] while (pos.getIndex() < pattern.length()) { [EOL] switch(c[pos.getIndex()]) { [EOL] case QUOTE: [EOL] appendQuotedString(pattern, pos, stripCustom, true); [EOL] break; [EOL] case START_FE: [EOL] fmtCount++; [EOL] seekNonWs(pattern, pos); [EOL] final int start = pos.getIndex(); [EOL] final int index = readArgumentIndex(pattern, next(pos)); [EOL] stripCustom.append(START_FE).append(index); [EOL] seekNonWs(pattern, pos); [EOL] Format format = null; [EOL] String formatDescription = null; [EOL] if (c[pos.getIndex()] == START_FMT) { [EOL] formatDescription = parseFormatDescription(pattern, next(pos)); [EOL] format = getFormat(formatDescription); [EOL] if (format == null) { [EOL] stripCustom.append(START_FMT).append(formatDescription); [EOL] } [EOL] } [EOL] foundFormats.add(format); [EOL] foundDescriptions.add(format == null ? null : formatDescription); [EOL] Validate.isTrue(foundFormats.size() == fmtCount); [EOL] Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL] if (c[pos.getIndex()] != END_FE) { [EOL] throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL] } [EOL] default: [EOL] stripCustom.append(c[pos.getIndex()]); [EOL] next(pos); [EOL] } [EOL] } [EOL] super.applyPattern(stripCustom.toString()); [EOL] toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL] if (containsElements(foundFormats)) { [EOL] final Format[] origFormats = getFormats(); [EOL] int i = 0; [EOL] for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL] final Format f = it.next(); [EOL] if (f != null) { [EOL] origFormats[i] = f; [EOL] } [EOL] } [EOL] super.setFormats(origFormats); [EOL] } [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}'];
private Format getFormat(final String desc) { [EOL] if (registry != null) { [EOL] String name = desc; [EOL] String args = null; [EOL] final int i = desc.indexOf(START_FMT); [EOL] if (i > 0) { [EOL] name = desc.substring(0, i).trim(); [EOL] args = desc.substring(i + 1).trim(); [EOL] } [EOL] final FormatFactory factory = registry.get(name); [EOL] if (factory != null) { [EOL] return factory.getFormat(name, args, getLocale()); [EOL] } [EOL] } [EOL] return null; [EOL] } [EOL] public ExtendedMessageFormat(final String pattern); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale); [EOL] public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); [EOL] public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); [EOL] public String toPattern(); [EOL] public final void applyPattern(final String pattern); [EOL] public void setFormat(final int formatElementIndex, final Format newFormat); [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); [EOL] public void setFormats(final Format[] newFormats); [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] private Format getFormat(final String desc); [EOL] private int readArgumentIndex(final String pattern, final ParsePosition pos); [EOL] private String parseFormatDescription(final String pattern, final ParsePosition pos); [EOL] private String insertFormats(final String pattern, final ArrayList<String> customPatterns); [EOL] private void seekNonWs(final String pattern, final ParsePosition pos); [EOL] private ParsePosition next(final ParsePosition pos); [EOL] private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); [EOL] private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); [EOL] private boolean containsElements(final Collection<?> coll); [EOL] long serialVersionUID=Optional[-2362048321261811743L]; [EOL] int HASH_SEED=Optional[31]; [EOL] String DUMMY_PATTERN=Optional[""]; [EOL] String ESCAPED_QUOTE=Optional["''"]; [EOL] char START_FMT=Optional[',']; [EOL] char END_FE=Optional['}'];
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL] if (!containsElements(customPatterns)) { [EOL] return pattern; [EOL] } [EOL] final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] int fe = -1; [EOL] int depth = 0; [EOL] while (pos.getIndex() < pattern.length()) { [EOL] final char c = pattern.charAt(pos.getIndex()); [EOL] switch(c) { [EOL] case QUOTE: [EOL] appendQuotedString(pattern, pos, sb, false); [EOL] break; [EOL] case START_FE: [EOL] depth++; [EOL] if (depth == 1) { [EOL] fe++; [EOL] sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL] final String customPattern = customPatterns.get(fe); [EOL] if (customPattern != null) { [EOL] sb.append(START_FMT).append(customPattern); [EOL] } [EOL] } [EOL] break; [EOL] case END_FE: [EOL] depth--; [EOL] default: [EOL] sb.append(c); [EOL] next(pos); [EOL] } [EOL] } [EOL] return sb.toString(); [EOL] }
private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL] final int start = pos.getIndex(); [EOL] final char[] c = pattern.toCharArray(); [EOL] if (escapingOn && c[start] == QUOTE) { [EOL] next(pos); [EOL] return appendTo == null ? null : appendTo.append(QUOTE); [EOL] } [EOL] int lastHold = start; [EOL] for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL] if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL] appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL] pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL] lastHold = pos.getIndex(); [EOL] continue; [EOL] } [EOL] switch(c[pos.getIndex()]) { [EOL] case QUOTE: [EOL] next(pos); [EOL] return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL] default: [EOL] next(pos); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] }
public void testOf_withNonNullValues() { [EOL] Integer left = 5; [EOL] String right = "test"; [EOL] Pair<Integer, String> result = Pair.of(left, right); [EOL] assertNotNull(result); [EOL] assertEquals(left, result.getLeft()); [EOL] assertEquals(right, result.getRight()); [EOL] } [EOL] public void testOf_withNullValues() { [EOL] Pair<Object, Object> result = Pair.of(null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLeft()); [EOL] assertNull(result.getRight()); [EOL] }
public void testCompareTo_EqualPairs() { [EOL] Pair<Integer, String> pair1 = Pair.of(1, "a"); [EOL] Pair<Integer, String> pair2 = Pair.of(1, "a"); [EOL] int result = pair1.compareTo(pair2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LeftGreater() { [EOL] Pair<Integer, String> pair1 = Pair.of(2, "a"); [EOL] Pair<Integer, String> pair2 = Pair.of(1, "a"); [EOL] int result = pair1.compareTo(pair2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_LeftLess() { [EOL] Pair<Integer, String> pair1 = Pair.of(1, "a"); [EOL] Pair<Integer, String> pair2 = Pair.of(2, "a"); [EOL] int result = pair1.compareTo(pair2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_RightGreater() { [EOL] Pair<Integer, String> pair1 = Pair.of(1, "b"); [EOL] Pair<Integer, String> pair2 = Pair.of(1, "a"); [EOL] int result = pair1.compareTo(pair2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_RightLess() { [EOL] Pair<Integer, String> pair1 = Pair.of(1, "a"); [EOL] Pair<Integer, String> pair2 = Pair.of(1, "b"); [EOL] int result = pair1.compareTo(pair2); [EOL] assertTrue(result < 0); [EOL] }
public void testEquals_Reflexive() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] assertTrue(constantInitializer.equals(constantInitializer)); [EOL] } [EOL] public void testEquals_Symmetric() { [EOL] ConstantInitializer<Integer> constantInitializer1 = new ConstantInitializer<>(5); [EOL] ConstantInitializer<Integer> constantInitializer2 = new ConstantInitializer<>(5); [EOL] assertTrue(constantInitializer1.equals(constantInitializer2)); [EOL] assertTrue(constantInitializer2.equals(constantInitializer1)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] assertFalse(constantInitializer.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] ConstantInitializer<Integer> constantInitializer = new ConstantInitializer<>(5); [EOL] Object otherObject = new Object(); [EOL] assertFalse(constantInitializer.equals(otherObject)); [EOL] } [EOL] public void testEquals_DifferentValue() { [EOL] ConstantInitializer<Integer> constantInitializer1 = new ConstantInitializer<>(5); [EOL] ConstantInitializer<Integer> constantInitializer2 = new ConstantInitializer<>(10); [EOL] assertFalse(constantInitializer1.equals(constantInitializer2)); [EOL] }

public void testSerializationExceptionConstructor() { [EOL] SerializationException exception = new SerializationException(); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getCause()); [EOL] }
public void testSerializationExceptionWithMessage() { [EOL] String message = "Test message"; [EOL] SerializationException exception = new SerializationException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] }
public void testSerializationExceptionWithMessageAndCause() { [EOL] String expectedMessage = "This is a test message"; [EOL] Throwable expectedCause = new Throwable("This is a test cause"); [EOL] SerializationException exception = new SerializationException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testInitializeThreadWithNamingPattern() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .namingPattern("test-thread-%d") [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.getName().matches("test-thread-\\d+")); [EOL] }
public void testInitializeThreadWithUncaughtExceptionHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (thread, throwable) -> { /* No-op */ }; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .uncaughtExceptionHandler(handler) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(handler, t.getUncaughtExceptionHandler()); [EOL] }
public void testInitializeThreadWithPriority() { [EOL] int priority = Thread.MAX_PRIORITY; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .priority(priority) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(priority, t.getPriority()); [EOL] }
public void testInitializeThreadWithDaemonFlag() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .daemon(true) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.isDaemon()); [EOL] }
public void testInitializeThreadWithNullValues() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder().build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertNotNull(t.getName()); // Default name should not be null [EOL] assertNull(t.getUncaughtExceptionHandler()); // No handler set [EOL] assertEquals(Thread.NORM_PRIORITY, t.getPriority()); // Default priority [EOL] assertFalse(t.isDaemon()); // Default is not a daemon [EOL] }
public void testUncaughtExceptionHandlerWithNonNullHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (t, e) -> { /* No-op handler */ }; [EOL] Builder builder = new Builder(); [EOL] Builder returnedBuilder = builder.uncaughtExceptionHandler(handler); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testUncaughtExceptionHandlerWithNullHandler() { [EOL] try { [EOL] new Builder().uncaughtExceptionHandler(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Uncaught exception handler must not be null!", e.getMessage()); [EOL] } [EOL] }
public void testGetContextEntries_NonEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] exceptionContext.addContextValue("key2", "value2"); [EOL] ExceptionContextException exception = new ExceptionContextException(exceptionContext); [EOL] List<Pair<String, Object>> contextEntries = exception.getContextEntries(); [EOL] assertNotNull(contextEntries); [EOL] assertEquals(2, contextEntries.size()); [EOL] assertEquals(new ImmutablePair<>("key1", "value1"), contextEntries.get(0)); [EOL] assertEquals(new ImmutablePair<>("key2", "value2"), contextEntries.get(1)); [EOL] }
public void testGetContextEntries_EmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] ExceptionContextException exception = new ExceptionContextException(exceptionContext); [EOL] List<Pair<String, Object>> contextEntries = exception.getContextEntries(); [EOL] assertNotNull(contextEntries); [EOL] assertTrue(contextEntries.isEmpty()); [EOL] }
public void testGetContextLabels_NonEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("label1", "value1"); [EOL] exceptionContext.addContextValue("label2", "value2"); [EOL] ExceptionContextException exception = new ExceptionContextException(exceptionContext); [EOL] Set<String> labels = exception.getContextLabels(); [EOL] assertNotNull(labels); [EOL] assertEquals(2, labels.size()); [EOL] assertTrue(labels.contains("label1")); [EOL] assertTrue(labels.contains("label2")); [EOL] }
public void testGetContextLabels_EmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] ExceptionContextException exception = new ExceptionContextException(exceptionContext); [EOL] Set<String> labels = exception.getContextLabels(); [EOL] assertNotNull(labels); [EOL] assertTrue(labels.isEmpty()); [EOL] }
public void testGetRawMessage_NullSuperMessage() { [EOL] Exception e = new Exception(null); [EOL] Throwable t = new Throwable(e); [EOL] assertNull(t.getRawMessage()); [EOL] }
public void testGetRawMessage_NonNullSuperMessage() { [EOL] String expectedMessage = "Error Message"; [EOL] Exception e = new Exception(expectedMessage); [EOL] Throwable t = new Throwable(e); [EOL] assertEquals(expectedMessage, t.getRawMessage()); [EOL] }
public void testFireReturnsNonNullProxy() { [EOL] MyClass myClassInstance = new MyClass(); // Replace MyClass with the actual class name [EOL] L result = myClassInstance.fire(); [EOL] assertNotNull("The proxy should not be null", result); [EOL] }
public void testAddListenerWithNonNullListener() { [EOL] YourListenerClass listenerToAdd = new YourListenerClass(); // Replace with your actual listener class [EOL] YourClassUnderTest testSubject = new YourClassUnderTest(); // Replace with your actual class that contains addListener [EOL] testSubject.addListener(listenerToAdd); [EOL] assertTrue(testSubject.getListeners().contains(listenerToAdd)); [EOL] }
public void testAddListenerWithNullListener() { [EOL] YourClassUnderTest testSubject = new YourClassUnderTest(); // Replace with your actual class that contains addListener [EOL] try { [EOL] testSubject.addListener(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Listener object cannot be null.", e.getMessage()); [EOL] } [EOL] }
public void testGetListenerCountWithEmptyListeners() { [EOL] YourClass instance = new YourClass(); [EOL] assertEquals(0, instance.getListenerCount()); [EOL] }
public void testGetListenerCountWithNonEmptyListeners() { [EOL] YourClass instance = new YourClass(); [EOL] instance.listeners.add(new ListenerType()); // Assuming ListenerType is the type of elements in listeners [EOL] assertEquals(1, instance.getListenerCount()); [EOL] }
public void testRemoveListenerWithNonNullListener() { [EOL] EventListenerList<L> list = new EventListenerList<>(); [EOL] L mockListener = mock(L.class); [EOL] list.addListener(mockListener); [EOL] list.removeListener(mockListener); [EOL] assertFalse(list.getListeners().contains(mockListener)); [EOL] }
public void testRemoveListenerWithNullListener() { [EOL] EventListenerList<L> list = new EventListenerList<>(); [EOL] try { [EOL] list.removeListener(null); [EOL] fail("Should have thrown IllegalArgumentException for null listener"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Listener object cannot be null.", ex.getMessage()); [EOL] } [EOL] }
public void testInvokeWithNoListeners() throws Throwable { [EOL] EventListenerSupport<EventListener> support = EventListenerSupport.create(EventListener.class); [EOL] Method method = EventListener.class.getMethod("onEvent"); [EOL] Object result = support.invoke(null, method, null); [EOL] assertNull(result); [EOL] } [EOL] public void testInvokeWithOneListener() throws Throwable { [EOL] EventListenerSupport<EventListener> support = EventListenerSupport.create(EventListener.class); [EOL] EventListener mockListener = mock(EventListener.class); [EOL] support.addListener(mockListener); [EOL] Method method = EventListener.class.getMethod("onEvent"); [EOL] support.invoke(null, method, null); [EOL] verify(mockListener).onEvent(); [EOL] } [EOL] public void testInvokeWithMultipleListeners() throws Throwable { [EOL] EventListenerSupport<EventListener> support = EventListenerSupport.create(EventListener.class); [EOL] EventListener mockListener1 = mock(EventListener.class); [EOL] EventListener mockListener2 = mock(EventListener.class); [EOL] support.addListener(mockListener1); [EOL] support.addListener(mockListener2); [EOL] Method method = EventListener.class.getMethod("onEvent"); [EOL] support.invoke(null, method, null); [EOL] verify(mockListener1).onEvent(); [EOL] verify(mockListener2).onEvent(); [EOL] }
public void testMutableFloatConstructor() { [EOL] MutableFloat mutFloat = new MutableFloat(); [EOL] assertNotNull(mutFloat); [EOL] assertEquals(0.0f, mutFloat.floatValue(), 0.0f); [EOL] }
public void testMutableFloatConstructor() { [EOL] float testValue = 1.0f; [EOL] MutableFloat mutableFloat = new MutableFloat(testValue); [EOL] assertEquals(testValue, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testGetValueWhenValueIsSet() { [EOL] YourClass instance = new YourClass("3.14"); // Replace 'YourClass' with the actual class name that contains the 'getValue' method [EOL] Float result = instance.getValue(); [EOL] assertEquals(Float.valueOf(3.14f), result); [EOL] }
public void testSetValue() { [EOL] MyClass instance = new MyClass(); [EOL] float expectedValue = 10.0f; [EOL] instance.setValue(expectedValue); [EOL] assertEquals(expectedValue, instance.value, 0.0f); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(null); [EOL] assertNull("Value should be null", instance.getValue()); [EOL] }
public void testSetValueWithInteger() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5); [EOL] assertEquals("Value should be 5.0f", 5.0f, instance.getValue()); [EOL] }
public void testSetValueWithDouble() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5.5); [EOL] assertEquals("Value should be 5.5f", 5.5f, instance.getValue()); [EOL] }
public void testIsNaN_WhenValueIsNaN_ShouldReturnTrue() { [EOL] MutableFloat mutableFloat = new MutableFloat(Float.NaN); [EOL] boolean result = mutableFloat.isNaN(); [EOL] assertTrue(result); [EOL] }
public void testIsNaN_WhenValueIsNotNaN_ShouldReturnFalse() { [EOL] MutableFloat mutableFloat = new MutableFloat(0.0f); [EOL] boolean result = mutableFloat.isNaN(); [EOL] assertFalse(result); [EOL] }
public void testIsInfinite_PositiveInfinity() { [EOL] MutableFloat mf = new MutableFloat(Float.POSITIVE_INFINITY); [EOL] assertTrue(mf.isInfinite()); [EOL] } [EOL] public void testIsInfinite_NegativeInfinity() { [EOL] MutableFloat mf = new MutableFloat(Float.NEGATIVE_INFINITY); [EOL] assertTrue(mf.isInfinite()); [EOL] } [EOL] public void testIsInfinite_NotInfinite() { [EOL] MutableFloat mf = new MutableFloat(0.0f); [EOL] assertFalse(mf.isInfinite()); [EOL] }
public void testIncrement() { [EOL] MutableInt mutableInt = new MutableInt(); [EOL] mutableInt.increment(); [EOL] assertEquals(1, mutableInt.intValue()); [EOL] }
public void testDecrement_PositiveValue() { [EOL] Counter counter = new Counter(1); [EOL] counter.decrement(); [EOL] assertEquals(0, counter.getValue()); [EOL] }
public void testDecrement_ZeroValue() { [EOL] Counter counter = new Counter(0); [EOL] counter.decrement(); [EOL] assertEquals(-1, counter.getValue()); [EOL] }
public void testDecrement_NegativeValue() { [EOL] Counter counter = new Counter(-1); [EOL] counter.decrement(); [EOL] assertEquals(-2, counter.getValue()); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableFloat mutableFloat = new MutableFloat(5.0f); [EOL] mutableFloat.subtract(2.0f); [EOL] assertEquals(3.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testSubtract_NegativeOperand() { [EOL] MutableFloat mutableFloat = new MutableFloat(5.0f); [EOL] mutableFloat.subtract(-3.0f); [EOL] assertEquals(8.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testSubtract_ZeroOperand() { [EOL] MutableFloat mutableFloat = new MutableFloat(5.0f); [EOL] mutableFloat.subtract(0.0f); [EOL] assertEquals(5.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testSubtractWithNullOperand() { [EOL] try { [EOL] MutableFloat mf = new MutableFloat(5.0f); [EOL] mf.subtract(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testSubtractWithValidOperand() { [EOL] MutableFloat mf = new MutableFloat(5.0f); [EOL] mf.subtract(new Float(2.5f)); [EOL] assertEquals(2.5f, mf.floatValue(), 0.0f); [EOL] }
public void testIntValue_PositiveValue() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(5, result); [EOL] }
public void testIntValue_NegativeValue() { [EOL] MutableInt mutableInt = new MutableInt(-5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(-5, result); [EOL] }
public void testIntValue_ZeroValue() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(5L, result); [EOL] }
public void testLongValue_Negative() { [EOL] MutableLong mutableLong = new MutableLong(-5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(-5L, result); [EOL] }
public void testLongValue_Zero() { [EOL] MutableLong mutableLong = new MutableLong(0); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testFloatValue_Positive() { [EOL] MutableFloat mutableFloat = new MutableFloat(1.0f); [EOL] assertEquals(1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Negative() { [EOL] MutableFloat mutableFloat = new MutableFloat(-1.0f); [EOL] assertEquals(-1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Zero() { [EOL] MutableFloat mutableFloat = new MutableFloat(0.0f); [EOL] assertEquals(0.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testDoubleValue_Positive() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] assertEquals(1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] MutableDouble mutableDouble = new MutableDouble(-1.0); [EOL] assertEquals(-1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] MutableDouble mutableDouble = new MutableDouble(0.0); [EOL] assertEquals(0.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testAddAbbreviation() { [EOL] String primitive = "int"; [EOL] String abbreviation = "I"; [EOL] ClassWithAddAbbreviationMethod.addAbbreviation(primitive, abbreviation); [EOL] assertEquals("I", ClassWithAddAbbreviationMethod.abbreviationMap.get("int")); [EOL] assertEquals("int", ClassWithAddAbbreviationMethod.reverseAbbreviationMap.get("I")); [EOL] }
public void testGetShortClassNameEmpty() { [EOL] String className = ""; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetShortClassNameNull() { [EOL] String className = null; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetShortClassNameWithoutPackage() { [EOL] String className = "String"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNameWithPackage() { [EOL] String className = "java.lang.String"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testGetShortClassNameInnerClass() { [EOL] String className = "java.lang.Map$Entry"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("Map.Entry", result); [EOL] } [EOL] public void testGetShortClassNameArray() { [EOL] String className = "[Ljava.lang.String;"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("String[]", result); [EOL] } [EOL] public void testGetShortClassNameArrayOfArrays() { [EOL] String className = "[[[Ljava.lang.String;"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("String[][][]", result); [EOL] } [EOL] public void testGetShortClassNamePrimitiveArray() { [EOL] String className = "[I"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("int[]", result); [EOL] } [EOL] public void testGetShortClassNameArrayOfPrimitiveArrays() { [EOL] String className = "[[I"; [EOL] String result = ClassNameUtil.getShortClassName(className); [EOL] assertEquals("int[][]", result); [EOL] }
public void testGetSimpleNameWithNullClass() { [EOL] String result = ClassNameUtils.getSimpleName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetSimpleNameWithRegularClass() { [EOL] String result = ClassNameUtils.getSimpleName(String.class); [EOL] assertEquals("String", result); [EOL] }
public void testConvertClassNamesToClasses_withNullInput() { [EOL] List<Class<?>> result = convertClassNamesToClasses(null); [EOL] assertNull(result); [EOL] }
public void testConvertClassNamesToClasses_withEmptyList() { [EOL] List<String> classNames = new ArrayList<>(); [EOL] List<Class<?>> result = convertClassNamesToClasses(classNames); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testConvertClassNamesToClasses_withValidClassNames() { [EOL] List<String> classNames = Arrays.asList("java.lang.String", "java.lang.Integer"); [EOL] List<Class<?>> result = convertClassNamesToClasses(classNames); [EOL] assertEquals(2, result.size()); [EOL] assertEquals(String.class, result.get(0)); [EOL] assertEquals(Integer.class, result.get(1)); [EOL] }
public void testConvertClassNamesToClasses_withInvalidClassName() { [EOL] List<String> classNames = Arrays.asList("java.lang.String", "invalid.ClassName"); [EOL] List<Class<?>> result = convertClassNamesToClasses(classNames); [EOL] assertEquals(2, result.size()); [EOL] assertEquals(String.class, result.get(0)); [EOL] assertNull(result.get(1)); [EOL] }
public void testConvertClassNamesToClasses_withMixedClassNames() { [EOL] List<String> classNames = Arrays.asList("java.lang.String", "invalid.ClassName", "java.lang.Integer"); [EOL] List<Class<?>> result = convertClassNamesToClasses(classNames); [EOL] assertEquals(3, result.size()); [EOL] assertEquals(String.class, result.get(0)); [EOL] assertNull(result.get(1)); [EOL] assertEquals(Integer.class, result.get(2)); [EOL] }
public void testIsPrimitiveOrWrapper_withNull() { [EOL] boolean result = isPrimitiveOrWrapper(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsPrimitiveOrWrapper_withPrimitive() { [EOL] boolean result = isPrimitiveOrWrapper(int.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsPrimitiveOrWrapper_withPrimitiveWrapper() { [EOL] boolean result = isPrimitiveOrWrapper(Integer.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsPrimitiveOrWrapper_withNonPrimitiveNonWrapper() { [EOL] boolean result = isPrimitiveOrWrapper(String.class); [EOL] assertFalse(result); [EOL] }
public void testIsPrimitiveWrapper_withPrimitiveWrapperClasses() { [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Integer.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Double.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Long.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Boolean.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Character.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Byte.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Short.class)); [EOL] assertTrue(StringUtils.isPrimitiveWrapper(Float.class)); [EOL] }
public void testIsPrimitiveWrapper_withNonPrimitiveWrapperClasses() { [EOL] assertFalse(StringUtils.isPrimitiveWrapper(String.class)); [EOL] assertFalse(StringUtils.isPrimitiveWrapper(Object.class)); [EOL] assertFalse(StringUtils.isPrimitiveWrapper(int.class)); [EOL] assertFalse(StringUtils.isPrimitiveWrapper(double.class)); [EOL] }
public void testIsPrimitiveWrapper_withNullInput() { [EOL] assertFalse(StringUtils.isPrimitiveWrapper(null)); [EOL] }
public void testIsAssignableWithNullClasses() { [EOL] boolean result = isAssignable(null, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithSameClass() { [EOL] boolean result = isAssignable(String.class, String.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithAssignableClasses() { [EOL] boolean result = isAssignable(Object.class, String.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithUnassignableClasses() { [EOL] boolean result = isAssignable(String.class, Object.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveClasses() { [EOL] boolean result = isAssignable(int.class, Integer.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToWrapper() { [EOL] boolean result = isAssignable(Integer.class, int.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToPrimitive() { [EOL] boolean result = isAssignable(int.class, int.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithWrapperToWrapper() { [EOL] boolean result = isAssignable(Integer.class, Integer.class); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithNullToClass() { [EOL] boolean result = isAssignable(String.class, null, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNullCls() { [EOL] boolean result = isAssignable(null, String.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingAndPrimitiveToWrapper() { [EOL] boolean result = isAssignable(int.class, Integer.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingAndWrapperToPrimitive() { [EOL] boolean result = isAssignable(Integer.class, int.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithClsEqualsToClass() { [EOL] boolean result = isAssignable(String.class, String.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToNonPrimitive() { [EOL] boolean result = isAssignable(int.class, String.class, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithIntegerToLong() { [EOL] boolean result = isAssignable(Integer.TYPE, Long.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithBooleanToOtherPrimitive() { [EOL] boolean result = isAssignable(Boolean.TYPE, Integer.TYPE, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithDoubleToOtherPrimitive() { [EOL] boolean result = isAssignable(Double.TYPE, Float.TYPE, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithFloatToDouble() { [EOL] boolean result = isAssignable(Float.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithCharacterToInteger() { [EOL] boolean result = isAssignable(Character.TYPE, Integer.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithShortToInteger() { [EOL] boolean result = isAssignable(Short.TYPE, Integer.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithByteToShort() { [EOL] boolean result = isAssignable(Byte.TYPE, Short.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNonPrimitiveToAssignable() { [EOL] boolean result = isAssignable(Number.class, Integer.class, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNonPrimitiveToNonAssignable() { [EOL] boolean result = isAssignable(String.class, Integer.class, false); [EOL] assertFalse(result); [EOL] }
public void testPrimitiveToWrapper_withNull() { [EOL] Class<?> result = ClassName.primitiveToWrapper(null); [EOL] assertNull(result); [EOL] }
public void testPrimitiveToWrapper_withPrimitive() { [EOL] Class<?> result = ClassName.primitiveToWrapper(int.class); [EOL] assertEquals(Integer.class, result); [EOL] }
public void testPrimitiveToWrapper_withNonPrimitive() { [EOL] Class<?> result = ClassName.primitiveToWrapper(String.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testWrapperToPrimitiveWithNull() { [EOL] Class<?> result = wrapperToPrimitive(null); [EOL] assertNull(result); [EOL] }
public void testWrapperToPrimitiveWithWrapperClass() { [EOL] Class<?> result = wrapperToPrimitive(Integer.class); [EOL] assertEquals(int.class, result); [EOL] }
public void testWrapperToPrimitiveWithPrimitiveClass() { [EOL] Class<?> result = wrapperToPrimitive(int.class); [EOL] assertNull(result); [EOL] }
public void testWrapperToPrimitiveWithNonWrapperClass() { [EOL] Class<?> result = wrapperToPrimitive(String.class); [EOL] assertNull(result); [EOL] }
public void testToClassWithNullArray() { [EOL] Class<?>[] result = ClassUtils.toClass(null); [EOL] assertNull(result); [EOL] }
public void testToClassWithEmptyArray() { [EOL] Class<?>[] result = ClassUtils.toClass(new Object[0]); [EOL] assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, result); [EOL] }
public void testToClassWithNonNullArray() { [EOL] Object[] array = new Object[] {"string", true, 1, 1.0}; [EOL] Class<?>[] result = ClassUtils.toClass(array); [EOL] Class<?>[] expectedClasses = new Class<?>[] {String.class, Boolean.class, Integer.class, Double.class}; [EOL] assertArrayEquals(expectedClasses, result); [EOL] }
public void testToClassWithAllNullElements() { [EOL] Object[] array = new Object[] {null, null}; [EOL] Class<?>[] result = ClassUtils.toClass(array); [EOL] Class<?>[] expectedClasses = new Class<?>[] {null, null}; [EOL] assertArrayEquals(expectedClasses, result); [EOL] }
public void testGetShortCanonicalName_NullInput() { [EOL] String result = ClassUtils.getShortCanonicalName(null); [EOL] assertNull(result); [EOL] }
public void testGetShortCanonicalName_EmptyString() { [EOL] String result = ClassUtils.getShortCanonicalName(""); [EOL] assertEquals("", result); [EOL] }
public void testGetShortCanonicalName_RegularClass() { [EOL] String result = ClassUtils.getShortCanonicalName("java.lang.String"); [EOL] assertEquals("String", result); [EOL] }
public void testGetShortCanonicalName_InnerClass() { [EOL] String result = ClassUtils.getShortCanonicalName("java.util.Map$Entry"); [EOL] assertEquals("Entry", result); [EOL] }
public void testGetShortCanonicalName_ArrayClass() { [EOL] String result = ClassUtils.getShortCanonicalName("[Ljava.lang.String;"); [EOL] assertEquals("String[]", result); [EOL] }
public void testGetShortCanonicalName_PrimitiveArray() { [EOL] String result = ClassUtils.getShortCanonicalName("[I"); [EOL] assertEquals("int[]", result); [EOL] }
public void testGetCanonicalName_NullInput() { [EOL] String className = null; [EOL] String result = getCanonicalName(className); [EOL] assertNull(result); [EOL] } [EOL] public void testGetCanonicalName_EmptyString() { [EOL] String className = ""; [EOL] String result = getCanonicalName(className); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCanonicalName_NoDimension() { [EOL] String className = "java.lang.String"; [EOL] String result = getCanonicalName(className); [EOL] assertEquals("java.lang.String", result); [EOL] } [EOL] public void testGetCanonicalName_SingleDimension() { [EOL] String className = "[Ljava.lang.String;"; [EOL] String result = getCanonicalName(className); [EOL] assertEquals("java.lang.String[]", result); [EOL] } [EOL] public void testGetCanonicalName_MultipleDimensions() { [EOL] String className = "[[[Ljava.lang.String;"; [EOL] String result = getCanonicalName(className); [EOL] assertEquals("java.lang.String[][][]", result); [EOL] } [EOL] public void testGetCanonicalName_PrimitiveType() { [EOL] String className = "[I"; [EOL] String result = getCanonicalName(className); [EOL] assertEquals("int[]", result); [EOL] } [EOL] public void testGetCanonicalName_InvalidClassName() { [EOL] String className = "[[InvalidClassName;"; [EOL] String result = getCanonicalName(className); [EOL] assertNull(result); // Assuming reverseAbbreviationMap does not contain "InvalidClassName" [EOL] }
public void testSetExternalExecutor_WhenNotStarted() { [EOL] MyClass instance = new MyClass(); [EOL] ExecutorService mockExecutorService = mock(ExecutorService.class); [EOL] instance.setExternalExecutor(mockExecutorService); [EOL] assertEquals(mockExecutorService, instance.getExternalExecutor()); [EOL] }
public void testSetExternalExecutor_WhenStarted_ThrowsException() { [EOL] MyClass instance = new MyClass(); [EOL] instance.start(); [EOL] ExecutorService mockExecutorService = mock(ExecutorService.class); [EOL] try { [EOL] instance.setExternalExecutor(mockExecutorService); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Cannot set ExecutorService after start()!", e.getMessage()); [EOL] } [EOL] }
public static String[][] ISO8859_1_ESCAPE() { [EOL] return ISO8859_1_ESCAPE.clone(); [EOL] } [EOL] public static String[][] ISO8859_1_ESCAPE; public static String[][] ISO8859_1_UNESCAPE; public static String[][] HTML40_EXTENDED_ESCAPE; public static String[][] HTML40_EXTENDED_UNESCAPE; public static String[][] BASIC_ESCAPE; public static String[][] BASIC_UNESCAPE; public static String[][] APOS_ESCAPE; public static String[][] APOS_UNESCAPE; public static String[][] JAVA_CTRL_CHARS_ESCAPE; public static String[][] JAVA_CTRL_CHARS_UNESCAPE; public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] ISO8859_1_UNESCAPE() { [EOL] return ISO8859_1_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] HTML40_EXTENDED_UNESCAPE() { [EOL] return HTML40_EXTENDED_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] BASIC_ESCAPE() { [EOL] return BASIC_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] BASIC_UNESCAPE() { [EOL] return BASIC_UNESCAPE.clone(); [EOL] } [EOL] public static String[][] ISO8859_1_ESCAPE(); [EOL] public static String[][] ISO8859_1_UNESCAPE(); [EOL] public static String[][] HTML40_EXTENDED_ESCAPE(); [EOL] public static String[][] HTML40_EXTENDED_UNESCAPE(); [EOL] public static String[][] BASIC_ESCAPE(); [EOL] public static String[][] BASIC_UNESCAPE(); [EOL] public static String[][] APOS_ESCAPE(); [EOL] public static String[][] APOS_UNESCAPE(); [EOL] public static String[][] JAVA_CTRL_CHARS_ESCAPE(); [EOL] public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); [EOL] public static String[][] invert(final String[][] array); [EOL] String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; [EOL] String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; [EOL] String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; [EOL] String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; [EOL] String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; [EOL] String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; [EOL] String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; [EOL] String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; [EOL] String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] APOS_ESCAPE() { [EOL] return APOS_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] APOS_UNESCAPE() { [EOL] return APOS_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
public static String[][] JAVA_CTRL_CHARS_ESCAPE() { [EOL] return JAVA_CTRL_CHARS_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ { "\u00A0", "&nbsp;" }, { "\u00A1", "&iexcl;" }, { "\u00A2", "&cent;" }, { "\u00A3", "&pound;" }, { "\u00A4", "&curren;" }, { "\u00A5", "&yen;" }, { "\u00A6", "&brvbar;" }, { "\u00A7", "&sect;" }, { "\u00A8", "&uml;" }, { "\u00A9", "&copy;" }, { "\u00AA", "&ordf;" }, { "\u00AB", "&laquo;" }, { "\u00AC", "&not;" }, { "\u00AD", "&shy;" }, { "\u00AE", "&reg;" }, { "\u00AF", "&macr;" }, { "\u00B0", "&deg;" }, { "\u00B1", "&plusmn;" }, { "\u00B2", "&sup2;" }, { "\u00B3", "&sup3;" }, { "\u00B4", "&acute;" }, { "\u00B5", "&micro;" }, { "\u00B6", "&para;" }, { "\u00B7", "&middot;" }, { "\u00B8", "&cedil;" }, { "\u00B9", "&sup1;" }, { "\u00BA", "&ordm;" }, { "\u00BB", "&raquo;" }, { "\u00BC", "&frac14;" }, { "\u00BD", "&frac12;" }, { "\u00BE", "&frac34;" }, { "\u00BF", "&iquest;" }, { "\u00C0", "&Agrave;" }, { "\u00C1", "&Aacute;" }, { "\u00C2", "&Acirc;" }, { "\u00C3", "&Atilde;" }, { "\u00C4", "&Auml;" }, { "\u00C5", "&Aring;" }, { "\u00C6", "&AElig;" }, { "\u00C7", "&Ccedil;" }, { "\u00C8", "&Egrave;" }, { "\u00C9", "&Eacute;" }, { "\u00CA", "&Ecirc;" }, { "\u00CB", "&Euml;" }, { "\u00CC", "&Igrave;" }, { "\u00CD", "&Iacute;" }, { "\u00CE", "&Icirc;" }, { "\u00CF", "&Iuml;" }, { "\u00D0", "&ETH;" }, { "\u00D1", "&Ntilde;" }, { "\u00D2", "&Ograve;" }, { "\u00D3", "&Oacute;" }, { "\u00D4", "&Ocirc;" }, { "\u00D5", "&Otilde;" }, { "\u00D6", "&Ouml;" }, { "\u00D7", "&times;" }, { "\u00D8", "&Oslash;" }, { "\u00D9", "&Ugrave;" }, { "\u00DA", "&Uacute;" }, { "\u00DB", "&Ucirc;" }, { "\u00DC", "&Uuml;" }, { "\u00DD", "&Yacute;" }, { "\u00DE", "&THORN;" }, { "\u00DF", "&szlig;" }, { "\u00E0", "&agrave;" }, { "\u00E1", "&aacute;" }, { "\u00E2", "&acirc;" }, { "\u00E3", "&atilde;" }, { "\u00E4", "&auml;" }, { "\u00E5", "&aring;" }, { "\u00E6", "&aelig;" }, { "\u00E7", "&ccedil;" }, { "\u00E8", "&egrave;" }, { "\u00E9", "&eacute;" }, { "\u00EA", "&ecirc;" }, { "\u00EB", "&euml;" }, { "\u00EC", "&igrave;" }, { "\u00ED", "&iacute;" }, { "\u00EE", "&icirc;" }, { "\u00EF", "&iuml;" }, { "\u00F0", "&eth;" }, { "\u00F1", "&ntilde;" }, { "\u00F2", "&ograve;" }, { "\u00F3", "&oacute;" }, { "\u00F4", "&ocirc;" }, { "\u00F5", "&otilde;" }, { "\u00F6", "&ouml;" }, { "\u00F7", "&divide;" }, { "\u00F8", "&oslash;" }, { "\u00F9", "&ugrave;" }, { "\u00FA", "&uacute;" }, { "\u00FB", "&ucirc;" }, { "\u00FC", "&uuml;" }, { "\u00FD", "&yacute;" }, { "\u00FE", "&thorn;" }, { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ { "\u0192", "&fnof;" }, { "\u0391", "&Alpha;" }, { "\u0392", "&Beta;" }, { "\u0393", "&Gamma;" }, { "\u0394", "&Delta;" }, { "\u0395", "&Epsilon;" }, { "\u0396", "&Zeta;" }, { "\u0397", "&Eta;" }, { "\u0398", "&Theta;" }, { "\u0399", "&Iota;" }, { "\u039A", "&Kappa;" }, { "\u039B", "&Lambda;" }, { "\u039C", "&Mu;" }, { "\u039D", "&Nu;" }, { "\u039E", "&Xi;" }, { "\u039F", "&Omicron;" }, { "\u03A0", "&Pi;" }, { "\u03A1", "&Rho;" }, { "\u03A3", "&Sigma;" }, { "\u03A4", "&Tau;" }, { "\u03A5", "&Upsilon;" }, { "\u03A6", "&Phi;" }, { "\u03A7", "&Chi;" }, { "\u03A8", "&Psi;" }, { "\u03A9", "&Omega;" }, { "\u03B1", "&alpha;" }, { "\u03B2", "&beta;" }, { "\u03B3", "&gamma;" }, { "\u03B4", "&delta;" }, { "\u03B5", "&epsilon;" }, { "\u03B6", "&zeta;" }, { "\u03B7", "&eta;" }, { "\u03B8", "&theta;" }, { "\u03B9", "&iota;" }, { "\u03BA", "&kappa;" }, { "\u03BB", "&lambda;" }, { "\u03BC", "&mu;" }, { "\u03BD", "&nu;" }, { "\u03BE", "&xi;" }, { "\u03BF", "&omicron;" }, { "\u03C0", "&pi;" }, { "\u03C1", "&rho;" }, { "\u03C2", "&sigmaf;" }, { "\u03C3", "&sigma;" }, { "\u03C4", "&tau;" }, { "\u03C5", "&upsilon;" }, { "\u03C6", "&phi;" }, { "\u03C7", "&chi;" }, { "\u03C8", "&psi;" }, { "\u03C9", "&omega;" }, { "\u03D1", "&thetasym;" }, { "\u03D2", "&upsih;" }, { "\u03D6", "&piv;" }, { "\u2022", "&bull;" }, { "\u2026", "&hellip;" }, { "\u2032", "&prime;" }, { "\u2033", "&Prime;" }, { "\u203E", "&oline;" }, { "\u2044", "&frasl;" }, { "\u2118", "&weierp;" }, { "\u2111", "&image;" }, { "\u211C", "&real;" }, { "\u2122", "&trade;" }, { "\u2135", "&alefsym;" }, { "\u2190", "&larr;" }, { "\u2191", "&uarr;" }, { "\u2192", "&rarr;" }, { "\u2193", "&darr;" }, { "\u2194", "&harr;" }, { "\u21B5", "&crarr;" }, { "\u21D0", "&lArr;" }, { "\u21D1", "&uArr;" }, { "\u21D2", "&rArr;" }, { "\u21D3", "&dArr;" }, { "\u21D4", "&hArr;" }, { "\u2200", "&forall;" }, { "\u2202", "&part;" }, { "\u2203", "&exist;" }, { "\u2205", "&empty;" }, { "\u2207", "&nabla;" }, { "\u2208", "&isin;" }, { "\u2209", "&notin;" }, { "\u220B", "&ni;" }, { "\u220F", "&prod;" }, { "\u2211", "&sum;" }, { "\u2212", "&minus;" }, { "\u2217", "&lowast;" }, { "\u221A", "&radic;" }, { "\u221D", "&prop;" }, { "\u221E", "&infin;" }, { "\u2220", "&ang;" }, { "\u2227", "&and;" }, { "\u2228", "&or;" }, { "\u2229", "&cap;" }, { "\u222A", "&cup;" }, { "\u222B", "&int;" }, { "\u2234", "&there4;" }, { "\u223C", "&sim;" }, { "\u2245", "&cong;" }, { "\u2248", "&asymp;" }, { "\u2260", "&ne;" }, { "\u2261", "&equiv;" }, { "\u2264", "&le;" }, { "\u2265", "&ge;" }, { "\u2282", "&sub;" }, { "\u2283", "&sup;" }, { "\u2286", "&sube;" }, { "\u2287", "&supe;" }, { "\u2295", "&oplus;" }, { "\u2297", "&otimes;" }, { "\u22A5", "&perp;" }, { "\u22C5", "&sdot;" }, { "\u2308", "&lceil;" }, { "\u2309", "&rceil;" }, { "\u230A", "&lfloor;" }, { "\u230B", "&rfloor;" }, { "\u2329", "&lang;" }, { "\u232A", "&rang;" }, { "\u25CA", "&loz;" }, { "\u2660", "&spades;" }, { "\u2663", "&clubs;" }, { "\u2665", "&hearts;" }, { "\u2666", "&diams;" }, { "\u0152", "&OElig;" }, { "\u0153", "&oelig;" }, { "\u0160", "&Scaron;" }, { "\u0161", "&scaron;" }, { "\u0178", "&Yuml;" }, { "\u02C6", "&circ;" }, { "\u02DC", "&tilde;" }, { "\u2002", "&ensp;" }, { "\u2003", "&emsp;" }, { "\u2009", "&thinsp;" }, { "\u200C", "&zwnj;" }, { "\u200D", "&zwj;" }, { "\u200E", "&lrm;" }, { "\u200F", "&rlm;" }, { "\u2013", "&ndash;" }, { "\u2014", "&mdash;" }, { "\u2018", "&lsquo;" }, { "\u2019", "&rsquo;" }, { "\u201A", "&sbquo;" }, { "\u201C", "&ldquo;" }, { "\u201D", "&rdquo;" }, { "\u201E", "&bdquo;" }, { "\u2020", "&dagger;" }, { "\u2021", "&Dagger;" }, { "\u2030", "&permil;" }, { "\u2039", "&lsaquo;" }, { "\u203A", "&rsaquo;" }, { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ { "\"", "&quot;" }, { "&", "&amp;" }, { "<", "&lt;" }, { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }];
```java [EOL] public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { [EOL] return JAVA_CTRL_CHARS_UNESCAPE.clone(); [EOL] } [EOL] public static String[][] ISO8859_1_ESCAPE(); [EOL] public static String[][] ISO8859_1_UNESCAPE(); [EOL] public static String[][] HTML40_EXTENDED_ESCAPE(); [EOL] public static String[][] HTML40_EXTENDED_UNESCAPE(); [EOL] public static String[][] BASIC_ESCAPE(); [EOL] public static String[][] BASIC_UNESCAPE(); [EOL] public static String[][] APOS_ESCAPE(); [EOL] public static String[][] APOS_UNESCAPE(); [EOL] public static String[][] JAVA_CTRL_CHARS_ESCAPE(); [EOL] public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); [EOL] public static String[][] invert(final String[][] array); [EOL] String[][] ISO8859_1_ESCAPE=Optional[{ [EOL] { "\u00A0", "&nbsp;" }, [EOL] { "\u00A1", "&iexcl;" }, [EOL] { "\u00A2", "&cent;" }, [EOL] { "\u00A3", "&pound;" }, [EOL] { "\u00A4", "&curren;" }, [EOL] { "\u00A5", "&yen;" }, [EOL] { "\u00A6", "&brvbar;" }, [EOL] { "\u00A7", "&sect;" }, [EOL] { "\u00A8", "&uml;" }, [EOL] { "\u00A9", "&copy;" }, [EOL] { "\u00AA", "&ordf;" }, [EOL] { "\u00AB", "&laquo;" }, [EOL] { "\u00AC", "&not;" }, [EOL] { "\u00AD", "&shy;" }, [EOL] { "\u00AE", "&reg;" }, [EOL] { "\u00AF", "&macr;" }, [EOL] { "\u00B0", "&deg;" }, [EOL] { "\u00B1", "&plusmn;" }, [EOL] { "\u00B2", "&sup2;" }, [EOL] { "\u00B3", "&sup3;" }, [EOL] { "\u00B4", "&acute;" }, [EOL] { "\u00B5", "&micro;" }, [EOL] { "\u00B6", "&para;" }, [EOL] { "\u00B7", "&middot;" }, [EOL] { "\u00B8", "&cedil;" }, [EOL] { "\u00B9", "&sup1;" }, [EOL] { "\u00BA", "&ordm;" }, [EOL] { "\u00BB", "&raquo;" }, [EOL] { "\u00BC", "&frac14;" }, [EOL] { "\u00BD", "&frac12;" }, [EOL] { "\u00BE", "&frac34;" }, [EOL] { "\u00BF", "&iquest;" }, [EOL] { "\u00C0", "&Agrave;" }, [EOL] { "\u00C1", "&Aacute;" }, [EOL] { "\u00C2", "&Acirc;" }, [EOL] { "\u00C3", "&Atilde;" }, [EOL] { "\u00C4", "&Auml;" }, [EOL] { "\u00C5", "&Aring;" }, [EOL] { "\u00C6", "&AElig;" }, [EOL] { "\u00C7", "&Ccedil;" }, [EOL] { "\u00C8", "&Egrave;" }, [EOL] { "\u00C9", "&Eacute;" }, [EOL] { "\u00CA", "&Ecirc;" }, [EOL] { "\u00CB", "&Euml;" }, [EOL] { "\u00CC", "&Igrave;" }, [EOL] { "\u00CD", "&Iacute;" }, [EOL] { "\u00CE", "&Icirc;" }, [EOL] { "\u00CF", "&Iuml;" }, [EOL] { "\u00D0", "&ETH;" }, [EOL] { "\u00D1", "&Ntilde;" }, [EOL] { "\u00D2", "&Ograve;" }, [EOL] { "\u00D3", "&Oacute;" }, [EOL] { "\u00D4", "&Ocirc;" }, [EOL] { "\u00D5", "&Otilde;" }, [EOL] { "\u00D6", "&Ouml;" }, [EOL] { "\u00D7", "&times;" }, [EOL] { "\u00D8", "&Oslash;" }, [EOL] { "\u00D9", "&Ugrave;" }, [EOL] { "\u00DA", "&Uacute;" }, [EOL] { "\u00DB", "&Ucirc;" }, [EOL] { "\u00DC", "&Uuml;" }, [EOL] { "\u00DD", "&Yacute;" }, [EOL] { "\u00DE", "&THORN;" }, [EOL] { "\u00DF", "&szlig;" }, [EOL] { "\u00E0", "&agrave;" }, [EOL] { "\u00E1", "&aacute;" }, [EOL] { "\u00E2", "&acirc;" }, [EOL] { "\u00E3", "&atilde;" }, [EOL] { "\u00E4", "&auml;" }, [EOL] { "\u00E5", "&aring;" }, [EOL] { "\u00E6", "&aelig;" }, [EOL] { "\u00E7", "&ccedil;" }, [EOL] { "\u00E8", "&egrave;" }, [EOL] { "\u00E9", "&eacute;" }, [EOL] { "\u00EA", "&ecirc;" }, [EOL] { "\u00EB", "&euml;" }, [EOL] { "\u00EC", "&igrave;" }, [EOL] { "\u00ED", "&iacute;" }, [EOL] { "\u00EE", "&icirc;" }, [EOL] { "\u00EF", "&iuml;" }, [EOL] { "\u00F0", "&eth;" }, [EOL] { "\u00F1", "&ntilde;" }, [EOL] { "\u00F2", "&ograve;" }, [EOL] { "\u00F3", "&oacute;" }, [EOL] { "\u00F4", "&ocirc;" }, [EOL] { "\u00F5", "&otilde;" }, [EOL] { "\u00F6", "&ouml;" }, [EOL] { "\u00F7", "&divide;" }, [EOL] { "\u00F8", "&oslash;" }, [EOL] { "\u00F9", "&ugrave;" }, [EOL] { "\u00FA", "&uacute;" }, [EOL] { "\u00FB", "&ucirc;" }, [EOL] { "\u00FC", "&uuml;" }, [EOL] { "\u00FD", "&yacute;" }, [EOL] { "\u00FE", "&thorn;" }, [EOL] { "\u00FF", "&yuml;" } [EOL] }]; [EOL] String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; [EOL] String[][] HTML40_EXTENDED_ESCAPE=Optional[{ [EOL] { "\u0192", "&fnof;" }, [EOL] { "\u0391", "&Alpha;" }, [EOL] { "\u0392", "&Beta;" }, [EOL] { "\u0393", "&Gamma;" }, [EOL] { "\u0394", "&Delta;" }, [EOL] { "\u0395", "&Epsilon;" }, [EOL] { "\u0396", "&Zeta;" }, [EOL] { "\u0397", "&Eta;" }, [EOL] { "\u0398", "&Theta;" }, [EOL] { "\u0399", "&Iota;" }, [EOL] { "\u039A", "&Kappa;" }, [EOL] { "\u039B", "&Lambda;" }, [EOL] { "\u039C", "&Mu;" }, [EOL] { "\u039D", "&Nu;" }, [EOL] { "\u039E", "&Xi;" }, [EOL] { "\u039F", "&Omicron;" }, [EOL] { "\u03A0", "&Pi;" }, [EOL] { "\u03A1", "&Rho;" }, [EOL] { "\u03A3", "&Sigma;" }, [EOL] { "\u03A4", "&Tau;" }, [EOL] { "\u03A5", "&Upsilon;" }, [EOL] { "\u03A6", "&Phi;" }, [EOL] { "\u03A7", "&Chi;" }, [EOL] { "\u03A8", "&Psi;" }, [EOL] { "\u03A9", "&Omega;" }, [EOL] { "\u03B1", "&alpha;" }, [EOL] { "\u03B2", "&beta;" }, [EOL] { "\u03B3", "&gamma;" }, [EOL] { "\u03B4", "&delta;" }, [EOL] { "\u03B5", "&epsilon;" }, [EOL] { "\u03B6", "&zeta;" }, [EOL] { "\u03B7", "&eta;" }, [EOL] { "\u03B8", "&theta;" }, [EOL] { "\u03B9", "&iota;" }, [EOL] { "\u03BA", "&kappa;" }, [EOL] { "\u03BB", "&lambda;" }, [EOL] { "\u03BC", "&mu;" }, [EOL] { "\u03BD", "&nu;" }, [EOL] { "\u03BE", "&xi;" }, [EOL] { "\u03BF", "&omicron;" }, [EOL] { "\u03C0", "&pi;" }, [EOL] { "\u03C1", "&rho;" }, [EOL] { "\u03C2", "&sigmaf;" }, [EOL] { "\u03C3", "&sigma;" }, [EOL] { "\u03C4", "&tau;" }, [EOL] { "\u03C5", "&upsilon;" }, [EOL] { "\u03C6", "&phi;" }, [EOL] { "\u03C7", "&chi;" }, [EOL] { "\u03C8", "&psi;" }, [EOL] { "\u03C9", "&omega;" }, [EOL] { "\u03D1", "&thetasym;" }, [EOL] { "\u03D2", "&upsih;" }, [EOL] { "\u03D6", "&piv;" }, [EOL] { "\u2022", "&bull;" }, [EOL] { "\u2026", "&hellip;" }, [EOL] { "\u2032", "&prime;" }, [EOL] { "\u2033", "&Prime;" }, [EOL] { "\u203E", "&oline;" }, [EOL] { "\u2044", "&frasl;" }, [EOL] { "\u2118", "&weierp;" }, [EOL] { "\u2111", "&image;" }, [EOL] { "\u211C", "&real;" }, [EOL] { "\u2122", "&trade;" }, [EOL] { "\u2135", "&alefsym;" }, [EOL] { "\u2190", "&larr;" }, [EOL] { "\u2191", "&uarr;" }, [EOL] { "\u2192", "&rarr;" }, [EOL] { "\u2193", "&darr;" }, [EOL] { "\u2194", "&harr;" }, [EOL] { "\u21B5", "&crarr;" }, [EOL] { "\u21D0", "&lArr;" }, [EOL] { "\u21D1", "&uArr;" }, [EOL] { "\u21D2", "&rArr;" }, [EOL] { "\u21D3", "&dArr;" }, [EOL] { "\u21D4", "&hArr;" }, [EOL] { "\u2200", "&forall;" }, [EOL] { "\u2202", "&part;" }, [EOL] { "\u2203", "&exist;" }, [EOL] { "\u2205", "&empty;" }, [EOL] { "\u2207", "&nabla;" }, [EOL] { "\u2208", "&isin;" }, [EOL] { "\u2209", "&notin;" }, [EOL] { "\u220B", "&ni;" }, [EOL] { "\u220F", "&prod;" }, [EOL] { "\u2211", "&sum;" }, [EOL] { "\u2212", "&minus;" }, [EOL] { "\u2217", "&lowast;" }, [EOL] { "\u221A", "&radic;" }, [EOL] { "\u221D", "&prop;" }, [EOL] { "\u221E", "&infin;" }, [EOL] { "\u2220", "&ang;" }, [EOL] { "\u2227", "&and;" }, [EOL] { "\u2228", "&or;" }, [EOL] { "\u2229", "&cap;" }, [EOL] { "\u222A", "&cup;" }, [EOL] { "\u222B", "&int;" }, [EOL] { "\u2234", "&there4;" }, [EOL] { "\u223C", "&sim;" }, [EOL] { "\u2245", "&cong;" }, [EOL] { "\u2248", "&asymp;" }, [EOL] { "\u2260", "&ne;" }, [EOL] { "\u2261", "&equiv;" }, [EOL] { "\u2264", "&le;" }, [EOL] { "\u2265", "&ge;" }, [EOL] { "\u2282", "&sub;" }, [EOL] { "\u2283", "&sup;" }, [EOL] { "\u2286", "&sube;" }, [EOL] { "\u2287", "&supe;" }, [EOL] { "\u2295", "&oplus;" }, [EOL] { "\u2297", "&otimes;" }, [EOL] { "\u22A5", "&perp;" }, [EOL] { "\u22C5", "&sdot;" }, [EOL] { "\u2308", "&lceil;" }, [EOL] { "\u2309", "&rceil;" }, [EOL] { "\u230A", "&lfloor;" }, [EOL] { "\u230B", "&rfloor;" }, [EOL] { "\u2329", "&lang;" }, [EOL] { "\u232A", "&rang;" }, [EOL] { "\u25CA", "&loz;" }, [EOL] { "\u2660", "&spades;" }, [EOL] { "\u2663", "&clubs;" }, [EOL] { "\u2665", "&hearts;" }, [EOL] { "\u2666", "&diams;" }, [EOL] { "\u0152", "&OElig;" }, [EOL] { "\u0153", "&oelig;" }, [EOL] { "\u0160", "&Scaron;" }, [EOL] { "\u0161", "&scaron;" }, [EOL] { "\u0178", "&Yuml;" }, [EOL] { "\u02C6", "&circ;" }, [EOL] { "\u02DC", "&tilde;" }, [EOL] { "\u2002", "&ensp;" }, [EOL] { "\u2003", "&emsp;" }, [EOL] { "\u2009", "&thinsp;" }, [EOL] { "\u200C", "&zwnj;" }, [EOL] { "\u200D", "&zwj;" }, [EOL] { "\u200E", "&lrm;" }, [EOL] { "\u200F", "&rlm;" }, [EOL] { "\u2013", "&ndash;" }, [EOL] { "\u2014", "&mdash;" }, [EOL] { "\u2018", "&lsquo;" }, [EOL] { "\u2019", "&rsquo;" }, [EOL] { "\u201A", "&sbquo;" }, [EOL] { "\u201C", "&ldquo;" }, [EOL] { "\u201D", "&rdquo;" }, [EOL] { "\u201E", "&bdquo;" }, [EOL] { "\u2020", "&dagger;" }, [EOL] { "\u2021", "&Dagger;" }, [EOL] { "\u2030", "&permil;" }, [EOL] { "\u2039", "&lsaquo;" }, [EOL] { "\u203A", "&rsaquo;" }, [EOL] { "\u20AC", "&euro;" } [EOL] }]; [EOL] String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; [EOL] String[][] BASIC_ESCAPE=Optional[{ [EOL] { "\"", "&quot;" }, [EOL] { "&", "&amp;" }, [EOL] { "<", "&lt;" }, [EOL] { ">", "&gt;" } [EOL] }]; [EOL] String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; [EOL] String[][] APOS_ESCAPE=Optional[{[E
public static String[][] invert(final String[][] array) { [EOL] final String[][] newarray = new String[array.length][2]; [EOL] for (int i = 0; i < array.length; i++) { [EOL] newarray[i][0] = array[i][1]; [EOL] newarray[i][1] = array[i][0]; [EOL] } [EOL] return newarray; [EOL] } [EOL] public static String[][] ISO8859_1_ESCAPE() { [EOL] return new String[][] { [EOL] { "\u00A0", "&nbsp;" }, [EOL] { "\u00A1", "&iexcl;" }, [EOL] { "\u00A2", "&cent;" }, [EOL] { "\u00A3", "&pound;" }, [EOL] { "\u00A4", "&curren;" }, [EOL] { "\u00A5", "&yen;" }, [EOL] { "\u00A6", "&brvbar;" }, [EOL] { "\u00A7", "&sect;" }, [EOL] { "\u00A8", "&uml;" }, [EOL] { "\u00A9", "&copy;" }, [EOL] { "\u00AA", "&ordf;" }, [EOL] { "\u00AB", "&laquo;" }, [EOL] { "\u00AC", "&not;" }, [EOL] { "\u00AD", "&shy;" }, [EOL] { "\u00AE", "&reg;" }, [EOL] { "\u00AF", "&macr;" }, [EOL] { "\u00B0", "&deg;" }, [EOL] { "\u00B1", "&plusmn;" }, [EOL] { "\u00B2", "&sup2;" }, [EOL] { "\u00B3", "&sup3;" }, [EOL] { "\u00B4", "&acute;" }, [EOL] { "\u00B5", "&micro;" }, [EOL] { "\u00B6", "&para;" }, [EOL] { "\u00B7", "&middot;" }, [EOL] { "\u00B8", "&cedil;" }, [EOL] { "\u00B9", "&sup1;" }, [EOL] { "\u00BA", "&ordm;" }, [EOL] { "\u00BB", "&raquo;" }, [EOL] { "\u00BC", "&frac14;" }, [EOL] { "\u00BD", "&frac12;" }, [EOL] { "\u00BE", "&frac34;" }, [EOL] { "\u00BF", "&iquest;" }, [EOL] { "\u00C0", "&Agrave;" }, [EOL] { "\u00C1", "&Aacute;" }, [EOL] { "\u00C2", "&Acirc;" }, [EOL] { "\u00C3", "&Atilde;" }, [EOL] { "\u00C4", "&Auml;" }, [EOL] { "\u00C5", "&Aring;" }, [EOL] { "\u00C6", "&AElig;" }, [EOL] { "\u00C7", "&Ccedil;" }, [EOL] { "\u00C8", "&Egrave;" }, [EOL] { "\u00C9", "&Eacute;" }, [EOL] { "\u00CA", "&Ecirc;" }, [EOL] { "\u00CB", "&Euml;" }, [EOL] { "\u00CC", "&Igrave;" }, [EOL] { "\u00CD", "&Iacute;" }, [EOL] { "\u00CE", "&Icirc;" }, [EOL] { "\u00CF", "&Iuml;" }, [EOL] { "\u00D0", "&ETH;" }, [EOL] { "\u00D1", "&Ntilde;" }, [EOL] { "\u00D2", "&Ograve;" }, [EOL] { "\u00D3", "&Oacute;" }, [EOL] { "\u00D4", "&Ocirc;" }, [EOL] { "\u00D5", "&Otilde;" }, [EOL] { "\u00D6", "&Ouml;" }, [EOL] { "\u00D7", "&times;" }, [EOL] { "\u00D8", "&Oslash;" }, [EOL] { "\u00D9", "&Ugrave;" }, [EOL] { "\u00DA", "&Uacute;" }, [EOL] { "\u00DB", "&Ucirc;" }, [EOL] { "\u00DC", "&Uuml;" }, [EOL] { "\u00DD", "&Yacute;" }, [EOL] { "\u00DE", "&THORN;" }, [EOL] { "\u00DF", "&szlig;" }, [EOL] { "\u00E0", "&agrave;" }, [EOL] { "\u00E1", "&aacute;" }, [EOL] { "\u00E2", "&acirc;" }, [EOL] { "\u00E3", "&atilde;" }, [EOL] { "\u00E4", "&auml;" }, [EOL] { "\u00E5", "&aring;" }, [EOL] { "\u00E6", "&aelig;" }, [EOL] { "\u00E7", "&ccedil;" }, [EOL] { "\u00E8", "&egrave;" }, [EOL] { "\u00E9", "&eacute;" }, [EOL] { "\u00EA", "&ecirc;" }, [EOL] { "\u00EB", "&euml;" }, [EOL] { "\u00EC", "&igrave;" }, [EOL] { "\u00ED", "&iacute;" }, [EOL] { "\u00EE", "&icirc;" }, [EOL] { "\u00EF", "&iuml;" }, [EOL] { "\u00F0", "&eth;" }, [EOL] { "\u00F1", "&ntilde;" }, [EOL] { "\u00F2", "&ograve;" }, [EOL] { "\u00F3", "&oacute;" }, [EOL] { "\u00F4", "&ocirc;" }, [EOL] { "\u00F5", "&otilde;" }, [EOL] { "\u00F6", "&ouml;" }, [EOL] { "\u00F7", "&divide;" }, [EOL] { "\u00F8", "&oslash;" }, [EOL] { "\u00F9", "&ugrave;" }, [EOL] { "\u00FA", "&uacute;" }, [EOL] { "\u00FB", "&ucirc;" }, [EOL] { "\u00FC", "&uuml;" }, [EOL] { "\u00FD", "&yacute;" }, [EOL] { "\u00FE", "&thorn;" }, [EOL] { "\u00FF", "&yuml;" } [EOL] }; [EOL] } [EOL] public static String[][] ISO8859_1_UNESCAPE() { [EOL] return invert(ISO8859_1_ESCAPE()); [EOL] } [EOL] public static String[][] BASIC_ESCAPE() { [EOL] return new String[][] { [EOL] { "\"", "&quot;" }, [EOL] { "&", "&amp;" }, [EOL] { "<", "&lt;" }, [EOL] { ">", "&gt;" } [EOL] }; [EOL] } [EOL] public static String[][] BASIC_UNESCAPE() { [EOL] return invert(BASIC_ESCAPE()); [EOL] } [EOL] public static String[][] APOS_ESCAPE() { [EOL] return new String[][] { [EOL] { "'", "&apos;" } [EOL] }; [EOL] } [EOL] public static String[][] APOS_UNESCAPE() { [EOL] return invert(APOS_ESCAPE()); [EOL] } [EOL] public static String[][] JAVA_CTRL_CHARS_ESCAPE() { [EOL] return new String[][] { [EOL] { "\b", "\\b" }, [EOL] { "\n", "\\n" }, [EOL] { "\t", "\\t" }, [EOL] { "\f", "\\f" }, [EOL] { "\r", "\\r" } [EOL] }; [EOL] }
public void testBetweenWithValidRange() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.between(50, 100); [EOL] assertNotNull(escaper); [EOL] assertTrue(escaper.isInclusive()); [EOL] assertEquals(50, escaper.getBelow()); [EOL] assertEquals(100, escaper.getAbove()); [EOL] }
public void testBetweenWithInvertedRange() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.between(100, 50); [EOL] assertNotNull(escaper); [EOL] assertTrue(escaper.isInclusive()); [EOL] assertEquals(100, escaper.getBelow()); [EOL] assertEquals(50, escaper.getAbove()); [EOL] }
public void testTranslate_CodepointOutsideRangeBelowAndBetweenTrue() throws IOException { [EOL] final int codepoint = 50; // Below the 'below' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeAboveAndBetweenTrue() throws IOException { [EOL] final int codepoint = 80; // Above the 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslate_CodepointWithinRangeAndBetweenTrue() throws IOException { [EOL] final int codepoint = 65; // Within the range [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("&#65;", out.toString()); [EOL] }
public void testTranslate_CodepointWithinRangeAndBetweenFalse() throws IOException { [EOL] final int codepoint = 65; // Within the range [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeBelowAndBetweenFalse() throws IOException { [EOL] final int codepoint = 50; // Below the 'below' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("&#50;", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeAboveAndBetweenFalse() throws IOException { [EOL] final int codepoint = 80; // Above the 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(between, below, above); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("&#80;", out.toString()); [EOL] }
public void testInitializeWithNonNullInitializer() throws ConcurrentException { [EOL] ConcurrentInitializer<Integer> initializer = mock(ConcurrentInitializer.class); [EOL] when(initializer.get()).thenReturn(42); [EOL] Integer result = ConcurrentUtils.initialize(initializer); [EOL] assertEquals(Integer.valueOf(42), result); [EOL] }
public void testInitializeWithNullInitializer() throws ConcurrentException { [EOL] Integer result = ConcurrentUtils.initialize(null); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentUncheckedWithExistingKey() { [EOL] ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>(); [EOL] String key = "existingKey"; [EOL] Integer value = 1; [EOL] map.put(key, value); [EOL] ConcurrentInitializer<Integer> init = () -> 2; [EOL] Integer result = ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] assertEquals(value, result); [EOL] }
public void testCreateIfAbsentUncheckedWithNewKey() { [EOL] ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>(); [EOL] String key = "newKey"; [EOL] ConcurrentInitializer<Integer> init = () -> 2; [EOL] Integer result = ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] assertEquals(Integer.valueOf(2), result); [EOL] assertTrue(map.containsKey(key)); [EOL] }
public void testCreateIfAbsentUncheckedWithConcurrentException() { [EOL] ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>(); [EOL] String key = "key"; [EOL] ConcurrentInitializer<Integer> init = () -> { throw new ConcurrentException("Test Exception"); }; [EOL] try { [EOL] ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] fail("Expected ConcurrentRuntimeException"); [EOL] } catch (ConcurrentRuntimeException cre) { [EOL] assertNotNull(cre.getCause()); [EOL] assertEquals(ConcurrentException.class, cre.getCause().getClass()); [EOL] assertEquals("Test Exception", cre.getCause().getMessage()); [EOL] } [EOL] }
public void testInitWithValidPattern() { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(parser.getParsePattern()); [EOL] assertEquals("yyyy-MM-dd", parser.getPattern()); [EOL] assertEquals(TimeZone.getDefault(), parser.getTimeZone()); [EOL] assertEquals(Locale.getDefault(), parser.getLocale()); [EOL] }
public void testInitWithInvalidPattern() { [EOL] try { [EOL] new FastDateParser("y", TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException for single 'y' pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testInitWithUnmatchedQuotePattern() { [EOL] try { [EOL] new FastDateParser("'unclosed", TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException for unmatched quote pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testInitWithEscapedQuotePattern() { [EOL] FastDateParser parser = new FastDateParser("''", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(parser.getParsePattern()); [EOL] assertEquals("''", parser.getPattern()); [EOL] }
public void testInitWithTextPattern() { [EOL] FastDateParser parser = new FastDateParser("MMMM", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(parser.getParsePattern()); [EOL] assertEquals("MMMM", parser.getPattern()); [EOL] }
public void testInitWithComplexPattern() { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd'T'HH:mm:ss", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(parser.getParsePattern()); [EOL] assertEquals("yyyy-MM-dd'T'HH:mm:ss", parser.getPattern()); [EOL] }
@Override [EOL] public Locale getLocale() { [EOL] return locale; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testParseWithNullDate() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] String source = "invalid-date"; [EOL] try { [EOL] parser.parse(source); [EOL] fail("Should have thrown ParseException"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testParseWithJapaneseImperialDate() throws ParseException { [EOL] FastDateParser parser = new FastDateParser("Gyyyy-MM-dd", TimeZone.getDefault(), Locale.JAPANESE_IMPERIAL); [EOL] String source = "invalid-date"; [EOL] try { [EOL] parser.parse(source); [EOL] fail("Should have thrown ParseException for Japanese Imperial date"); [EOL] } catch (ParseException e) { [EOL] assertTrue(e.getMessage().contains("The ja_JP_JP locale does not support dates before 1868 AD")); [EOL] } [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL] final int offset = pos.getIndex(); [EOL] final Matcher matcher = parsePattern.matcher(source.substring(offset)); [EOL] if (!matcher.lookingAt()) { [EOL] return null; [EOL] } [EOL] final Calendar cal = Calendar.getInstance(timeZone, locale); [EOL] cal.clear(); [EOL] for (int i = 0; i < strategies.length; ) { [EOL] final Strategy strategy = strategies[i++]; [EOL] strategy.setCalendar(this, cal, matcher.group(i)); [EOL] } [EOL] pos.setIndex(offset + matcher.end()); [EOL] return cal.getTime(); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
public void testEscapeRegexWithUnquoteAndSingleQuoteAtEnd() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test'"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Incorrect regex escape with unquote and single quote at end", "\\Qtest\\E", result.toString()); [EOL] } [EOL] public void testEscapeRegexWithUnquoteAndNoSingleQuote() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Incorrect regex escape with unquote and no single quote", "\\Qtest\\E", result.toString()); [EOL] } [EOL] public void testEscapeRegexWithoutUnquoteAndWithBackslashAtEnd() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test\\"; [EOL] boolean unquote = false; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Incorrect regex escape without unquote and backslash at end", "\\Qtest\\E", result.toString()); [EOL] } [EOL] public void testEscapeRegexWithUnquoteAndEscapedE() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test\\Etest"; [EOL] boolean unquote = true; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Incorrect regex escape with unquote and escaped E", "\\QtestEE\\\\EQtest\\E", result.toString()); [EOL] } [EOL] public void testEscapeRegexWithoutUnquoteAndEscapedE() { [EOL] StringBuilder regex = new StringBuilder(); [EOL] String value = "test\\Etest"; [EOL] boolean unquote = false; [EOL] StringBuilder result = escapeRegex(regex, value, unquote); [EOL] assertEquals("Incorrect regex escape without unquote and escaped E", "\\Qtest\\EE\\\\EQtest\\E", result.toString()); [EOL] }
int getFieldWidth() { [EOL] return currentFormatField.length(); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testGetStrategyWithSingleQuote() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("'SingleQuote'", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("D", definingCalendar); [EOL] assertSame(DAY_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithDayOfWeek() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("E", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfWeekInMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("F", definingCalendar); [EOL] assertSame(DAY_OF_WEEK_IN_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithEra() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("G", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithHourOfDay() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("H", definingCalendar); [EOL] assertSame(MODULO_HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("K", definingCalendar); [EOL] assertSame(HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("M", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy || result instanceof NumberStrategy); [EOL] } [EOL] public void testGetStrategyWithMillisecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("S", definingCalendar); [EOL] assertSame(MILLISECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("W", definingCalendar); [EOL] assertSame(WEEK_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithAmPm() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("a", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("d", definingCalendar); [EOL] assertSame(DAY_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour12() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("h", definingCalendar); [EOL] assertSame(MODULO_HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour24() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("k", definingCalendar); [EOL] assertSame(HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMinute() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("m", definingCalendar); [EOL] assertSame(MINUTE_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithSecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("s", definingCalendar); [EOL] assertSame(SECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("w", definingCalendar); [EOL] assertSame(WEEK_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("y", definingCalendar); [EOL] assertTrue(result instanceof NumberStrategy); [EOL] } [EOL] public void testGetStrategyWithTimeZoneOffset() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("Z", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithTimeZoneName() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("z", definingCalendar); [EOL] assertTrue(result instanceof LocaleSpecificStrategy); [EOL] } [EOL] public void testGetStrategyWithEscapedText() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("'EscapedText'", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] } [EOL] public void testGetStrategyWithDefault() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("X", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] }
private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) { [EOL] final ConcurrentMap<Locale, Strategy> cache = getCache(field); [EOL] Strategy strategy = cache.get(locale); [EOL] if (strategy == null) { [EOL] strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new TextStrategy(field, definingCalendar, locale); [EOL] final Strategy inCache = cache.putIfAbsent(locale, strategy); [EOL] if (inCache != null) { [EOL] return inCache; [EOL] } [EOL] } [EOL] return strategy; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testIsNumber_withSingleQuotePrefix() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("'9"); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public void testIsNumber_withDigitPrefix() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("2"); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public void testIsNumber_withNonDigit() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("A"); [EOL] assertFalse(strategy.isNumber()); [EOL] }
public void testIsNumber_withEscapedDigit() { [EOL] CopyQuotedStrategy strategy = new CopyQuotedStrategy("''1"); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public void testIsNumber() { [EOL] assertTrue(new NumberStrategy(Calendar.DAY_OF_MONTH).isNumber()); [EOL] }
public void testSetCalendarWithAbbreviatedYearStrategy() { [EOL] FastDateParser parser = new FastDateParser("yy", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] ABBREVIATED_YEAR_STRATEGY.setCalendar(parser, cal, "20"); [EOL] int expectedYear = parser.adjustYear(20); [EOL] assertEquals(expectedYear, cal.get(Calendar.YEAR)); [EOL] }
public void testSetCalendarWithNumberMonthStrategy() { [EOL] FastDateParser parser = new FastDateParser("MM", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] NUMBER_MONTH_STRATEGY.setCalendar(parser, cal, "01"); [EOL] assertEquals(0, cal.get(Calendar.MONTH)); [EOL] }
public void testModifyWithModuloHourOfDayStrategy() { [EOL] int modifiedValue = MODULO_HOUR_OF_DAY_STRATEGY.modify(25); [EOL] assertEquals(1, modifiedValue); [EOL] }
public void testModifyWithModuloHourStrategy() { [EOL] int modifiedValue = MODULO_HOUR_STRATEGY.modify(13); [EOL] assertEquals(1, modifiedValue); [EOL] }
public void testAddRegexWithNextNumberTrue() { [EOL] FastDateParser parser = Mockito.mock(FastDateParser.class); [EOL] StringBuilder regex = new StringBuilder(); [EOL] Mockito.when(parser.isNextNumber()).thenReturn(true); [EOL] Mockito.when(parser.getFieldWidth()).thenReturn(4); [EOL] boolean result = parser.addRegex(parser, regex); [EOL] assertTrue(result); [EOL] assertEquals("(\\p{IsNd}{4}+)", regex.toString()); [EOL] }
public void testAddRegexWithNextNumberFalse() { [EOL] FastDateParser parser = Mockito.mock(FastDateParser.class); [EOL] StringBuilder regex = new StringBuilder(); [EOL] Mockito.when(parser.isNextNumber()).thenReturn(false); [EOL] boolean result = parser.addRegex(parser, regex); [EOL] assertTrue(result); [EOL] assertEquals("(\\p{IsNd}++)", regex.toString()); [EOL] }
public void testTimeZoneStrategyWithLocale() { [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZoneStrategy strategy = new TimeZoneStrategy(locale); [EOL] assertNotNull(strategy); [EOL] }
public void testTimeZoneStrategyWithNonGMTTimeZone() { [EOL] Locale locale = Locale.US; [EOL] TimeZoneStrategy strategy = new TimeZoneStrategy(locale); [EOL] String nonGMTId = "America/New_York"; [EOL] TimeZone tz = TimeZone.getTimeZone(nonGMTId); [EOL] String shortName = tz.getDisplayName(false, TimeZone.SHORT, locale); [EOL] String longName = tz.getDisplayName(false, TimeZone.LONG, locale); [EOL] assertTrue(strategy.tzNames.containsKey(shortName)); [EOL] assertTrue(strategy.tzNames.containsKey(longName)); [EOL] if (tz.useDaylightTime()) { [EOL] String shortDstName = tz.getDisplayName(true, TimeZone.SHORT, locale); [EOL] String longDstName = tz.getDisplayName(true, TimeZone.LONG, locale); [EOL] assertTrue(strategy.tzNames.containsKey(shortDstName)); [EOL] assertTrue(strategy.tzNames.containsKey(longDstName)); [EOL] } [EOL] }
public void testTimeZoneStrategyWithGMTTimeZone() { [EOL] Locale locale = Locale.UK; [EOL] TimeZoneStrategy strategy = new TimeZoneStrategy(locale); [EOL] String gmtId = "GMT+00:00"; [EOL] assertFalse(strategy.tzNames.containsKey(gmtId)); [EOL] }
public void testTimeZoneStrategyValidTimeZoneChars() { [EOL] Locale locale = Locale.CANADA; [EOL] TimeZoneStrategy strategy = new TimeZoneStrategy(locale); [EOL] assertNotNull(strategy.validTimeZoneChars); [EOL] assertTrue(strategy.validTimeZoneChars.contains("(GMT[+\\-]\\d{0,1}\\d{2}|[+\\-]\\d{2}:?\\d{2}|")); [EOL] }
public void testGetFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 0); [EOL] fail("Expected ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_NegativeDenominator_PositiveNumerator() { [EOL] Fraction fraction = Fraction.getFraction(1, -2); [EOL] assertEquals(-1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_NegativeDenominator_NegativeNumerator() { [EOL] Fraction fraction = Fraction.getFraction(-1, -2); [EOL] assertEquals(1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_PositiveDenominator_PositiveNumerator() { [EOL] Fraction fraction = Fraction.getFraction(1, 2); [EOL] assertEquals(1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_OverflowCondition_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MIN_VALUE, Integer.MIN_VALUE); [EOL] fail("Expected ArithmeticException due to overflow condition"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_ValidInput_PositiveWhole() { [EOL] Fraction result = Fraction.getFraction(1, 1, 2); [EOL] assertEquals(3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_ValidInput_NegativeWhole() { [EOL] Fraction result = Fraction.getFraction(-1, 1, 2); [EOL] assertEquals(-3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 1, 0); [EOL] fail("Expected ArithmeticException for zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NegativeDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 1, -1); [EOL] fail("Expected ArithmeticException for negative denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be negative", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NegativeNumerator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, -1, 2); [EOL] fail("Expected ArithmeticException for negative numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The numerator must not be negative", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NumeratorTooLarge_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MAX_VALUE, 1, 1); [EOL] fail("Expected ArithmeticException for numerator too large"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Numerator too large to represent as an Integer.", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NumeratorTooSmall_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MIN_VALUE, 1, 1); [EOL] fail("Expected ArithmeticException for numerator too small"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Numerator too large to represent as an Integer.", ae.getMessage()); [EOL] } [EOL] }
public void testNegate_NumeratorIsMinValue_ShouldThrowArithmeticException() { [EOL] Fraction fraction = new Fraction(Integer.MIN_VALUE, 1); [EOL] try { [EOL] fraction.negate(); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: too large to negate", e.getMessage()); [EOL] } [EOL] }
public void testNegate_NumeratorIsNotMinValue_ShouldNegate() { [EOL] Fraction fraction = new Fraction(1, 1); [EOL] Fraction result = fraction.negate(); [EOL] assertEquals(-1, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testAbsWithPositiveNumerator() { [EOL] Fraction positiveFraction = new Fraction(5, 10); [EOL] Fraction result = positiveFraction.abs(); [EOL] assertEquals(positiveFraction, result); [EOL] }
public void testAbsWithNegativeNumerator() { [EOL] Fraction negativeFraction = new Fraction(-5, 10); [EOL] Fraction result = negativeFraction.abs(); [EOL] assertEquals(new Fraction(5, 10), result); [EOL] }
public void testAbsWithZeroNumerator() { [EOL] Fraction zeroNumeratorFraction = new Fraction(0, 10); [EOL] Fraction result = zeroNumeratorFraction.abs(); [EOL] assertEquals(zeroNumeratorFraction, result); [EOL] }
public void testSubAndCheckNoOverflow() { [EOL] int x = 1; [EOL] int y = 1; [EOL] int result = subAndCheck(x, y); [EOL] assertEquals(0, result); [EOL] }
public void testSubAndCheckOverflowPositive() { [EOL] try { [EOL] int x = Integer.MAX_VALUE; [EOL] int y = -1; [EOL] subAndCheck(x, y); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: add", e.getMessage()); [EOL] } [EOL] }
public void testSubAndCheckOverflowNegative() { [EOL] try { [EOL] int x = Integer.MIN_VALUE; [EOL] int y = 1; [EOL] subAndCheck(x, y); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: add", e.getMessage()); [EOL] } [EOL] }
public void testSubtract_NullFraction() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] try { [EOL] baseFraction.subtract(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testSubtract_Zero() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] final Fraction zeroFraction = Fraction.getZero(); [EOL] Fraction resultFraction = baseFraction.subtract(zeroFraction); [EOL] assertEquals(Fraction.getFraction(1, 2), resultFraction); [EOL] } [EOL] public void testSubtract_PositiveFraction() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] final Fraction subtractFraction = Fraction.getFraction(1, 4); [EOL] Fraction resultFraction = baseFraction.subtract(subtractFraction); [EOL] assertEquals(Fraction.getFraction(1, 4), resultFraction); [EOL] } [EOL] public void testSubtract_NegativeFraction() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] final Fraction subtractFraction = Fraction.getFraction(-1, 4); [EOL] Fraction resultFraction = baseFraction.subtract(subtractFraction); [EOL] assertEquals(Fraction.getFraction(3, 4), resultFraction); [EOL] } [EOL] public void testSubtract_WholeNumber() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] final Fraction subtractFraction = Fraction.getFraction(1); [EOL] Fraction resultFraction = baseFraction.subtract(subtractFraction); [EOL] assertEquals(Fraction.getFraction(-1, 2), resultFraction); [EOL] } [EOL] public void testSubtract_LargeFraction() { [EOL] final Fraction baseFraction = Fraction.getFraction(1, 2); [EOL] final Fraction subtractFraction = Fraction.getFraction(Integer.MAX_VALUE, Integer.MAX_VALUE - 1); [EOL] Fraction resultFraction = baseFraction.subtract(subtractFraction); [EOL] assertEquals(Fraction.getFraction(-Integer.MAX_VALUE + 2, 2 * (Integer.MAX_VALUE - 1)), resultFraction); [EOL] }
public void testAddSub_NullFraction_ThrowsIllegalArgumentException() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] try { [EOL] fraction.addSub(null, true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testAddSub_ZeroNumerator_ReturnsFraction() { [EOL] Fraction fraction = new Fraction(0, 3); [EOL] Fraction addend = new Fraction(1, 2); [EOL] Fraction result = fraction.addSub(addend, true); [EOL] assertEquals(new Fraction(1, 2), result); [EOL] }
public void testAddSub_ZeroNumeratorFraction_ReturnsThis() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Fraction addend = new Fraction(0, 3); [EOL] Fraction result = fraction.addSub(addend, true); [EOL] assertEquals(fraction, result); [EOL] }
public void testAddSub_GCDOne_ReturnsNewFraction() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Fraction addend = new Fraction(1, 3); [EOL] Fraction result = fraction.addSub(addend, true); [EOL] assertEquals(new Fraction(5, 6), result); [EOL] }
public void testAddSub_GCDNotOne_ReturnsNewFraction() { [EOL] Fraction fraction = new Fraction(1, 4); [EOL] Fraction addend = new Fraction(1, 6); [EOL] Fraction result = fraction.addSub(addend, true); [EOL] assertEquals(new Fraction(5, 12), result); [EOL] }
public void testAddSub_OverflowInNumerator_ThrowsArithmeticException() { [EOL] Fraction fraction = new Fraction(Integer.MAX_VALUE, 1); [EOL] Fraction addend = new Fraction(1, Integer.MAX_VALUE); [EOL] try { [EOL] fraction.addSub(addend, true); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testIndexOf_CharSequenceWithCharFromString() { [EOL] CharSequence cs = "abcdef"; [EOL] int searchChar = 'c'; [EOL] int start = 0; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromStringStartingIndex() { [EOL] CharSequence cs = "abcdef"; [EOL] int searchChar = 'c'; [EOL] int start = 2; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromStringNotFound() { [EOL] CharSequence cs = "abcdef"; [EOL] int searchChar = 'x'; [EOL] int start = 0; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromStringNegativeStart() { [EOL] CharSequence cs = "abcdef"; [EOL] int searchChar = 'c'; [EOL] int start = -1; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromStringStartAfterEnd() { [EOL] CharSequence cs = "abcdef"; [EOL] int searchChar = 'c'; [EOL] int start = 10; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromNonString() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] int searchChar = 'c'; [EOL] int start = 0; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromNonStringNegativeStart() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] int searchChar = 'c'; [EOL] int start = -1; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharSequenceWithCharFromNonStringStartAfterEnd() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] int searchChar = 'c'; [EOL] int start = 10; [EOL] int result = StringUtils.indexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testRegionMatches_StringMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "bcde", 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_StringNoMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "BCDE", 0, 4); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_IgnoreCaseMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", true, 1, "BCDE", 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_IgnoreCaseNoMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", true, 1, "BCDEf", 0, 5); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_CharSequenceMatch() { [EOL] boolean result = StringUtils.regionMatches(new StringBuilder("abcdef"), false, 1, new StringBuilder("bcde"), 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_CharSequenceNoMatch() { [EOL] boolean result = StringUtils.regionMatches(new StringBuilder("abcdef"), false, 1, new StringBuilder("BCDE"), 0, 4); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_CharSequenceIgnoreCaseMatch() { [EOL] boolean result = StringUtils.regionMatches(new StringBuilder("abcdef"), true, 1, new StringBuilder("BCDE"), 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_CharSequenceIgnoreCaseNoMatch() { [EOL] boolean result = StringUtils.regionMatches(new StringBuilder("abcdef"), true, 1, new StringBuilder("BCDEf"), 0, 5); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_EmptySubstring() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "", 0, 0); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_NegativeStart() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, -1, "abc", 0, 3); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_StartGreaterThanLength() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 6, "abc", 0, 3); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_LengthExceedsFirstString() { [EOL] boolean result = StringUtils.regionMatches("abc", false, 1, "bcdef", 0, 5); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_LengthExceedsSecondString() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "bc", 0, 3); [EOL] assertFalse(result); [EOL] }
public void testGetCSVInstanceWithNullInput() { [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(null); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetCSVInstanceWithEmptyInput() { [EOL] char[] input = new char[0]; [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(input); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetCSVInstanceWithNonEmptyInput() { [EOL] char[] input = new char[]{'a', ',', 'b'}; [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(input); [EOL] assertNotNull(tokenizer); [EOL] assertTrue(tokenizer.hasNext()); [EOL] assertEquals("a", tokenizer.next()); [EOL] assertEquals("b", tokenizer.next()); [EOL] }
public void testOutsideOf_ValidRange() { [EOL] JavaUnicodeEscaper escaper = JavaUnicodeEscaper.outsideOf(50, 100); [EOL] assertNotNull(escaper); [EOL] assertEquals(50, escaper.getBelow()); [EOL] assertEquals(100, escaper.getAbove()); [EOL] assertFalse(escaper.isBetween()); [EOL] }
public void testOutsideOf_InvertedRange() { [EOL] JavaUnicodeEscaper escaper = JavaUnicodeEscaper.outsideOf(100, 50); [EOL] assertNotNull(escaper); [EOL] assertEquals(100, escaper.getBelow()); [EOL] assertEquals(50, escaper.getAbove()); [EOL] assertFalse(escaper.isBetween()); [EOL] }
public void testJavaUnicodeEscaperConstructorValidRange() { [EOL] JavaUnicodeEscaper escaper = new JavaUnicodeEscaper(0, 100, true); [EOL] assertNotNull(escaper); [EOL] }
public void testJavaUnicodeEscaperConstructorNegativeBelow() { [EOL] try { [EOL] JavaUnicodeEscaper escaper = new JavaUnicodeEscaper(-1, 100, true); [EOL] fail("Should have thrown IllegalArgumentException for negative below range"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testJavaUnicodeEscaperConstructorAboveLessThanBelow() { [EOL] try { [EOL] JavaUnicodeEscaper escaper = new JavaUnicodeEscaper(100, 50, true); [EOL] fail("Should have thrown IllegalArgumentException for above less than below"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testJavaUnicodeEscaperConstructorNegativeAbove() { [EOL] try { [EOL] JavaUnicodeEscaper escaper = new JavaUnicodeEscaper(0, -1, true); [EOL] fail("Should have thrown IllegalArgumentException for negative above range"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
protected List<Rule> parsePattern() { [EOL] final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL] final List<Rule> rules = new ArrayList<Rule>(); [EOL] final String[] ERAs = symbols.getEras(); [EOL] final String[] months = symbols.getMonths(); [EOL] final String[] shortMonths = symbols.getShortMonths(); [EOL] final String[] weekdays = symbols.getWeekdays(); [EOL] final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL] final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL] final int length = mPattern.length(); [EOL] final int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] final String token = parseToken(mPattern, indexRef); [EOL] i = indexRef[0]; [EOL] final int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] Rule rule; [EOL] final char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] rule = new TextField(Calendar.ERA, ERAs); [EOL] break; [EOL] case 'y': [EOL] if (tokenLen == 2) { [EOL] rule = TwoDigitYearField.INSTANCE; [EOL] } else { [EOL] rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 4) { [EOL] rule = new TextField(Calendar.MONTH, months); [EOL] } else if (tokenLen == 3) { [EOL] rule = new TextField(Calendar.MONTH, shortMonths); [EOL] } else if (tokenLen == 2) { [EOL] rule = TwoDigitMonthField.INSTANCE; [EOL] } else { [EOL] rule = UnpaddedMonthField.INSTANCE; [EOL] } [EOL] break; [EOL] case 'd': [EOL] rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL] break; [EOL] case 'h': [EOL] rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL] break; [EOL] case 'H': [EOL] rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL] break; [EOL] case 'm': [EOL] rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL] break; [EOL] case 's': [EOL] rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL] break; [EOL] case 'S': [EOL] rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL] break; [EOL] case 'E': [EOL] rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL] break; [EOL] case 'D': [EOL] rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL] break; [EOL] case 'F': [EOL] rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL] break; [EOL] case 'w': [EOL] rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL] break; [EOL] case 'W': [EOL] rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL] break; [EOL] case 'a': [EOL] rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL] break; [EOL] case 'k': [EOL] rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL] break; [EOL] case 'K': [EOL] rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL] } else { [EOL] rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL] } else { [EOL] rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL] } [EOL] break; [EOL] case '\'': [EOL] final String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] rule = new CharacterLiteral(sub.charAt(0)); [EOL] } else { [EOL] rule = new StringLiteral(sub); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] rules.add(rule); [EOL] } [EOL] return rules; [EOL] }
public void testParseTokenWithSingleLetter() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithMultipleSameLetters() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("AAAA", indexRef); [EOL] assertEquals("AAAA", result); [EOL] assertEquals(4, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithDifferentLetters() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("ABCD", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithSingleQuote() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("'", indexRef); [EOL] assertEquals("'", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithEscapedQuote() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("''", indexRef); [EOL] assertEquals("'", result); [EOL] assertEquals(2, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithMixedContent() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A'BC'D", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithNonLetter() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("123", indexRef); [EOL] assertEquals("'123", result); [EOL] assertEquals(3, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithMixedQuotes() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A''BC", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithLiteralContainingLetter() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("'A'", indexRef); [EOL] assertEquals("'A'", result); [EOL] assertEquals(3, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithEndQuote() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A'B'C", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] }
public void testApplyRulesToStringWithNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] String result = fdf.applyRulesToString(null); [EOL] assertNull("The result should be null when the calendar is null", result); [EOL] }
public void testApplyRulesToStringWithNonNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String result = fdf.applyRulesToString(calendar); [EOL] assertNotNull("The result should not be null when the calendar is non-null", result); [EOL] assertFalse("The result should not be empty", result.isEmpty()); [EOL] }
private GregorianCalendar newCalendar() { [EOL] return new GregorianCalendar(mTimeZone, mLocale); [EOL] }
public void testFormatWithNullDate() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] try { [EOL] fdf.format((Date) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormatWithValidDate() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Date date = new Date(); [EOL] String formattedDate = fdf.format(date); [EOL] assertNotNull("The formatted date should not be null", formattedDate); [EOL] assertFalse("The formatted date should not be empty", formattedDate.isEmpty()); [EOL] }
public void testReadObject() throws IOException, ClassNotFoundException { [EOL] ObjectInputStream in = mock(ObjectInputStream.class); [EOL] MyClass myClassInstance = new MyClass(); [EOL] Method readObjectMethod = MyClass.class.getDeclaredMethod("readObject", ObjectInputStream.class); [EOL] readObjectMethod.setAccessible(true); [EOL] doNothing().when(in).defaultReadObject(); [EOL] readObjectMethod.invoke(myClassInstance, in); [EOL] verify(in).defaultReadObject(); [EOL] Method initMethod = MyClass.class.getDeclaredMethod("init"); [EOL] initMethod.setAccessible(true); [EOL] }
public void testStringLiteralWithNull() { [EOL] StringLiteral literal = new StringLiteral(null); [EOL] assertNull("The value should be null", literal.getValue()); [EOL] }
public void testStringLiteralWithEmptyString() { [EOL] StringLiteral literal = new StringLiteral(""); [EOL] assertEquals("The value should be an empty string", "", literal.getValue()); [EOL] }
public void testStringLiteralWithNonEmptyString() { [EOL] StringLiteral literal = new StringLiteral("test"); [EOL] assertEquals("The value should be 'test'", "test", literal.getValue()); [EOL] }
public void testEstimateLengthEmptyString() { [EOL] StrBuilder strBuilder = new StrBuilder(""); [EOL] int length = strBuilder.estimateLength(); [EOL] assertEquals(0, length); [EOL] }
public void testEstimateLengthNonEmptyString() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] int length = strBuilder.estimateLength(); [EOL] assertEquals(3, length); [EOL] }
public void testAppendToWithNonNullBufferAndCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] fdf.appendTo(buffer, calendar); [EOL] assertNotNull("Buffer should not be null after appendTo", buffer); [EOL] assertTrue("Buffer should contain formatted date", buffer.length() > 0); [EOL] }
public void testAppendTo_SingleDigit() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 5; [EOL] appendTo(buffer, value); [EOL] assertEquals("5", buffer.toString()); [EOL] } [EOL] public void testAppendTo_TwoDigits() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 42; [EOL] appendTo(buffer, value); [EOL] assertEquals("42", buffer.toString()); [EOL] } [EOL] public void testAppendTo_MoreThanTwoDigits() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 123; [EOL] appendTo(buffer, value); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testUnpaddedMonthField() { [EOL] UnpaddedMonthField field = new UnpaddedMonthField(); [EOL] assertNotNull(field); [EOL] }
public void testTwoDigitYearField() { [EOL] new TwoDigitYearField(); [EOL] }
public void testTwelveHourFieldConstructorWithNullRule() { [EOL] try { [EOL] new TwelveHourField(null); [EOL] fail("Should have thrown IllegalArgumentException for null rule"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testTwelveHourFieldConstructorWithNonNullRule() { [EOL] NumberRule rule = mock(NumberRule.class); [EOL] TwelveHourField field = new TwelveHourField(rule); [EOL] assertNotNull("TwelveHourField should not be null", field); [EOL] }
public void testTwentyFourHourFieldConstructorWithNullRule() { [EOL] try { [EOL] new TwentyFourHourField(null); [EOL] fail("Should have thrown IllegalArgumentException for null rule"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testTwentyFourHourFieldConstructorWithNonNullRule() { [EOL] NumberRule rule = mock(NumberRule.class); [EOL] TwentyFourHourField field = new TwentyFourHourField(rule); [EOL] assertNotNull("TwentyFourHourField should not be null", field); [EOL] }
public void testEstimateLength() { [EOL] FormatRule mRule = mock(FormatRule.class); [EOL] when(mRule.estimateLength()).thenReturn(10); [EOL] FormatRuleAdapter adapter = new FormatRuleAdapter(mRule); [EOL] int estimatedLength = adapter.estimateLength(); [EOL] assertEquals(10, estimatedLength); [EOL] }
static Set<Pair<IDKey, IDKey>> getRegistry() { [EOL] return REGISTRY.get(); [EOL] }
public void testGetRegisterPairWithNonNullValues() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] Pair<IDKey, IDKey> result = ClassName.getRegisterPair(lhs, rhs); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getLeft()); [EOL] assertNotNull(result.getRight()); [EOL] assertNotSame(lhs, result.getLeft().getValue()); [EOL] assertNotSame(rhs, result.getRight().getValue()); [EOL] } [EOL] public void testGetRegisterPairWithNullValues() { [EOL] Pair<IDKey, IDKey> result = ClassName.getRegisterPair(null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLeft().getValue()); [EOL] assertNull(result.getRight().getValue()); [EOL] }
public void testIsRegisteredWithNullRegistry() { [EOL] final Object lhs = new Object(); [EOL] final Object rhs = new Object(); [EOL] mockStatic(YourClass.class); [EOL] when(YourClass.getRegistry()).thenReturn(null); [EOL] boolean result = YourClass.isRegistered(lhs, rhs); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsRegisteredWithEmptyRegistry() { [EOL] final Object lhs = new Object(); [EOL] final Object rhs = new Object(); [EOL] Set<Pair<IDKey, IDKey>> emptyRegistry = Collections.emptySet(); [EOL] mockStatic(YourClass.class); [EOL] when(YourClass.getRegistry()).thenReturn(emptyRegistry); [EOL] boolean result = YourClass.isRegistered(lhs, rhs); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsRegisteredWithNonEmptyRegistryContainingPair() { [EOL] final Object lhs = new Object(); [EOL] final Object rhs = new Object(); [EOL] Set<Pair<IDKey, IDKey>> registry = new HashSet<>(); [EOL] Pair<IDKey, IDKey> pair = YourClass.getRegisterPair(lhs, rhs); [EOL] registry.add(pair); [EOL] mockStatic(YourClass.class); [EOL] when(YourClass.getRegistry()).thenReturn(registry); [EOL] boolean result = YourClass.isRegistered(lhs, rhs); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsRegisteredWithNonEmptyRegistryContainingSwappedPair() { [EOL] final Object lhs = new Object(); [EOL] final Object rhs = new Object(); [EOL] Set<Pair<IDKey, IDKey>> registry = new HashSet<>(); [EOL] Pair<IDKey, IDKey> pair = YourClass.getRegisterPair(lhs, rhs); [EOL] Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight()); [EOL] registry.add(swappedPair); [EOL] mockStatic(YourClass.class); [EOL] when(YourClass.getRegistry()).thenReturn(registry); [EOL] boolean result = YourClass.isRegistered(lhs, rhs); [EOL] assertTrue(result); [EOL] }
public void testRegisterWithNewRegistry() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] EqualsBuilder.register(lhs, rhs); [EOL] assertTrue(EqualsBuilder.getRegistry().contains(EqualsBuilder.getRegisterPair(lhs, rhs))); [EOL] } [EOL] public void testRegisterWithExistingRegistry() { [EOL] Object lhs1 = new Object(); [EOL] Object rhs1 = new Object(); [EOL] EqualsBuilder.register(lhs1, rhs1); // First registration to create the registry [EOL] Object lhs2 = new Object(); [EOL] Object rhs2 = new Object(); [EOL] EqualsBuilder.register(lhs2, rhs2); // Second registration to use the existing registry [EOL] assertTrue(EqualsBuilder.getRegistry().contains(EqualsBuilder.getRegisterPair(lhs2, rhs2))); [EOL] }
public void testUnregisterWithNonNullRegistryAndNonEmptyAfterRemove() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] EqualsBuilder.register(lhs, rhs); [EOL] EqualsBuilder.unregister(lhs, rhs); [EOL] }
public void testUnregisterWithNonNullRegistryAndEmptyAfterRemove() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] EqualsBuilder.register(lhs, rhs); [EOL] EqualsBuilder.unregister(lhs, rhs); [EOL] }
public void testUnregisterWithNullRegistry() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] EqualsBuilder.unregister(lhs, rhs); [EOL] }
public void testReflectionEqualsWithNulls() { [EOL] boolean result = reflectionEquals(null, null, true); [EOL] assertTrue(result); [EOL] }
public void testReflectionEqualsWithNonNulls() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] boolean result = reflectionEquals(lhs, rhs, true); [EOL] assertFalse(result); [EOL] }
public void testReflectionEqualsWithSameObject() { [EOL] Object obj = new Object(); [EOL] boolean result = reflectionEquals(obj, obj, true); [EOL] assertTrue(result); [EOL] }
public void testReflectionEqualsWithDifferentTransientSettings() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] boolean resultWithTransients = reflectionEquals(lhs, rhs, true); [EOL] boolean resultWithoutTransients = reflectionEquals(lhs, rhs, false); [EOL] assertFalse(resultWithTransients); [EOL] assertFalse(resultWithoutTransients); [EOL] }
public void testReflectionEquals_BothNull() { [EOL] boolean result = reflectionEquals(null, null, false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_FirstNullSecondNotNull() { [EOL] boolean result = reflectionEquals(null, new Object(), false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_FirstNotNullSecondNull() { [EOL] boolean result = reflectionEquals(new Object(), null, false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_SameObject() { [EOL] Object obj = new Object(); [EOL] boolean result = reflectionEquals(obj, obj, false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_DifferentClasses() { [EOL] boolean result = reflectionEquals(new Object(), new String(), false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_CompatibleClasses() { [EOL] boolean result = reflectionEquals("test", new String("test"), false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_CompatibleClassesWithExclusion() { [EOL] boolean result = reflectionEquals("test", new String("test"), false, null, "dummyField"); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_IncompatibleClasses() { [EOL] boolean result = reflectionEquals(new Integer(1), new String("1"), false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_CompatibleClassesDifferentValues() { [EOL] boolean result = reflectionEquals("test1", new String("test2"), false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_WithReflectUpToClass() { [EOL] boolean result = reflectionEquals("test", new String("test"), false, String.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithReflectUpToClassAndExclusion() { [EOL] boolean result = reflectionEquals("test", new String("test"), false, String.class, "dummyField"); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithReflectUpToClassIncompatible() { [EOL] boolean result = reflectionEquals(new Integer(1), new String("1"), false, Number.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransients() { [EOL] boolean result = reflectionEquals(new TransientTestClass(1, "test"), new TransientTestClass(1, "test"), true, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransientsDifferentValues() { [EOL] boolean result = reflectionEquals(new TransientTestClass(1, "test1"), new TransientTestClass(2, "test2"), true, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransientsAndReflectUpToClass() { [EOL] boolean result = reflectionEquals(new TransientTestClass(1, "test"), new TransientTestClass(1, "test"), true, TransientTestClass.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransientsAndReflectUpToClassDifferentValues() { [EOL] boolean result = reflectionEquals(new TransientTestClass(1, "test1"), new TransientTestClass(2, "test2"), true, TransientTestClass.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransientsAndReflectUpToClassAndExclusion() { [EOL] boolean result = reflectionEquals(new TransientTestClass(1, "test"), new TransientTestClass(1, "test"), true, TransientTestClass.class, "dummyField"); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithIllegalArgumentException() { [EOL] boolean result = reflectionEquals(new IllegalArgumentTestClass(), new IllegalArgumentTestClass(), false, null); [EOL] assertFalse(result); [EOL] } [EOL] static class TransientTestClass { [EOL] private transient int id; [EOL] private transient String name; [EOL] TransientTestClass(int id, String name) { [EOL] this.id = id; [EOL] this.name = name; [EOL] } [EOL] } [EOL] static class IllegalArgumentTestClass { [EOL] @Override [EOL] public boolean equals(Object obj) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] }
public void testReflectionAppend_RegisteredObjects() { [EOL] final Object lhs = new Object(); [EOL] final Object rhs = new Object(); [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] EqualsBuilderTest.register(lhs, rhs); [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertTrue(builder.isEquals()); [EOL] EqualsBuilderTest.unregister(lhs, rhs); [EOL] }
public void testReflectionAppend_WithTransientFields() { [EOL] final Object lhs = new Object() { [EOL] private transient int transientField = 1; [EOL] }; [EOL] final Object rhs = new Object() { [EOL] private transient int transientField = 1; [EOL] }; [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testReflectionAppend_WithExcludedFields() { [EOL] final Object lhs = new Object() { [EOL] private int includedField = 1; [EOL] private int excludedField = 2; [EOL] }; [EOL] final Object rhs = new Object() { [EOL] private int includedField = 1; [EOL] private int excludedField = 3; [EOL] }; [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[]{"excludedField"}; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testReflectionAppend_WithInaccessibleField() { [EOL] final Object lhs = new Object() { [EOL] private int inaccessibleField = 1; [EOL] }; [EOL] final Object rhs = new Object() { [EOL] private int inaccessibleField = 2; [EOL] }; [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testReflectionAppend_WithStaticField() { [EOL] final Object lhs = new Object() { [EOL] private static int staticField = 1; [EOL] }; [EOL] final Object rhs = new Object() { [EOL] private static int staticField = 1; [EOL] }; [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testReflectionAppend_WithInnerClassField() { [EOL] final Object lhs = new Object() { [EOL] private int normalField = 1; [EOL] private int $innerClassField = 2; [EOL] }; [EOL] final Object rhs = new Object() { [EOL] private int normalField = 1; [EOL] private int $innerClassField = 2; [EOL] }; [EOL] final Class<?> clazz = lhs.getClass(); [EOL] final EqualsBuilder builder = new EqualsBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(null, null); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_SameObject() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj, obj); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentNonArrayObjects() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_DifferentClasses() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] String rhs = "test"; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_LongArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long[] lhs = {1L, 2L, 3L}; [EOL] long[] rhs = {1L, 2L, 3L}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_IntArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] int[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ShortArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short[] lhs = {1, 2, 3}; [EOL] short[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_CharArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ByteArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = {1, 2, 3}; [EOL] byte[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DoubleArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] double[] lhs = {1.0, 2.0, 3.0}; [EOL] double[] rhs = {1.0, 2.0, 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_FloatArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_BooleanArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ObjectArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = {1, "two", 3.0}; [EOL] Object[] rhs = {1, "two", 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentArrayTypes() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] char[] rhs = {'1', '2', '3'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendIntegersEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(5, 5); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendIntegersNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(5, 10); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendIntegersWhenAlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(5, 10); // Set isEquals to false [EOL] builder.append(10, 10); // Should not change isEquals [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendCharsEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char lhs = 'a'; [EOL] char rhs = 'a'; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendCharsNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char lhs = 'a'; [EOL] char rhs = 'b'; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendCharsWhenIsEqualsIsFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(true, false); // Set isEquals to false [EOL] char lhs = 'a'; [EOL] char rhs = 'a'; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendBytesEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte lhs = 1; [EOL] byte rhs = 1; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendBytesNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte lhs = 1; [EOL] byte rhs = 2; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendBytesWhenIsEqualsIsFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.isEquals = false; [EOL] byte lhs = 1; [EOL] byte rhs = 1; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendSameArrays() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendDifferentArraysSameLength() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 4}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendDifferentLengthArrays() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNullLeftArray() { [EOL] int[] lhs = null; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNullRightArray() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendNullBothArrays() { [EOL] int[] lhs = null; [EOL] int[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendNonEqualIsEqualsSetFalse() { [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_CharArray_Equal() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_NotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'x', 'y', 'z'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_LeftNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_RightNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_BothNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_DifferentLength() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_AlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendSameArrays() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array1); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendDifferentLengthArrays() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = new byte[] {1, 2, 3, 4}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendDifferentArrays() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = new byte[] {4, 5, 6}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendNullAndNonNullArrays() { [EOL] byte[] array1 = null; [EOL] byte[] array2 = new byte[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendNonNullAndNullArrays() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendBothNullArrays() { [EOL] byte[] array1 = null; [EOL] byte[] array2 = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendWithInitialFalse() { [EOL] byte[] array1 = new byte[] {1, 2, 3}; [EOL] byte[] array2 = new byte[] {1, 2, 3}; [EOL] EqualsBuilder builder = new EqualsBuilder().setEquals(false); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testReset() { [EOL] EqualsBuilder testBuilder = new EqualsBuilder(); [EOL] testBuilder.setEquals(false); [EOL] testBuilder.reset(); [EOL] assertTrue(testBuilder.isEquals()); [EOL] }
public void testNoMatcherConstructor() { [EOL] try { [EOL] new NoMatcher(); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testTrimMatcherConstructor() { [EOL] TrimMatcher trimMatcher = new TrimMatcher(); [EOL] assertNotNull(trimMatcher); [EOL] }
public void testRandomStringLengthZero() { [EOL] String result = RandomStringUtils.random(0, 0, 0, false, false, null, new Random()); [EOL] assertEquals("", result); [EOL] }
public void testRandomStringLengthNegative() { [EOL] try { [EOL] RandomStringUtils.random(-1, 0, 0, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringCharsArrayEmpty() { [EOL] try { [EOL] RandomStringUtils.random(5, 0, 0, false, false, new char[]{}, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringInvalidRange() { [EOL] try { [EOL] RandomStringUtils.random(5, 10, 5, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[a-zA-Z0-9]{5}")); [EOL] }
public void testRandomStringLettersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[a-zA-Z]{5}")); [EOL] }
public void testRandomStringNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, false, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[0-9]{5}")); [EOL] }
public void testRandomStringCustomCharsArray() { [EOL] char[] customChars = {'a', 'b', 'c', '1', '2', '3'}; [EOL] String result = RandomStringUtils.random(5, 0, customChars.length, false, false, customChars, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[abc123]{5}")); [EOL] }
public void testRandomStringCustomRange() { [EOL] String result = RandomStringUtils.random(5, 'a', 'f', false, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[a-e]{5}")); [EOL] }
public void testRandomStringSurrogatePairs() { [EOL] String result = RandomStringUtils.random(2, 0, 0, false, false, new char[]{'\uD83D', '\uDC00'}, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.codePointCount(0, result.length()) == 2); [EOL] }
public void testMutableByteConstructorWithValidString() { [EOL] MutableByte mb = new MutableByte("10"); [EOL] assertEquals(10, mb.byteValue()); [EOL] }
public void testMutableByteConstructorWithInvalidString() { [EOL] try { [EOL] new MutableByte("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMutableByteConstructorWithNullString() { [EOL] try { [EOL] new MutableByte(null); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableByte mbFive = new MutableByte((byte) 5); [EOL] MutableByte mbTen = new MutableByte((byte) 10); [EOL] int result = mbFive.compareTo(mbTen); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_Equal() { [EOL] MutableByte mbFive1 = new MutableByte((byte) 5); [EOL] MutableByte mbFive2 = new MutableByte((byte) 5); [EOL] int result = mbFive1.compareTo(mbFive2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableByte mbTen = new MutableByte((byte) 10); [EOL] MutableByte mbFive = new MutableByte((byte) 5); [EOL] int result = mbTen.compareTo(mbFive); [EOL] assertTrue(result > 0); [EOL] }
public void testWith_NullInput() { [EOL] final CharSequenceTranslator originalTranslator = new CharSequenceTranslatorImpl(); [EOL] try { [EOL] originalTranslator.with(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testWith_EmptyInput() { [EOL] final CharSequenceTranslator originalTranslator = new CharSequenceTranslatorImpl(); [EOL] CharSequenceTranslator result = originalTranslator.with(); [EOL] assertTrue(result instanceof AggregateTranslator); [EOL] assertEquals("AggregateTranslator must contain the original translator", 1, ((AggregateTranslator) result).getTranslators().length); [EOL] } [EOL] public void testWith_SingleTranslator() { [EOL] final CharSequenceTranslator originalTranslator = new CharSequenceTranslatorImpl(); [EOL] final CharSequenceTranslator additionalTranslator = new CharSequenceTranslatorImpl(); [EOL] CharSequenceTranslator result = originalTranslator.with(additionalTranslator); [EOL] assertTrue(result instanceof AggregateTranslator); [EOL] assertEquals("AggregateTranslator must contain two translators", 2, ((AggregateTranslator) result).getTranslators().length); [EOL] } [EOL] public void testWith_MultipleTranslators() { [EOL] final CharSequenceTranslator originalTranslator = new CharSequenceTranslatorImpl(); [EOL] final CharSequenceTranslator translator1 = new CharSequenceTranslatorImpl(); [EOL] final CharSequenceTranslator translator2 = new CharSequenceTranslatorImpl(); [EOL] CharSequenceTranslator result = originalTranslator.with(translator1, translator2); [EOL] assertTrue(result instanceof AggregateTranslator); [EOL] assertEquals("AggregateTranslator must contain three translators", 3, ((AggregateTranslator) result).getTranslators().length); [EOL] }

public void testAppendWithValidParameters() { [EOL] CharSequence seq = "Test sequence"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] CharSequence ellipsis = "..."; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, ellipsis); [EOL] assertNotNull(result); [EOL] assertEquals("Test sequence", result.toString()); [EOL] }
public void testAppendWithNullSequence() { [EOL] CharSequence seq = null; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] CharSequence ellipsis = "..."; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, ellipsis); [EOL] assertNotNull(result); [EOL] assertEquals("", result.toString()); [EOL] }
public void testAppendWithEmptyFormatter() { [EOL] CharSequence seq = "Test sequence"; [EOL] Formatter formatter = new Formatter(new StringBuilder()); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] CharSequence ellipsis = "..."; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, ellipsis); [EOL] assertNotNull(result); [EOL] assertEquals("Test sequence", result.toString()); [EOL] }
public void testGetEnumListWithValidEnumClass() { [EOL] List<DayOfWeek> enumList = EnumUtils.getEnumList(DayOfWeek.class); [EOL] assertNotNull(enumList); [EOL] assertFalse(enumList.isEmpty()); [EOL] assertEquals(7, enumList.size()); [EOL] assertTrue(enumList.contains(DayOfWeek.MONDAY)); [EOL] }
public void testGetEnumListWithNullEnumClass() { [EOL] try { [EOL] List<?> enumList = EnumUtils.getEnumList(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testGenerateBitVectorWithValidEnumAndValues() { [EOL] EnumSet<TestEnum> values = EnumSet.of(TestEnum.CONSTANT1, TestEnum.CONSTANT2); [EOL] long bitVector = EnumUtils.generateBitVector(TestEnum.class, values); [EOL] long expectedBitVector = (1L << TestEnum.CONSTANT1.ordinal()) | (1L << TestEnum.CONSTANT2.ordinal()); [EOL] assertEquals(expectedBitVector, bitVector); [EOL] } [EOL] public void testGenerateBitVectorWithNullEnumClass() { [EOL] try { [EOL] EnumUtils.generateBitVector(null, EnumSet.noneOf(TestEnum.class)); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] } [EOL] public void testGenerateBitVectorWithNullValues() { [EOL] try { [EOL] EnumUtils.generateBitVector(TestEnum.class, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] } [EOL] public void testGenerateBitVectorWithNullElementInValues() { [EOL] try { [EOL] EnumUtils.generateBitVector(TestEnum.class, Arrays.asList(TestEnum.CONSTANT1, null)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGenerateBitVectorWithNonNullValues() { [EOL] long bitVector = EnumUtils.generateBitVector(SomeEnum.class, SomeEnum.CONSTANT1, SomeEnum.CONSTANT2); [EOL] assertTrue((bitVector & (1L << SomeEnum.CONSTANT1.ordinal())) != 0); [EOL] assertTrue((bitVector & (1L << SomeEnum.CONSTANT2.ordinal())) != 0); [EOL] }
public void testGenerateBitVectorWithNullValues() { [EOL] try { [EOL] EnumUtils.generateBitVector(SomeEnum.class, (SomeEnum) null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testGenerateBitVectorWithEmptyValues() { [EOL] long bitVector = EnumUtils.generateBitVector(SomeEnum.class); [EOL] assertEquals(0L, bitVector); [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL] asEnum(enumClass); [EOL] Validate.noNullElements(values); [EOL] final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL] Collections.addAll(condensed, values); [EOL] final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL] for (final E value : condensed) { [EOL] result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL] } [EOL] ArrayUtils.reverse(result); [EOL] return result; [EOL] }
public void testCheckBitVectorableWithValidEnum() { [EOL] Class<AnEnum> enumClass = AnEnum.class; [EOL] Class<AnEnum> result = checkBitVectorable(enumClass); [EOL] assertNotNull(result); [EOL] assertEquals(enumClass, result); [EOL] }
public void testCheckBitVectorableWithInvalidEnum() { [EOL] Class<TooManyEnumConstants> enumClass = TooManyEnumConstants.class; [EOL] try { [EOL] checkBitVectorable(enumClass); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Cannot store 65 values in 64 bits", ex.getMessage()); [EOL] } [EOL] }
public void testAsEnumWithValidEnumClass() { [EOL] Class<TimeUnit> result = asEnum(TimeUnit.class); [EOL] assertNotNull(result); [EOL] assertEquals(TimeUnit.class, result); [EOL] }
public void testAsEnumWithNullClass() { [EOL] try { [EOL] asEnum(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testAsEnumWithNonEnumClass() { [EOL] try { [EOL] asEnum(String.class); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetInstance_CoversDefaultLocaleAndTimeZone() { [EOL] F instance = new F(); [EOL] assertNotNull(instance.getInstance()); [EOL] }
public void testSetDefaultStyleWithNonNull() { [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] ToStringBuilder.setDefaultStyle(style); [EOL] } [EOL] public void testSetDefaultStyleWithNull() { [EOL] try { [EOL] ToStringBuilder.setDefaultStyle(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToStringBuilderWithNullStyle() { [EOL] Object object = new Object(); [EOL] ToStringBuilder tsb = new ToStringBuilder(object, null); [EOL] assertNotNull(tsb); [EOL] }
public void testToStringBuilderWithNonNullStyle() { [EOL] Object object = new Object(); [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] ToStringBuilder tsb = new ToStringBuilder(object, style); [EOL] assertNotNull(tsb); [EOL] }
public void testAppendByteArrayNull() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] byte[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{}"); [EOL] } [EOL] public void testAppendByteArrayEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] byte[] array = new byte[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{}"); [EOL] } [EOL] public void testAppendByteArray() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] byte[] array = new byte[] {1, 2, 3}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{1,2,3}"); [EOL] }

public void testAppendShort() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] short value = 123; [EOL] tsb.append(value); [EOL] assertEquals("Appending short value failed", tsb.toString(), this.toString() + value); [EOL] }
public void testAppendShort() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append("ShortField", (short) 123); [EOL] assertEquals("ShortField=<ShortValue>", tsb.toString()); [EOL] }
public void testAppendShortNullFieldName() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.append(null, (short) 123); [EOL] assertEquals("<NullFieldName>=<ShortValue>", tsb.toString()); [EOL] }
public void testAppendToStringWithNonNull() { [EOL] ToStringBuilder tsb = new ToStringBuilder(new Object(), ToStringStyle.DEFAULT_STYLE); [EOL] String testString = "TestString"; [EOL] tsb.appendToString(testString); [EOL] assertEquals("Appending a non-null string should include it in the builder output", [EOL] testString, tsb.toString()); [EOL] }
public void testAppendToStringWithNull() { [EOL] ToStringBuilder tsb = new ToStringBuilder(new Object(), ToStringStyle.DEFAULT_STYLE); [EOL] tsb.appendToString(null); [EOL] assertEquals("Appending null should not alter the builder output", [EOL] "", tsb.toString()); [EOL] }
public void testBuildReturnsToString() { [EOL] Builder builder = new Builder(); [EOL] String expected = builder.toString(); [EOL] String actual = builder.build(); [EOL] assertEquals(expected, actual); [EOL] }
public void testMutableObjectConstructor() { [EOL] MutableObject<Object> mutableObject = new MutableObject<>(); [EOL] assertNull(mutableObject.getValue()); [EOL] }
public void testMutableObjectWithNull() { [EOL] MutableObject<Object> mutable = new MutableObject<>(null); [EOL] assertNull(mutable.getValue()); [EOL] }
public void testMutableObjectWithNonNull() { [EOL] String testValue = "test"; [EOL] MutableObject<String> mutable = new MutableObject<>(testValue); [EOL] assertEquals(testValue, mutable.getValue()); [EOL] }
public void testGetValue() { [EOL] MyClass<String> myClass = new MyClass<>("testValue"); [EOL] String value = myClass.getValue(); [EOL] assertEquals("testValue", value); [EOL] }
public void testEquals_withNull() { [EOL] MutableObject<?> mutableObject = new MutableObject<>(new Object()); [EOL] assertFalse(mutableObject.equals(null)); [EOL] }
public void testEquals_withSelf() { [EOL] MutableObject<?> mutableObject = new MutableObject<>(new Object()); [EOL] assertTrue(mutableObject.equals(mutableObject)); [EOL] }
public void testEquals_withDifferentClass() { [EOL] MutableObject<?> mutableObject = new MutableObject<>(new Object()); [EOL] Object differentClassObject = new Object(); [EOL] assertFalse(mutableObject.equals(differentClassObject)); [EOL] }
public void testEquals_withEqualMutableObjects() { [EOL] Object value = new Object(); [EOL] MutableObject<?> mutableObject1 = new MutableObject<>(value); [EOL] MutableObject<?> mutableObject2 = new MutableObject<>(value); [EOL] assertTrue(mutableObject1.equals(mutableObject2)); [EOL] }
public void testEquals_withNonEqualMutableObjects() { [EOL] MutableObject<?> mutableObject1 = new MutableObject<>(new Object()); [EOL] MutableObject<?> mutableObject2 = new MutableObject<>(new Object()); [EOL] assertFalse(mutableObject1.equals(mutableObject2)); [EOL] }
public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { [EOL] return parseDate(str, null, parsePatterns); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { [EOL] return parseDateStrictly(str, null, parsePatterns); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] };
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { [EOL] return parseDateWithLeniency(str, null, parsePatterns, false); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL] if (str == null || parsePatterns == null) { [EOL] throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL] } [EOL] SimpleDateFormat parser; [EOL] if (locale == null) { [EOL] parser = new SimpleDateFormat(); [EOL] } else { [EOL] parser = new SimpleDateFormat("", locale); [EOL] } [EOL] parser.setLenient(lenient); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] for (final String parsePattern : parsePatterns) { [EOL] String pattern = parsePattern; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] pattern = pattern.substring(0, pattern.length() - 1); [EOL] } [EOL] parser.applyPattern(pattern); [EOL] pos.setIndex(0); [EOL] String str2 = str; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL] } [EOL] final Date date = parser.parse(str2, pos); [EOL] if (date != null && pos.getIndex() == str2.length()) { [EOL] return date; [EOL] } [EOL] } [EOL] throw new ParseException("Unable to parse the date: " + str, -1); [EOL] }
public void testToCalendarWithNonNullDate() { [EOL] Date date = new Date(); [EOL] Calendar calendar = DateUtils.toCalendar(date); [EOL] assertEquals(date.getTime(), calendar.getTimeInMillis()); [EOL] } [EOL] public void testToCalendarWithNullDate() { [EOL] try { [EOL] DateUtils.toCalendar(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
private static void modify(final Calendar val, final int field, final int modType) { [EOL] if (val.get(Calendar.YEAR) > 280000000) { [EOL] throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL] } [EOL] if (field == Calendar.MILLISECOND) { [EOL] return; [EOL] } [EOL] final Date date = val.getTime(); [EOL] long time = date.getTime(); [EOL] boolean done = false; [EOL] final int millisecs = val.get(Calendar.MILLISECOND); [EOL] if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL] time = time - millisecs; [EOL] } [EOL] if (field == Calendar.SECOND) { [EOL] done = true; [EOL] } [EOL] final int seconds = val.get(Calendar.SECOND); [EOL] if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL] time = time - (seconds * 1000L); [EOL] } [EOL] if (field == Calendar.MINUTE) { [EOL] done = true; [EOL] } [EOL] final int minutes = val.get(Calendar.MINUTE); [EOL] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL] time = time - (minutes * 60000L); [EOL] } [EOL] if (date.getTime() != time) { [EOL] date.setTime(time); [EOL] val.setTime(date); [EOL] } [EOL] boolean roundUp = false; [EOL] for (final int[] aField : fields) { [EOL] for (final int element : aField) { [EOL] if (element == field) { [EOL] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL] if (field == DateUtils.SEMI_MONTH) { [EOL] if (val.get(Calendar.DATE) == 1) { [EOL] val.add(Calendar.DATE, 15); [EOL] } else { [EOL] val.add(Calendar.DATE, -15); [EOL] val.add(Calendar.MONTH, 1); [EOL] } [EOL] } else if (field == Calendar.AM_PM) { [EOL] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL] val.add(Calendar.HOUR_OF_DAY, 12); [EOL] } else { [EOL] val.add(Calendar.HOUR_OF_DAY, -12); [EOL] val.add(Calendar.DATE, 1); [EOL] } [EOL] } else { [EOL] val.add(aField[0], 1); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] int offset = 0; [EOL] boolean offsetSet = false; [EOL] switch(field) { [EOL] case DateUtils.SEMI_MONTH: [EOL] if (aField[0] == Calendar.DATE) { [EOL] offset = val.get(Calendar.DATE) - 1; [EOL] if (offset >= 15) { [EOL] offset -= 15; [EOL] } [EOL] roundUp = offset > 7; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] case Calendar.AM_PM: [EOL] if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL] offset = val.get(Calendar.HOUR_OF_DAY); [EOL] if (offset >= 12) { [EOL] offset -= 12; [EOL] } [EOL] roundUp = offset >= 6; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] } [EOL] if (!offsetSet) { [EOL] final int min = val.getActualMinimum(aField[0]); [EOL] final int max = val.getActualMaximum(aField[0]); [EOL] offset = val.get(aField[0]) - min; [EOL] roundUp = offset > ((max - min) / 2); [EOL] } [EOL] if (offset != 0) { [EOL] val.set(aField[0], val.get(aField[0]) - offset); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL] if (focus == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] Calendar start = null; [EOL] Calendar end = null; [EOL] int startCutoff = Calendar.SUNDAY; [EOL] int endCutoff = Calendar.SATURDAY; [EOL] switch(rangeStyle) { [EOL] case RANGE_MONTH_SUNDAY: [EOL] case RANGE_MONTH_MONDAY: [EOL] start = truncate(focus, Calendar.MONTH); [EOL] end = (Calendar) start.clone(); [EOL] end.add(Calendar.MONTH, 1); [EOL] end.add(Calendar.DATE, -1); [EOL] if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] } [EOL] break; [EOL] case RANGE_WEEK_SUNDAY: [EOL] case RANGE_WEEK_MONDAY: [EOL] case RANGE_WEEK_RELATIVE: [EOL] case RANGE_WEEK_CENTER: [EOL] start = truncate(focus, Calendar.DATE); [EOL] end = truncate(focus, Calendar.DATE); [EOL] switch(rangeStyle) { [EOL] case RANGE_WEEK_SUNDAY: [EOL] break; [EOL] case RANGE_WEEK_MONDAY: [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] break; [EOL] case RANGE_WEEK_RELATIVE: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL] endCutoff = startCutoff - 1; [EOL] break; [EOL] case RANGE_WEEK_CENTER: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL] endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL] break; [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL] } [EOL] if (startCutoff < Calendar.SUNDAY) { [EOL] startCutoff += 7; [EOL] } [EOL] if (startCutoff > Calendar.SATURDAY) { [EOL] startCutoff -= 7; [EOL] } [EOL] if (endCutoff < Calendar.SUNDAY) { [EOL] endCutoff += 7; [EOL] } [EOL] if (endCutoff > Calendar.SATURDAY) { [EOL] endCutoff -= 7; [EOL] } [EOL] while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL] start.add(Calendar.DATE, -1); [EOL] } [EOL] while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL] end.add(Calendar.DATE, 1); [EOL] } [EOL] return new DateIterator(start, end); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }};
public void testIteratorWithNullFocus() { [EOL] try { [EOL] DateUtils.iterator(null, DateUtils.RANGE_MONTH_SUNDAY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIteratorWithDateFocus() { [EOL] Date focus = new Date(); [EOL] Iterator<?> it = DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] assertNotNull("Iterator should not be null", it); [EOL] } [EOL] public void testIteratorWithCalendarFocus() { [EOL] Calendar focus = Calendar.getInstance(); [EOL] Iterator<?> it = DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] assertNotNull("Iterator should not be null", it); [EOL] } [EOL] public void testIteratorWithUnsupportedFocusType() { [EOL] try { [EOL] Object focus = new Object(); [EOL] DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException cce) { [EOL] } [EOL] }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL] return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL] if (calendar == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final long millisPerUnit = getMillisPerUnit(unit); [EOL] long result = 0; [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] case Calendar.MONTH: [EOL] result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] } [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] case Calendar.MONTH: [EOL] case Calendar.DAY_OF_YEAR: [EOL] case Calendar.DATE: [EOL] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL] case Calendar.HOUR_OF_DAY: [EOL] result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL] case Calendar.MINUTE: [EOL] result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL] case Calendar.SECOND: [EOL] result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL] break; [EOL] case Calendar.MILLISECOND: [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL] } [EOL] return result; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public Calendar next() { [EOL] if (spot.equals(endFinal)) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] spot.add(Calendar.DATE, 1); [EOL] return (Calendar) spot.clone(); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public void testRemoveUnsupportedOperationException() { [EOL] DateIterator dateIterator = new DateIterator(null, null); [EOL] try { [EOL] dateIterator.remove(); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testWordUtilsConstructor() { [EOL] new WordUtils(); [EOL] }
public void testWrapNullStr() { [EOL] String result = StringUtils.wrap(null, 10); [EOL] assertNull(result); [EOL] }
public void testWrapEmptyStr() { [EOL] String result = StringUtils.wrap("", 10); [EOL] assertEquals("", result); [EOL] }
public void testWrapNegativeWrapLength() { [EOL] String result = StringUtils.wrap("test", -1); [EOL] assertEquals("test", result); [EOL] }
public void testWrapValidWrapLength() { [EOL] String result = StringUtils.wrap("wrap this string", 5); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("\n")); [EOL] }
public void testWrapNullStr() { [EOL] String wrapped = StringUtils.wrap(null, 10, "\n", true); [EOL] assertNull(wrapped); [EOL] }
public void testWrapNullNewLineStr() { [EOL] String wrapped = StringUtils.wrap("test", 10, null, true); [EOL] assertNotNull(wrapped); [EOL] assertTrue(wrapped.contains(SystemUtils.LINE_SEPARATOR)); [EOL] }
public void testWrapNegativeWrapLength() { [EOL] String wrapped = StringUtils.wrap("test", -1, "\n", true); [EOL] assertEquals("test", wrapped); [EOL] }
public void testWrapNormal() { [EOL] String wrapped = StringUtils.wrap("test test", 5, "\n", false); [EOL] assertEquals("test\n test", wrapped); [EOL] }
public void testWrapLongWord() { [EOL] String wrapped = StringUtils.wrap("testtest", 4, "\n", true); [EOL] assertEquals("test\ntest", wrapped); [EOL] }
public void testWrapLongWordWithoutWrap() { [EOL] String wrapped = StringUtils.wrap("testtest", 4, "\n", false); [EOL] assertEquals("testtest", wrapped); [EOL] }
public void testWrapWithSpaceAtWrapLength() { [EOL] String wrapped = StringUtils.wrap("test test", 4, "\n", false); [EOL] assertEquals("test\ntest", wrapped); [EOL] }
public void testWrapWithSpaceBeforeWrapLength() { [EOL] String wrapped = StringUtils.wrap("te st", 4, "\n", false); [EOL] assertEquals("te\nst", wrapped); [EOL] }
public void testWrapWithSpaceAfterWrapLength() { [EOL] String wrapped = StringUtils.wrap("t est", 1, "\n", false); [EOL] assertEquals("t\nest", wrapped); [EOL] }
public void testWrapWithNoSpaces() { [EOL] String wrapped = StringUtils.wrap("test", 2, "\n", false); [EOL] assertEquals("test", wrapped); [EOL] }
public void testAggregateTranslatorWithNull() { [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator((CharSequenceTranslator) null); [EOL] assertNull(aggregateTranslator.translators); [EOL] }
public void testAggregateTranslatorWithEmpty() { [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator(); [EOL] assertNotNull(aggregateTranslator.translators); [EOL] assertEquals(0, aggregateTranslator.translators.length); [EOL] }
public void testAggregateTranslatorWithSingleTranslator() { [EOL] CharSequenceTranslator mockTranslator = mock(CharSequenceTranslator.class); [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator(mockTranslator); [EOL] assertNotNull(aggregateTranslator.translators); [EOL] assertEquals(1, aggregateTranslator.translators.length); [EOL] assertSame(mockTranslator, aggregateTranslator.translators[0]); [EOL] }
public void testAggregateTranslatorWithMultipleTranslators() { [EOL] CharSequenceTranslator mockTranslator1 = mock(CharSequenceTranslator.class); [EOL] CharSequenceTranslator mockTranslator2 = mock(CharSequenceTranslator.class); [EOL] AggregateTranslator aggregateTranslator = new AggregateTranslator(mockTranslator1, mockTranslator2); [EOL] assertNotNull(aggregateTranslator.translators); [EOL] assertEquals(2, aggregateTranslator.translators.length); [EOL] assertSame(mockTranslator1, aggregateTranslator.translators[0]); [EOL] assertSame(mockTranslator2, aggregateTranslator.translators[1]); [EOL] }
public void testAddInitializerWithNullName() { [EOL] final MultiBackgroundInitializer multiInitializer = new MultiBackgroundInitializer(); [EOL] try { [EOL] multiInitializer.addInitializer(null, new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return new Object(); [EOL] } [EOL] }); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Name of child initializer must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerWithNullInitializer() { [EOL] final MultiBackgroundInitializer multiInitializer = new MultiBackgroundInitializer(); [EOL] try { [EOL] multiInitializer.addInitializer("test", null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Child initializer must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerAfterStart() throws Exception { [EOL] final MultiBackgroundInitializer multiInitializer = new MultiBackgroundInitializer(); [EOL] multiInitializer.start(); [EOL] try { [EOL] multiInitializer.addInitializer("test", new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return new Object(); [EOL] } [EOL] }); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException ex) { [EOL] assertEquals("addInitializer() must not be called after start()!", ex.getMessage()); [EOL] } [EOL] }
public void testAddInitializerSuccess() { [EOL] final MultiBackgroundInitializer multiInitializer = new MultiBackgroundInitializer(); [EOL] final BackgroundInitializer<Object> init = new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] multiInitializer.addInitializer("test", init); [EOL] }
public void testAvailableLocaleList() { [EOL] List<Locale> locales = LocaleUtils.availableLocaleList(); [EOL] assertNotNull("Available locale list should not be null", locales); [EOL] assertFalse("Available locale list should not be empty", locales.isEmpty()); [EOL] }
public void testCountriesByLanguageWithNullLanguageCode() { [EOL] List<Locale> result = LocaleUtils.countriesByLanguage(null); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCountriesByLanguageWithNonExistentLanguageCode() { [EOL] List<Locale> result = LocaleUtils.countriesByLanguage("xx"); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCountriesByLanguageWithExistentLanguageCode() { [EOL] List<Locale> result = LocaleUtils.countriesByLanguage("en"); [EOL] assertFalse(result.isEmpty()); [EOL] for (Locale locale : result) { [EOL] assertEquals("en", locale.getLanguage()); [EOL] assertFalse(locale.getCountry().isEmpty()); [EOL] assertTrue(locale.getVariant().isEmpty()); [EOL] } [EOL] }
public void testIsEquals_BothNull() { [EOL] boolean result = isEquals(null, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEquals_FirstNullSecondNotNull() { [EOL] boolean result = isEquals(null, new Object()); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsEquals_FirstNotNullSecondNull() { [EOL] boolean result = isEquals(new Object(), null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsEquals_BothNotNullEqual() { [EOL] Object obj = new Object(); [EOL] boolean result = isEquals(obj, obj); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEquals_BothNotNullNotEqual() { [EOL] boolean result = isEquals(new Object(), new Object()); [EOL] assertFalse(result); [EOL] }
public void testClone_NullArray() { [EOL] char[] array = null; [EOL] char[] clonedArray = StringUtils.clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] char[] clonedArray = StringUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char[] clonedArray = StringUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] int[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] int[] emptyArray = new int[0]; [EOL] int[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] int[] nonEmptyArray = new int[]{1, 2, 3}; [EOL] int[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] double[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyInput() { [EOL] double[] input = new double[0]; [EOL] double[] result = ArrayUtils.nullToEmpty(input); [EOL] assertSame(input, result); [EOL] }
public void testNullToEmptyWithNonEmptyInput() { [EOL] double[] input = new double[] {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.nullToEmpty(input); [EOL] assertSame(input, result); [EOL] }
public void testSubarray_NullArray() { [EOL] Integer[] array = null; [EOL] Integer[] result = ArrayUtils.subarray(array, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_EmptyArray() { [EOL] Integer[] array = new Integer[0]; [EOL] Integer[] result = ArrayUtils.subarray(array, 0, 1); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testSubarray_StartIndexNegative() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.subarray(array, -1, 2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(Integer.valueOf(1), result[0]); [EOL] assertEquals(Integer.valueOf(2), result[1]); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.subarray(array, 1, 5); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(Integer.valueOf(2), result[0]); [EOL] assertEquals(Integer.valueOf(3), result[1]); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = ArrayUtils.subarray(array, 1, 3); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(Integer.valueOf(2), result[0]); [EOL] assertEquals(Integer.valueOf(3), result[1]); [EOL] } [EOL] public void testSubarray_StartIndexEqualsEndIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.subarray(array, 2, 2); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testSubarray_EndIndexLessThanStartIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.subarray(array, 2, 1); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSubarray_NullArray() { [EOL] char[] result = StringUtils.subarray(null, 0, 3); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_NegativeStartIndex() { [EOL] char[] array = {'a', 'b', 'c', 'd', 'e'}; [EOL] char[] result = StringUtils.subarray(array, -1, 3); [EOL] assertArrayEquals(new char[] {'a', 'b', 'c'}, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] char[] array = {'a', 'b', 'c', 'd', 'e'}; [EOL] char[] result = StringUtils.subarray(array, 1, 10); [EOL] assertArrayEquals(new char[] {'b', 'c', 'd', 'e'}, result); [EOL] } [EOL] public void testSubarray_ZeroNewSize() { [EOL] char[] array = {'a', 'b', 'c', 'd', 'e'}; [EOL] char[] result = StringUtils.subarray(array, 3, 3); [EOL] assertArrayEquals(new char[] {}, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] char[] array = {'a', 'b', 'c', 'd', 'e'}; [EOL] char[] result = StringUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new char[] {'b', 'c', 'd'}, result); [EOL] }
public void testSubarray_NullInput() { [EOL] boolean[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_StartIndexNegative() { [EOL] boolean[] array = new boolean[] {true, false, true}; [EOL] boolean[] result = ArrayUtils.subarray(array, -1, 2); [EOL] boolean[] expected = new boolean[] {true, false}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] boolean[] array = new boolean[] {true, false, true}; [EOL] boolean[] result = ArrayUtils.subarray(array, 1, 5); [EOL] boolean[] expected = new boolean[] {false, true}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] boolean[] array = new boolean[] {true, false, true, false}; [EOL] boolean[] result = ArrayUtils.subarray(array, 1, 3); [EOL] boolean[] expected = new boolean[] {false, true}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testSubarray_EmptyResultByIndices() { [EOL] boolean[] array = new boolean[] {true, false, true}; [EOL] boolean[] result = ArrayUtils.subarray(array, 2, 2); [EOL] boolean[] expected = new boolean[0]; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testSubarray_EmptyResultByNonPositiveSize() { [EOL] boolean[] array = new boolean[] {true, false, true}; [EOL] boolean[] result = ArrayUtils.subarray(array, 3, 2); [EOL] boolean[] expected = new boolean[0]; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] long[] array1 = null; [EOL] long[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] long[] array1 = null; [EOL] long[] array2 = new long[] {1, 2, 3}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_FirstArrayNotEmptySecondArrayNull() { [EOL] long[] array1 = new long[] {1, 2, 3}; [EOL] long[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysDifferentLengths() { [EOL] long[] array1 = new long[] {1, 2, 3}; [EOL] long[] array2 = new long[] {1, 2}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] long[] array1 = new long[] {1, 2, 3}; [EOL] long[] array2 = new long[] {4, 5, 6}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] boolean[] array1 = null; [EOL] boolean[] array2 = null; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_FirstArrayNullSecondNotEmpty() { [EOL] boolean[] array1 = null; [EOL] boolean[] array2 = new boolean[] {true, false}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_SecondArrayNullFirstNotEmpty() { [EOL] boolean[] array1 = new boolean[] {true, false}; [EOL] boolean[] array2 = null; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysDifferentLengths() { [EOL] boolean[] array1 = new boolean[] {true}; [EOL] boolean[] array2 = new boolean[] {false, true}; [EOL] assertFalse(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] boolean[] array1 = new boolean[] {true, false}; [EOL] boolean[] array2 = new boolean[] {false, true}; [EOL] assertTrue(ArrayUtils.isSameLength(array1, array2)); [EOL] }
public void testGetLength_NullArray() { [EOL] int length = ArrayUtils.getLength(null); [EOL] assertEquals(0, length); [EOL] }
public void testGetLength_EmptyArray() { [EOL] int[] emptyArray = new int[0]; [EOL] int length = ArrayUtils.getLength(emptyArray); [EOL] assertEquals(0, length); [EOL] }
public void testGetLength_NonEmptyArray() { [EOL] int[] nonEmptyArray = new int[]{1, 2, 3}; [EOL] int length = ArrayUtils.getLength(nonEmptyArray); [EOL] assertEquals(3, length); [EOL] }
public void testGetLength_NonArray() { [EOL] try { [EOL] ArrayUtils.getLength(123); [EOL] fail("Should throw IllegalArgumentException for non-array input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsSameType_BothArraysNull_ThrowsException() { [EOL] try { [EOL] ArrayUtils.isSameType(null, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsSameType_FirstArrayNull_ThrowsException() { [EOL] try { [EOL] ArrayUtils.isSameType(null, new int[] {}); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsSameType_SecondArrayNull_ThrowsException() { [EOL] try { [EOL] ArrayUtils.isSameType(new int[] {}, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsSameType_DifferentTypes_ReturnsFalse() { [EOL] boolean result = ArrayUtils.isSameType(new int[] {}, new String[] {}); [EOL] assertFalse(result); [EOL] }
public void testIsSameType_SameTypes_ReturnsTrue() { [EOL] boolean result = ArrayUtils.isSameType(new int[] {}, new int[] {}); [EOL] assertTrue(result); [EOL] }
public void testReverse_NullArray() { [EOL] Object[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array); [EOL] }
public void testReverse_EmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length); [EOL] }
public void testReverse_NonEmptyArray() { [EOL] Object[] array = {1, 2, 3, 4, 5}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new Object[]{5, 4, 3, 2, 1}, array); [EOL] }
public void testReverse_NullArray() { [EOL] short[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "The array should remain null after reverse operation."); [EOL] }
public void testReverse_EmptyArray() { [EOL] short[] array = new short[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "The array should remain empty after reverse operation."); [EOL] }
public void testReverse_SingleElementArray() { [EOL] short[] array = {1}; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(1, array.length, "The array should contain one element after reverse operation."); [EOL] assertEquals(1, array[0], "The element should remain unchanged after reverse operation."); [EOL] }
public void testReverse_MultipleElementsArray() { [EOL] short[] array = {1, 2, 3, 4}; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(4, array.length, "The array should contain the same number of elements after reverse operation."); [EOL] assertArrayEquals(new short[]{4, 3, 2, 1}, array, "The array should be reversed after reverse operation."); [EOL] }
public void testReverse_NullArray() { [EOL] char[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "Reversing a null array should not change it."); [EOL] }
public void testReverse_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "Reversing an empty array should not change its length."); [EOL] }
public void testReverse_SingleElementArray() { [EOL] char[] array = {'a'}; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals('a', array[0], "Reversing a single-element array should not change its content."); [EOL] }
public void testReverse_MultipleElementsArray() { [EOL] char[] array = {'a', 'b', 'c', 'd'}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new char[]{'d', 'c', 'b', 'a'}, array, "Reversing a multiple-element array should reverse its content."); [EOL] }
public void testReverse_NullArray() { [EOL] byte[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "The array should remain null after reverse operation"); [EOL] }
public void testReverse_EmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "The array should remain empty after reverse operation"); [EOL] }
public void testReverse_NonEmptyArray() { [EOL] byte[] array = {1, 2, 3, 4}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new byte[]{4, 3, 2, 1}, array, "The array should be reversed"); [EOL] }
public void testReverse_NullArray() { [EOL] double[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "The array should remain null."); [EOL] }
public void testReverse_EmptyArray() { [EOL] double[] array = {}; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "The array should be empty."); [EOL] }
public void testReverse_SingleElementArray() { [EOL] double[] array = {1.0}; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(1.0, array[0], "The array with one element should remain unchanged."); [EOL] }
public void testReverse_MultipleElementsArray() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new double[]{3.0, 2.0, 1.0}, array, "The array should be reversed."); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] final long[] array = null; [EOL] final long valueToFind = 1L; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartIndexLessThanZero() { [EOL] final long[] array = new long[] {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartIndexGreaterThanOrEqualToArrayLength() { [EOL] final long[] array = new long[] {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] int startIndex = 5; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_ValueNotFound() { [EOL] final long[] array = new long[] {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 6L; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_ValueFound() { [EOL] final long[] array = new long[] {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testContains_withEmptyArray() { [EOL] long[] array = {}; [EOL] long valueToFind = 1L; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withNullArray() { [EOL] long[] array = null; [EOL] long valueToFind = 1L; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withArrayContainingValue() { [EOL] long[] array = {1L, 2L, 3L}; [EOL] long valueToFind = 2L; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_withArrayNotContainingValue() { [EOL] long[] array = {1L, 2L, 3L}; [EOL] long valueToFind = 4L; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withValuePresent() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_withValueAbsent() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 6; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withEmptyArray() { [EOL] int[] array = {}; [EOL] int valueToFind = 1; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_withNullArray() { [EOL] int[] array = null; [EOL] int valueToFind = 1; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] double tolerance = 0.01; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withNoMatch() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] double valueToFind = 5.5; [EOL] double tolerance = 0.01; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withExactMatch() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] double valueToFind = 3.3; [EOL] double tolerance = 0.01; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(2, index); [EOL] }
public void testLastIndexOf_withToleranceMatch() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] double valueToFind = 3.35; [EOL] double tolerance = 0.05; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(2, index); [EOL] }
public void testLastIndexOf_withNegativeTolerance() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] double valueToFind = 3.3; [EOL] double tolerance = -0.01; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withLargeTolerance() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] double valueToFind = 1.1; [EOL] double tolerance = 10.0; [EOL] int index = ArrayUtils.lastIndexOf(array, valueToFind, tolerance); [EOL] assertEquals(0, index); [EOL] }
public void testLastIndexOf_emptyArray() { [EOL] double[] array = {}; [EOL] int index = ArrayUtils.lastIndexOf(array, 1.0, 0, 0.1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_startIndexNegative() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.0, -1, 0.1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_startIndexGreaterThanLength() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 3.0, 4, 0.1); [EOL] assertEquals(2, index); [EOL] }
public void testLastIndexOf_valueWithinTolerance() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.05, 2, 0.1); [EOL] assertEquals(1, index); [EOL] }
public void testLastIndexOf_valueNotWithinTolerance() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.2, 2, 0.1); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_valueAtStartIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.0, 3, 0.1); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_valueBeforeStartIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.0, 2, 0.1); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_withEmptyArray() { [EOL] float[] array = {}; [EOL] float valueToFind = 1.0f; [EOL] int index = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_withNullArray() { [EOL] float[] array = null; [EOL] float valueToFind = 1.0f; [EOL] int index = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_withValuePresent() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 2.0f; [EOL] int index = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_withValueNotPresent() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float valueToFind = 4.0f; [EOL] int index = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_emptyArray() { [EOL] float[] array = {}; [EOL] int index = ArrayUtils.indexOf(array, 1.0f, 0); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_startIndexNegative() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] int index = ArrayUtils.indexOf(array, 1.0f, -1); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOf_valueNotFound() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] int index = ArrayUtils.indexOf(array, 4.0f, 0); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_valueFound() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] int index = ArrayUtils.indexOf(array, 2.0f, 0); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_valueFoundAfterStartIndex() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 2.0f}; [EOL] int index = ArrayUtils.indexOf(array, 2.0f, 2); [EOL] assertEquals(3, index); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Long[] array = null; [EOL] long[] result = ArrayUtils.toPrimitive(array); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyInput() { [EOL] Long[] array = new Long[0]; [EOL] long[] result = ArrayUtils.toPrimitive(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, result); [EOL] }
public void testToPrimitiveWithValidInput() { [EOL] Long[] array = new Long[] {1L, 2L, 3L}; [EOL] long[] result = ArrayUtils.toPrimitive(array); [EOL] long[] expected = new long[] {1L, 2L, 3L}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] long[] result = ArrayUtils.toPrimitive(null, 0L); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Long[] emptyArray = new Long[0]; [EOL] long[] result = ArrayUtils.toPrimitive(emptyArray, 0L); [EOL] assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNullValues() { [EOL] Long[] arrayWithNulls = new Long[] {null, null, null}; [EOL] long valueForNull = 42L; [EOL] long[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] long[] expected = new long[] {valueForNull, valueForNull, valueForNull}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNonNullValues() { [EOL] Long[] array = new Long[] {1L, 2L, 3L}; [EOL] long valueForNull = 42L; // This value is not used since there are no nulls in the array [EOL] long[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] long[] expected = new long[] {1L, 2L, 3L}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedValues() { [EOL] Long[] mixedArray = new Long[] {1L, null, 3L}; [EOL] long valueForNull = 42L; [EOL] long[] result = ArrayUtils.toPrimitive(mixedArray, valueForNull); [EOL] long[] expected = new long[] {1L, valueForNull, 3L}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] int[] result = ArrayUtils.toPrimitive(null, 0); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Integer[] emptyArray = new Integer[0]; [EOL] int[] result = ArrayUtils.toPrimitive(emptyArray, 0); [EOL] assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNullValues() { [EOL] Integer[] arrayWithNulls = new Integer[] {null, null, null}; [EOL] int valueForNull = 1; [EOL] int[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] int[] expected = new int[] {valueForNull, valueForNull, valueForNull}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNonNullValues() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] int valueForNull = 0; [EOL] int[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] int[] expected = new int[] {1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedValues() { [EOL] Integer[] array = new Integer[] {1, null, 3}; [EOL] int valueForNull = 2; [EOL] int[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] int[] expected = new int[] {1, valueForNull, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] byte[] result = ArrayUtils.toPrimitive(null, (byte) 0); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Byte[] array = new Byte[0]; [EOL] byte[] result = ArrayUtils.toPrimitive(array, (byte) 0); [EOL] assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNullValues() { [EOL] Byte[] array = new Byte[] { null, null, null }; [EOL] byte valueForNull = (byte) 1; [EOL] byte[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] byte[] expected = new byte[] { valueForNull, valueForNull, valueForNull }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNonNullArrayAndNonNullValues() { [EOL] Byte[] array = new Byte[] { 2, 3, 4 }; [EOL] byte valueForNull = (byte) 1; [EOL] byte[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] byte[] expected = new byte[] { 2, 3, 4 }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedValuesArray() { [EOL] Byte[] array = new Byte[] { 2, null, 4 }; [EOL] byte valueForNull = (byte) 1; [EOL] byte[] result = ArrayUtils.toPrimitive(array, valueForNull); [EOL] byte[] expected = new byte[] { 2, valueForNull, 4 }; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObject_NullArray() { [EOL] Boolean[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObject_EmptyArray() { [EOL] Boolean[] result = ArrayUtils.toObject(new boolean[]{}); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObject_NonEmptyArray() { [EOL] boolean[] array = {true, false, true}; [EOL] Boolean[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] assertEquals(Boolean.TRUE, result[0]); [EOL] assertEquals(Boolean.FALSE, result[1]); [EOL] assertEquals(Boolean.TRUE, result[2]); [EOL] }
public void testAddAllWithBothArraysNull() { [EOL] Integer[] result = ArrayUtils.addAll(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllWithFirstArrayNull() { [EOL] Integer[] array2 = new Integer[] {1, 2}; [EOL] Integer[] result = ArrayUtils.addAll(null, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array2, result); [EOL] } [EOL] public void testAddAllWithSecondArrayNull() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] Integer[] result = ArrayUtils.addAll(array1, null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array1, result); [EOL] } [EOL] public void testAddAllWithNoArrayNull() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] Integer[] array2 = new Integer[] {3, 4}; [EOL] Integer[] result = ArrayUtils.addAll(array1, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new Integer[] {1, 2, 3, 4}, result); [EOL] } [EOL] public void testAddAllWithTypeMismatch() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] String[] array2 = new String[] {"a", "b"}; [EOL] try { [EOL] ArrayUtils.addAll(array1, array2); [EOL] fail("Expected an ArrayStoreException to be thrown"); [EOL] } catch (ArrayStoreException ase) { [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testAddAllBothArraysNull() { [EOL] boolean[] result = ArrayUtils.addAll(null, (boolean[]) null); [EOL] assertNull(result); [EOL] }
public void testAddAllFirstArrayNull() { [EOL] boolean[] array2 = {true, false}; [EOL] boolean[] result = ArrayUtils.addAll(null, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array2, result); [EOL] }
public void testAddAllSecondArrayNull() { [EOL] boolean[] array1 = {true, false}; [EOL] boolean[] result = ArrayUtils.addAll(array1, (boolean[]) null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array1, result); [EOL] }
public void testAddAllNonEmptyArrays() { [EOL] boolean[] array1 = {true, false}; [EOL] boolean[] array2 = {false, true}; [EOL] boolean[] result = ArrayUtils.addAll(array1, array2); [EOL] assertNotNull(result); [EOL] boolean[] expected = {true, false, false, true}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddAllBothArraysNull() { [EOL] char[] result = addAll(null, null); [EOL] assertNull(result); [EOL] }
public void testAddAllFirstArrayNull() { [EOL] char[] array2 = {'a', 'b', 'c'}; [EOL] char[] result = addAll(null, array2); [EOL] assertArrayEquals(array2, result); [EOL] }
public void testAddAllSecondArrayNull() { [EOL] char[] array1 = {'a', 'b', 'c'}; [EOL] char[] result = addAll(array1, null); [EOL] assertArrayEquals(array1, result); [EOL] }
public void testAddAllNoArraysNull() { [EOL] char[] array1 = {'a', 'b', 'c'}; [EOL] char[] array2 = {'d', 'e', 'f'}; [EOL] char[] expected = {'a', 'b', 'c', 'd', 'e', 'f'}; [EOL] char[] result = addAll(array1, array2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddAllBothArraysNull() { [EOL] byte[] result = addAll(null, (byte[]) null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllFirstArrayNull() { [EOL] byte[] array2 = {1, 2}; [EOL] byte[] result = addAll(null, array2); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(2, result[1]); [EOL] } [EOL] public void testAddAllSecondArrayNull() { [EOL] byte[] array1 = {1, 2}; [EOL] byte[] result = addAll(array1, (byte[]) null); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(2, result[1]); [EOL] } [EOL] public void testAddAllBothArraysNonNull() { [EOL] byte[] array1 = {1, 2}; [EOL] byte[] array2 = {3, 4}; [EOL] byte[] result = addAll(array1, array2); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(2, result[1]); [EOL] assertEquals(3, result[2]); [EOL] assertEquals(4, result[3]); [EOL] }
public void testAddAllBothArraysNull() { [EOL] short[] result = addAll(null, (short[]) null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllFirstArrayNull() { [EOL] short[] array2 = {1, 2}; [EOL] short[] result = addAll(null, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array2, result); [EOL] } [EOL] public void testAddAllSecondArrayNull() { [EOL] short[] array1 = {1, 2}; [EOL] short[] result = addAll(array1, (short[]) null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array1, result); [EOL] } [EOL] public void testAddAllBothArraysNonNull() { [EOL] short[] array1 = {1, 2}; [EOL] short[] array2 = {3, 4}; [EOL] short[] result = addAll(array1, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new short[]{1, 2, 3, 4}, result); [EOL] }
public void testAddAllBothArraysNull() { [EOL] int[] result = ArrayUtils.addAll(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllFirstArrayNull() { [EOL] int[] array2 = {1, 2, 3}; [EOL] int[] result = ArrayUtils.addAll(null, array2); [EOL] assertArrayEquals(array2, result); [EOL] } [EOL] public void testAddAllSecondArrayNull() { [EOL] int[] array1 = {1, 2, 3}; [EOL] int[] result = ArrayUtils.addAll(array1, (int[]) null); [EOL] assertArrayEquals(array1, result); [EOL] } [EOL] public void testAddAllBothArraysNonNull() { [EOL] int[] array1 = {1, 2, 3}; [EOL] int[] array2 = {4, 5, 6}; [EOL] int[] expected = {1, 2, 3, 4, 5, 6}; [EOL] int[] result = ArrayUtils.addAll(array1, array2); [EOL] assertArrayEquals(expected, result); [EOL] }

public void testAddAllBothArraysNull() { [EOL] long[] result = ArrayUtils.addAll(null, (long[]) null); [EOL] assertNull(result); [EOL] }
public void testAddAllFirstArrayNull() { [EOL] long[] array2 = {1, 2, 3}; [EOL] long[] result = ArrayUtils.addAll(null, array2); [EOL] assertArrayEquals(array2, result); [EOL] }
public void testAddAllSecondArrayNull() { [EOL] long[] array1 = {1, 2, 3}; [EOL] long[] result = ArrayUtils.addAll(array1, (long[]) null); [EOL] assertArrayEquals(array1, result); [EOL] }
public void testAddAllNoArrayNull() { [EOL] long[] array1 = {1, 2, 3}; [EOL] long[] array2 = {4, 5, 6}; [EOL] long[] expected = {1, 2, 3, 4, 5, 6}; [EOL] long[] result = ArrayUtils.addAll(array1, array2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddAllBothArraysNull() { [EOL] float[] result = ArrayUtils.addAll(null, (float[]) null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllFirstArrayNull() { [EOL] float[] array2 = new float[] {1.0f, 2.0f}; [EOL] float[] result = ArrayUtils.addAll(null, array2); [EOL] assertArrayEquals(array2, result); [EOL] } [EOL] public void testAddAllSecondArrayNull() { [EOL] float[] array1 = new float[] {1.0f, 2.0f}; [EOL] float[] result = ArrayUtils.addAll(array1, (float[]) null); [EOL] assertArrayEquals(array1, result); [EOL] } [EOL] public void testAddAllNonEmptyArrays() { [EOL] float[] array1 = new float[] {1.0f, 2.0f}; [EOL] float[] array2 = new float[] {3.0f, 4.0f}; [EOL] float[] result = ArrayUtils.addAll(array1, array2); [EOL] float[] expected = new float[] {1.0f, 2.0f, 3.0f, 4.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddAllBothArraysNull() { [EOL] double[] result = ArrayUtils.addAll(null, (double[]) null); [EOL] assertNull(result); [EOL] }
public void testAddAllFirstArrayNull() { [EOL] double[] array2 = {1.0, 2.0}; [EOL] double[] result = ArrayUtils.addAll(null, array2); [EOL] assertArrayEquals(array2, result); [EOL] }
public void testAddAllSecondArrayNull() { [EOL] double[] array1 = {1.0, 2.0}; [EOL] double[] result = ArrayUtils.addAll(array1, (double[]) null); [EOL] assertArrayEquals(array1, result); [EOL] }
public void testAddAllNonEmptyArrays() { [EOL] double[] array1 = {1.0, 2.0}; [EOL] double[] array2 = {3.0, 4.0}; [EOL] double[] expected = {1.0, 2.0, 3.0, 4.0}; [EOL] double[] result = ArrayUtils.addAll(array1, array2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAddNullByteArray() { [EOL] final byte element = 1; [EOL] byte[] result = ArrayUtils.add(null, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[0]); [EOL] }
public void testAddByteArray() { [EOL] final byte[] array = {1, 2, 3}; [EOL] final byte element = 4; [EOL] byte[] result = ArrayUtils.add(array, element); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(element, result[3]); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(array[i], result[i]); [EOL] } [EOL] }
public void testRemove_NullArray() { [EOL] char[] result = StringUtils.remove(null, 1); [EOL] assertNull(result); [EOL] }
public void testRemove_EmptyArray() { [EOL] char[] emptyArray = new char[0]; [EOL] char[] result = StringUtils.remove(emptyArray, 1); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testRemove_ArrayWithOneElement() { [EOL] char[] singleElementArray = new char[]{'a'}; [EOL] char[] result = StringUtils.remove(singleElementArray, 0); [EOL] assertArrayEquals(new char[0], result); [EOL] }
public void testRemove_PositiveIndex() { [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] char[] result = StringUtils.remove(array, 1); [EOL] assertArrayEquals(new char[]{'a', 'c'}, result); [EOL] }
public void testRemove_NegativeIndex() { [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] char[] result = StringUtils.remove(array, -1); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] char[] result = StringUtils.remove(array, array.length); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemove_DoubleArrayAtIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] double[] result = ArrayUtils.remove(array, 2); [EOL] double[] expected = {1.0, 2.0, 4.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_DoubleArrayAtFirstIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] double[] result = ArrayUtils.remove(array, 0); [EOL] double[] expected = {2.0, 3.0, 4.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_DoubleArrayAtLastIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] double[] result = ArrayUtils.remove(array, 3); [EOL] double[] expected = {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_DoubleArrayWithSingleElement() { [EOL] double[] array = {1.0}; [EOL] double[] result = ArrayUtils.remove(array, 0); [EOL] double[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_DoubleArrayWithInvalidIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] try { [EOL] ArrayUtils.remove(array, 4); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveShortArrayAtIndex() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.remove(array, 2); [EOL] short[] expected = {1, 2, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveShortArrayAtStart() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.remove(array, 0); [EOL] short[] expected = {2, 3, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveShortArrayAtEnd() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.remove(array, 4); [EOL] short[] expected = {1, 2, 3, 4}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveShortArrayWithInvalidIndex() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] try { [EOL] ArrayUtils.remove(array, 5); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveShortArrayWithNegativeIndex() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] try { [EOL] ArrayUtils.remove(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveShortArrayWithNullInput() { [EOL] try { [EOL] ArrayUtils.remove((short[]) null, 0); [EOL] fail("Should throw a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemoveElement_ArrayWithElement() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short elementToRemove = 3; [EOL] short[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] short[] expected = {1, 2, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_ArrayWithoutElement() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short elementToRemove = 6; [EOL] short[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] short[] expected = {1, 2, 3, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_NullArray() { [EOL] short[] result = ArrayUtils.removeElement(null, (short) 1); [EOL] assertNull(result); [EOL] }
public void testRemoveElement_EmptyArray() { [EOL] short[] array = {}; [EOL] short elementToRemove = 1; [EOL] short[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] short[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_ValidIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] int indexToRemove = 1; [EOL] Integer[] expected = new Integer[] {1, 3}; [EOL] Object result = remove(array, indexToRemove); [EOL] assertTrue(Arrays.equals(expected, (Object[]) result)); [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] int indexToRemove = 3; [EOL] try { [EOL] remove(array, indexToRemove); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index: 3, Length: 3", e.getMessage()); [EOL] } [EOL] }
public void testRemove_NegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] int indexToRemove = -1; [EOL] try { [EOL] remove(array, indexToRemove); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index: -1, Length: 3", e.getMessage()); [EOL] } [EOL] }
public void testRemoveAll_NullArray() { [EOL] Integer[] result = ArrayUtils.removeAll((Integer[]) null, 1); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] Integer[] emptyArray = new Integer[0]; [EOL] Integer[] result = ArrayUtils.removeAll(emptyArray, 1); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testRemoveAll_NoIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_SingleIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.removeAll(array, 1); [EOL] Integer[] expected = new Integer[] {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_MultipleIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4}; [EOL] Integer[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] Integer[] expected = new Integer[] {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_AllIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.removeAll(array, 0, 1, 2); [EOL] Integer[] expected = new Integer[0]; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_InvalidIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElementsWithEmptyArray() { [EOL] Integer[] array = new Integer[0]; [EOL] Integer[] valuesToRemove = new Integer[]{1, 2}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testRemoveElementsWithEmptyValues() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] valuesToRemove = new Integer[0]; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElementsWithNonEmptyArrayAndValues() { [EOL] Integer[] array = new Integer[]{1, 2, 3, 4, 3, 2, 1}; [EOL] Integer[] valuesToRemove = new Integer[]{2, 3}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] Integer[] expected = new Integer[]{1, 4, 1}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElementsWithAllElementsToRemove() { [EOL] Integer[] array = new Integer[]{1, 1, 1}; [EOL] Integer[] valuesToRemove = new Integer[]{1}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testRemoveElementsWithNoMatchingValues() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] valuesToRemove = new Integer[]{4}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElementsWithNullArray() { [EOL] Integer[] array = null; [EOL] Integer[] valuesToRemove = new Integer[]{1, 2}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNull(result); [EOL] }
public void testRemoveElementsWithNullValues() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] result = ArrayUtils.removeElements(array, (Integer[]) null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElementsWithDuplicateValues() { [EOL] Integer[] array = new Integer[]{1, 2, 3, 1, 2, 3}; [EOL] Integer[] valuesToRemove = new Integer[]{2, 2, 3}; [EOL] Integer[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertNotNull(result); [EOL] Integer[] expected = new Integer[]{1, 1}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_NullArray() { [EOL] byte[] array = null; [EOL] byte[] values = new byte[]{1, 2}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] byte[] array = new byte[]{}; [EOL] byte[] values = new byte[]{1, 2}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NullValues() { [EOL] byte[] array = new byte[]{1, 2, 3}; [EOL] byte[] values = null; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_EmptyValues() { [EOL] byte[] array = new byte[]{1, 2, 3}; [EOL] byte[] values = new byte[]{}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoMatch() { [EOL] byte[] array = new byte[]{1, 2, 3}; [EOL] byte[] values = new byte[]{4}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_SingleMatch() { [EOL] byte[] array = new byte[]{1, 2, 3}; [EOL] byte[] values = new byte[]{2}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] byte[] expected = new byte[]{1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleMatches() { [EOL] byte[] array = new byte[]{1, 2, 3, 2, 2}; [EOL] byte[] values = new byte[]{2}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] byte[] expected = new byte[]{1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleValues() { [EOL] byte[] array = new byte[]{1, 2, 3, 4, 5}; [EOL] byte[] values = new byte[]{2, 4}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] byte[] expected = new byte[]{1, 3, 5}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleOccurrences() { [EOL] byte[] array = new byte[]{1, 2, 3, 2, 4, 2, 5}; [EOL] byte[] values = new byte[]{2, 2}; [EOL] byte[] result = ArrayUtils.removeElements(array, values); [EOL] byte[] expected = new byte[]{1, 3, 4, 5}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_NullArray() { [EOL] boolean[] result = ArrayUtils.removeElements(null, true); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] boolean[] array = {}; [EOL] boolean[] result = ArrayUtils.removeElements(array, true); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesToRemove() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesMatch() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, false, false); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_RemoveSingleValue() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, false); [EOL] boolean[] expected = {true, true}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveMultipleValues() { [EOL] boolean[] array = {true, false, true, false, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, false, true); [EOL] boolean[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveAllOccurrences() { [EOL] boolean[] array = {true, true, true, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, true); [EOL] boolean[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveSubsetOfOccurrences() { [EOL] boolean[] array = {true, false, true, false, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, true, false); [EOL] boolean[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveWithNoOccurrences() { [EOL] boolean[] array = {true, true, true}; [EOL] boolean[] result = ArrayUtils.removeElements(array, false); [EOL] boolean[] expected = {true, true, true}; [EOL] assertArrayEquals(expected, result); [EOL] }
static void setAccessibleWorkaround(final AccessibleObject o) { [EOL] if (o == null || o.isAccessible()) { [EOL] return; [EOL] } [EOL] final Member m = (Member) o; [EOL] if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { [EOL] try { [EOL] o.setAccessible(true); [EOL] } catch (final SecurityException e) { [EOL] } [EOL] } [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL] if (destClass.isPrimitive()) { [EOL] return getPrimitivePromotionCost(srcClass, destClass); [EOL] } [EOL] float cost = 0.0f; [EOL] while (srcClass != null && !destClass.equals(srcClass)) { [EOL] if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL] cost += 0.25f; [EOL] break; [EOL] } [EOL] cost++; [EOL] srcClass = srcClass.getSuperclass(); [EOL] } [EOL] if (srcClass == null) { [EOL] cost += 1.5f; [EOL] } [EOL] return cost; [EOL] }
public void testGetRawTypeWithClass() { [EOL] Class<?> result = TypeUtils.getRawType(String.class, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetRawTypeWithParameterizedType() throws NoSuchFieldException { [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] Class<?> result = TypeUtils.getRawType(type, null); [EOL] assertEquals(ArrayList.class, result); [EOL] }
public void testGetRawTypeWithTypeVariableAssigningTypeNull() { [EOL] TypeVariable<Class<TypeUtils>> typeVariable = TypeUtils.class.getTypeParameters()[0]; [EOL] Class<?> result = TypeUtils.getRawType(typeVariable, null); [EOL] assertNull(result); [EOL] }
public void testGetRawTypeWithTypeVariable() throws NoSuchFieldException { [EOL] TypeVariable<Class<TypeUtils>> typeVariable = TypeUtils.class.getTypeParameters()[0]; [EOL] Type assigningType = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] Class<?> result = TypeUtils.getRawType(typeVariable, assigningType); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetRawTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] Type genericArrayType = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] Class<?> result = TypeUtils.getRawType(genericArrayType, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void testGetRawTypeWithWildcardType() throws NoSuchFieldException { [EOL] Type wildcardType = getClass().getDeclaredField("wildcardType").getGenericType(); [EOL] Class<?> result = TypeUtils.getRawType(wildcardType, null); [EOL] assertNull(result); [EOL] }
public void testGetRawTypeWithUnknownType() { [EOL] Type unknownType = new Type() { [EOL] }; [EOL] try { [EOL] TypeUtils.getRawType(unknownType, null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsArrayTypeWithGenericArrayType() { [EOL] Type genericArrayType = new Type() { [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] assertTrue(StringUtils.isArrayType(genericArrayType)); [EOL] }
public void testIsArrayTypeWithClassArray() { [EOL] Class<?> arrayClass = String[].class; [EOL] assertTrue(StringUtils.isArrayType(arrayClass)); [EOL] }
public void testIsArrayTypeWithNonArrayClass() { [EOL] Class<?> nonArrayClass = String.class; [EOL] assertFalse(StringUtils.isArrayType(nonArrayClass)); [EOL] }
public void testIsArrayTypeWithNull() { [EOL] assertFalse(StringUtils.isArrayType(null)); [EOL] }
public void testAddContextValue_NewValue() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context = context.addContextValue("testLabel", "testValue"); [EOL] assertEquals(1, context.getContextEntries().size()); [EOL] assertEquals(new ImmutablePair<>("testLabel", "testValue"), context.getContextEntries().get(0)); [EOL] }
public void testAddContextValue_NullLabel() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context = context.addContextValue(null, "testValue"); [EOL] assertEquals(1, context.getContextEntries().size()); [EOL] assertEquals(new ImmutablePair<>(null, "testValue"), context.getContextEntries().get(0)); [EOL] }
public void testAddContextValue_NullValue() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context = context.addContextValue("testLabel", null); [EOL] assertEquals(1, context.getContextEntries().size()); [EOL] assertEquals(new ImmutablePair<>("testLabel", null), context.getContextEntries().get(0)); [EOL] }
public void testAddContextValue_NullLabelAndValue() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context = context.addContextValue(null, null); [EOL] assertEquals(1, context.getContextEntries().size()); [EOL] assertEquals(new ImmutablePair<>(null, null), context.getContextEntries().get(0)); [EOL] }
public void testSetContextValue_NewValue() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context.setContextValue("key1", "value1"); [EOL] assertEquals("value1", context.getFirstContextValue("key1")); [EOL] }
public void testSetContextValue_ReplaceExisting() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context.addContextValue("key1", "value1"); [EOL] context.setContextValue("key1", "newValue1"); [EOL] assertEquals("newValue1", context.getFirstContextValue("key1")); [EOL] assertEquals(1, context.getContextEntries().size()); [EOL] }
public void testSetContextValue_NullKey() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context.addContextValue(null, "value1"); [EOL] context.setContextValue(null, "newValue1"); [EOL] assertEquals("newValue1", context.getFirstContextValue(null)); [EOL] }
public void testSetContextValue_NullValue() { [EOL] DefaultExceptionContext context = new DefaultExceptionContext(); [EOL] context.addContextValue("key1", null); [EOL] context.setContextValue("key1", "newValue1"); [EOL] assertEquals("newValue1", context.getFirstContextValue("key1")); [EOL] }
public void testGetFirstContextValue_WithExistingLabel_ShouldReturnCorrespondingValue() { [EOL] contextValues.add(new ImmutablePair<>("label1", "value1")); [EOL] contextValues.add(new ImmutablePair<>("label2", "value2")); [EOL] Object result = getFirstContextValue("label1"); [EOL] assertEquals("value1", result); [EOL] }
public void testGetFirstContextValue_WithNonExistingLabel_ShouldReturnNull() { [EOL] contextValues.add(new ImmutablePair<>("label1", "value1")); [EOL] contextValues.add(new ImmutablePair<>("label2", "value2")); [EOL] Object result = getFirstContextValue("nonExistingLabel"); [EOL] assertNull(result); [EOL] }
public void testGetFirstContextValue_WithNullLabel_ShouldReturnNull() { [EOL] contextValues.add(new ImmutablePair<>("label1", "value1")); [EOL] contextValues.add(new ImmutablePair<>(null, "valueWithNullLabel")); [EOL] Object result = getFirstContextValue(null); [EOL] assertEquals("valueWithNullLabel", result); [EOL] }
public void testGetFirstContextValue_WithEmptyContext_ShouldReturnNull() { [EOL] Object result = getFirstContextValue("anyLabel"); [EOL] assertNull(result); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] exceptionContext.addContextValue("key2", "value2"); [EOL] String baseMessage = "Base error message."; [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertTrue(formattedMessage.startsWith(baseMessage)); [EOL] assertTrue(formattedMessage.contains("Exception Context:")); [EOL] assertTrue(formattedMessage.contains("[1:key1=value1]")); [EOL] assertTrue(formattedMessage.contains("[2:key2=value2]")); [EOL] assertTrue(formattedMessage.endsWith("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertFalse(formattedMessage.startsWith("null")); [EOL] assertTrue(formattedMessage.contains("Exception Context:")); [EOL] assertTrue(formattedMessage.contains("[1:key1=value1]")); [EOL] assertTrue(formattedMessage.endsWith("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageAndEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String baseMessage = "Base error message."; [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertEquals(baseMessage, formattedMessage); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageAndEmptyContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertEquals("", formattedMessage); [EOL] }
public void testGetFormattedExceptionMessageWithExceptionInToString() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object problematicObject = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] throw new RuntimeException("Simulated toString() exception"); [EOL] } [EOL] }; [EOL] exceptionContext.addContextValue("problematicKey", problematicObject); [EOL] String formattedMessage = exceptionContext.getFormattedExceptionMessage("Error occurred"); [EOL] assertTrue(formattedMessage.contains("Exception thrown on toString()")); [EOL] }
public void testIsEmpty_True() { [EOL] CustomList customList = new CustomList(); [EOL] assertTrue(customList.isEmpty()); [EOL] }
public void testIsEmpty_False() { [EOL] CustomList customList = new CustomList(); [EOL] customList.add("element"); [EOL] assertFalse(customList.isEmpty()); [EOL] }
public void testClear() { [EOL] StrBuilder sb = new StrBuilder("test"); [EOL] sb.clear(); [EOL] assertEquals(0, sb.length()); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testSetCharAt_ValidIndex() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.setCharAt(1, 'x'); [EOL] assertEquals("axc", sb.toString()); [EOL] }
public void testSetCharAt_InvalidIndex_TooLow() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.setCharAt(-1, 'x'); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSetCharAt_InvalidIndex_TooHigh() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.setCharAt(3, 'x'); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testToCharArrayWhenSizeIsZero() { [EOL] CharArray ca = new CharArray(0, new char[0]); // size is set to 0 [EOL] char[] result = ca.toCharArray(); [EOL] assertArrayEquals("Expected empty char array when size is 0", ArrayUtils.EMPTY_CHAR_ARRAY, result); [EOL] }
public void testToCharArrayWhenSizeIsNonZero() { [EOL] char[] initialBuffer = new char[] {'a', 'b', 'c'}; [EOL] CharArray ca = new CharArray(3, initialBuffer); // size is set to 3 [EOL] char[] result = ca.toCharArray(); [EOL] assertArrayEquals("Expected char array to match the initial buffer", initialBuffer, result); [EOL] }
public void testGetCharsStartIndexNegative() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(-1, 5, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetCharsEndIndexNegative() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(0, -1, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetCharsEndIndexGreaterThanLength() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(0, 11, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetCharsStartIndexGreaterThanEndIndex() { [EOL] try { [EOL] char[] destination = new char[10]; [EOL] getChars(5, 4, destination, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testGetCharsValidIndices() { [EOL] char[] destination = new char[10]; [EOL] getChars(0, 5, destination, 0); [EOL] }
public void testAppendNullWithNullText() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(null); [EOL] assertSame(builder, builder.appendNull()); [EOL] }
public void testAppendNullWithNonNullText() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText("null"); [EOL] int lenBefore = builder.length(); [EOL] builder.appendNull(); [EOL] assertEquals(lenBefore + 4, builder.length()); [EOL] assertEquals("null", builder.substring(lenBefore)); [EOL] }
public void testAppendWithNullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.append((Object) null); [EOL] assertEquals("null", builder.toString()); [EOL] }
public void testAppendWithNonNullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] Object obj = new Integer(123); [EOL] builder.append(obj); [EOL] assertEquals("123", builder.toString()); [EOL] }
public void testAppendWithNullCharSequence() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.append((CharSequence) null); [EOL] assertEquals("null", builder.toString()); [EOL] }
public void testAppendWithNonNullCharSequence() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] CharSequence seq = "Test"; [EOL] builder.append(seq); [EOL] assertEquals("Test", builder.toString()); [EOL] }
public void testAppend_StrBuilder_null() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((StrBuilder) null); [EOL] assertEquals(0, sb.length()); [EOL] }
public void testAppend_StrBuilder_empty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder(); [EOL] sb.append(toAppend); [EOL] assertEquals(0, sb.length()); [EOL] }
public void testAppend_StrBuilder_nonEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend); [EOL] assertEquals(3, sb.length()); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppend_StrBuilder_null() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((StrBuilder) null, 0, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppend_StrBuilder_validRange() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend, 0, 3); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testAppend_StrBuilder_invalidStartIndex() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend, 4, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppend_StrBuilder_invalidLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend, 1, 5); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppend_StrBuilder_negativeStartIndex() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend, -1, 2); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppend_StrBuilder_negativeLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abc"); [EOL] sb.append(toAppend, 0, -1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendCharArray_Null() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((char[]) null); [EOL] assertEquals("appendNull method should be called", "null", sb.toString()); [EOL] }
public void testAppendCharArray_Empty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(new char[0]); [EOL] assertEquals("Buffer should remain unchanged", "", sb.toString()); [EOL] }
public void testAppendCharArray_NonEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] sb.append(chars); [EOL] assertEquals("Buffer should contain appended chars", "abc", sb.toString()); [EOL] }
public void testAppendlnWithNullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((String) null); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(""); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithNonEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln("test"); [EOL] assertEquals("test" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendAllWithNonNullIterator() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] List<String> list = Arrays.asList("a", "b", "c"); [EOL] builder.appendAll(list.iterator()); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testAppendAllWithNullIterator() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendAll(null); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendWithSeparators_NullIterator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] Iterator<?> it = null; [EOL] String separator = ","; [EOL] StrBuilder result = sb.appendWithSeparators(it, separator); [EOL] assertEquals("", result.toString()); [EOL] }
public void testAppendWithSeparators_EmptyIterator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] Iterator<?> it = Collections.emptyIterator(); [EOL] String separator = ","; [EOL] StrBuilder result = sb.appendWithSeparators(it, separator); [EOL] assertEquals("", result.toString()); [EOL] }
public void testAppendWithSeparators_SingleElementIterator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] Iterator<?> it = Collections.singleton("One").iterator(); [EOL] String separator = ","; [EOL] StrBuilder result = sb.appendWithSeparators(it, separator); [EOL] assertEquals("One", result.toString()); [EOL] }
public void testAppendWithSeparators_MultipleElementsIterator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] List<String> list = Arrays.asList("One", "Two", "Three"); [EOL] Iterator<?> it = list.iterator(); [EOL] String separator = ","; [EOL] StrBuilder result = sb.appendWithSeparators(it, separator); [EOL] assertEquals("One,Two,Three", result.toString()); [EOL] }
public void testAppendWithSeparators_NullSeparator() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] List<String> list = Arrays.asList("One", "Two"); [EOL] Iterator<?> it = list.iterator(); [EOL] String separator = null; [EOL] StrBuilder result = sb.appendWithSeparators(it, separator); [EOL] assertEquals("OneTwo", result.toString()); [EOL] }
public void testAppendSeparator_StandardNotEmpty() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.appendSeparator(",", "-"); [EOL] assertEquals("abc,", sb.toString()); [EOL] }
public void testAppendSeparator_StandardEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(",", "-"); [EOL] assertEquals("-", sb.toString()); [EOL] }
public void testAppendSeparator_DefaultIfEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(null, "-"); [EOL] assertEquals("-", sb.toString()); [EOL] }
public void testAppendSeparator_BothNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(null, null); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendPadding_PositiveLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendPadding(5, 'x'); [EOL] assertEquals("xxxxx", sb.toString()); [EOL] }
public void testAppendPadding_ZeroLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendPadding(0, 'x'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendPadding_NegativeLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendPadding(-1, 'x'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testDeleteAllWithNullMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.deleteAll(null); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testDeleteAllWithNoMatch() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.deleteAll(StrMatcher.noneMatcher()); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testDeleteAllWithMatch() { [EOL] StrBuilder builder = new StrBuilder("a-b-c"); [EOL] builder.deleteAll(StrMatcher.charMatcher('-')); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testDeleteAllWithMultipleMatches() { [EOL] StrBuilder builder = new StrBuilder("a-b-c-"); [EOL] builder.deleteAll(StrMatcher.charMatcher('-')); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceImpl_ReplaceWithSameLength() { [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] int removeLen = 5; [EOL] String insertStr = "Hello"; [EOL] int insertLen = insertStr.length(); [EOL] replaceImpl(startIndex, endIndex, removeLen, insertStr, insertLen); [EOL] assertEquals("Hello", new String(buffer, startIndex, insertLen)); [EOL] assertEquals(newSize, size); [EOL] }
public void testReplaceImpl_ReplaceWithLongerLength() { [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] int removeLen = 3; [EOL] String insertStr = "World"; [EOL] int insertLen = insertStr.length(); [EOL] replaceImpl(startIndex, endIndex, removeLen, insertStr, insertLen); [EOL] assertEquals("World", new String(buffer, startIndex, insertLen)); [EOL] assertTrue(newSize > size); [EOL] }
public void testReplaceImpl_ReplaceWithShorterLength() { [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] int removeLen = 7; [EOL] String insertStr = "Hi"; [EOL] int insertLen = insertStr.length(); [EOL] replaceImpl(startIndex, endIndex, removeLen, insertStr, insertLen); [EOL] assertEquals("Hi", new String(buffer, startIndex, insertLen)); [EOL] assertTrue(newSize < size); [EOL] }
public void testReplaceImpl_ReplaceWithNoLength() { [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] int removeLen = 5; [EOL] String insertStr = ""; [EOL] int insertLen = insertStr.length(); [EOL] replaceImpl(startIndex, endIndex, removeLen, insertStr, insertLen); [EOL] assertEquals("", new String(buffer, startIndex, insertLen)); [EOL] assertEquals(newSize, size - removeLen); [EOL] }
public void testReplaceAll_NullSearchString() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.replaceAll(null, "x"); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_EmptySearchString() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.replaceAll("", "x"); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_NullReplaceString() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("a", null); [EOL] assertEquals("bcbc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_NonEmptySearchAndReplaceString() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("a", "x"); [EOL] assertEquals("xbcxbc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_SearchStringNotFound() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("d", "x"); [EOL] assertEquals("abcabc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_EmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(""); [EOL] sb.replaceAll("a", "x"); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testReplaceAll_ReplaceWithLongerString() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("a", "xyz"); [EOL] assertEquals("xyzbcxyzbc", sb.toString()); [EOL] } [EOL] public void testReplaceAll_ReplaceWithShorterString() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("abc", "x"); [EOL] assertEquals("xx", sb.toString()); [EOL] } [EOL] public void testReplaceAll_ReplaceWithItself() { [EOL] StrBuilder sb = new StrBuilder("abcabc"); [EOL] sb.replaceAll("abc", "abc"); [EOL] assertEquals("abcabc", sb.toString()); [EOL] }
public void testReplaceAll_NullMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.replaceAll(null, "x"); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceAll_EmptyReplaceStr() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.replaceAll(StrMatcher.charMatcher('a'), ""); [EOL] assertEquals("bc", builder.toString()); [EOL] }
public void testReplaceAll_NonMatchingMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.replaceAll(StrMatcher.charMatcher('d'), "x"); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceAll_MatchingMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.replaceAll(StrMatcher.charMatcher('a'), "x"); [EOL] assertEquals("xbc", builder.toString()); [EOL] }
public void testTrim_EmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals(0, trimmed.length()); [EOL] assertSame(sb, trimmed); [EOL] }
public void testTrim_NoTrimNeeded() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] assertSame(sb, trimmed); [EOL] }
public void testTrim_TrimStart() { [EOL] StrBuilder sb = new StrBuilder("  abc"); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testTrim_TrimEnd() { [EOL] StrBuilder sb = new StrBuilder("abc  "); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testTrim_TrimStartAndEnd() { [EOL] StrBuilder sb = new StrBuilder("  abc  "); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testStartsWith_NullString() { [EOL] boolean result = startsWith(null); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_EmptyString() { [EOL] boolean result = startsWith(""); [EOL] assertTrue(result); [EOL] }
public void testStartsWith_StringLongerThanBuffer() { [EOL] boolean result = startsWith("stringThatIsLongerThanBuffer"); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_StringNotMatchingStartOfBuffer() { [EOL] boolean result = startsWith("mismatch"); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_StringMatchingStartOfBuffer() { [EOL] boolean result = startsWith("match"); [EOL] assertTrue(result); [EOL] }
public void testMidString_NegativeIndex() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] MyClass instance = new MyClass(buffer, size); [EOL] String result = instance.midString(-1, 2); [EOL] assertEquals("ab", result); [EOL] }
public void testMidString_LengthZeroOrIndexGreaterThanOrEqualToSize() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] MyClass instance = new MyClass(buffer, size); [EOL] String result = instance.midString(0, 0); [EOL] assertEquals("", result); [EOL] result = instance.midString(size, 1); [EOL] assertEquals("", result); [EOL] }
public void testMidString_IndexPlusLengthExceedsSize() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] MyClass instance = new MyClass(buffer, size); [EOL] String result = instance.midString(3, 3); [EOL] assertEquals("de", result); [EOL] }
public void testMidString_ValidIndexAndLength() { [EOL] char[] buffer = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int size = buffer.length; [EOL] MyClass instance = new MyClass(buffer, size); [EOL] String result = instance.midString(1, 3); [EOL] assertEquals("bcd", result); [EOL] }
public void testContains_charExists() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] MyClass myClass = new MyClass(buffer, size); [EOL] boolean result = myClass.contains('b'); [EOL] assert result == true; [EOL] }
public void testContains_charDoesNotExist() { [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int size = buffer.length; [EOL] MyClass myClass = new MyClass(buffer, size); [EOL] boolean result = myClass.contains('d'); [EOL] assert result == false; [EOL] }
public void testIndexOf_CharInBufferFromStart() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final int size = testBuffer.length; [EOL] final char ch = 'c'; [EOL] final int startIndex = 0; [EOL] int result = indexOf(ch, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_CharNotInBuffer() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final int size = testBuffer.length; [EOL] final char ch = 'z'; [EOL] final int startIndex = 0; [EOL] int result = indexOf(ch, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_CharInBufferFromIndex() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'c'}; [EOL] final int size = testBuffer.length; [EOL] final char ch = 'c'; [EOL] final int startIndex = 3; [EOL] int result = indexOf(ch, startIndex); [EOL] assertEquals(4, result); [EOL] }
public void testIndexOf_StartIndexOutOfBounds() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final int size = testBuffer.length; [EOL] final char ch = 'a'; [EOL] final int startIndex = size; // Start index is equal to size, which is out of bounds [EOL] int result = indexOf(ch, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final char[] testBuffer = {'a', 'b', 'c', 'd', 'e'}; [EOL] final int size = testBuffer.length; [EOL] final char ch = 'a'; [EOL] final int startIndex = -1; // Negative start index [EOL] int result = indexOf(ch, startIndex); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_NullString() { [EOL] int result = indexOf(null, 0); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOf_NegativeStartIndex() { [EOL] int result = indexOf("a", -1); [EOL] assertEquals(-1, result); // Assuming size is 0 for this test case [EOL] } [EOL] public void testIndexOf_StartIndexGreaterThanSize() { [EOL] int result = indexOf("a", 10); [EOL] assertEquals(-1, result); // Assuming size is less than 10 for this test case [EOL] } [EOL] public void testIndexOf_SingleCharacterString() { [EOL] int result = indexOf("a", 0); [EOL] assertEquals(0, result); // Assuming buffer starts with 'a' and size is at least 1 [EOL] } [EOL] public void testIndexOf_EmptyString() { [EOL] int result = indexOf("", 0); [EOL] assertEquals(0, result); // Assuming size is at least 0 [EOL] } [EOL] public void testIndexOf_StringLongerThanSize() { [EOL] int result = indexOf("longstring", 0); [EOL] assertEquals(-1, result); // Assuming size is less than "longstring".length() [EOL] } [EOL] public void testIndexOf_StringNotFound() { [EOL] int result = indexOf("b", 0); [EOL] assertEquals(-1, result); // Assuming buffer does not contain 'b' [EOL] } [EOL] public void testIndexOf_StringFound() { [EOL] int result = indexOf("a", 0); [EOL] assertEquals(0, result); // Assuming buffer contains 'a' at the beginning [EOL] }
public int indexOf(final StrMatcher matcher) { [EOL] return indexOf(matcher, 0); [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL] if (startIndex < 0) { [EOL] return INDEX_NOT_FOUND; [EOL] } [EOL] if (startIndex >= size) { [EOL] startIndex = size - 1; [EOL] } [EOL] for (int i = startIndex; i >= 0; i--) { [EOL] if (array[i] == ch) { [EOL] return i; [EOL] } [EOL] } [EOL] return INDEX_NOT_FOUND; [EOL] }
public void testLastIndexOf_CharInBuffer() { [EOL] final char[] testBuffer = new char[] {'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd'}; [EOL] final int size = testBuffer.length; [EOL] final int startIndex = size - 1; [EOL] final char ch = 'a'; [EOL] int result = lastIndexOf(ch, startIndex, testBuffer, size); [EOL] assertEquals(4, result); [EOL] }
public void testLastIndexOf_CharNotInBuffer() { [EOL] final char[] testBuffer = new char[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}; [EOL] final int size = testBuffer.length; [EOL] final int startIndex = size - 1; [EOL] final char ch = 'z'; [EOL] int result = lastIndexOf(ch, startIndex, testBuffer, size); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_NegativeStartIndex() { [EOL] final char[] testBuffer = new char[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}; [EOL] final int size = testBuffer.length; [EOL] final int startIndex = -1; [EOL] final char ch = 'a'; [EOL] int result = lastIndexOf(ch, startIndex, testBuffer, size); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_StartIndexGreaterThanSize() { [EOL] final char[] testBuffer = new char[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}; [EOL] final int size = testBuffer.length; [EOL] final int startIndex = 100; [EOL] final char ch = 'a'; [EOL] int result = lastIndexOf(ch, startIndex, testBuffer, size); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_NullString() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf(null, 10); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_NegativeStartIndex() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("a", -1); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ValidString() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("validString", size - 1); [EOL] int expectedIndex = /* the expected index */; [EOL] assertEquals(expectedIndex, result); [EOL] }
public void testLastIndexOf_SingleCharacterString() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("a", size - 1); [EOL] int expectedIndex = /* the expected index */; [EOL] assertEquals(expectedIndex, result); [EOL] }
public void testLastIndexOf_EmptyString() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("", size - 1); [EOL] assertEquals(size - 1, result); [EOL] }
public void testLastIndexOf_StringLargerThanBuffer() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("stringThatIsDefinitelyLargerThanBuffer", size - 1); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_StringNotFound() { [EOL] YourClass obj = new YourClass(buffer, size); [EOL] int result = obj.lastIndexOf("notFound", size - 1); [EOL] assertEquals(-1, result); [EOL] }
public void testAsWriter() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] Writer writer = strBuilder.asWriter(); [EOL] assertNotNull(writer); [EOL] assertTrue(writer instanceof StrBuilder.StrBuilderWriter); [EOL] }
public void testStrBuilderWriterConstructor() { [EOL] StrBuilderWriter strBuilderWriter = new StrBuilderWriter(); [EOL] assertNotNull(strBuilderWriter.getBuilder()); [EOL] assertEquals(0, strBuilderWriter.getBuilder().length()); [EOL] }
It appears that the provided input text is an empty method `close()` which does not contain any executable lines of code. Since there are no operations or logic within the method, there is no code to cover with unit tests. Therefore, no unit test cases can be generated for this method as it stands. [EOL] If the method were to contain logic or operations, then unit test cases could be generated to cover those lines of code. However, with the given input, there is nothing to test.
It appears that the provided method `flush()` is empty and does not contain any executable code. Since there are no operations or logic within the method, there is no line of code to cover with tests, and thus no meaningful unit test can be generated for this method. [EOL] In a typical scenario, if the method contained logic, I would provide you with Java test methods that execute the method and assert the expected outcomes to ensure maximum line coverage. However, in this case, there is nothing to test. If the `flush()` method is supposed to be part of an interface or an abstract class, it might be implemented in subclasses, and tests should be written for those implementations instead.
public void testWrite_singleChar() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.write('a'); [EOL] assertEquals("a", strBuilder.toString()); [EOL] }
public void testWrite_specialChar() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.write('\n'); [EOL] assertEquals("\n", strBuilder.toString()); [EOL] }
public void testWriteWithNullCharArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.write(null); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testWriteWithEmptyCharArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.write(new char[0]); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testWriteWithNonEmptyCharArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] char[] charArray = {'a', 'b', 'c'}; [EOL] builder.write(charArray); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testWrite_withValidInput() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int off = 1; [EOL] int len = 3; [EOL] sb.write(cbuf, off, len); [EOL] assertEquals("bcd", sb.toString()); [EOL] }
public void testWrite_withOffsetOutOfBounds() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int off = 6; [EOL] int len = 1; [EOL] try { [EOL] sb.write(cbuf, off, len); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWrite_withNegativeOffset() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int off = -1; [EOL] int len = 2; [EOL] try { [EOL] sb.write(cbuf, off, len); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWrite_withNegativeLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int off = 1; [EOL] int len = -1; [EOL] try { [EOL] sb.write(cbuf, off, len); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWrite_withLengthExceedingBuffer() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int off = 1; [EOL] int len = 5; [EOL] try { [EOL] sb.write(cbuf, off, len); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWriteNullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write(null); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testWriteEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write(""); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testWriteNonEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write("test"); [EOL] assertEquals("test", sb.toString()); [EOL] }
public void testWrite_NullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write(null, 0, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testWrite_ValidString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write("abc", 0, 3); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testWrite_Substring() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.write("abc", 1, 2); [EOL] assertEquals("bc", sb.toString()); [EOL] }
public void testWrite_InvalidOffset() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] try { [EOL] sb.write("abc", -1, 2); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWrite_InvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] try { [EOL] sb.write("abc", 1, -1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWrite_LengthExceeds() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] try { [EOL] sb.write("abc", 1, 5); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertNotNull(fdf); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance(); [EOL] assertSame(fdf, fdf2); [EOL] }
public void testGetInstanceWithPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern); [EOL] assertNotNull(fdf); [EOL] assertEquals(pattern, fdf.getPattern()); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("MM/dd/yyyy"); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetInstanceWithPatternTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance(pattern, TimeZone.getTimeZone("UTC")); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetInstanceWithPatternLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance(pattern, Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetInstanceWithPatternTimeZoneLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance(pattern, TimeZone.getTimeZone("UTC"), Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateInstance() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style); [EOL] assertNotNull(fdf); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateInstance(DateFormat.LONG); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateInstanceWithLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateInstance(style, Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateInstanceWithTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateInstance(style, TimeZone.getTimeZone("UTC")); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateInstanceWithTimeZoneLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateInstance(style, TimeZone.getTimeZone("UTC"), Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetTimeInstance() { [EOL] int style = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style); [EOL] assertNotNull(fdf); [EOL] FastDateFormat fdf2 = FastDateFormat.getTimeInstance(DateFormat.LONG); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetTimeInstanceWithLocale() { [EOL] int style = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getTimeInstance(style, Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetTimeInstanceWithTimeZone() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] FastDateFormat fdf2 = FastDateFormat.getTimeInstance(style, TimeZone.getTimeZone("UTC")); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetTimeInstanceWithTimeZoneLocale() { [EOL] int style = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(style, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getTimeInstance(style, TimeZone.getTimeZone("UTC"), Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateTimeInstance() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle); [EOL] assertNotNull(fdf); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateTimeInstanceWithLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateTimeInstanceWithTimeZone() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, TimeZone.getTimeZone("UTC")); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetDateTimeInstanceWithTimeZoneLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.SHORT; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] FastDateFormat fdf2 = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, TimeZone.getTimeZone("UTC"), Locale.US); [EOL] assertNotSame(fdf, fdf2); [EOL] }
public void testGetInstanceWithPatternAndTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat instance = FastDateFormat.getInstance(pattern, timeZone); [EOL] assertNotNull(instance); [EOL] assertEquals(timeZone, instance.getTimeZone()); [EOL] assertEquals(pattern, instance.getPattern()); [EOL] }
public void testGetInstanceWithPatternAndNullTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] FastDateFormat instance = FastDateFormat.getInstance(pattern, null); [EOL] assertNotNull(instance); [EOL] assertEquals(TimeZone.getDefault(), instance.getTimeZone()); [EOL] assertEquals(pattern, instance.getPattern()); [EOL] }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL] return parser.parse(source); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; }]
@Override [EOL] public TimeZone getTimeZone() { [EOL] return printer.getTimeZone(); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=Optional[2L]; [EOL] int FULL=Optional[DateFormat.FULL]; [EOL] int LONG=Optional[DateFormat.LONG]; [EOL] int MEDIUM=Optional[DateFormat.MEDIUM]; [EOL] int SHORT=Optional[DateFormat.SHORT]; [EOL] FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }]
public void testGetUserDir_ValidSystemProperty() { [EOL] System.setProperty("user.dir", "/path/to/user/dir"); [EOL] File userDir = FileUtils.getUserDir(); [EOL] assertNotNull(userDir); [EOL] assertEquals("/path/to/user/dir", userDir.getAbsolutePath()); [EOL] }
public void testGetUserHome() { [EOL] File userHome = FileUtils.getUserHome(); [EOL] assertNotNull(userHome); [EOL] assertTrue(userHome.exists()); [EOL] assertEquals(System.getProperty("user.home"), userHome.getPath()); [EOL] }
public void testGetFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testGetFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testGetFieldWithExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "CASE_INSENSITIVE_ORDER", false); [EOL] assertNotNull("Should find field", field); [EOL] } [EOL] public void testGetFieldWithNonExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "nonExistingField", false); [EOL] assertNull("Should not find field", field); [EOL] } [EOL] public void testGetFieldWithPrivateFieldWithoutForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", false); [EOL] assertNull("Should not find private field without force access", field); [EOL] } [EOL] public void testGetFieldWithPrivateFieldWithForceAccess() { [EOL] Field field = FieldUtils.getField(TestClass.class, "privateField", true); [EOL] assertNotNull("Should find private field with force access", field); [EOL] } [EOL] public void testGetFieldWithAmbiguousField() { [EOL] try { [EOL] FieldUtils.getField(TestClassWithAmbiguousFields.class, "AMBIGUOUS_FIELD", false); [EOL] fail("Should have thrown IllegalArgumentException for ambiguous field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }

public void testReadDeclaredStaticField_ValidField() throws IllegalAccessException { [EOL] final String fieldName = "CONSTANT"; // Assume CONSTANT is a valid static field in SomeClass [EOL] Object result = FieldUtils.readDeclaredStaticField(SomeClass.class, fieldName, true); [EOL] assertNotNull(result); [EOL] assertEquals(SomeClass.CONSTANT, result); [EOL] }
public void testReadDeclaredStaticField_FieldDoesNotExist() { [EOL] final String fieldName = "NON_EXISTENT_FIELD"; [EOL] try { [EOL] FieldUtils.readDeclaredStaticField(SomeClass.class, fieldName, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for non-existent field"); [EOL] } [EOL] }
public void testReadDeclaredStaticField_IllegalAccess() { [EOL] final String fieldName = "PRIVATE_CONSTANT"; // Assume PRIVATE_CONSTANT is a private static field in SomeClass [EOL] try { [EOL] FieldUtils.readDeclaredStaticField(SomeClass.class, fieldName, false); [EOL] fail("Should have thrown IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testWriteDeclaredField() throws IllegalAccessException { [EOL] final TestClass target = new TestClass(); [EOL] final String fieldName = "privateField"; [EOL] final String value = "newValue"; [EOL] FieldUtils.writeDeclaredField(target, fieldName, value); [EOL] assertEquals("Field should be updated with new value", value, target.getPrivateField()); [EOL] }
public void testWriteDeclaredFieldWithNullTarget() { [EOL] final String fieldName = "privateField"; [EOL] final String value = "newValue"; [EOL] try { [EOL] FieldUtils.writeDeclaredField(null, fieldName, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should have thrown IllegalArgumentException instead of IllegalAccessException"); [EOL] } [EOL] }
public void testWriteDeclaredFieldWithEmptyFieldName() throws IllegalAccessException { [EOL] final TestClass target = new TestClass(); [EOL] final String value = "newValue"; [EOL] try { [EOL] FieldUtils.writeDeclaredField(target, "", value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteDeclaredFieldWithNullFieldName() throws IllegalAccessException { [EOL] final TestClass target = new TestClass(); [EOL] final String value = "newValue"; [EOL] try { [EOL] FieldUtils.writeDeclaredField(target, null, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteDeclaredField_NullTarget() { [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] FieldUtils.writeDeclaredField(null, "fieldName", "value", true); [EOL] }); [EOL] assertEquals("target object must not be null", exception.getMessage()); [EOL] }
public void testWriteDeclaredField_ValidField() throws IllegalAccessException { [EOL] MyClass target = new MyClass(); [EOL] FieldUtils.writeDeclaredField(target, "privateField", "newValue", true); [EOL] assertEquals("newValue", target.getPrivateField()); [EOL] }
public void testWriteDeclaredField_FieldNotFound() { [EOL] MyClass target = new MyClass(); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] FieldUtils.writeDeclaredField(target, "nonExistentField", "value", true); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Cannot locate declared field")); [EOL] }
public void testGetInstance_NullInput() { [EOL] CharSet result = CharSet.getInstance((String[]) null); [EOL] assertNull(result); [EOL] }
public void testGetInstance_SingleElementInCommonMap() { [EOL] CharSet result = CharSet.getInstance("a"); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_SingleElementNotInCommonMap() { [EOL] CharSet result = CharSet.getInstance("not_in_common"); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_MultipleElements() { [EOL] CharSet result = CharSet.getInstance("a", "b", "c"); [EOL] assertNotNull(result); [EOL] }
public void testCharSetWithEmptyArray() { [EOL] CharSet cs = new CharSet(new String[]{}); [EOL] assertTrue(cs.isEmpty()); [EOL] }
public void testCharSetWithNullElement() { [EOL] CharSet cs = new CharSet(new String[]{null}); [EOL] assertTrue(cs.isEmpty()); [EOL] }
public void testCharSetWithValidElements() { [EOL] CharSet cs = new CharSet(new String[]{"a", "b", "c"}); [EOL] assertFalse(cs.isEmpty()); [EOL] assertTrue(cs.contains('a')); [EOL] assertTrue(cs.contains('b')); [EOL] assertTrue(cs.contains('c')); [EOL] }
public void testAddWithNullString() { [EOL] add(null); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithEmptyString() { [EOL] add(""); [EOL] assertTrue(set.isEmpty()); [EOL] }
public void testAddWithSingleCharacter() { [EOL] add("a"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.is('a'))); [EOL] }
public void testAddWithSimpleRange() { [EOL] add("a-c"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] }
public void testAddWithNegatedCharacter() { [EOL] add("^a"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isNot('a'))); [EOL] }
public void testAddWithNegatedRange() { [EOL] add("^a-c"); [EOL] assertEquals(1, set.size()); [EOL] assertTrue(set.contains(CharRange.isNotIn('a', 'c'))); [EOL] }
public void testAddWithMultipleRanges() { [EOL] add("a-ce-gi-k"); [EOL] assertEquals(3, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isIn('e', 'g'))); [EOL] assertTrue(set.contains(CharRange.isIn('i', 'k'))); [EOL] }
public void testAddWithMixedRangesAndCharacters() { [EOL] add("a-c^e-gi-k^m"); [EOL] assertEquals(5, set.size()); [EOL] assertTrue(set.contains(CharRange.isIn('a', 'c'))); [EOL] assertTrue(set.contains(CharRange.isNotIn('e', 'g'))); [EOL] assertTrue(set.contains(CharRange.isIn('i', 'k'))); [EOL] assertTrue(set.contains(CharRange.isNot('m'))); [EOL] }
public void testContains_CharacterInRange() { [EOL] CharRange range1 = CharRange.is('a'); [EOL] CharRange range2 = CharRange.is('z'); [EOL] CharRange[] ranges = new CharRange[]{range1, range2}; [EOL] CharSet charSet = new CharSet(ranges); [EOL] assertTrue(charSet.contains('a')); [EOL] assertTrue(charSet.contains('z')); [EOL] }
public void testContains_CharacterNotInRange() { [EOL] CharRange range1 = CharRange.is('a'); [EOL] CharRange range2 = CharRange.is('z'); [EOL] CharRange[] ranges = new CharRange[]{range1, range2}; [EOL] CharSet charSet = new CharSet(ranges); [EOL] assertFalse(charSet.contains('b')); [EOL] assertFalse(charSet.contains('y')); [EOL] }
public void testContains_EmptyCharSet() { [EOL] CharSet charSet = new CharSet(new CharRange[0]); [EOL] assertFalse(charSet.contains('a')); [EOL] }
public void testGetFirstContextValue_WithExistingLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("testLabel", "testValue"); [EOL] Object result = exceptionContext.getFirstContextValue("testLabel"); [EOL] assertEquals("testValue", result); [EOL] }
public void testGetFirstContextValue_WithNonExistingLabel() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object result = exceptionContext.getFirstContextValue("nonExistingLabel"); [EOL] assertNull(result); [EOL] }
public void testGetMatchingAccessibleConstructor_ExactMatch() throws Exception { [EOL] Constructor<String> constructor = StringUtils.class.getConstructor(String.class); [EOL] Constructor<String> result = MethodUtils.getMatchingAccessibleConstructor(StringUtils.class, String.class); [EOL] assertNotNull(result); [EOL] assertEquals(constructor, result); [EOL] } [EOL] public void testGetMatchingAccessibleConstructor_InexactMatch() throws Exception { [EOL] Constructor<Number> constructor = Integer.class.getConstructor(int.class); [EOL] Constructor<Number> result = MethodUtils.getMatchingAccessibleConstructor(Number.class, int.class); [EOL] assertNull(result); [EOL] } [EOL] public void testGetMatchingAccessibleConstructor_NoSuchMethod() { [EOL] Constructor<Number> result = MethodUtils.getMatchingAccessibleConstructor(Number.class, String.class); [EOL] assertNull(result); [EOL] } [EOL] public void testGetMatchingAccessibleConstructor_NullClass() { [EOL] try { [EOL] Constructor<Object> result = MethodUtils.getMatchingAccessibleConstructor(null, Object.class); [EOL] fail("Should throw IllegalArgumentException when cls is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testGetMatchingAccessibleConstructor_NullParameterTypes() throws Exception { [EOL] Constructor<Object> constructor = Object.class.getConstructor(); [EOL] Constructor<Object> result = MethodUtils.getMatchingAccessibleConstructor(Object.class, (Class<?>[]) null); [EOL] assertNotNull(result); [EOL] assertEquals(constructor, result); [EOL] } [EOL] public void testGetMatchingAccessibleConstructor_EmptyParameterTypes() throws Exception { [EOL] Constructor<Object> constructor = Object.class.getConstructor(); [EOL] Constructor<Object> result = MethodUtils.getMatchingAccessibleConstructor(Object.class); [EOL] assertNotNull(result); [EOL] assertEquals(constructor, result); [EOL] }
public void testCharRange_Normal() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testCharRange_Reversed() { [EOL] CharRange range = new CharRange('z', 'a', false); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertFalse(range.isNegated()); [EOL] }
public void testCharRange_Negated() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] assertEquals('a', range.getStart()); [EOL] assertEquals('z', range.getEnd()); [EOL] assertTrue(range.isNegated()); [EOL] }
public void testContains_CharacterInRangeNotNegated() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] assertTrue(range.contains('m')); [EOL] }
public void testContains_CharacterInRangeNegated() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] assertFalse(range.contains('m')); [EOL] }
public void testContains_CharacterOutOfRangeNotNegated() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] assertFalse(range.contains('A')); [EOL] }
public void testContains_CharacterOutOfRangeNegated() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] assertTrue(range.contains('A')); [EOL] }
public void testEquals_Reflexive() { [EOL] CharRange range = new CharRange('a'); [EOL] assertTrue(range.equals(range)); [EOL] }
public void testEquals_SameValue() { [EOL] CharRange range1 = new CharRange('a'); [EOL] CharRange range2 = new CharRange('a'); [EOL] assertTrue(range1.equals(range2)); [EOL] }
public void testEquals_DifferentValue() { [EOL] CharRange range1 = new CharRange('a'); [EOL] CharRange range2 = new CharRange('b'); [EOL] assertFalse(range1.equals(range2)); [EOL] }
public void testEquals_DifferentType() { [EOL] CharRange range = new CharRange('a'); [EOL] Object obj = new Object(); [EOL] assertFalse(range.equals(obj)); [EOL] }
public void testEquals_Negated() { [EOL] CharRange range1 = new CharRange('a', 'a', true); [EOL] CharRange range2 = new CharRange('a', 'a', false); [EOL] assertFalse(range1.equals(range2)); [EOL] }
public void testHashCode_PositiveValues() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean negated = false; [EOL] int expectedHashCode = 83 + 5 + 7 * 10 + (negated ? 1 : 0); [EOL] assertEquals(expectedHashCode, range.hashCode()); [EOL] }
public void testHashCode_NegativeValues() { [EOL] Range<Integer> range = Range.between(-5, -10); [EOL] boolean negated = false; [EOL] int expectedHashCode = 83 - 5 + 7 * -10 + (negated ? 1 : 0); [EOL] assertEquals(expectedHashCode, range.hashCode()); [EOL] }
public void testHashCode_Negated() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean negated = true; [EOL] int expectedHashCode = 83 + 5 + 7 * 10 + (negated ? 1 : 0); [EOL] assertEquals(expectedHashCode, range.hashCode()); [EOL] }
public void testToStringWhenToStringIsNullAndIsNegated() { [EOL] CharRange range = new CharRange('a', 'z', true); [EOL] String result = range.toString(); [EOL] assertEquals("^a-z", result); [EOL] } [EOL] public void testToStringWhenToStringIsNullAndNotNegated() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] String result = range.toString(); [EOL] assertEquals("a-z", result); [EOL] } [EOL] public void testToStringWhenToStringIsNullAndStartEqualsEnd() { [EOL] CharRange range = new CharRange('a', 'a', false); [EOL] String result = range.toString(); [EOL] assertEquals("a", result); [EOL] } [EOL] public void testToStringWhenToStringIsNotNull() { [EOL] CharRange range = new CharRange('a', 'z', false); [EOL] range.toString(); // Call once to set iToString [EOL] String result = range.toString(); // Call again to test the already initialized case [EOL] assertEquals("a-z", result); [EOL] }
public void testMinWithNullArray() { [EOL] try { [EOL] ArrayUtils.min(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMinWithEmptyArray() { [EOL] try { [EOL] ArrayUtils.min(new double[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMinWithValidArray() { [EOL] double[] array = {1.0, 2.0, 0.5, 4.5, -0.1}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals("Min should be -0.1", -0.1, result, 0.0); [EOL] }
public void testMinWithSingleElementArray() { [EOL] double[] array = {2.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals("Min with single element array should be the element itself", 2.0, result, 0.0); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] double[] array = {2.0, 2.0, 2.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals("Min with all equal elements should be the element itself", 2.0, result, 0.0); [EOL] }
public void testMinWithNullArray() { [EOL] try { [EOL] ArrayUtils.min(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMinWithEmptyArray() { [EOL] try { [EOL] ArrayUtils.min(new float[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMinWithValidArray() { [EOL] float[] array = {1.0f, 2.0f, 0.5f}; [EOL] float result = ArrayUtils.min(array); [EOL] assertEquals(0.5f, result, 0.0f); [EOL] } [EOL] public void testMinWithSingleElementArray() { [EOL] float[] array = {2.0f}; [EOL] float result = ArrayUtils.min(array); [EOL] assertEquals(2.0f, result, 0.0f); [EOL] } [EOL] public void testMinWithTwoElementsArray() { [EOL] float[] array = {2.0f, 1.0f}; [EOL] float result = ArrayUtils.min(array); [EOL] assertEquals(1.0f, result, 0.0f); [EOL] }
public void testMinWithAllPositiveNumbers() { [EOL] double a = 1.0; [EOL] double b = 2.0; [EOL] double c = 3.0; [EOL] double result = min(a, b, c); [EOL] assertEquals(1.0, result, 0.0); [EOL] }
public void testMinWithAllNegativeNumbers() { [EOL] double a = -1.0; [EOL] double b = -2.0; [EOL] double c = -3.0; [EOL] double result = min(a, b, c); [EOL] assertEquals(-3.0, result, 0.0); [EOL] }
public void testMinWithMixedNumbers() { [EOL] double a = -1.0; [EOL] double b = 2.0; [EOL] double c = 0.0; [EOL] double result = min(a, b, c); [EOL] assertEquals(-1.0, result, 0.0); [EOL] }
public void testMinWithEqualNumbers() { [EOL] double a = 2.0; [EOL] double b = 2.0; [EOL] double c = 2.0; [EOL] double result = min(a, b, c); [EOL] assertEquals(2.0, result, 0.0); [EOL] }
public void testMinWithFirstArgNaN() { [EOL] double a = Double.NaN; [EOL] double b = 1.0; [EOL] double result = min(a, b); [EOL] assertEquals(b, result, 0.0); [EOL] } [EOL] public void testMinWithSecondArgNaN() { [EOL] double a = 1.0; [EOL] double b = Double.NaN; [EOL] double result = min(a, b); [EOL] assertEquals(a, result, 0.0); [EOL] } [EOL] public void testMinWithNoArgNaN() { [EOL] double a = 1.0; [EOL] double b = 2.0; [EOL] double result = min(a, b); [EOL] assertEquals(Math.min(a, b), result, 0.0); [EOL] }
public void testMinWithAllPositiveValues() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float c = 3.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(1.0f, result, 0.0f); [EOL] }
public void testMinWithAllNegativeValues() { [EOL] float a = -1.0f; [EOL] float b = -2.0f; [EOL] float c = -3.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(-3.0f, result, 0.0f); [EOL] }
public void testMinWithMixedValues() { [EOL] float a = -1.0f; [EOL] float b = 2.0f; [EOL] float c = 0.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(-1.0f, result, 0.0f); [EOL] }
public void testMinWithEqualValues() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float c = 2.0f; [EOL] float result = min(a, b, c); [EOL] assertEquals(2.0f, result, 0.0f); [EOL] }
public void testMinWithFirstArgNaN() { [EOL] float a = Float.NaN; [EOL] float b = 1.0f; [EOL] float result = min(a, b); [EOL] assertEquals(b, result, 0.0f); [EOL] } [EOL] public void testMinWithSecondArgNaN() { [EOL] float a = 1.0f; [EOL] float b = Float.NaN; [EOL] float result = min(a, b); [EOL] assertEquals(a, result, 0.0f); [EOL] } [EOL] public void testMinWithNoArgNaN() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float result = min(a, b); [EOL] assertEquals(Math.min(a, b), result, 0.0f); [EOL] } [EOL] public void testMinWithBothArgsNaN() { [EOL] float a = Float.NaN; [EOL] float b = Float.NaN; [EOL] float result = min(a, b); [EOL] assertTrue(Float.isNaN(result)); [EOL] }
public void testMaxWithNullArray() { [EOL] try { [EOL] ArrayUtils.max(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMaxWithEmptyArray() { [EOL] try { [EOL] ArrayUtils.max(new double[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMaxWithValidArray() { [EOL] double[] array = {1.0, 3.5, 2.2, 5.4}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals("Max should be 5.4", 5.4, result, 0.0); [EOL] }
public void testMaxWithAllEqualElementsArray() { [EOL] double[] array = {2.0, 2.0, 2.0, 2.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals("Max should be 2.0", 2.0, result, 0.0); [EOL] }
public void testMaxWithNullArray() { [EOL] try { [EOL] ArrayUtils.max(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMaxWithEmptyArray() { [EOL] try { [EOL] ArrayUtils.max(new float[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testMaxWithValidArray() { [EOL] float[] array = {1.0f, 3.5f, 2.2f, 5.4f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals("Max should be 5.4", 5.4f, result, 0.0f); [EOL] } [EOL] public void testMaxWithAllEqualElements() { [EOL] float[] array = {2.0f, 2.0f, 2.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals("Max should be 2.0", 2.0f, result, 0.0f); [EOL] }
public void testMaxWithDistinctValues() { [EOL] double a = 1.0; [EOL] double b = 2.0; [EOL] double c = 3.0; [EOL] double result = max(a, b, c); [EOL] assertEquals(c, result, 0.0); [EOL] }
public void testMaxWithNegativeValues() { [EOL] double a = -1.0; [EOL] double b = -2.0; [EOL] double c = -3.0; [EOL] double result = max(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMaxWithAllEqualValues() { [EOL] double a = 2.0; [EOL] double b = 2.0; [EOL] double c = 2.0; [EOL] double result = max(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMaxWithFirstTwoEqualAndGreater() { [EOL] double a = 3.0; [EOL] double b = 3.0; [EOL] double c = 2.0; [EOL] double result = max(a, b, c); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMaxWithLastTwoEqualAndGreater() { [EOL] double a = 1.0; [EOL] double b = 3.0; [EOL] double c = 3.0; [EOL] double result = max(a, b, c); [EOL] assertEquals(b, result, 0.0); [EOL] }
public void testMaxWithFirstArgNaN() { [EOL] double a = Double.NaN; [EOL] double b = 1.0; [EOL] double result = max(a, b); [EOL] assertEquals(b, result, 0.0); [EOL] } [EOL] public void testMaxWithSecondArgNaN() { [EOL] double a = 1.0; [EOL] double b = Double.NaN; [EOL] double result = max(a, b); [EOL] assertEquals(a, result, 0.0); [EOL] } [EOL] public void testMaxWithNoNaN() { [EOL] double a = 1.0; [EOL] double b = 2.0; [EOL] double result = max(a, b); [EOL] assertEquals(b, result, 0.0); [EOL] } [EOL] public void testMaxWithEqualValues() { [EOL] double a = 2.0; [EOL] double b = 2.0; [EOL] double result = max(a, b); [EOL] assertEquals(a, result, 0.0); [EOL] }
public void testMaxWithAllPositiveValues() { [EOL] float a = 10.0f; [EOL] float b = 20.0f; [EOL] float c = 30.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(30.0f, result, 0.0f); [EOL] }
public void testMaxWithAllNegativeValues() { [EOL] float a = -10.0f; [EOL] float b = -20.0f; [EOL] float c = -30.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(-10.0f, result, 0.0f); [EOL] }
public void testMaxWithMixedValues() { [EOL] float a = -10.0f; [EOL] float b = 20.0f; [EOL] float c = 0.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(20.0f, result, 0.0f); [EOL] }
public void testMaxWithEqualValues() { [EOL] float a = 20.0f; [EOL] float b = 20.0f; [EOL] float c = 20.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(20.0f, result, 0.0f); [EOL] }
public void testMaxWithFirstArgNaN() { [EOL] float a = Float.NaN; [EOL] float b = 1.0f; [EOL] float result = max(a, b); [EOL] assertEquals(b, result, 0.0f); [EOL] }
public void testMaxWithSecondArgNaN() { [EOL] float a = 1.0f; [EOL] float b = Float.NaN; [EOL] float result = max(a, b); [EOL] assertEquals(a, result, 0.0f); [EOL] }
public void testMaxWithNoNaN() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float result = max(a, b); [EOL] assertEquals(b, result, 0.0f); [EOL] }
public void testMaxWithEqualValues() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float result = max(a, b); [EOL] assertEquals(a, result, 0.0f); [EOL] }
public void testAppendByte() { [EOL] final int initialConstant = 37; [EOL] final int initialValue = 17; [EOL] final byte testValue = 123; [EOL] HashCodeBuilder builder = new HashCodeBuilder(initialValue, initialConstant); [EOL] int expectedValue = initialValue * initialConstant + testValue; [EOL] builder.append(testValue); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendByteZero() { [EOL] final int initialConstant = 37; [EOL] final int initialValue = 17; [EOL] final byte testValue = 0; [EOL] HashCodeBuilder builder = new HashCodeBuilder(initialValue, initialConstant); [EOL] int expectedValue = initialValue * initialConstant + testValue; [EOL] builder.append(testValue); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendByteNegative() { [EOL] final int initialConstant = 37; [EOL] final int initialValue = 17; [EOL] final byte testValue = -1; [EOL] HashCodeBuilder builder = new HashCodeBuilder(initialValue, initialConstant); [EOL] int expectedValue = initialValue * initialConstant + testValue; [EOL] builder.append(testValue); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendWithNullByteArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] byte[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17 * 37, result.toHashCode()); [EOL] }
public void testAppendWithEmptyByteArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] byte[] array = new byte[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyByteArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] int expectedHashCode = calculateExpectedHashCode(hcb, array); [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] } [EOL] private int calculateExpectedHashCode(HashCodeBuilder hcb, byte[] array) { [EOL] int total = 17; // initial value [EOL] int constant = 37; // constant [EOL] for (byte element : array) { [EOL] total = total * constant + element; [EOL] } [EOL] return total; [EOL] }
public void testAppendDouble() { [EOL] final double testValue = 123.456; [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] builder.append(testValue); [EOL] long expectedValue = Double.doubleToLongBits(testValue); [EOL] assertEquals("Failed to append double value", expectedValue, builder.toHashCode()); [EOL] }
public void testAppendDoubleNaN() { [EOL] final double testValue = Double.NaN; [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] builder.append(testValue); [EOL] long expectedValue = Double.doubleToLongBits(testValue); [EOL] assertEquals("Failed to append NaN double value", expectedValue, builder.toHashCode()); [EOL] }
public void testAppendDoublePositiveInfinity() { [EOL] final double testValue = Double.POSITIVE_INFINITY; [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] builder.append(testValue); [EOL] long expectedValue = Double.doubleToLongBits(testValue); [EOL] assertEquals("Failed to append positive infinity double value", expectedValue, builder.toHashCode()); [EOL] }
public void testAppendDoubleNegativeInfinity() { [EOL] final double testValue = Double.NEGATIVE_INFINITY; [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] builder.append(testValue); [EOL] long expectedValue = Double.doubleToLongBits(testValue); [EOL] assertEquals("Failed to append negative infinity double value", expectedValue, builder.toHashCode()); [EOL] }
public void testAppendWithNullDoubleArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17 * 37, result.toHashCode()); [EOL] }
public void testAppendWithEmptyDoubleArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = new double[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyDoubleArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] int expectedHashCode = calculateExpectedHashCode(array); [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] } [EOL] private int calculateExpectedHashCode(double[] array) { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] for (double element : array) { [EOL] hcb.append(element); [EOL] } [EOL] return hcb.toHashCode(); [EOL] }
public void testAppendLong_maxValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Long.MAX_VALUE); [EOL] int expectedValue = 17 * 37 + (int) (Long.MAX_VALUE ^ (Long.MAX_VALUE >> 32)); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendLong_minValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Long.MIN_VALUE); [EOL] int expectedValue = 17 * 37 + (int) (Long.MIN_VALUE ^ (Long.MIN_VALUE >> 32)); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendLong_zero() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(0L); [EOL] int expectedValue = 17 * 37 + (int) (0L ^ (0L >> 32)); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendWithNull() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append((Object) null); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithLongArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithIntArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithShortArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithCharArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] char[] array = {'a', 'b', 'c'}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithByteArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithDoubleArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithFloatArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithBooleanArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithObjectArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] Object[] array = {new Object(), new Object(), new Object()}; [EOL] hcb.append(array); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(array); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithRegularObject() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] Object obj = new Object(); [EOL] int initialTotal = hcb.hashCode(); [EOL] hcb.append(obj); [EOL] assertNotEquals(initialTotal, hcb.hashCode()); [EOL] }
public void testAppendWithNullArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] Object[] array = null; [EOL] int initialTotal = hcb.toHashCode(); [EOL] hcb.append(array); [EOL] int finalTotal = hcb.toHashCode(); [EOL] assertNotEquals(initialTotal, finalTotal); [EOL] }
public void testAppendWithEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] Object[] array = new Object[0]; [EOL] int initialTotal = hcb.toHashCode(); [EOL] hcb.append(array); [EOL] int finalTotal = hcb.toHashCode(); [EOL] assertEquals(initialTotal, finalTotal); [EOL] }
public void testAppendWithNonEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] Object[] array = new Object[] { "element1", "element2", "element3" }; [EOL] int initialTotal = hcb.toHashCode(); [EOL] hcb.append(array); [EOL] int finalTotal = hcb.toHashCode(); [EOL] assertNotEquals(initialTotal, finalTotal); [EOL] }
public void testCloneWithNullObject() { [EOL] Serializable object = null; [EOL] Serializable clonedObject = SerializationUtils.clone(object); [EOL] assertNull(clonedObject); [EOL] }
public void testCloneWithValidObject() throws Exception { [EOL] Serializable object = new SerializableObject(); [EOL] Serializable clonedObject = SerializationUtils.clone(object); [EOL] assertNotNull(clonedObject); [EOL] assertNotSame(object, clonedObject); [EOL] assertEquals(object, clonedObject); [EOL] }
public void testCloneWithIOException() { [EOL] Serializable object = new SerializableObject() { [EOL] private void writeObject(java.io.ObjectOutputStream out) throws IOException { [EOL] throw new IOException("Forced IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] SerializationUtils.clone(object); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof IOException); [EOL] } [EOL] }
public void testCloneWithClassNotFoundException() { [EOL] Serializable object = new SerializableObject() { [EOL] private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL] throw new ClassNotFoundException("Forced ClassNotFoundException"); [EOL] } [EOL] }; [EOL] try { [EOL] SerializationUtils.clone(object); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassNotFoundException); [EOL] } [EOL] }
public void testToIntValueWithNonAsciiNumeric() { [EOL] final int defaultValue = 5; [EOL] final char nonAsciiNumeric = 'a'; [EOL] int result = toIntValue(nonAsciiNumeric, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testToIntValueWithAsciiNumeric() { [EOL] final int defaultValue = 5; [EOL] final char asciiNumeric = '1'; [EOL] int result = toIntValue(asciiNumeric, defaultValue); [EOL] assertEquals(1, result); [EOL] }
public void testToIntValue_WithNullCharacter() { [EOL] int defaultValue = 5; [EOL] int result = StringUtils.toIntValue(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testToIntValue_WithValidCharacter() { [EOL] char validChar = 'A'; [EOL] int defaultValue = 0; [EOL] int expectedValue = (int) validChar; [EOL] int result = StringUtils.toIntValue(validChar, defaultValue); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testToString_withAsciiChar() { [EOL] char ch = 'A'; // ASCII character [EOL] String result = StringUtils.toString(ch); [EOL] assertEquals("A", result); [EOL] }
public void testToString_withNonAsciiChar() { [EOL] char ch = '\u0100'; // Non-ASCII character [EOL] String result = StringUtils.toString(ch); [EOL] assertEquals("\u0100", result); [EOL] }
public void testUnicodeEscapedWithCharLessThan16() { [EOL] char ch = 0x000F; // char value less than 0x10 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u000f", result); [EOL] }
public void testUnicodeEscapedWithCharLessThan256() { [EOL] char ch = 0x00FF; // char value less than 0x100 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u00ff", result); [EOL] }
public void testUnicodeEscapedWithCharLessThan4096() { [EOL] char ch = 0x0FFF; // char value less than 0x1000 [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\u0fff", result); [EOL] }
public void testUnicodeEscapedWithCharGreaterThan4095() { [EOL] char ch = 0xFFFF; // char value greater than 0x0FFF [EOL] String result = StringUtils.unicodeEscaped(ch); [EOL] assertEquals("\\uffff", result); [EOL] }
public void testIsAscii_CharInRange() { [EOL] assertTrue(StringUtils.isAscii('A')); [EOL] assertTrue(StringUtils.isAscii(' ')); [EOL] assertTrue(StringUtils.isAscii('z')); [EOL] }
public void testIsAscii_CharNotInRange() { [EOL] assertFalse(StringUtils.isAscii('é')); [EOL] assertFalse(StringUtils.isAscii('ÿ')); [EOL] assertFalse(StringUtils.isAscii('ø')); [EOL] }
public void testIsAscii_BoundaryValues() { [EOL] assertTrue(StringUtils.isAscii('\u0000')); [EOL] assertTrue(StringUtils.isAscii('\u007F')); [EOL] assertFalse(StringUtils.isAscii('\u0080')); [EOL] assertFalse(StringUtils.isAscii('\uFFFF')); [EOL] }
public void testIsAsciiPrintable_true() { [EOL] assertTrue(StringUtils.isAsciiPrintable('A')); [EOL] assertTrue(StringUtils.isAsciiPrintable('z')); [EOL] assertTrue(StringUtils.isAsciiPrintable('5')); [EOL] assertTrue(StringUtils.isAsciiPrintable(' ')); [EOL] }
public void testIsAsciiPrintable_false() { [EOL] assertFalse(StringUtils.isAsciiPrintable((char) 31)); [EOL] assertFalse(StringUtils.isAsciiPrintable((char) 127)); [EOL] }
public void testIsAsciiAlpha_withUpperCaseLetter() { [EOL] boolean result = StringUtils.isAsciiAlpha('A'); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAsciiAlpha_withLowerCaseLetter() { [EOL] boolean result = StringUtils.isAsciiAlpha('a'); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAsciiAlpha_withNonAlpha() { [EOL] boolean result = StringUtils.isAsciiAlpha('1'); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAsciiAlpha_withSpecialCharacter() { [EOL] boolean result = StringUtils.isAsciiAlpha('&'); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAsciiAlpha_withAsciiBoundaryCharacter() { [EOL] boolean upperBoundaryResult = StringUtils.isAsciiAlpha('Z'); [EOL] assertTrue(upperBoundaryResult); [EOL] boolean lowerBoundaryResult = StringUtils.isAsciiAlpha('z'); [EOL] assertTrue(lowerBoundaryResult); [EOL] } [EOL] public void testIsAsciiAlpha_withNonAsciiCharacter() { [EOL] boolean result = StringUtils.isAsciiAlpha('é'); [EOL] assertFalse(result); [EOL] }
public void testIsAsciiAlphaUpper_withUpperCaseLetters() { [EOL] assertTrue(StringUtils.isAsciiAlphaUpper('A')); [EOL] assertTrue(StringUtils.isAsciiAlphaUpper('Z')); [EOL] }
public void testIsAsciiAlphaUpper_withLowerCaseLetters() { [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('a')); [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('z')); [EOL] }
public void testIsAsciiAlphaUpper_withNonAlphaCharacters() { [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('0')); [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('@')); [EOL] }
public void testIsAsciiAlphaUpper_withBoundaryCharacters() { [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('/')); [EOL] assertTrue(StringUtils.isAsciiAlphaUpper('A')); [EOL] assertFalse(StringUtils.isAsciiAlphaUpper('[')); [EOL] }
public void testIsAsciiAlphaLower_withLowercaseLetters() { [EOL] assertTrue(StringUtils.isAsciiAlphaLower('a')); [EOL] assertTrue(StringUtils.isAsciiAlphaLower('m')); [EOL] assertTrue(StringUtils.isAsciiAlphaLower('z')); [EOL] }
public void testIsAsciiAlphaLower_withUppercaseLetters() { [EOL] assertFalse(StringUtils.isAsciiAlphaLower('A')); [EOL] assertFalse(StringUtils.isAsciiAlphaLower('M')); [EOL] assertFalse(StringUtils.isAsciiAlphaLower('Z')); [EOL] }
public void testIsAsciiAlphaLower_withNonAlphabeticCharacters() { [EOL] assertFalse(StringUtils.isAsciiAlphaLower('1')); [EOL] assertFalse(StringUtils.isAsciiAlphaLower('@')); [EOL] assertFalse(StringUtils.isAsciiAlphaLower(' ')); [EOL] }
public void testIsAsciiNumeric_withNumericChars() { [EOL] assertTrue(CharUtils.isAsciiNumeric('0')); [EOL] assertTrue(CharUtils.isAsciiNumeric('5')); [EOL] assertTrue(CharUtils.isAsciiNumeric('9')); [EOL] }
public void testIsAsciiNumeric_withNonNumericChars() { [EOL] assertFalse(CharUtils.isAsciiNumeric('a')); [EOL] assertFalse(CharUtils.isAsciiNumeric('A')); [EOL] assertFalse(CharUtils.isAsciiNumeric('/')); [EOL] assertFalse(CharUtils.isAsciiNumeric(':')); [EOL] }
public void testRangeConstructorWithNullElements() { [EOL] try { [EOL] new Range<>(null, "element2", Comparator.naturalOrder()); [EOL] fail("Should have thrown IllegalArgumentException for null element1"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] try { [EOL] new Range<>("element1", null, Comparator.naturalOrder()); [EOL] fail("Should have thrown IllegalArgumentException for null element2"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testRangeConstructorWithNullComparator() { [EOL] Range<String> range = new Range<>("element1", "element2", null); [EOL] assertNotNull("Comparator should default to ComparableComparator", range.comparator); [EOL] }
public void testRangeConstructorWithNaturalOrder() { [EOL] Range<Integer> range = new Range<>(1, 2, Comparator.naturalOrder()); [EOL] assertEquals("Minimum should be 1", Integer.valueOf(1), range.minimum); [EOL] assertEquals("Maximum should be 2", Integer.valueOf(2), range.maximum); [EOL] }
public void testRangeConstructorWithReverseOrder() { [EOL] Range<Integer> range = new Range<>(2, 1, Comparator.reverseOrder()); [EOL] assertEquals("Minimum should be 1 with reverse comparator", Integer.valueOf(1), range.minimum); [EOL] assertEquals("Maximum should be 2 with reverse comparator", Integer.valueOf(2), range.maximum); [EOL] }
public Comparator<T> getComparator() { [EOL] return comparator; [EOL] }
public void testIsNaturalOrderingTrue() { [EOL] ComparableComparator<?> instance = ComparableComparator.INSTANCE; [EOL] Range<?> range = Range.between(instance, instance); [EOL] assertTrue(range.isNaturalOrdering()); [EOL] }
public void testIsNaturalOrderingFalse() { [EOL] Comparator<?> customComparator = (o1, o2) -> 0; [EOL] Range<?> range = Range.between(customComparator, customComparator); [EOL] assertFalse(range.isNaturalOrdering()); [EOL] }
public void testIsOverlappedBy_NullRange() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] boolean result = range.isOverlappedBy(null); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeBefore() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(1, 4); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeAfter() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(11, 15); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeOverlapAtStart() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(3, 6); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeOverlapAtEnd() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(9, 12); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeInside() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(6, 9); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeContains() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(4, 11); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeExact() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(5, 10); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeRange_NullRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean result = range.isBeforeRange(null); [EOL] assertFalse(result); [EOL] }
public void testIsBeforeRange_BeforeRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(11, 15); [EOL] boolean result = range.isBeforeRange(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeRange_NotBeforeRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(3, 7); [EOL] boolean result = range.isBeforeRange(otherRange); [EOL] assertFalse(result); [EOL] }
public void testIntersectionWith_NonOverlappingRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(6, 10); [EOL] try { [EOL] range1.intersectionWith(range2); [EOL] fail("Expected IllegalArgumentException for non-overlapping ranges"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntersectionWith_EqualRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 5); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] assertEquals(range1, result); [EOL] }
public void testIntersectionWith_OverlappingRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(3, 7); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] Range<Integer> expected = Range.between(3, 5); [EOL] assertEquals(expected, result); [EOL] }
public void testIntersectionWith_ContainedRange() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(2, 4); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] assertEquals(range2, result); [EOL] }
public void testEquals_SameObject() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertTrue(range.equals(range)); [EOL] }
public void testEquals_Null() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertFalse(range.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] assertFalse(range.equals(new Object())); [EOL] }
public void testEquals_EqualRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 5); [EOL] assertTrue(range1.equals(range2)); [EOL] }
public void testEquals_NotEqualRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 6); [EOL] assertFalse(range1.equals(range2)); [EOL] }
public void testToStringExcludeWithNullObject() { [EOL] String result = StringUtils.toStringExclude(null, Collections.singletonList("id")); [EOL] assertNull(result); [EOL] }
public void testToStringExcludeWithEmptyExcludeFields() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.toStringExclude(object, Collections.emptyList()); [EOL] assertNotNull(result); [EOL] }
public void testToStringExcludeWithNonNullObjectAndFields() { [EOL] Object object = new ExampleObject(); // ExampleObject should be a valid object in your project [EOL] String result = StringUtils.toStringExclude(object, Collections.singletonList("fieldName")); [EOL] assertNotNull(result); [EOL] assertFalse(result.contains("fieldName=")); [EOL] }
public void testToNoNullStringArrayWithNullCollection() { [EOL] String[] result = toNoNullStringArray(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testToNoNullStringArrayWithNonNullCollection() { [EOL] Collection<String> collection = new ArrayList<>(); [EOL] collection.add("String1"); [EOL] collection.add("String2"); [EOL] collection.add(null); [EOL] String[] result = toNoNullStringArray(collection); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("String1", result[0]); [EOL] assertEquals("String2", result[1]); [EOL] assertNull(result[2]); [EOL] }
protected void appendFieldsIn(final Class<?> clazz) { [EOL] if (clazz.isArray()) { [EOL] this.reflectionAppendArray(this.getObject()); [EOL] return; [EOL] } [EOL] final Field[] fields = clazz.getDeclaredFields(); [EOL] AccessibleObject.setAccessible(fields, true); [EOL] for (final Field field : fields) { [EOL] final String fieldName = field.getName(); [EOL] if (this.accept(field)) { [EOL] try { [EOL] final Object fieldValue = this.getValue(field); [EOL] this.append(fieldName, fieldValue); [EOL] } catch (final IllegalAccessException ex) { [EOL] throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL] } [EOL] } [EOL] } [EOL] }
public void testReflectionAppendArrayWithNullArray() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] ReflectionToStringBuilder result = builder.reflectionAppendArray(null); [EOL] assertNotNull(result); [EOL] assertEquals(builder, result); [EOL] }
public void testReflectionAppendArrayWithNonNullArray() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] Object[] array = new Object[] { "element1", "element2" }; [EOL] ReflectionToStringBuilder result = builder.reflectionAppendArray(array); [EOL] assertNotNull(result); [EOL] assertEquals(builder, result); [EOL] assertTrue(result.toString().contains("element1")); [EOL] assertTrue(result.toString().contains("element2")); [EOL] }
public void testMutableLongConstructor() { [EOL] MutableLong mutLong = new MutableLong(); [EOL] assertNotNull(mutLong); [EOL] assertEquals(0L, mutLong.longValue()); [EOL] }
public void testMutableLongConstructor() { [EOL] long initialValue = 10L; [EOL] MutableLong mutableLong = new MutableLong(initialValue); [EOL] assertEquals(initialValue, mutableLong.longValue()); [EOL] }
public void testMutableLongConstructorWithNegativeValue() { [EOL] long initialValue = -10L; [EOL] MutableLong mutableLong = new MutableLong(initialValue); [EOL] assertEquals(initialValue, mutableLong.longValue()); [EOL] }
public void testMutableLongConstructorWithZeroValue() { [EOL] long initialValue = 0L; [EOL] MutableLong mutableLong = new MutableLong(initialValue); [EOL] assertEquals(initialValue, mutableLong.longValue()); [EOL] }
public void testMutableLongWithNull() { [EOL] try { [EOL] new MutableLong(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableLongWithLong() { [EOL] final long longValue = 123L; [EOL] MutableLong mutLong = new MutableLong(longValue); [EOL] assertEquals(longValue, mutLong.longValue()); [EOL] }
public void testMutableLongWithInteger() { [EOL] final int intValue = 123; [EOL] MutableLong mutLong = new MutableLong(intValue); [EOL] assertEquals((long) intValue, mutLong.longValue()); [EOL] }
public void testMutableLongWithShort() { [EOL] final short shortValue = 123; [EOL] MutableLong mutLong = new MutableLong(shortValue); [EOL] assertEquals((long) shortValue, mutLong.longValue()); [EOL] }
public void testMutableLongWithByte() { [EOL] final byte byteValue = 123; [EOL] MutableLong mutLong = new MutableLong(byteValue); [EOL] assertEquals((long) byteValue, mutLong.longValue()); [EOL] }
public void testMutableLongWithValidString() { [EOL] String validString = "12345"; [EOL] MutableLong mutableLong = new MutableLong(validString); [EOL] assertEquals(12345L, mutableLong.longValue()); [EOL] }
public void testMutableLongWithInvalidString() { [EOL] String invalidString = "invalid"; [EOL] try { [EOL] new MutableLong(invalidString); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMutableLongWithNullString() { [EOL] try { [EOL] new MutableLong(null); [EOL] fail("Should have thrown NumberFormatException for null input"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testAdd_PositiveOperand() { [EOL] MutableLong mutableLong = new MutableLong(1); [EOL] mutableLong.add(1); [EOL] assertEquals(2, mutableLong.value); [EOL] }
public void testAdd_NegativeOperand() { [EOL] MutableLong mutableLong = new MutableLong(1); [EOL] mutableLong.add(-1); [EOL] assertEquals(0, mutableLong.value); [EOL] }
public void testAdd_ZeroOperand() { [EOL] MutableLong mutableLong = new MutableLong(1); [EOL] mutableLong.add(0); [EOL] assertEquals(1, mutableLong.value); [EOL] }
public void testLongValue_Positive() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(5L, result); [EOL] }
public void testLongValue_Negative() { [EOL] MutableLong mutableLong = new MutableLong(-5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(-5L, result); [EOL] }
public void testLongValue_Zero() { [EOL] MutableLong mutableLong = new MutableLong(0); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testMutableIntConstructor() { [EOL] MutableInt mutInt = new MutableInt(); [EOL] assertNotNull(mutInt); [EOL] assertEquals(0, mutInt.intValue()); [EOL] }
public void testMutableIntWithNull() { [EOL] try { [EOL] new MutableInt(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableIntWithInteger() { [EOL] final int testValue = 5; [EOL] MutableInt mutInt = new MutableInt(testValue); [EOL] assertEquals("The value must be equal to the integer provided", testValue, mutInt.intValue()); [EOL] }
public void testMutableIntWithLong() { [EOL] final long testValue = 5L; [EOL] MutableInt mutInt = new MutableInt(testValue); [EOL] assertEquals("The value must be equal to the long provided", (int) testValue, mutInt.intValue()); [EOL] }
public void testMutableIntWithShort() { [EOL] final short testValue = 5; [EOL] MutableInt mutInt = new MutableInt(testValue); [EOL] assertEquals("The value must be equal to the short provided", (int) testValue, mutInt.intValue()); [EOL] }
public void testMutableIntWithByte() { [EOL] final byte testValue = 5; [EOL] MutableInt mutInt = new MutableInt(testValue); [EOL] assertEquals("The value must be equal to the byte provided", (int) testValue, mutInt.intValue()); [EOL] }
public void testMutableIntWithValidNumberString() { [EOL] MutableInt mutableInt = new MutableInt("123"); [EOL] assertEquals(123, mutableInt.intValue()); [EOL] }
public void testMutableIntWithInvalidNumberString() { [EOL] try { [EOL] new MutableInt("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testAdd_PositiveOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.add(10); [EOL] assertEquals(15, mutableInt.intValue()); [EOL] }
public void testAdd_NegativeOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.add(-10); [EOL] assertEquals(-5, mutableInt.intValue()); [EOL] }
public void testAdd_ZeroOperand() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.add(0); [EOL] assertEquals(5, mutableInt.intValue()); [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(123); [EOL] int expected = 123; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testObjectUtilsConstructor() { [EOL] new ObjectUtils(); [EOL] }
public void testIdentityToStringWithNonNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] identityToString(buffer, object); [EOL] String expected = object.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object)); [EOL] assertTrue(buffer.toString().equals(expected)); [EOL] }
public void testIdentityToStringWithNullObject() { [EOL] try { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] identityToString(buffer, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Cannot get the toString of a null identity", e.getMessage()); [EOL] } [EOL] }
public void testMode_withNotEmptyArrayShouldReturnMostFrequentElement() { [EOL] Integer[] array = {1, 2, 2, 3}; [EOL] Integer result = ArrayUtils.mode(array); [EOL] assertEquals(Integer.valueOf(2), result); [EOL] } [EOL] public void testMode_withEmptyArrayShouldReturnNull() { [EOL] Integer[] array = {}; [EOL] Integer result = ArrayUtils.mode(array); [EOL] assertNull(result); [EOL] } [EOL] public void testMode_withNullArrayShouldReturnNull() { [EOL] Integer[] array = null; [EOL] Integer result = ArrayUtils.mode(array); [EOL] assertNull(result); [EOL] } [EOL] public void testMode_withAllElementsUniqueShouldReturnNull() { [EOL] Integer[] array = {1, 2, 3, 4}; [EOL] Integer result = ArrayUtils.mode(array); [EOL] assertNull(result); [EOL] } [EOL] public void testMode_withMultipleMostFrequentElementsShouldReturnNull() { [EOL] Integer[] array = {1, 1, 2, 2}; [EOL] Integer result = ArrayUtils.mode(array); [EOL] assertNull(result); [EOL] }

public void testCloneWithCloneableArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testCloneWithPrimitiveArray() { [EOL] int[] array = new int[]{1, 2, 3}; [EOL] int[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testCloneWithNonCloneable() { [EOL] Object obj = new Object(); [EOL] Object clonedObj = ObjectUtils.clone(obj); [EOL] assertNull(clonedObj); [EOL] }
public void testCloneWithCloneable() throws Exception { [EOL] CloneableTestClass testClass = new CloneableTestClass(); [EOL] CloneableTestClass clonedTestClass = ObjectUtils.clone(testClass); [EOL] assertNotSame(testClass, clonedTestClass); [EOL] assertEquals(testClass, clonedTestClass); [EOL] }
public void testCloneWithCloneableThrowingException() { [EOL] CloneableThrowingTestClass testClass = new CloneableThrowingTestClass(); [EOL] try { [EOL] ObjectUtils.clone(testClass); [EOL] fail("Should have thrown CloneFailedException"); [EOL] } catch (CloneFailedException e) { [EOL] } [EOL] } [EOL] class CloneableTestClass implements Cloneable { [EOL] private int value; [EOL] public CloneableTestClass() { [EOL] this.value = 0; [EOL] } [EOL] public void setValue(int value) { [EOL] this.value = value; [EOL] } [EOL] @Override [EOL] public boolean equals(Object obj) { [EOL] if (this == obj) return true; [EOL] if (obj == null || getClass() != obj.getClass()) return false; [EOL] CloneableTestClass that = (CloneableTestClass) obj; [EOL] return value == that.value; [EOL] } [EOL] @Override [EOL] protected Object clone() throws CloneNotSupportedException { [EOL] return super.clone(); [EOL] } [EOL] } [EOL] class CloneableThrowingTestClass implements Cloneable { [EOL] @Override [EOL] protected Object clone() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException("Cannot clone"); [EOL] } [EOL] }
public void testCloneFailedExceptionWithMessageAndCause() { [EOL] String expectedMessage = "Clone failed"; [EOL] Throwable expectedCause = new Exception("Error occurred"); [EOL] CloneFailedException exception = new CloneFailedException(expectedMessage, expectedCause); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] assertEquals(expectedCause, exception.getCause()); [EOL] }
public void testNotEmptyWithNullCollection() { [EOL] try { [EOL] Collection<?> result = Validate.notEmpty(null, "Collection must not be null"); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Collection must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNotEmptyWithEmptyCollection() { [EOL] try { [EOL] Collection<?> emptyCollection = new ArrayList<>(); [EOL] Collection<?> result = Validate.notEmpty(emptyCollection, "Collection must not be empty"); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Collection must not be empty", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNotEmptyWithNonEmptyCollection() { [EOL] Collection<String> nonEmptyCollection = new ArrayList<>(); [EOL] nonEmptyCollection.add("item"); [EOL] Collection<?> result = Validate.notEmpty(nonEmptyCollection, "Collection must not be empty"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testNotEmptyWithNonEmptyCollection() { [EOL] List<String> collection = new ArrayList<>(); [EOL] collection.add("item"); [EOL] Collection<?> result = CollectionUtils.notEmpty(collection); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testNotEmptyWithEmptyCollection() { [EOL] List<String> collection = new ArrayList<>(); [EOL] try { [EOL] CollectionUtils.notEmpty(collection); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testNotEmptyWithNullCollection() { [EOL] try { [EOL] CollectionUtils.notEmpty(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testNotEmptyWithNullMap() { [EOL] try { [EOL] Map<?, ?> result = notEmpty(null, "Map must not be null"); [EOL] fail("NullPointerException expected"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Map must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyWithEmptyMap() { [EOL] try { [EOL] Map<?, ?> emptyMap = new HashMap<>(); [EOL] Map<?, ?> result = notEmpty(emptyMap, "Map must not be empty"); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Map must not be empty", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyWithNonEmptyMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] map.put("key", "value"); [EOL] Map<?, ?> result = notEmpty(map, "Map should not be empty"); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testNotEmptyWithNonEmptyMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] map.put("key", "value"); [EOL] Map<String, String> result = MapUtils.notEmpty(map); [EOL] assertNotNull(result); [EOL] assertEquals(map, result); [EOL] } [EOL] public void testNotEmptyWithEmptyMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] try { [EOL] MapUtils.notEmpty(map); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testNotEmptyWithNullMap() { [EOL] try { [EOL] MapUtils.notEmpty(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testNotBlank_NullInput_ThrowsNullPointerException() { [EOL] String message = "The char sequence must not be null"; [EOL] try { [EOL] StringUtils.notBlank(null, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals(message, e.getMessage()); [EOL] } [EOL] }
public void testNotBlank_BlankInput_ThrowsIllegalArgumentException() { [EOL] String message = "The char sequence must not be blank"; [EOL] try { [EOL] StringUtils.notBlank(" ", message); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(message, e.getMessage()); [EOL] } [EOL] }
public void testNotBlank_NonBlankInput_ReturnsInput() { [EOL] String input = "abc"; [EOL] String result = StringUtils.notBlank(input, "The char sequence must not be blank"); [EOL] assertEquals(input, result); [EOL] }
public void testNotBlankWithNull() { [EOL] try { [EOL] StringUtils.notBlank(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The validated character sequence must not be blank", ex.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithEmptyString() { [EOL] try { [EOL] StringUtils.notBlank(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The validated character sequence must not be blank", ex.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithWhitespace() { [EOL] try { [EOL] StringUtils.notBlank("   "); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The validated character sequence must not be blank", ex.getMessage()); [EOL] } [EOL] }
public void testNotBlankWithValidString() { [EOL] String result = StringUtils.notBlank("abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testNoNullElementsWithNonNullIterable() { [EOL] List<String> list = Arrays.asList("a", "b", "c"); [EOL] List<String> result = Validate.noNullElements(list, "List must not contain null elements"); [EOL] assertSame("Result must be the same as input list", list, result); [EOL] }
public void testNoNullElementsWithNullElement() { [EOL] List<String> listWithNull = Arrays.asList("a", null, "c"); [EOL] try { [EOL] Validate.noNullElements(listWithNull, "List must not contain null elements at index: %d", 1); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("List must not contain null elements at index: 1", e.getMessage()); [EOL] } [EOL] }
public void testNoNullElementsWithNullIterable() { [EOL] try { [EOL] Validate.noNullElements(null, "Iterable must not be null"); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The validated object is null", e.getMessage()); [EOL] } [EOL] }
public void testNoNullElementsWithNonNullCollection() { [EOL] List<String> inputList = Arrays.asList("a", "b", "c"); [EOL] List<String> result = IterableUtils.noNullElements(inputList); [EOL] assertNotNull(result); [EOL] assertEquals(inputList, result); [EOL] }
public void testNoNullElementsWithNullCollection() { [EOL] List<String> inputList = null; [EOL] try { [EOL] IterableUtils.noNullElements(inputList); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testNoNullElementsWithCollectionContainingNull() { [EOL] List<String> inputList = Arrays.asList("a", null, "c"); [EOL] try { [EOL] IterableUtils.noNullElements(inputList); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMatchesPattern_ValidPattern() { [EOL] String input = "123abc"; [EOL] String pattern = "\\d+\\w+"; [EOL] matchesPattern(input, pattern, "Pattern did not match"); [EOL] }
public void testMatchesPattern_InvalidPattern_ThrowsException() { [EOL] String input = "123abc"; [EOL] String pattern = "\\d+"; [EOL] try { [EOL] matchesPattern(input, pattern, "Pattern did not match"); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Pattern did not match", e.getMessage()); [EOL] } [EOL] }
public void testMatchesPattern_NullInput_ThrowsException() { [EOL] String pattern = "\\d+"; [EOL] try { [EOL] matchesPattern(null, pattern, "Input should not be null"); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Input should not be null", e.getMessage()); [EOL] } [EOL] }
public void testMatchesPattern_NullPattern_ThrowsException() { [EOL] String input = "123abc"; [EOL] try { [EOL] matchesPattern(input, null, "Pattern should not be null"); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMatchesPattern_WithMessageAndValues() { [EOL] String input = "123abc"; [EOL] String pattern = "\\d+"; [EOL] try { [EOL] matchesPattern(input, pattern, "Expected %s but was %s", pattern, input); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected \\d+ but was 123abc", e.getMessage()); [EOL] } [EOL] }
public void testInclusiveBetween_WithinBounds() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 3; [EOL] RangeUtils.inclusiveBetween(start, end, value); [EOL] }
public void testInclusiveBetween_BelowLowerBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 0; [EOL] try { [EOL] RangeUtils.inclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 0 is not in the specified inclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] }
public void testInclusiveBetween_AboveUpperBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 6; [EOL] try { [EOL] RangeUtils.inclusiveBetween(start, end, value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The value 6 is not in the specified inclusive range of 1 to 5", ex.getMessage()); [EOL] } [EOL] }
public void testInclusiveBetween_AtLowerBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 1; [EOL] RangeUtils.inclusiveBetween(start, end, value); [EOL] }
public void testInclusiveBetween_AtUpperBound() { [EOL] Integer start = 1; [EOL] Integer end = 5; [EOL] Integer value = 5; [EOL] RangeUtils.inclusiveBetween(start, end, value); [EOL] }
public void testIsAssignableFrom_WithAssignableClasses_ShouldPass() { [EOL] Class<?> superType = Number.class; [EOL] Class<?> type = Integer.class; [EOL] String message = "Type %s is not assignable from %s"; [EOL] isAssignableFrom(superType, type, message, type.getSimpleName(), superType.getSimpleName()); [EOL] } [EOL] public void testIsAssignableFrom_WithNonAssignableClasses_ShouldThrowException() { [EOL] try { [EOL] Class<?> superType = String.class; [EOL] Class<?> type = Integer.class; [EOL] String message = "Type %s is not assignable from %s"; [EOL] isAssignableFrom(superType, type, message, type.getSimpleName(), superType.getSimpleName()); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Type Integer is not assignable from String", e.getMessage()); [EOL] } [EOL] } [EOL] public void testIsAssignableFrom_WithNullSuperType_ShouldThrowException() { [EOL] try { [EOL] Class<?> superType = null; [EOL] Class<?> type = Integer.class; [EOL] String message = "SuperType cannot be null"; [EOL] isAssignableFrom(superType, type, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testIsAssignableFrom_WithNullType_ShouldThrowException() { [EOL] try { [EOL] Class<?> superType = Number.class; [EOL] Class<?> type = null; [EOL] String message = "Type cannot be null"; [EOL] isAssignableFrom(superType, type, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testIsAssignableFrom_WithNullMessage_ShouldThrowException() { [EOL] try { [EOL] Class<?> superType = Number.class; [EOL] Class<?> type = Integer.class; [EOL] String message = null; [EOL] isAssignableFrom(superType, type, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testHashCodeWhenValueIsTrue() { [EOL] BooleanValue booleanValue = new BooleanValue(true); [EOL] int expectedHashCode = Boolean.TRUE.hashCode(); [EOL] int actualHashCode = booleanValue.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWhenValueIsFalse() { [EOL] BooleanValue booleanValue = new BooleanValue(false); [EOL] int expectedHashCode = Boolean.FALSE.hashCode(); [EOL] int actualHashCode = booleanValue.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testFormatDurationISO_Zero() { [EOL] String result = DurationFormatUtils.formatDurationISO(0L); [EOL] assertEquals("PT0S", result); [EOL] }
public void testFormatDurationISO_Positive() { [EOL] String result = DurationFormatUtils.formatDurationISO(1234L); [EOL] assertEquals("PT1.234S", result); [EOL] }
public void testFormatDurationISO_Negative() { [EOL] String result = DurationFormatUtils.formatDurationISO(-1234L); [EOL] assertEquals("-PT1.234S", result); [EOL] }
public void testFormatDurationWithDefaultLocale() { [EOL] long durationMillis = 5000; [EOL] String format = "H:mm:ss.SSS"; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format); [EOL] assertEquals("0:00:05.000", result); [EOL] }
public void testFormatDurationWithCustomFormat() { [EOL] long durationMillis = 1000; [EOL] String format = "ss 'seconds'"; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format); [EOL] assertEquals("01 seconds", result); [EOL] }
public void testFormatDurationWithNegativeDuration() { [EOL] long durationMillis = -1000; [EOL] String format = "ss 'seconds'"; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format); [EOL] assertEquals("-01 seconds", result); [EOL] }
public void testFormatDurationWithDays() { [EOL] String format = "d 'days'"; [EOL] long durationMillis = 3 * DateUtils.MILLIS_PER_DAY; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("3 days", result); [EOL] }
public void testFormatDurationWithHours() { [EOL] String format = "H 'hours'"; [EOL] long durationMillis = 5 * DateUtils.MILLIS_PER_HOUR; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("5 hours", result); [EOL] }
public void testFormatDurationWithMinutes() { [EOL] String format = "m 'minutes'"; [EOL] long durationMillis = 30 * DateUtils.MILLIS_PER_MINUTE; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("30 minutes", result); [EOL] }
public void testFormatDurationWithSeconds() { [EOL] String format = "s 'seconds'"; [EOL] long durationMillis = 45 * DateUtils.MILLIS_PER_SECOND; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("45 seconds", result); [EOL] }
public void testFormatDurationWithMilliseconds() { [EOL] String format = "S 'milliseconds'"; [EOL] long durationMillis = 125; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("125 milliseconds", result); [EOL] }
public void testFormatDurationWithMixedUnits() { [EOL] String format = "d 'days' H 'hours' m 'minutes' s 'seconds' S 'milliseconds'"; [EOL] long durationMillis = 2 * DateUtils.MILLIS_PER_DAY + 3 * DateUtils.MILLIS_PER_HOUR + 4 * DateUtils.MILLIS_PER_MINUTE + 5 * DateUtils.MILLIS_PER_SECOND + 678; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("2 days 3 hours 4 minutes 5 seconds 678 milliseconds", result); [EOL] }
public void testFormatDurationWithPadding() { [EOL] String format = "HH 'hours' mm 'minutes' ss 'seconds'"; [EOL] long durationMillis = 1 * DateUtils.MILLIS_PER_HOUR + 9 * DateUtils.MILLIS_PER_MINUTE + 7 * DateUtils.MILLIS_PER_SECOND; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, true); [EOL] assertEquals("01 hours 09 minutes 07 seconds", result); [EOL] }
public void testFormatDurationWithoutPadding() { [EOL] String format = "H 'hours' m 'minutes' s 'seconds'"; [EOL] long durationMillis = 1 * DateUtils.MILLIS_PER_HOUR + 9 * DateUtils.MILLIS_PER_MINUTE + 7 * DateUtils.MILLIS_PER_SECOND; [EOL] String result = DurationFormatUtils.formatDuration(durationMillis, format, false); [EOL] assertEquals("1 hours 9 minutes 7 seconds", result); [EOL] }
public void testFormatDurationWords_ZeroMillis() { [EOL] String result = DurationFormatUtils.formatDurationWords(0L, true, true); [EOL] assertEquals("0 seconds", result); [EOL] }
public void testFormatDurationWords_OneSecond() { [EOL] String result = DurationFormatUtils.formatDurationWords(1000L, false, false); [EOL] assertEquals("0 days 0 hours 0 minutes 1 second", result); [EOL] }
public void testFormatDurationWords_OneMinuteOneSecond() { [EOL] String result = DurationFormatUtils.formatDurationWords(61000L, false, false); [EOL] assertEquals("0 days 0 hours 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_OneHourOneMinuteOneSecond() { [EOL] String result = DurationFormatUtils.formatDurationWords(3661000L, false, false); [EOL] assertEquals("0 days 1 hour 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_OneDayOneHourOneMinuteOneSecond() { [EOL] String result = DurationFormatUtils.formatDurationWords(90061000L, false, false); [EOL] assertEquals("1 day 1 hour 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_SuppressLeadingZeroElements() { [EOL] String result = DurationFormatUtils.formatDurationWords(90061000L, true, false); [EOL] assertEquals("1 day 1 hour 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_SuppressTrailingZeroElements() { [EOL] String result = DurationFormatUtils.formatDurationWords(90061000L, false, true); [EOL] assertEquals("1 day 1 hour 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_SuppressLeadingAndTrailingZeroElements() { [EOL] String result = DurationFormatUtils.formatDurationWords(90061000L, true, true); [EOL] assertEquals("1 day 1 hour 1 minute 1 second", result); [EOL] }
public void testFormatDurationWords_OnlySeconds() { [EOL] String result = DurationFormatUtils.formatDurationWords(2000L, true, true); [EOL] assertEquals("2 seconds", result); [EOL] }
public void testFormatDurationWords_OnlyMinutes() { [EOL] String result = DurationFormatUtils.formatDurationWords(120000L, true, true); [EOL] assertEquals("2 minutes", result); [EOL] }
public void testFormatDurationWords_OnlyHours() { [EOL] String result = DurationFormatUtils.formatDurationWords(7200000L, true, true); [EOL] assertEquals("2 hours", result); [EOL] }
public void testFormatDurationWords_OnlyDays() { [EOL] String result = DurationFormatUtils.formatDurationWords(172800000L, true, true); [EOL] assertEquals("2 days", result); [EOL] }
public void testFormatWithYears() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.y, 4) }; [EOL] String result = DurationFormatUtils.format(tokens, 2023, 0, 0, 0, 0, 0, 0, true); [EOL] assertEquals("2023", result); [EOL] }
public void testFormatWithMonths() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.M, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 12, 0, 0, 0, 0, 0, true); [EOL] assertEquals("12", result); [EOL] }
public void testFormatWithDays() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.d, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 31, 0, 0, 0, 0, true); [EOL] assertEquals("31", result); [EOL] }
public void testFormatWithHours() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.H, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 0, 23, 0, 0, 0, true); [EOL] assertEquals("23", result); [EOL] }
public void testFormatWithMinutes() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.m, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 0, 0, 59, 0, 0, true); [EOL] assertEquals("59", result); [EOL] }
public void testFormatWithSeconds() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.s, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 0, 0, 0, 59, 0, true); [EOL] assertEquals("59", result); [EOL] }
public void testFormatWithMillisecondsAndLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.s, 2), new Token(DurationFormatUtils.Token.S, 3) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 0, 0, 0, 1, 234, true); [EOL] assertEquals("01234", result); [EOL] }
public void testFormatWithMillisecondsWithoutLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.S, 3) }; [EOL] String result = DurationFormatUtils.format(tokens, 0, 0, 0, 0, 0, 0, 234, true); [EOL] assertEquals("234", result); [EOL] }
public void testFormatWithStringBuilderToken() { [EOL] Token[] tokens = new Token[] { new Token(new StringBuilder("prefix")), new Token(DurationFormatUtils.Token.y, 4) }; [EOL] String result = DurationFormatUtils.format(tokens, 2023, 0, 0, 0, 0, 0, 0, true); [EOL] assertEquals("prefix2023", result); [EOL] }
public void testFormatWithoutPadding() { [EOL] Token[] tokens = new Token[] { new Token(DurationFormatUtils.Token.y, 4), new Token(DurationFormatUtils.Token.M, 2) }; [EOL] String result = DurationFormatUtils.format(tokens, 2023, 1, 0, 0, 0, 0, 0, false); [EOL] assertEquals("20231", result); [EOL] }
public void testLexxEmptyString() { [EOL] Token[] tokens = lexx(""); [EOL] assertEquals(0, tokens.length); [EOL] }
public void testLexxSingleQuoteLiteral() { [EOL] Token[] tokens = lexx("'"); [EOL] assertEquals(1, tokens.length); [EOL] assertTrue(tokens[0].isLiteral()); [EOL] }
public void testLexxLiteralWithCharacters() { [EOL] Token[] tokens = lexx("'literal'"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals("literal", tokens[0].getValue()); [EOL] }
public void testLexxMultipleLiterals() { [EOL] Token[] tokens = lexx("lit1'lit2'lit3"); [EOL] assertEquals(3, tokens.length); [EOL] assertEquals("lit1", tokens[0].getValue()); [EOL] assertEquals("lit2", tokens[1].getValue()); [EOL] assertEquals("lit3", tokens[2].getValue()); [EOL] }
public void testLexxYearToken() { [EOL] Token[] tokens = lexx("y"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.YEAR, tokens[0].getType()); [EOL] }
public void testLexxMonthToken() { [EOL] Token[] tokens = lexx("M"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.MONTH, tokens[0].getType()); [EOL] }
public void testLexxDayToken() { [EOL] Token[] tokens = lexx("d"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.DAY, tokens[0].getType()); [EOL] }
public void testLexxHourToken() { [EOL] Token[] tokens = lexx("H"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.HOUR, tokens[0].getType()); [EOL] }
public void testLexxMinuteToken() { [EOL] Token[] tokens = lexx("m"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.MINUTE, tokens[0].getType()); [EOL] }
public void testLexxSecondToken() { [EOL] Token[] tokens = lexx("s"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.SECOND, tokens[0].getType()); [EOL] }
public void testLexxMillisecondToken() { [EOL] Token[] tokens = lexx("S"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.MILLISECOND, tokens[0].getType()); [EOL] }
public void testLexxUnrecognizedToken() { [EOL] Token[] tokens = lexx("x"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals("x", tokens[0].getValue()); [EOL] }
public void testLexxMixedTokens() { [EOL] Token[] tokens = lexx("yMdHmsS'literal'"); [EOL] assertEquals(8, tokens.length); [EOL] assertEquals(Token.Type.YEAR, tokens[0].getType()); [EOL] assertEquals(Token.Type.MONTH, tokens[1].getType()); [EOL] assertEquals(Token.Type.DAY, tokens[2].getType()); [EOL] assertEquals(Token.Type.HOUR, tokens[3].getType()); [EOL] assertEquals(Token.Type.MINUTE, tokens[4].getType()); [EOL] assertEquals(Token.Type.SECOND, tokens[5].getType()); [EOL] assertEquals(Token.Type.MILLISECOND, tokens[6].getType()); [EOL] assertEquals("literal", tokens[7].getValue()); [EOL] }
public void testLexxIncrementalToken() { [EOL] Token[] tokens = lexx("yyyy"); [EOL] assertEquals(1, tokens.length); [EOL] assertEquals(Token.Type.YEAR, tokens[0].getType()); [EOL] assertEquals(4, tokens[0].getCount()); [EOL] }
public void testContainsTokenWithValue_NullArray() { [EOL] Token[] tokens = null; [EOL] Object value = new Object(); [EOL] try { [EOL] boolean result = containsTokenWithValue(tokens, value); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testContainsTokenWithValue_EmptyArray() { [EOL] Token[] tokens = new Token[0]; [EOL] Object value = new Object(); [EOL] boolean result = containsTokenWithValue(tokens, value); [EOL] assertFalse("Empty array should return false", result); [EOL] }
public void testContainsTokenWithValue_TokenNotFound() { [EOL] Token[] tokens = new Token[] {new Token("value1"), new Token("value2")}; [EOL] Object value = "value3"; [EOL] boolean result = containsTokenWithValue(tokens, value); [EOL] assertFalse("Array without the token should return false", result); [EOL] }
public void testContainsTokenWithValue_TokenFound() { [EOL] Token token1 = new Token("value1"); [EOL] Token token2 = new Token("value2"); [EOL] Token[] tokens = new Token[] {token1, token2}; [EOL] Object value = "value2"; [EOL] boolean result = containsTokenWithValue(tokens, value); [EOL] assertTrue("Array containing the token should return true", result); [EOL] }
public void testContainsTokenWithValue_TokenWithNullValue() { [EOL] Token token1 = new Token(null); [EOL] Token token2 = new Token("value2"); [EOL] Token[] tokens = new Token[] {token1, token2}; [EOL] Object value = null; [EOL] boolean result = containsTokenWithValue(tokens, value); [EOL] assertTrue("Array containing the token with null value should return true", result); [EOL] }
public void testTokenConstructorWithNullValue() { [EOL] Token token = new Token(null); [EOL] assertNull(token.getValue()); [EOL] assertEquals(1, token.getCount()); [EOL] }
public void testTokenConstructorWithNonNullValue() { [EOL] Object testValue = new Object(); [EOL] Token token = new Token(testValue); [EOL] assertSame(testValue, token.getValue()); [EOL] assertEquals(1, token.getCount()); [EOL] }
public void testIncrementOnce() { [EOL] Counter counter = new Counter(); [EOL] counter.increment(); [EOL] assertEquals(1, counter.getCount()); [EOL] }
public void testIncrementMultipleTimes() { [EOL] Counter counter = new Counter(); [EOL] for (int i = 0; i < 5; i++) { [EOL] counter.increment(); [EOL] } [EOL] assertEquals(5, counter.getCount()); [EOL] }
public void testGetCount() { [EOL] MyClass myClassInstance = new MyClass(); [EOL] int expectedCount = 0; // Assuming count is initialized to 0 [EOL] int actualCount = myClassInstance.getCount(); [EOL] assertEquals(expectedCount, actualCount); [EOL] }
public void testGetValue() { [EOL] MyClass myClass = new MyClass(); [EOL] Object expectedValue = "expectedValue"; [EOL] myClass.setValue(expectedValue); [EOL] Object actualValue = myClass.getValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testCharSetUtilsConstructor() { [EOL] CharSetUtils charSetUtils = new CharSetUtils(); [EOL] }
public void testCountEmptyString() { [EOL] int result = StringUtils.count("", "a"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountEmptySet() { [EOL] int result = StringUtils.count("abc", new String[]{}); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountNullString() { [EOL] int result = StringUtils.count(null, "a"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountNullSet() { [EOL] int result = StringUtils.count("abc", (String[]) null); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountValidStringAndSet() { [EOL] int result = StringUtils.count("aabbcc", "a", "b"); [EOL] assertEquals(4, result); [EOL] } [EOL] public void testCountValidStringAndSetWithNonMatchingChars() { [EOL] int result = StringUtils.count("aabbcc", "x", "y"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountValidStringAndSetWithPartialMatch() { [EOL] int result = StringUtils.count("aabbcc", "b", "c"); [EOL] assertEquals(4, result); [EOL] }
public void testDeleteWithEmptyString() { [EOL] String result = StringUtils.delete("", "a"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testDeleteWithNullString() { [EOL] String result = StringUtils.delete(null, "a"); [EOL] assertNull(result); [EOL] } [EOL] public void testDeleteWithEmptySet() { [EOL] String result = StringUtils.delete("abc", new String[]{}); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testDeleteWithNullSet() { [EOL] String result = StringUtils.delete("abc", (String[]) null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testDeleteWithValidSet() { [EOL] String result = StringUtils.delete("aabbcc", "a", "b"); [EOL] assertEquals("cc", result); [EOL] }
public void testDeleteWithPartialMatchSet() { [EOL] String result = StringUtils.delete("aabbcc", "d"); [EOL] assertEquals("aabbcc", result); [EOL] }
public void testModifyWithEmptyStringAndEmptySetExpectTrue() { [EOL] String result = modify("", new String[]{}, true); [EOL] assertEquals("", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndEmptySetExpectTrue() { [EOL] String result = modify("abc", new String[]{}, true); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndEmptySetExpectFalse() { [EOL] String result = modify("abc", new String[]{}, false); [EOL] assertEquals("", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndNonEmptySetExpectTrue() { [EOL] String result = modify("abc", new String[]{"a"}, true); [EOL] assertEquals("a", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndNonEmptySetExpectFalse() { [EOL] String result = modify("abc", new String[]{"a"}, false); [EOL] assertEquals("bc", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndMultipleSetExpectTrue() { [EOL] String result = modify("abc", new String[]{"a", "b"}, true); [EOL] assertEquals("ab", result); [EOL] } [EOL] public void testModifyWithNonEmptyStringAndMultipleSetExpectFalse() { [EOL] String result = modify("abc", new String[]{"a", "b"}, false); [EOL] assertEquals("c", result); [EOL] } [EOL] public void testModifyWithSpecialCharactersAndSetExpectTrue() { [EOL] String result = modify("a1!b@c", new String[]{"1", "!"}, true); [EOL] assertEquals("1!", result); [EOL] } [EOL] public void testModifyWithSpecialCharactersAndSetExpectFalse() { [EOL] String result = modify("a1!b@c", new String[]{"1", "!"}, false); [EOL] assertEquals("abc", result); [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type) { [EOL] return indexOf(throwable, type, 0, true); [EOL] } [EOL] public ExceptionUtils(); [EOL] public static String[] getDefaultCauseMethodNames(); [EOL] public static Throwable getCause(final Throwable throwable); [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames); [EOL] public static Throwable getRootCause(final Throwable throwable); [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); [EOL] public static int getThrowableCount(final Throwable throwable); [EOL] public static Throwable[] getThrowables(final Throwable throwable); [EOL] public static List<Throwable> getThrowableList(Throwable throwable); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); [EOL] public static void printRootCauseStackTrace(final Throwable throwable); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable); [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); [EOL] public static String getStackTrace(final Throwable throwable); [EOL] public static String[] getStackFrames(final Throwable throwable); [EOL] static String[] getStackFrames(final String stackTrace); [EOL] static List<String> getStackFrameList(final Throwable t); [EOL] public static String getMessage(final Throwable th); [EOL] public static String getRootCauseMessage(final Throwable th); [EOL] String WRAPPED_MARKER=Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL] return indexOf(throwable, type, fromIndex, true); [EOL] } [EOL] public ExceptionUtils(); [EOL] public static String[] getDefaultCauseMethodNames(); [EOL] public static Throwable getCause(final Throwable throwable); [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames); [EOL] public static Throwable getRootCause(final Throwable throwable); [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); [EOL] public static int getThrowableCount(final Throwable throwable); [EOL] public static Throwable[] getThrowables(final Throwable throwable); [EOL] public static List<Throwable> getThrowableList(Throwable throwable); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); [EOL] public static void printRootCauseStackTrace(final Throwable throwable); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable); [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); [EOL] public static String getStackTrace(final Throwable throwable); [EOL] public static String[] getStackFrames(final Throwable throwable); [EOL] static String[] getStackFrames(final String stackTrace); [EOL] static List<String> getStackFrameList(final Throwable t); [EOL] public static String getMessage(final Throwable th); [EOL] public static String getRootCauseMessage(final Throwable th); [EOL] String WRAPPED_MARKER=Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testIndexOfThrowable_NullThrowable() { [EOL] int index = ExceptionUtils.indexOf(null, Throwable.class, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_NullType() { [EOL] Throwable throwable = new Throwable(); [EOL] int index = ExceptionUtils.indexOf(throwable, null, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_NegativeFromIndex() { [EOL] Throwable throwable = new Throwable(); [EOL] int index = ExceptionUtils.indexOf(throwable, Throwable.class, -1, false); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_FromIndexOutOfBounds() { [EOL] Throwable throwable = new Throwable(); [EOL] int index = ExceptionUtils.indexOf(throwable, Throwable.class, 1, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfThrowable_SubclassTrue() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Exception.class, 0, true); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_SubclassFalse_Positive() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, RuntimeException.class, 0, false); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOfThrowable_SubclassFalse_Negative() { [EOL] Throwable throwable = new RuntimeException(); [EOL] int index = ExceptionUtils.indexOf(throwable, Exception.class, 0, false); [EOL] assertEquals(-1, index); [EOL] }
public void testMutableShortWithNull() { [EOL] try { [EOL] new MutableShort(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableShortWithByteValue() { [EOL] byte byteValue = 1; [EOL] MutableShort mutableShort = new MutableShort(byteValue); [EOL] assertEquals("The value should be equal to the byte value", byteValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithShortValue() { [EOL] short shortValue = 2; [EOL] MutableShort mutableShort = new MutableShort(shortValue); [EOL] assertEquals("The value should be equal to the short value", shortValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithIntValue() { [EOL] int intValue = 3; [EOL] MutableShort mutableShort = new MutableShort(intValue); [EOL] assertEquals("The value should be equal to the int value", (short)intValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithLongValue() { [EOL] long longValue = 4L; [EOL] MutableShort mutableShort = new MutableShort(longValue); [EOL] assertEquals("The value should be equal to the long value", (short)longValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithFloatValue() { [EOL] float floatValue = 5.0f; [EOL] MutableShort mutableShort = new MutableShort(floatValue); [EOL] assertEquals("The value should be equal to the float value", (short)floatValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithDoubleValue() { [EOL] double doubleValue = 6.0; [EOL] MutableShort mutableShort = new MutableShort(doubleValue); [EOL] assertEquals("The value should be equal to the double value", (short)doubleValue, mutableShort.shortValue()); [EOL] }
public void testMutableShortWithValidString() { [EOL] MutableShort mutShort = new MutableShort("123"); [EOL] assertEquals(123, mutShort.shortValue()); [EOL] }
public void testMutableShortWithInvalidString() { [EOL] try { [EOL] new MutableShort("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMutableShortWithEmptyString() { [EOL] try { [EOL] new MutableShort(""); [EOL] fail("Should have thrown NumberFormatException for empty string"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMutableShortWithNull() { [EOL] try { [EOL] new MutableShort(null); [EOL] fail("Should have thrown NumberFormatException for null"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void addTestWithPositiveOperand() { [EOL] MutableShort mutableShort = new MutableShort((short) 5); [EOL] mutableShort.add((short) 3); [EOL] assertEquals(8, mutableShort.shortValue()); [EOL] }
public void addTestWithNegativeOperand() { [EOL] MutableShort mutableShort = new MutableShort((short) 5); [EOL] mutableShort.add((short) -3); [EOL] assertEquals(2, mutableShort.shortValue()); [EOL] }
public void addTestWithZeroOperand() { [EOL] MutableShort mutableShort = new MutableShort((short) 5); [EOL] mutableShort.add((short) 0); [EOL] assertEquals(5, mutableShort.shortValue()); [EOL] }
public void testAddWithPositiveOperand() { [EOL] MutableShort instance = new MutableShort((short)5); [EOL] instance.add((Number)10); [EOL] assertEquals((short)15, instance.shortValue()); [EOL] }
public void testAddWithNegativeOperand() { [EOL] MutableShort instance = new MutableShort((short)5); [EOL] instance.add((Number)(-10)); [EOL] assertEquals((short)(-5), instance.shortValue()); [EOL] }
public void testAddWithNullOperand() { [EOL] MutableShort instance = new MutableShort((short)5); [EOL] try { [EOL] instance.add(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testIntValue_PositiveValue() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(5, result); [EOL] }
public void testIntValue_NegativeValue() { [EOL] MutableInt mutableInt = new MutableInt(-5); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(-5, result); [EOL] }
public void testIntValue_ZeroValue() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] int result = mutableInt.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testStopWhenNotRunning() { [EOL] stopwatch.runningState = STATE_UNSTARTED; [EOL] try { [EOL] stopwatch.stop(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch is not running. ", e.getMessage()); [EOL] } [EOL] }
public void testStopWhenRunning() { [EOL] stopwatch.runningState = STATE_RUNNING; [EOL] stopwatch.stop(); [EOL] assertTrue(stopwatch.stopTime > 0); [EOL] assertEquals(STATE_STOPPED, stopwatch.runningState); [EOL] }
public void testStopWhenSuspended() { [EOL] stopwatch.runningState = STATE_SUSPENDED; [EOL] stopwatch.stop(); [EOL] assertEquals(STATE_STOPPED, stopwatch.runningState); [EOL] }
public void testSplit_WhenNotRunning_ShouldThrowIllegalStateException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.split(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch is not running. ", e.getMessage()); [EOL] } [EOL] }
public void testSplit_WhenRunning_ShouldUpdateSplitTime() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.split(); [EOL] long splitTime = stopwatch.getSplitTime(); [EOL] assertTrue(splitTime > 0); [EOL] assertEquals(Stopwatch.STATE_SPLIT, stopwatch.getSplitState()); [EOL] }
public void testUnsplitWhenNotSplit() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.unsplit(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException ex) { [EOL] assertEquals("Stopwatch has not been split. ", ex.getMessage()); [EOL] } [EOL] }
public void testUnsplitWhenSplit() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.split(); [EOL] try { [EOL] stopwatch.unsplit(); [EOL] assertEquals(Stopwatch.STATE_UNSPLIT, stopwatch.getSplitState()); [EOL] } catch (IllegalStateException ex) { [EOL] fail("Should not have thrown IllegalStateException"); [EOL] } [EOL] }
public void testGetSplitTimeWhenSplitNanoTimeIsPositive() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] Thread.sleep(10); [EOL] stopWatch.split(); [EOL] long splitTime = stopWatch.getSplitTime(); [EOL] assertTrue(splitTime >= 10); [EOL] }
public void testGetSplitTimeWhenSplitNanoTimeIsZero() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] stopWatch.split(); [EOL] long splitTime = stopWatch.getSplitTime(); [EOL] assertEquals(0, splitTime); [EOL] }
public void testGetSplitNanoTime_WhenNotSplit_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.getSplitNanoTime(); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException ex) { [EOL] assertEquals("Stopwatch must be split to get the split time. ", ex.getMessage()); [EOL] } [EOL] }
public void testGetSplitNanoTime_WhenSplit_ShouldReturnCorrectNanoTime() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] try { [EOL] Thread.sleep(10); [EOL] } catch (InterruptedException e) { [EOL] Thread.currentThread().interrupt(); [EOL] } [EOL] stopwatch.split(); [EOL] long expectedSplitTime = stopwatch.getSplitNanoTime(); [EOL] assertTrue(expectedSplitTime > 0); [EOL] }
public String toSplitString() { [EOL] return DurationFormatUtils.formatDurationHMS(getSplitTime()); [EOL] }
public void testReflectionCompare_BothObjectsNull_ThrowsNullPointerException() { [EOL] try { [EOL] int result = Lang3.reflectionCompare(null, null, false, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReflectionCompare_SameObject_ReturnsZero() { [EOL] Object obj = new Object(); [EOL] int result = Lang3.reflectionCompare(obj, obj, false, null); [EOL] assertEquals(0, result); [EOL] }
public void testReflectionCompare_FirstObjectNull_ThrowsNullPointerException() { [EOL] try { [EOL] Object rhs = new Object(); [EOL] int result = Lang3.reflectionCompare(null, rhs, false, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReflectionCompare_SecondObjectNull_ThrowsNullPointerException() { [EOL] try { [EOL] Object lhs = new Object(); [EOL] int result = Lang3.reflectionCompare(lhs, null, false, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReflectionCompare_ObjectsNotAssignable_ThrowsClassCastException() { [EOL] try { [EOL] Object lhs = new Object(); [EOL] String rhs = "test"; [EOL] int result = Lang3.reflectionCompare(lhs, rhs, false, null); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testReflectionCompare_WithExcludeFields() { [EOL] Object lhs = new SomeClass(); [EOL] Object rhs = new SomeClass(); [EOL] int result = Lang3.reflectionCompare(lhs, rhs, true, SomeClass.class, "excludedField"); [EOL] }
public void testReflectionCompare_WithCompareTransients() { [EOL] Object lhs = new SomeClassWithTransients(); [EOL] Object rhs = new SomeClassWithTransients(); [EOL] int result = Lang3.reflectionCompare(lhs, rhs, true, null); [EOL] }
public void testReflectionCompare_WithoutCompareTransients() { [EOL] Object lhs = new SomeClassWithTransients(); [EOL] Object rhs = new SomeClassWithTransients(); [EOL] int result = Lang3.reflectionCompare(lhs, rhs, false, null); [EOL] }
public void testReflectionCompare_ReflectUpToClass() { [EOL] Object lhs = new SomeSubClass(); [EOL] Object rhs = new SomeSubClass(); [EOL] int result = Lang3.reflectionCompare(lhs, rhs, false, SomeSuperClass.class); [EOL] }
public void testReflectionAppendWithAllFields() throws Exception { [EOL] final Object lhs = new TestObject(1); [EOL] final Object rhs = new TestObject(1); [EOL] final Class<?> clazz = TestObject.class; [EOL] final CompareToBuilder builder = new CompareToBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = {}; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testReflectionAppendWithExcludedFields() throws Exception { [EOL] final Object lhs = new TestObject(1); [EOL] final Object rhs = new TestObject(2); [EOL] final Class<?> clazz = TestObject.class; [EOL] final CompareToBuilder builder = new CompareToBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = {"value"}; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testReflectionAppendWithoutTransients() throws Exception { [EOL] final Object lhs = new TestObject(1); [EOL] final Object rhs = new TestObject(1); [EOL] final Class<?> clazz = TestObject.class; [EOL] final CompareToBuilder builder = new CompareToBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = {}; [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testReflectionAppendWithInaccessibleFields() throws Exception { [EOL] final Object lhs = new TestObject(1); [EOL] final Object rhs = new TestObject(1); [EOL] final Class<?> clazz = TestObjectWithPrivateField.class; [EOL] final CompareToBuilder builder = new CompareToBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = {}; [EOL] try { [EOL] reflectionAppend(lhs, rhs, clazz, builder, useTransients, excludeFields); [EOL] fail("Should have thrown InternalError"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testAppend_BothObjectsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, null, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LeftObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, new Object(), null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_RightObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(new Object(), null, null); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppend_BothObjectsSame() { [EOL] Object obj = new Object(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(obj, obj, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_WithComparator() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] Comparator<Object> comparator = Comparator.naturalOrder(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(comparator.compare(lhs, rhs), builder.toComparison()); [EOL] }
public void testAppend_WithoutComparator() { [EOL] Comparable<Object> lhs = "a"; [EOL] Comparable<Object> rhs = "b"; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(lhs.compareTo(rhs), builder.toComparison()); [EOL] }
public void testAppend_WithArray() { [EOL] long[] lhsArray = {1L, 2L, 3L}; [EOL] long[] rhsArray = {1L, 2L, 3L}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_WithDifferentArrayTypes() { [EOL] int[] lhsArray = {1, 2, 3}; [EOL] int[] rhsArray = {1, 2, 3}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_BothValuesEqual() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(5, 5); [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] } [EOL] public void testAppend_LeftLessThanRight() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(3, 5); [EOL] assertEquals(-1, compareToBuilder.toComparison()); [EOL] } [EOL] public void testAppend_LeftGreaterThanRight() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(10, 5); [EOL] assertEquals(1, compareToBuilder.toComparison()); [EOL] } [EOL] public void testAppend_ComparisonAlreadySet() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(5, 5); [EOL] compareToBuilder.append(10, 5); // This should not affect the comparison since it's already set to 0 [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] }

public void testAppend_ShortEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append((short)5, (short)5); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_ShortLessThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append((short)3, (short)5); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_ShortGreaterThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append((short)6, (short)5); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppend_ShortWithNonZeroComparison() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append((short)1, (short)1); [EOL] builder.append((short)2, (short)3); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendSameArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] array = new int[] {1, 2, 3}; [EOL] builder.append(array, array); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendDifferentLengthArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendDifferentArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 4}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendNonNullVsNullArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendNullVsNonNullArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = null; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendBothNullArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = null; [EOL] int[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendWithComparisonAlreadySet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); // This should not change the comparison since it's already set [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendShortArraysWithEqualArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = new short[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendShortArraysFirstArrayIsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = null; [EOL] short[] rhs = new short[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendShortArraysSecondArrayIsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendShortArraysFirstArrayIsShorter() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = new short[]{1, 2}; [EOL] short[] rhs = new short[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendShortArraysSecondArrayIsShorter() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = new short[]{1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendShortArraysDifferentElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = new short[]{1, 3, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.toComparison() == 0); [EOL] }
public void testAppendShortArraysWhenComparisonIsNonZero() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] short[] lhs = new short[]{1, 2, 3}; [EOL] short[] rhs = new short[]{1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.toComparison() == 0); [EOL] }
public void testBuildReturnsCorrectInteger() { [EOL] YourObjectUnderTest obj = new YourObjectUnderTest(); [EOL] Integer expected = Integer.valueOf(obj.toComparison()); [EOL] Integer result = obj.build(); [EOL] assertEquals(expected, result); [EOL] }
public void testIsNotEmpty_NullString() { [EOL] boolean result = StringUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyString() { [EOL] boolean result = StringUtils.isNotEmpty(""); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_WhitespaceString() { [EOL] boolean result = StringUtils.isNotEmpty(" "); [EOL] assertTrue(result); [EOL] }
public void testIsNotEmpty_NonEmptyString() { [EOL] boolean result = StringUtils.isNotEmpty("abc"); [EOL] assertTrue(result); [EOL] }
public void testStripToNull_NullInput() { [EOL] String input = null; [EOL] String result = StringUtils.stripToNull(input); [EOL] assertNull(result); [EOL] } [EOL] public void testStripToNull_EmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.stripToNull(input); [EOL] assertNull(result); [EOL] } [EOL] public void testStripToNull_OnlyWhitespaces() { [EOL] String input = "   "; [EOL] String result = StringUtils.stripToNull(input); [EOL] assertNull(result); [EOL] } [EOL] public void testStripToNull_NonEmptyString() { [EOL] String input = " abc "; [EOL] String result = StringUtils.stripToNull(input); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }

public void testStripToEmpty_NullInput() { [EOL] String result = StringUtils.stripToEmpty(null); [EOL] assertEquals("", result); [EOL] }
public void testStripToEmpty_EmptyInput() { [EOL] String result = StringUtils.stripToEmpty(""); [EOL] assertEquals("", result); [EOL] }
public void testStripToEmpty_WhitespaceInput() { [EOL] String result = StringUtils.stripToEmpty("   "); [EOL] assertEquals("", result); [EOL] }
public void testStripToEmpty_NonEmptyInput() { [EOL] String result = StringUtils.stripToEmpty("  abc  "); [EOL] assertEquals("abc", result); [EOL] }
public void testStripAccents_nullInput() { [EOL] String input = null; [EOL] String result = StringUtils.stripAccents(input); [EOL] assertNull(result); [EOL] }
public void testStripAccents_emptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.stripAccents(input); [EOL] assertEquals("", result); [EOL] }
public void testStripAccents_noAccents() { [EOL] String input = "test"; [EOL] String result = StringUtils.stripAccents(input); [EOL] assertEquals("test", result); [EOL] }
public void testStripAccents_withAccents() { [EOL] String input = "tést"; [EOL] String result = StringUtils.stripAccents(input); [EOL] assertEquals("test", result); [EOL] }
public void testStripAccents_allAccents() { [EOL] String input = "àáâãäåçèéêëìíîïðñòóôõöùúûüýÿ"; [EOL] String result = StringUtils.stripAccents(input); [EOL] assertEquals("aaaaaaceeeeiiiidnoooooouuuuyy", result); [EOL] }
public void testEqualsIgnoreCase_BothNull() { [EOL] boolean result = StringUtils.equalsIgnoreCase(null, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testEqualsIgnoreCase_FirstNull() { [EOL] boolean result = StringUtils.equalsIgnoreCase(null, "abc"); [EOL] assertFalse(result); [EOL] } [EOL] public void testEqualsIgnoreCase_SecondNull() { [EOL] boolean result = StringUtils.equalsIgnoreCase("abc", null); [EOL] assertFalse(result); [EOL] } [EOL] public void testEqualsIgnoreCase_SameReference() { [EOL] CharSequence str = "abc"; [EOL] boolean result = StringUtils.equalsIgnoreCase(str, str); [EOL] assertTrue(result); [EOL] } [EOL] public void testEqualsIgnoreCase_EqualStrings() { [EOL] boolean result = StringUtils.equalsIgnoreCase("abc", "abc"); [EOL] assertTrue(result); [EOL] } [EOL] public void testEqualsIgnoreCase_EqualStringsDifferentCase() { [EOL] boolean result = StringUtils.equalsIgnoreCase("abc", "ABC"); [EOL] assertTrue(result); [EOL] } [EOL] public void testEqualsIgnoreCase_DifferentLength() { [EOL] boolean result = StringUtils.equalsIgnoreCase("abc", "abcd"); [EOL] assertFalse(result); [EOL] } [EOL] public void testEqualsIgnoreCase_DifferentStrings() { [EOL] boolean result = StringUtils.equalsIgnoreCase("abc", "def"); [EOL] assertFalse(result); [EOL] }
public void testIndexOf_NullSeq() { [EOL] int result = indexOf(null, 'a', 0); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_EmptySeq() { [EOL] int result = indexOf("", 'a', 0); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValidCharFound() { [EOL] int result = indexOf("abc", 'b', 0); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOf_ValidCharNotFound() { [EOL] int result = indexOf("abc", 'd', 0); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_ValidCharWithStartPos() { [EOL] int result = indexOf("abc", 'a', 1); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_NegativeStartPos() { [EOL] int result = indexOf("abc", 'a', -1); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOf_StartPosGreaterThanLength() { [EOL] int result = indexOf("abc", 'a', 4); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfIgnoreCase_NullInputs() { [EOL] int result = StringUtils.indexOfIgnoreCase(null, null); [EOL] assertEquals("Should return -1 for null inputs", -1, result); [EOL] }
public void testIndexOfIgnoreCase_NullStr() { [EOL] int result = StringUtils.indexOfIgnoreCase(null, "abc"); [EOL] assertEquals("Should return -1 when str is null", -1, result); [EOL] }
public void testIndexOfIgnoreCase_NullSearchStr() { [EOL] int result = StringUtils.indexOfIgnoreCase("abc", null); [EOL] assertEquals("Should return -1 when searchStr is null", -1, result); [EOL] }
public void testIndexOfIgnoreCase_EmptySearchStr() { [EOL] int result = StringUtils.indexOfIgnoreCase("abc", ""); [EOL] assertEquals("Should return 0 when searchStr is empty", 0, result); [EOL] }
public void testIndexOfIgnoreCase_StrEqualsSearchStr() { [EOL] int result = StringUtils.indexOfIgnoreCase("abc", "abc"); [EOL] assertEquals("Should return 0 when str equals searchStr", 0, result); [EOL] }
public void testIndexOfIgnoreCase_IgnoreCase() { [EOL] int result = StringUtils.indexOfIgnoreCase("aBcDeF", "BcD"); [EOL] assertEquals("Should return 1 when searchStr is found ignoring case", 1, result); [EOL] }
public void testIndexOfIgnoreCase_NotFound() { [EOL] int result = StringUtils.indexOfIgnoreCase("abc", "xyz"); [EOL] assertEquals("Should return -1 when searchStr is not found", -1, result); [EOL] }
public void testIndexOfIgnoreCase_NullInputs() { [EOL] final int result = StringUtils.indexOfIgnoreCase(null, null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfIgnoreCase_NegativeStartPos() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "A", -1); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfIgnoreCase_StartPosGreaterThanEndLimit() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "d", 4); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfIgnoreCase_EmptySearchStr() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "", 2); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOfIgnoreCase_ExactMatch() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "B", 0); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfIgnoreCase_NoMatchFound() { [EOL] final int result = StringUtils.indexOfIgnoreCase("abc", "D", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NullSeq() { [EOL] int result = StringUtils.lastIndexOf(null, 'a', 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_EmptySeq() { [EOL] int result = StringUtils.lastIndexOf("", 'a', 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_ValidCharFound() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'b', 4); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_ValidCharNotFound() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'd', 4); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_ValidCharFoundAtStart() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'a', 0); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_ValidCharFoundBeforeStart() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'b', 1); [EOL] assertEquals(1, result); [EOL] }
public void testLastIndexOf_SearchCharNotFoundAndStartPosNegative() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'd', -1); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_SearchCharFoundAndStartPosNegative() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'a', -1); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartPosGreaterThanLength() { [EOL] int result = StringUtils.lastIndexOf("abcba", 'a', 10); [EOL] assertEquals(4, result); [EOL] }
public void testContainsIgnoreCaseWithNullInputs() { [EOL] assertFalse(StringUtils.containsIgnoreCase(null, null)); [EOL] assertFalse(StringUtils.containsIgnoreCase(null, "abc")); [EOL] assertFalse(StringUtils.containsIgnoreCase("abc", null)); [EOL] }
public void testContainsIgnoreCaseWithEmptyStrings() { [EOL] assertTrue(StringUtils.containsIgnoreCase("", "")); [EOL] assertFalse(StringUtils.containsIgnoreCase("abc", "")); [EOL] assertTrue(StringUtils.containsIgnoreCase("", "abc")); [EOL] }
public void testContainsIgnoreCaseWithNonEmptyStrings() { [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "a")); [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "A")); [EOL] assertFalse(StringUtils.containsIgnoreCase("abc", "d")); [EOL] }
public void testContainsIgnoreCaseWithSubstring() { [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "ab")); [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "bc")); [EOL] assertFalse(StringUtils.containsIgnoreCase("abc", "bd")); [EOL] }
public void testContainsIgnoreCaseWithFullString() { [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "abc")); [EOL] assertTrue(StringUtils.containsIgnoreCase("abc", "ABC")); [EOL] }
public void testContainsIgnoreCaseWithLongerSearchString() { [EOL] assertFalse(StringUtils.containsIgnoreCase("abc", "abcd")); [EOL] }
public void testIndexOfAny_EmptyInput() { [EOL] final int result = StringUtils.indexOfAny("", 'a', 'b'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullInput() { [EOL] final int result = StringUtils.indexOfAny(null, 'a', 'b'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullSearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", (char[]) null); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", new char[]{}); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput_MatchAtStart() { [EOL] final int result = StringUtils.indexOfAny("abc", 'a', 'b'); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput_MatchInMiddle() { [EOL] final int result = StringUtils.indexOfAny("abc", 'b'); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput_MatchAtEnd() { [EOL] final int result = StringUtils.indexOfAny("abc", 'c'); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput_NoMatch() { [EOL] final int result = StringUtils.indexOfAny("abc", 'd'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePair_MatchHigh() { [EOL] final int result = StringUtils.indexOfAny("\uD83D\uDE00\uD83D\uDE01", '\uD83D'); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePair_MatchLow() { [EOL] final int result = StringUtils.indexOfAny("\uD83D\uDE00\uD83D\uDE01", '\uDE01'); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePair_NoMatch() { [EOL] final int result = StringUtils.indexOfAny("\uD83D\uDE00\uD83D\uDE01", 'a'); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOfAny_EmptyInput() { [EOL] final int result = StringUtils.indexOfAny("", "abc"); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullInput() { [EOL] final int result = StringUtils.indexOfAny(null, "abc"); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", ""); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullSearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", null); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput() { [EOL] final int result = StringUtils.indexOfAny("abc", "b"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAny_NoMatch() { [EOL] final int result = StringUtils.indexOfAny("abc", "d"); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOfAnyBut_EmptyCs() { [EOL] final int result = StringUtils.indexOfAnyBut("", 'a', 'b'); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", new char[]{}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_NotFound() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", 'd', 'e'); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_Found() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", 'a', 'b'); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairs() { [EOL] final int result = StringUtils.indexOfAnyBut("a\uD83D\uDE00bc", 'a', '\uD83D', '\uDE00'); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOfAnyBut_SurrogatePairsAtEnd() { [EOL] final int result = StringUtils.indexOfAnyBut("ab\uD83D\uDE00", 'a', 'b', '\uD83D', '\uDE00'); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfAnyBut_EmptySeq() { [EOL] final int result = StringUtils.indexOfAnyBut("", "abc"); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAnyBut("xyz", ""); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_NoMatch() { [EOL] final int result = StringUtils.indexOfAnyBut("xyz", "abc"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchAtStart() { [EOL] final int result = StringUtils.indexOfAnyBut("ayz", "abc"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchAtEnd() { [EOL] final int result = StringUtils.indexOfAnyBut("xya", "abc"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchInMiddle() { [EOL] final int result = StringUtils.indexOfAnyBut("xay", "abc"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairAtStart() { [EOL] final int result = StringUtils.indexOfAnyBut("\uD83D\uDE00z", "\uD83D\uDE00"); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairInMiddle() { [EOL] final int result = StringUtils.indexOfAnyBut("x\uD83D\uDE00z", "\uD83D\uDE00"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairAtEnd() { [EOL] final int result = StringUtils.indexOfAnyBut("xy\uD83D\uDE00", "\uD83D\uDE00"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairNoMatch() { [EOL] final int result = StringUtils.indexOfAnyBut("\uD83D\uDE00\uD83D\uDE01", "\uD83D\uDE00"); [EOL] assertEquals(2, result); [EOL] }
public void testContainsOnlyWithNullInputs() { [EOL] assertFalse(StringUtils.containsOnly(null, (char[]) null)); [EOL] assertFalse(StringUtils.containsOnly(null, 'a', 'b')); [EOL] assertFalse(StringUtils.containsOnly("abc", (char[]) null)); [EOL] }
public void testContainsOnlyWithEmptyCharSequence() { [EOL] assertTrue(StringUtils.containsOnly("", 'a', 'b')); [EOL] }
public void testContainsOnlyWithEmptyValidChars() { [EOL] assertFalse(StringUtils.containsOnly("abc", new char[0])); [EOL] }
public void testContainsOnlyValidCase() { [EOL] assertTrue(StringUtils.containsOnly("ab", 'a', 'b')); [EOL] }
public void testContainsOnlyInvalidCase() { [EOL] assertFalse(StringUtils.containsOnly("abc", 'a', 'b')); [EOL] }
public void testContainsOnlyWithNullInputs() { [EOL] assertFalse(StringUtils.containsOnly(null, "abc")); [EOL] assertFalse(StringUtils.containsOnly("abc", null)); [EOL] } [EOL] public void testContainsOnlyWithValidInputs() { [EOL] assertTrue(StringUtils.containsOnly("aabbcc", "abc")); [EOL] } [EOL] public void testContainsOnlyWithInvalidInputs() { [EOL] assertFalse(StringUtils.containsOnly("aabbcc", "ab")); [EOL] } [EOL] public void testContainsOnlyWithEmptyString() { [EOL] assertTrue(StringUtils.containsOnly("", "abc")); [EOL] } [EOL] public void testContainsOnlyWithEmptyValidChars() { [EOL] assertFalse(StringUtils.containsOnly("abc", "")); [EOL] } [EOL] public void testContainsOnlyWithBothEmpty() { [EOL] assertTrue(StringUtils.containsOnly("", "")); [EOL] }
public void testContainsNoneWithNullInputs() { [EOL] assertTrue(StringUtils.containsNone(null, (char[]) null)); [EOL] }
public void testContainsNoneWithEmptyCharSequence() { [EOL] assertTrue(StringUtils.containsNone("", 'a', 'b')); [EOL] }
public void testContainsNoneWithEmptySearchChars() { [EOL] assertTrue(StringUtils.containsNone("abc", new char[] {})); [EOL] }
public void testContainsNoneWithNonMatchingChar() { [EOL] assertTrue(StringUtils.containsNone("abc", 'x', 'y')); [EOL] }
public void testContainsNoneWithMatchingChar() { [EOL] assertFalse(StringUtils.containsNone("abc", 'b', 'x')); [EOL] }
public void testContainsNoneWithSurrogatePairAtEnd() { [EOL] assertFalse(StringUtils.containsNone("a\uD83D\uDE00", '\uD83D', '\uDE00')); [EOL] }
public void testContainsNoneWithSurrogatePairInMiddle() { [EOL] assertFalse(StringUtils.containsNone("a\uD83D\uDE00b", '\uD83D', '\uDE00')); [EOL] }
public void testContainsNoneWithInvalidSurrogatePair() { [EOL] assertTrue(StringUtils.containsNone("a\uD83D\uDE00", '\uDE00', '\uD83D')); [EOL] }
public void testSubstring_NullString() { [EOL] String result = StringUtils.substring(null, 0, 5); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstring_NegativeEnd() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 0, -1); [EOL] assertEquals("abcde", result); [EOL] } [EOL] public void testSubstring_NegativeStart() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, -1, 5); [EOL] assertEquals("abcde", result); [EOL] } [EOL] public void testSubstring_EndGreaterThanLength() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 2, 10); [EOL] assertEquals("cdef", result); [EOL] } [EOL] public void testSubstring_StartGreaterThanEnd() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 4, 2); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstring_NegativeStartAndEnd() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, -2, -1); [EOL] assertEquals("e", result); [EOL] } [EOL] public void testSubstring_ValidRange() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 2, 4); [EOL] assertEquals("cd", result); [EOL] } [EOL] public void testSubstring_StartAndEndZero() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 0, 0); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstring_FullString() { [EOL] String str = "abcdef"; [EOL] String result = StringUtils.substring(str, 0, str.length()); [EOL] assertEquals("abcdef", result); [EOL] }
public void testSubstringAfterLast_NullString() { [EOL] String result = StringUtils.substringAfterLast(null, "separator"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringAfterLast_EmptyString() { [EOL] String result = StringUtils.substringAfterLast("", "separator"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfterLast_NullSeparator() { [EOL] String result = StringUtils.substringAfterLast("str", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfterLast_EmptySeparator() { [EOL] String result = StringUtils.substringAfterLast("str", ""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfterLast_SeparatorNotFound() { [EOL] String result = StringUtils.substringAfterLast("str", "notfound"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfterLast_SeparatorAtEnd() { [EOL] String result = StringUtils.substringAfterLast("strseparator", "separator"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfterLast_SeparatorInMiddle() { [EOL] String result = StringUtils.substringAfterLast("strseparatorstr", "separator"); [EOL] assertEquals("str", result); [EOL] }
public void testSubstringsBetween_NullInputs() { [EOL] String[] result = StringUtils.substringsBetween(null, "open", "close"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringsBetween_EmptyOpenClose() { [EOL] String[] result = StringUtils.substringsBetween("string", "", ""); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringsBetween_EmptyString() { [EOL] String[] result = StringUtils.substringsBetween("", "(", ")"); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testSubstringsBetween_NoSubstrings() { [EOL] String[] result = StringUtils.substringsBetween("string", "(", ")"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringsBetween_NoOpenCloseTags() { [EOL] String[] result = StringUtils.substringsBetween("string", "{", "}"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringsBetween_ValidCase() { [EOL] String[] result = StringUtils.substringsBetween("[one][two][three]", "[", "]"); [EOL] assertEquals(3, result.length); [EOL] assertEquals("one", result[0]); [EOL] assertEquals("two", result[1]); [EOL] assertEquals("three", result[2]); [EOL] } [EOL] public void testSubstringsBetween_Nested() { [EOL] String[] result = StringUtils.substringsBetween("[one[two[three]]]", "[", "]"); [EOL] assertEquals(1, result.length); [EOL] assertEquals("one[two[three", result[0]); [EOL] } [EOL] public void testSubstringsBetween_EndOfStr() { [EOL] String[] result = StringUtils.substringsBetween("one[two[three]]", "[", "]"); [EOL] assertEquals(2, result.length); [EOL] assertEquals("two[three", result[1]); [EOL] }
public void testSplitPreserveAllTokens_NullInput() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(null, ','); [EOL] assertNull(result); [EOL] }
public void testSplitPreserveAllTokens_EmptyInput() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("", ','); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitPreserveAllTokens_SeparatorInString() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a,b,c", ','); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitPreserveAllTokens_SeparatorAtTheEnd() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a,b,c,", ','); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] assertEquals("", result[3]); [EOL] }
public void testSplitPreserveAllTokens_SeparatorAtTheBeginning() { [EOL] String[] result = StringUtils.splitPreserveAllTokens(",a,b,c", ','); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("", result[0]); [EOL] assertEquals("a", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[3]); [EOL] }
public void testSplitPreserveAllTokens_ContinuousSeparators() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a,,b,c", ','); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("", result[1]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[3]); [EOL] }
public void testSplitPreserveAllTokens_DifferentSeparator() { [EOL] String[] result = StringUtils.splitPreserveAllTokens("a;b;c", ';'); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testSplitWorker_nullString() { [EOL] String[] result = splitWorker(null, ',', false); [EOL] assertNull("splitWorker should return null for null input", result); [EOL] } [EOL] public void testSplitWorker_emptyString() { [EOL] String[] result = splitWorker("", ',', false); [EOL] assertNotNull("splitWorker should not return null for empty input", result); [EOL] assertEquals("splitWorker should return empty array for empty input", 0, result.length); [EOL] } [EOL] public void testSplitWorker_noPreserveAllTokens() { [EOL] String[] result = splitWorker("a,b,c", ',', false); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 3 elements", 3, result.length); [EOL] assertEquals("First element should be 'a'", "a", result[0]); [EOL] assertEquals("Second element should be 'b'", "b", result[1]); [EOL] assertEquals("Third element should be 'c'", "c", result[2]); [EOL] }
public void testSplitWorker_preserveAllTokens() { [EOL] String[] result = splitWorker("a,,b,c,", ',', true); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 5 elements", 5, result.length); [EOL] assertEquals("First element should be 'a'", "a", result[0]); [EOL] assertEquals("Second element should be ''", "", result[1]); [EOL] assertEquals("Third element should be 'b'", "b", result[2]); [EOL] assertEquals("Fourth element should be 'c'", "c", result[3]); [EOL] assertEquals("Fifth element should be ''", "", result[4]); [EOL] }
public void testSplitWorker_noMatchWithPreserveAllTokens() { [EOL] String[] result = splitWorker("abc", ',', true); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 1 element", 1, result.length); [EOL] assertEquals("First element should be 'abc'", "abc", result[0]); [EOL] }
public void testSplitWorker_noMatchWithoutPreserveAllTokens() { [EOL] String[] result = splitWorker("abc", ',', false); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 1 element", 1, result.length); [EOL] assertEquals("First element should be 'abc'", "abc", result[0]); [EOL] }
public void testSplitWorker_emptyTokensWithPreserveAllTokens() { [EOL] String[] result = splitWorker(",,", ',', true); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 3 elements", 3, result.length); [EOL] assertEquals("First element should be ''", "", result[0]); [EOL] assertEquals("Second element should be ''", "", result[1]); [EOL] assertEquals("Third element should be ''", "", result[2]); [EOL] }
public void testSplitWorker_emptyTokensWithoutPreserveAllTokens() { [EOL] String[] result = splitWorker(",,", ',', false); [EOL] assertNotNull("splitWorker should not return null", result); [EOL] assertEquals("splitWorker should return 0 elements", 0, result.length); [EOL] }
public void testSplitByCharacterType_NullInput() { [EOL] String[] result = StringUtils.splitByCharacterType(null); [EOL] assertNull(result); [EOL] }
public void testSplitByCharacterType_EmptyString() { [EOL] String[] result = StringUtils.splitByCharacterType(""); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitByCharacterType_SimpleSplit() { [EOL] String[] result = StringUtils.splitByCharacterType("ab de"); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals(" ", result[1]); [EOL] assertEquals("de", result[2]); [EOL] }
public void testSplitByCharacterType_MixedTypes() { [EOL] String[] result = StringUtils.splitByCharacterType("ab123 de456"); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length); [EOL] assertEquals("ab", result[0]); [EOL] assertEquals("123", result[1]); [EOL] assertEquals(" ", result[2]); [EOL] assertEquals("de", result[3]); [EOL] assertEquals("456", result[4]); [EOL] }
public void testJoin_withNullArray() { [EOL] String result = StringUtils.join(null, ','); [EOL] assertNull(result); [EOL] }
public void testJoin_withEmptyArray() { [EOL] String result = StringUtils.join(new Object[0], ','); [EOL] assertEquals("", result); [EOL] }
public void testJoin_withSingleElementArray() { [EOL] String result = StringUtils.join(new Object[]{"a"}, ','); [EOL] assertEquals("a", result); [EOL] }
public void testJoin_withMultipleElementsArray() { [EOL] String result = StringUtils.join(new Object[]{"a", "b", "c"}, ','); [EOL] assertEquals("a,b,c", result); [EOL] }
public void testJoin_FloatArrayWithSeparator_ShouldReturnNullWhenArrayIsNull() { [EOL] float[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoin_FloatArrayWithSeparator_ShouldJoinWhenArrayIsNotEmpty() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1.0,2.0,3.0", result); [EOL] }
public void testJoin_FloatArrayWithSeparator_ShouldReturnEmptyStringWhenArrayIsEmpty() { [EOL] float[] array = {}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayWithCharSeparatorNullArray() { [EOL] String result = StringUtils.join(null, ',', 0, 10); [EOL] assertNull(result); [EOL] }
public void testJoinArrayWithCharSeparatorEmptyArray() { [EOL] String result = StringUtils.join(new Object[0], ',', 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayWithCharSeparatorValidArray() { [EOL] String[] array = {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ',', 0, array.length); [EOL] assertEquals("a,b,c", result); [EOL] }
public void testJoinArrayWithCharSeparatorPartialArray() { [EOL] String[] array = {"a", "b", "c", null, "d"}; [EOL] String result = StringUtils.join(array, ',', 1, 4); [EOL] assertEquals("b,c,", result); [EOL] }
public void testJoinArrayWithCharSeparatorNoItems() { [EOL] String[] array = {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ',', 2, 2); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayNull() { [EOL] float[] array = null; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 1; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertNull(result); [EOL] }
public void testJoinArrayEmpty() { [EOL] float[] array = new float[0]; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 0; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayValid() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = array.length; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1.0,2.0,3.0", result); [EOL] }
public void testJoinArrayPartial() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] char separator = ';'; [EOL] int startIndex = 1; [EOL] int endIndex = 3; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("2.0;3.0", result); [EOL] }
public void testJoinArraySingleElement() { [EOL] float[] array = {1.0f}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 1; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1.0", result); [EOL] }
public void testJoinArrayInvalidRange() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] char separator = ','; [EOL] int startIndex = 2; [EOL] int endIndex = 1; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayNull() { [EOL] Object[] array = null; [EOL] String separator = ","; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoinArrayEmpty() { [EOL] Object[] array = new Object[0]; [EOL] String separator = ","; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoinArraySingleElement() { [EOL] Object[] array = new Object[]{"one"}; [EOL] String separator = ","; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("one", result); [EOL] }
public void testJoinArrayMultipleElements() { [EOL] Object[] array = new Object[]{"one", "two", "three"}; [EOL] String separator = ","; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("one,two,three", result); [EOL] }
public void testJoinArrayWithNullSeparator() { [EOL] Object[] array = new Object[]{"one", "two", "three"}; [EOL] String separator = null; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("onetwothree", result); [EOL] }
public void testJoinArrayWithNullArray() { [EOL] String result = StringUtils.join(null, ",", 0, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testJoinArrayWithNullSeparator() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, null, 0, 3); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testJoinArrayWithValidInput() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ",", 0, 3); [EOL] assertEquals("a,b,c", result); [EOL] } [EOL] public void testJoinArrayWithEmptyString() { [EOL] String[] array = new String[] {}; [EOL] String result = StringUtils.join(array, ",", 0, 0); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoinArrayWithInvalidRange() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ",", 2, 1); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayWithPartialRange() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ",", 1, 2); [EOL] assertEquals("b", result); [EOL] }
public void testJoinArrayWithSingleElement() { [EOL] String[] array = new String[] {"a"}; [EOL] String result = StringUtils.join(array, ",", 0, 1); [EOL] assertEquals("a", result); [EOL] }
public void testJoinArrayWithEndIndexExceedingArrayLength() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String result = StringUtils.join(array, ",", 0, 5); [EOL] assertEquals("a,b,c", result); [EOL] }
public void testJoin_NullIterator() { [EOL] String result = StringUtils.join(null, ","); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_EmptyIterator() { [EOL] List<String> list = Collections.emptyList(); [EOL] String result = StringUtils.join(list.iterator(), ","); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_SingleElementIterator() { [EOL] List<String> list = Collections.singletonList("one"); [EOL] String result = StringUtils.join(list.iterator(), ","); [EOL] assertEquals("one", result); [EOL] } [EOL] public void testJoin_MultipleElementsIterator() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list.iterator(), ","); [EOL] assertEquals("one,two,three", result); [EOL] } [EOL] public void testJoin_MultipleElementsIteratorWithNullSeparator() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list.iterator(), null); [EOL] assertEquals("onetwothree", result); [EOL] } [EOL] public void testJoin_MultipleElementsIteratorWithNullElements() { [EOL] List<String> list = Arrays.asList("one", null, "three"); [EOL] String result = StringUtils.join(list.iterator(), ","); [EOL] assertEquals("one,null,three", result); [EOL] } [EOL] public void testJoin_MultipleElementsIteratorWithEmptyStringSeparator() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] String result = StringUtils.join(list.iterator(), ""); [EOL] assertEquals("onetwothree", result); [EOL] }
public void testReplacePattern_NullSource() { [EOL] String result = StringUtils.replacePattern(null, "regex", "replacement"); [EOL] assertNull(result); [EOL] }
public void testReplacePattern_EmptySource() { [EOL] String result = StringUtils.replacePattern("", "regex", "replacement"); [EOL] assertEquals("", result); [EOL] }
public void testReplacePattern_NullRegex() { [EOL] try { [EOL] StringUtils.replacePattern("source", null, "replacement"); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReplacePattern_NullReplacement() { [EOL] String result = StringUtils.replacePattern("source", "regex", null); [EOL] assertNull(result); [EOL] }
public void testReplacePattern_ValidInput() { [EOL] String result = StringUtils.replacePattern("123abc", "\\d+", "number"); [EOL] assertEquals("numberabc", result); [EOL] }
public void testReplacePattern_NoMatch() { [EOL] String result = StringUtils.replacePattern("abc", "\\d+", "number"); [EOL] assertEquals("abc", result); [EOL] }
public void testReplacePattern_EmptyRegex() { [EOL] String result = StringUtils.replacePattern("source", "", "replacement"); [EOL] assertEquals("replacementreplacementreplacementreplacementreplacementreplacement", result); [EOL] }
public void testReplacePattern_EmptyReplacement() { [EOL] String result = StringUtils.replacePattern("123abc", "\\d+", ""); [EOL] assertEquals("abc", result); [EOL] }
public void testChop_NullInput() { [EOL] String result = StringUtils.chop(null); [EOL] assertNull(result); [EOL] } [EOL] public void testChop_EmptyString() { [EOL] String result = StringUtils.chop(""); [EOL] assertEquals(StringUtils.EMPTY, result); [EOL] } [EOL] public void testChop_SingleCharacter() { [EOL] String result = StringUtils.chop("a"); [EOL] assertEquals(StringUtils.EMPTY, result); [EOL] } [EOL] public void testChop_TwoCharacters() { [EOL] String result = StringUtils.chop("ab"); [EOL] assertEquals("a", result); [EOL] } [EOL] public void testChop_NewLineAtEnd() { [EOL] String result = StringUtils.chop("abc\n"); [EOL] assertEquals("ab", result); [EOL] } [EOL] public void testChop_CarriageReturnNewLineAtEnd() { [EOL] String result = StringUtils.chop("abc\r\n"); [EOL] assertEquals("ab", result); [EOL] } [EOL] public void testChop_RegularString() { [EOL] String result = StringUtils.chop("abcd"); [EOL] assertEquals("abc", result); [EOL] }
public void testRepeat_CharZeroTimes() { [EOL] String repeated = StringUtils.repeat('a', 0); [EOL] assertEquals("", repeated); [EOL] } [EOL] public void testRepeat_CharOnce() { [EOL] String repeated = StringUtils.repeat('a', 1); [EOL] assertEquals("a", repeated); [EOL] } [EOL] public void testRepeat_CharMultipleTimes() { [EOL] String repeated = StringUtils.repeat('a', 3); [EOL] assertEquals("aaa", repeated); [EOL] } [EOL] public void testRepeat_CharNegativeTimes() { [EOL] String repeated = StringUtils.repeat('a', -1); [EOL] assertEquals("", repeated); [EOL] }
public void testRightPad_NullString() { [EOL] String padded = rightPad(null, 5, ' '); [EOL] assertNull(padded); [EOL] }
public void testRightPad_NoPaddingNeeded() { [EOL] String original = "abc"; [EOL] String padded = rightPad(original, 3, ' '); [EOL] assertSame("No padding should be added", original, padded); [EOL] }
public void testRightPad_WithPadding() { [EOL] String original = "abc"; [EOL] String padded = rightPad(original, 5, 'x'); [EOL] assertEquals("abcxx", padded); [EOL] }
public void testRightPad_WithPaddingGreaterThanPadLimit() { [EOL] String original = "abc"; [EOL] int size = PAD_LIMIT + 2; [EOL] String padded = rightPad(original, size, 'y'); [EOL] assertEquals(original + repeat('y', size - original.length()), padded); [EOL] }
public void testLeftPad_NullString() { [EOL] String padded = leftPad(null, 10, ' '); [EOL] assertNull(padded); [EOL] }
public void testLeftPad_NoPaddingNeeded() { [EOL] String originalString = "abc"; [EOL] String padded = leftPad(originalString, 3, ' '); [EOL] assertEquals(originalString, padded); [EOL] }
public void testLeftPad_WithPadding() { [EOL] String originalString = "abc"; [EOL] String padded = leftPad(originalString, 5, 'x'); [EOL] assertEquals("xxabc", padded); [EOL] }
public void testLeftPad_WithPaddingGreaterThanPadLimit() { [EOL] String originalString = "abc"; [EOL] int size = 100000; // Assume PAD_LIMIT is less than 100000 [EOL] String padded = leftPad(originalString, size, 'x'); [EOL] assertNotNull(padded); [EOL] assertTrue(padded.length() == size); [EOL] }
public void testLengthWithNullCharSequence() { [EOL] int result = StringUtils.length(null); [EOL] assertEquals(0, result); [EOL] }
public void testLengthWithEmptyCharSequence() { [EOL] CharSequence cs = "" ; [EOL] int result = StringUtils.length(cs); [EOL] assertEquals(0, result); [EOL] }
public void testLengthWithNonEmptyCharSequence() { [EOL] CharSequence cs = "abc"; [EOL] int result = StringUtils.length(cs); [EOL] assertEquals(3, result); [EOL] }
public void testCenter_NullString() { [EOL] String centered = StringUtils.center(null, 10); [EOL] assertNull(centered); [EOL] }
public void testCenter_EmptyString() { [EOL] String centered = StringUtils.center("", 10); [EOL] assertEquals("          ", centered); [EOL] }
public void testCenter_SizeLessThanStringSize() { [EOL] String centered = StringUtils.center("abc", 2); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_SizeEqualToStringSize() { [EOL] String centered = StringUtils.center("abc", 3); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_SizeGreaterThanStringSize() { [EOL] String centered = StringUtils.center("abc", 5); [EOL] assertEquals(" abc ", centered); [EOL] }
public void testCenter_SizeMuchGreaterThanStringSize() { [EOL] String centered = StringUtils.center("abc", 7); [EOL] assertEquals("  abc  ", centered); [EOL] }
public void testCenter_SizeEvenStringOdd() { [EOL] String centered = StringUtils.center("abc", 6); [EOL] assertEquals(" abc  ", centered); [EOL] }
public void testCenter_SizeOddStringEven() { [EOL] String centered = StringUtils.center("abcd", 7); [EOL] assertEquals(" abcd  ", centered); [EOL] }
public void testCenter_NullString() { [EOL] String centered = StringUtils.center(null, 10, '*'); [EOL] assertNull(centered); [EOL] }
public void testCenter_NegativeSize() { [EOL] String centered = StringUtils.center("abc", -1, '*'); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_SizeLessThanStringLength() { [EOL] String centered = StringUtils.center("abc", 2, '*'); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_SizeEqualToStringLength() { [EOL] String centered = StringUtils.center("abc", 3, '*'); [EOL] assertEquals("abc", centered); [EOL] }
public void testCenter_SizeGreaterThanStringLength_OddPads() { [EOL] String centered = StringUtils.center("abc", 7, '*'); [EOL] assertEquals("**abc**", centered); [EOL] }
public void testCenter_SizeGreaterThanStringLength_EvenPads() { [EOL] String centered = StringUtils.center("abc", 8, '*'); [EOL] assertEquals("***abc**", centered); [EOL] }
public void testUpperCaseWithNullInput() { [EOL] String input = null; [EOL] String result = StringUtils.upperCase(input); [EOL] assertNull(result); [EOL] }
public void testUpperCaseWithEmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.upperCase(input); [EOL] assertEquals("", result); [EOL] }
public void testUpperCaseWithNonEmptyString() { [EOL] String input = "test"; [EOL] String result = StringUtils.upperCase(input); [EOL] assertEquals("TEST", result); [EOL] }
public void testUpperCase_NullString() { [EOL] String result = upperCase(null, Locale.ENGLISH); [EOL] assertNull(result); [EOL] } [EOL] public void testUpperCase_EmptyString() { [EOL] String result = upperCase("", Locale.ENGLISH); [EOL] assertEquals("", result); [EOL] } [EOL] public void testUpperCase_WithLocale() { [EOL] String result = upperCase("test", Locale.ENGLISH); [EOL] assertEquals("TEST", result); [EOL] } [EOL] public void testUpperCase_WithDifferentLocale() { [EOL] String result = upperCase("i", new Locale("tr", "TR")); [EOL] assertEquals("İ", result); [EOL] }
public void testLowerCaseWithNull() { [EOL] String input = null; [EOL] String result = StringUtils.lowerCase(input); [EOL] assertNull(result); [EOL] }
public void testLowerCaseWithEmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.lowerCase(input); [EOL] assertEquals("", result); [EOL] }
public void testLowerCaseWithUpperCaseString() { [EOL] String input = "TEST"; [EOL] String result = StringUtils.lowerCase(input); [EOL] assertEquals("test", result); [EOL] }
public void testLowerCaseWithMixedCaseString() { [EOL] String input = "TeSt"; [EOL] String result = StringUtils.lowerCase(input); [EOL] assertEquals("test", result); [EOL] }
public void testLowerCaseWithNullString() { [EOL] String result = StringUtils.lowerCase(null, Locale.ENGLISH); [EOL] assertNull(result); [EOL] }
public void testLowerCaseWithNonNullString() { [EOL] String result = StringUtils.lowerCase("TEST", Locale.ENGLISH); [EOL] assertEquals("test", result); [EOL] }
public void testLowerCaseWithLocale() { [EOL] String result = StringUtils.lowerCase("TEST", Locale.GERMAN); [EOL] assertEquals("test", result); [EOL] }
public void testCapitalize_NullString() { [EOL] String input = null; [EOL] String result = StringUtils.capitalize(input); [EOL] assertNull(result); [EOL] }
public void testCapitalize_EmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.capitalize(input); [EOL] assertEquals("", result); [EOL] }
public void testCapitalize_AlreadyCapitalized() { [EOL] String input = "Capitalized"; [EOL] String result = StringUtils.capitalize(input); [EOL] assertEquals("Capitalized", result); [EOL] }
public void testCapitalize_NotCapitalized() { [EOL] String input = "uncapitalized"; [EOL] String result = StringUtils.capitalize(input); [EOL] assertEquals("Uncapitalized", result); [EOL] }
public void testUncapitalize_NullInput() { [EOL] String result = StringUtils.uncapitalize(null); [EOL] assertNull(result); [EOL] }
public void testUncapitalize_EmptyString() { [EOL] String result = StringUtils.uncapitalize(""); [EOL] assertEquals("", result); [EOL] }
public void testUncapitalize_AlreadyUncapitalized() { [EOL] String result = StringUtils.uncapitalize("uncapitalized"); [EOL] assertEquals("uncapitalized", result); [EOL] }
public void testUncapitalize_CapitalizedString() { [EOL] String result = StringUtils.uncapitalize("Capitalized"); [EOL] assertEquals("capitalized", result); [EOL] }
public void testIsNumeric_Null() { [EOL] boolean result = StringUtils.isNumeric(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNumeric_Empty() { [EOL] boolean result = StringUtils.isNumeric(""); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNumeric_Numeric() { [EOL] boolean result = StringUtils.isNumeric("12345"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNumeric_NonNumeric() { [EOL] boolean result = StringUtils.isNumeric("1234a5"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNumeric_Space() { [EOL] boolean result = StringUtils.isNumeric(" "); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNumeric_MixedWithSpaces() { [EOL] boolean result = StringUtils.isNumeric(" 12345 "); [EOL] assertFalse(result); [EOL] }
public void testIsNumericSpace_NullInput() { [EOL] boolean result = StringUtils.isNumericSpace(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNumericSpace_EmptyString() { [EOL] boolean result = StringUtils.isNumericSpace(""); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNumericSpace_OnlyDigits() { [EOL] boolean result = StringUtils.isNumericSpace("12345"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNumericSpace_OnlySpaces() { [EOL] boolean result = StringUtils.isNumericSpace("     "); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNumericSpace_DigitsAndSpaces() { [EOL] boolean result = StringUtils.isNumericSpace(" 123 45 "); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsNumericSpace_NonNumericCharacters() { [EOL] boolean result = StringUtils.isNumericSpace("12a34"); [EOL] assertFalse(result); [EOL] }
public void testIsAllUpperCase_nullInput() { [EOL] boolean result = StringUtils.isAllUpperCase(null); [EOL] assertFalse(result); [EOL] }
public void testIsAllUpperCase_emptyString() { [EOL] boolean result = StringUtils.isAllUpperCase(""); [EOL] assertFalse(result); [EOL] }
public void testIsAllUpperCase_allUpperCase() { [EOL] boolean result = StringUtils.isAllUpperCase("ABC"); [EOL] assertTrue(result); [EOL] }
public void testIsAllUpperCase_notAllUpperCase() { [EOL] boolean result = StringUtils.isAllUpperCase("AbC"); [EOL] assertFalse(result); [EOL] }
public void testIsAllUpperCase_allLowerCase() { [EOL] boolean result = StringUtils.isAllUpperCase("abc"); [EOL] assertFalse(result); [EOL] }
public void testDefaultStringWithNullStr() { [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultString(null, defaultStr); [EOL] assertEquals(defaultStr, result); [EOL] }
public void testDefaultStringWithNonNullStr() { [EOL] String str = "actual"; [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultString(str, defaultStr); [EOL] assertEquals(str, result); [EOL] }
public void testAbbreviateMiddle_EmptyString() { [EOL] String result = StringUtils.abbreviateMiddle(null, "*", 10); [EOL] assertEquals(null, result); [EOL] result = StringUtils.abbreviateMiddle("", "*", 10); [EOL] assertEquals("", result); [EOL] } [EOL] public void testAbbreviateMiddle_EmptyMiddle() { [EOL] String result = StringUtils.abbreviateMiddle("abc", null, 10); [EOL] assertEquals("abc", result); [EOL] result = StringUtils.abbreviateMiddle("abc", "", 10); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testAbbreviateMiddle_ShortLength() { [EOL] String result = StringUtils.abbreviateMiddle("abc", "*", 1); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testAbbreviateMiddle_LengthLessThanStr() { [EOL] String result = StringUtils.abbreviateMiddle("abcdefg", "*", 7); [EOL] assertEquals("abcdefg", result); [EOL] } [EOL] public void testAbbreviateMiddle_LengthEqualsStr() { [EOL] String result = StringUtils.abbreviateMiddle("abcdefg", "*", 8); [EOL] assertEquals("abcdefg", result); [EOL] } [EOL] public void testAbbreviateMiddle_ProperAbbreviation() { [EOL] String result = StringUtils.abbreviateMiddle("abcdefg", "*", 5); [EOL] assertEquals("ab*fg", result); [EOL] } [EOL] public void testAbbreviateMiddle_LengthSmallerThanMiddle() { [EOL] String result = StringUtils.abbreviateMiddle("abcdefg", "*****", 4); [EOL] assertEquals("abcdefg", result); [EOL] } [EOL] public void testAbbreviateMiddle_ExactMiddleLength() { [EOL] String result = StringUtils.abbreviateMiddle("abcdefg", "***", 5); [EOL] assertEquals("ab***fg", result); [EOL] }
public void testIndexOfDifference_nullOrEmpty() { [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, StringUtils.indexOfDifference((CharSequence[]) null)); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, StringUtils.indexOfDifference()); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, StringUtils.indexOfDifference("", "")); [EOL] }
public void testIndexOfDifference_allStringsNull() { [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, StringUtils.indexOfDifference(null, null, null)); [EOL] }
public void testIndexOfDifference_someStringsNull() { [EOL] assertEquals(0, StringUtils.indexOfDifference(null, "abc")); [EOL] assertEquals(0, StringUtils.indexOfDifference("", null)); [EOL] }
public void testIndexOfDifference_equalStrings() { [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, StringUtils.indexOfDifference("abc", "abc")); [EOL] }
public void testIndexOfDifference_firstStringShorter() { [EOL] assertEquals(1, StringUtils.indexOfDifference("a", "ab")); [EOL] }
public void testIndexOfDifference_firstStringLonger() { [EOL] assertEquals(2, StringUtils.indexOfDifference("abc", "ab")); [EOL] }
public void testIndexOfDifference_sameLengthDifferentStrings() { [EOL] assertEquals(1, StringUtils.indexOfDifference("abc", "adc")); [EOL] }
public void testGetLevenshteinDistance_NullInputs() { [EOL] try { [EOL] StringUtils.getLevenshteinDistance(null, "test", 1); [EOL] fail("Expected IllegalArgumentException for null first parameter"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] try { [EOL] StringUtils.getLevenshteinDistance("test", null, 1); [EOL] fail("Expected IllegalArgumentException for null second parameter"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testGetLevenshteinDistance_NegativeThreshold() { [EOL] try { [EOL] StringUtils.getLevenshteinDistance("test", "test", -1); [EOL] fail("Expected IllegalArgumentException for negative threshold"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testGetLevenshteinDistance_EmptyStrings() { [EOL] assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0)); [EOL] } [EOL] public void testGetLevenshteinDistance_SameStrings() { [EOL] assertEquals(0, StringUtils.getLevenshteinDistance("test", "test", 10)); [EOL] } [EOL] public void testGetLevenshteinDistance_DistanceWithinThreshold() { [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("test", "tost", 1)); [EOL] } [EOL] public void testGetLevenshteinDistance_DistanceExceedsThreshold() { [EOL] assertEquals(-1, StringUtils.getLevenshteinDistance("test", "testing", 3)); [EOL] } [EOL] public void testGetLevenshteinDistance_FirstStringEmpty() { [EOL] assertEquals(4, StringUtils.getLevenshteinDistance("", "test", 10)); [EOL] } [EOL] public void testGetLevenshteinDistance_SecondStringEmpty() { [EOL] assertEquals(4, StringUtils.getLevenshteinDistance("test", "", 10)); [EOL] } [EOL] public void testGetLevenshteinDistance_ThresholdTooLow() { [EOL] assertEquals(-1, StringUtils.getLevenshteinDistance("test", "testing", 2)); [EOL] } [EOL] public void testGetLevenshteinDistance_ThresholdEqualsDistance() { [EOL] assertEquals(3, StringUtils.getLevenshteinDistance("test", "testing", 3)); [EOL] } [EOL] public void testGetLevenshteinDistance_SwapStrings() { [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("tost", "test", 1)); [EOL] } [EOL] public void testGetLevenshteinDistance_MaxIntegerValues() { [EOL] assertEquals(-1, StringUtils.getLevenshteinDistance("test", "test", Integer.MAX_VALUE)); [EOL] }
public void testStartsWith_NullStr() { [EOL] boolean result = StringUtils.startsWith(null, "prefix"); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_NullPrefix() { [EOL] boolean result = StringUtils.startsWith("str", null); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_BothNull() { [EOL] boolean result = StringUtils.startsWith(null, null); [EOL] assertTrue(result); [EOL] }
public void testStartsWith_EmptyStr() { [EOL] boolean result = StringUtils.startsWith("", "prefix"); [EOL] assertFalse(result); [EOL] }
public void testStartsWith_EmptyPrefix() { [EOL] boolean result = StringUtils.startsWith("str", ""); [EOL] assertTrue(result); [EOL] }
public void testStartsWith_BothEmpty() { [EOL] boolean result = StringUtils.startsWith("", ""); [EOL] assertTrue(result); [EOL] }
public void testStartsWith_ValidStrAndPrefix() { [EOL] boolean result = StringUtils.startsWith("str", "st"); [EOL] assertTrue(result); [EOL] }
public void testStartsWith_InValidStrAndPrefix() { [EOL] boolean result = StringUtils.startsWith("str", "prefix"); [EOL] assertFalse(result); [EOL] }
public void testStartsWithAny_StringIsEmpty() { [EOL] boolean result = StringUtils.startsWithAny("", "abc", "def"); [EOL] assertFalse(result); [EOL] } [EOL] public void testStartsWithAny_SearchStringsIsEmpty() { [EOL] boolean result = StringUtils.startsWithAny("abc", new String[]{}); [EOL] assertFalse(result); [EOL] } [EOL] public void testStartsWithAny_StringIsNull() { [EOL] boolean result = StringUtils.startsWithAny(null, "abc", "def"); [EOL] assertFalse(result); [EOL] } [EOL] public void testStartsWithAny_SearchStringsIsNull() { [EOL] boolean result = StringUtils.startsWithAny("abc", (CharSequence[]) null); [EOL] assertFalse(result); [EOL] } [EOL] public void testStartsWithAny_StringStartsWithSearchString() { [EOL] boolean result = StringUtils.startsWithAny("abc", "a", "b"); [EOL] assertTrue(result); [EOL] } [EOL] public void testStartsWithAny_StringDoesNotStartWithSearchStrings() { [EOL] boolean result = StringUtils.startsWithAny("abc", "x", "y"); [EOL] assertFalse(result); [EOL] }
public void testStartsWithAny_SearchStringIsNull() { [EOL] boolean result = StringUtils.startsWithAny("abc", "a", null, "b"); [EOL] assertTrue(result); [EOL] }
public void testEndsWithAny_BothEmpty() { [EOL] boolean result = StringUtils.endsWithAny("", new CharSequence[]{}); [EOL] assertFalse(result); [EOL] }
public void testEndsWithAny_StringEmpty() { [EOL] boolean result = StringUtils.endsWithAny("", new CharSequence[]{"abc"}); [EOL] assertFalse(result); [EOL] }
public void testEndsWithAny_SearchStringsEmpty() { [EOL] boolean result = StringUtils.endsWithAny("abc", new CharSequence[]{}); [EOL] assertFalse(result); [EOL] }
public void testEndsWithAny_MatchAtEnd() { [EOL] boolean result = StringUtils.endsWithAny("abcdef", new CharSequence[]{"def"}); [EOL] assertTrue(result); [EOL] }
public void testEndsWithAny_NoMatch() { [EOL] boolean result = StringUtils.endsWithAny("abcdef", new CharSequence[]{"ghijk"}); [EOL] assertFalse(result); [EOL] }
public void testEndsWithAny_MatchAtBeginning() { [EOL] boolean result = StringUtils.endsWithAny("abcdef", new CharSequence[]{"abc"}); [EOL] assertFalse(result); [EOL] }
public void testEndsWithAny_MultipleSearchStrings_OneMatch() { [EOL] boolean result = StringUtils.endsWithAny("abcdef", new CharSequence[]{"xyz", "def"}); [EOL] assertTrue(result); [EOL] }
public void testEndsWithAny_MultipleSearchStrings_NoMatch() { [EOL] boolean result = StringUtils.endsWithAny("abcdef", new CharSequence[]{"xyz", "uvw"}); [EOL] assertFalse(result); [EOL] }
public void testPrependIfMissing_nullStr() { [EOL] final String result = prependIfMissing(null, "prefix", false); [EOL] assertNull(result); [EOL] }
public void testPrependIfMissing_emptyPrefix() { [EOL] final String result = prependIfMissing("str", "", false); [EOL] assertEquals("str", result); [EOL] }
public void testPrependIfMissing_alreadyStartsWithPrefix() { [EOL] final String result = prependIfMissing("prefixStr", "prefix", false); [EOL] assertEquals("prefixStr", result); [EOL] }
public void testPrependIfMissing_ignoreCaseTrueAndStartsWithPrefix() { [EOL] final String result = prependIfMissing("PrefixStr", "prefix", true); [EOL] assertEquals("PrefixStr", result); [EOL] }
public void testPrependIfMissing_ignoreCaseFalseAndNotStartsWithPrefix() { [EOL] final String result = prependIfMissing("str", "prefix", false); [EOL] assertEquals("prefixstr", result); [EOL] }
public void testPrependIfMissing_withPrefixesArrayNull() { [EOL] final String result = prependIfMissing("str", "prefix", false, (CharSequence[]) null); [EOL] assertEquals("prefixstr", result); [EOL] }
public void testPrependIfMissing_withPrefixesArrayEmpty() { [EOL] final String result = prependIfMissing("str", "prefix", false, new CharSequence[0]); [EOL] assertEquals("prefixstr", result); [EOL] }
public void testPrependIfMissing_withPrefixesArrayContainingMatch() { [EOL] final String result = prependIfMissing("str", "prefix", false, "pre", "pro"); [EOL] assertEquals("str", result); [EOL] }
public void testPrependIfMissing_withPrefixesArrayNotContainingMatch() { [EOL] final String result = prependIfMissing("str", "prefix", false, "pre", "pro"); [EOL] assertEquals("prefixstr", result); [EOL] }
public void testPrependIfMissingIgnoreCase_NullStr() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase(null, "prefix"); [EOL] assertNull(result); [EOL] }
public void testPrependIfMissingIgnoreCase_EmptyStr() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("", "prefix"); [EOL] assertEquals("prefix", result); [EOL] }
public void testPrependIfMissingIgnoreCase_NoPrependNeeded() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("prefixString", "prefix"); [EOL] assertEquals("prefixString", result); [EOL] }
public void testPrependIfMissingIgnoreCase_PrependNeeded() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("String", "prefix"); [EOL] assertEquals("prefixString", result); [EOL] }
public void testPrependIfMissingIgnoreCase_PrependNeededIgnoreCase() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("string", "Prefix"); [EOL] assertEquals("Prefixstring", result); [EOL] }
public void testPrependIfMissingIgnoreCase_MultiplePrefixes() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("string", "pre", "prefix", "PRE"); [EOL] assertEquals("prestring", result); [EOL] }
public void testPrependIfMissingIgnoreCase_MultiplePrefixesNoneMatch() { [EOL] String result = StringUtils.prependIfMissingIgnoreCase("string", "pre", "some", "other"); [EOL] assertEquals("prestring", result); [EOL] }
public void testAddWithPositiveOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(1.0); [EOL] assertEquals(2.0, mutableDouble.doubleValue(), 0.01); [EOL] }
public void testAddWithNegativeOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(-1.0); [EOL] assertEquals(0.0, mutableDouble.doubleValue(), 0.01); [EOL] }
public void testAddWithZeroOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(0.0); [EOL] assertEquals(1.0, mutableDouble.doubleValue(), 0.01); [EOL] }
public void testAddWithNullOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] try { [EOL] mutableDouble.add(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testFloatValue_Positive() { [EOL] MyNumber number = new MyNumber(10); // Assuming MyNumber is the class and value is a field [EOL] float result = number.floatValue(); [EOL] assertEquals(10.0f, result, 0.0f); [EOL] }
public void testFloatValue_Negative() { [EOL] MyNumber number = new MyNumber(-10); // Assuming MyNumber is the class and value is a field [EOL] float result = number.floatValue(); [EOL] assertEquals(-10.0f, result, 0.0f); [EOL] }
public void testFloatValue_Zero() { [EOL] MyNumber number = new MyNumber(0); // Assuming MyNumber is the class and value is a field [EOL] float result = number.floatValue(); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testToDouble_NullValue() { [EOL] MutableDouble mutableDouble = new MutableDouble(null); [EOL] assertNull(mutableDouble.toDouble()); [EOL] }
public void testToDouble_NonNullValue() { [EOL] MutableDouble mutableDouble = new MutableDouble(0.0); [EOL] assertEquals(Double.valueOf(0.0), mutableDouble.toDouble()); [EOL] }
public void testEquals_withSameValues() { [EOL] MutableDouble md1 = new MutableDouble(1.0); [EOL] MutableDouble md2 = new MutableDouble(1.0); [EOL] assertTrue(md1.equals(md2)); [EOL] }
public void testEquals_withDifferentValues() { [EOL] MutableDouble md1 = new MutableDouble(1.0); [EOL] MutableDouble md2 = new MutableDouble(2.0); [EOL] assertFalse(md1.equals(md2)); [EOL] }
public void testEquals_withNull() { [EOL] MutableDouble md1 = new MutableDouble(1.0); [EOL] assertFalse(md1.equals(null)); [EOL] }
public void testEquals_withDifferentClass() { [EOL] MutableDouble md1 = new MutableDouble(1.0); [EOL] Object obj = new Object(); [EOL] assertFalse(md1.equals(obj)); [EOL] }
public void testToString_whenValueIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue("TestValue"); [EOL] String result = instance.toString(); [EOL] assert "TestValue".equals(result); [EOL] } [EOL] public void testToString_whenValueIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue(null); [EOL] String result = instance.toString(); [EOL] assert "null".equals(result); [EOL] }
public void testAppendToStringWithNonNullToStringContainingContentStartAndEnd() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "[content]"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart("["); [EOL] style.setContentEnd("]"); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("content,", buffer.toString()); [EOL] }
public void testAppendToStringWithNullToString() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = null; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithNonNullToStringNotContainingContentStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "content]"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart("["); [EOL] style.setContentEnd("]"); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithNonNullToStringNotContainingContentEnd() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "[content"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart("["); [EOL] style.setContentEnd("]"); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithFieldSeparatorAtStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "[content]"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart("["); [EOL] style.setContentEnd("]"); [EOL] style.setFieldSeparatorAtStart(true); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("content,", buffer.toString()); [EOL] }
public void testAppendStartWithNonNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendStart(buffer, object); [EOL] assertTrue(buffer.length() > 0); [EOL] } [EOL] public void testAppendStartWithNullObject() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendStart(buffer, null); [EOL] assertEquals(0, buffer.length()); [EOL] }
public void testAppendStartWithFieldSeparatorAtStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Object object = new Object(); [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldSeparatorAtStart(true); [EOL] style.appendStart(buffer, object); [EOL] assertTrue(buffer.toString().contains(DefaultToStringStyle.DEFAULT_STYLE.getFieldSeparator())); [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL] appendCyclicObject(buffer, fieldName, value); [EOL] return; [EOL] } [EOL] register(value); [EOL] try { [EOL] if (value instanceof Collection<?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Collection<?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL] } [EOL] } else if (value instanceof Map<?, ?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL] } [EOL] } else if (value instanceof long[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (long[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (long[]) value); [EOL] } [EOL] } else if (value instanceof int[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (int[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (int[]) value); [EOL] } [EOL] } else if (value instanceof short[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (short[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (short[]) value); [EOL] } [EOL] } else if (value instanceof byte[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (byte[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (byte[]) value); [EOL] } [EOL] } else if (value instanceof char[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (char[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (char[]) value); [EOL] } [EOL] } else if (value instanceof double[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (double[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (double[]) value); [EOL] } [EOL] } else if (value instanceof float[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (float[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (float[]) value); [EOL] } [EOL] } else if (value instanceof boolean[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (boolean[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (boolean[]) value); [EOL] } [EOL] } else if (value.getClass().isArray()) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Object[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (Object[]) value); [EOL] } [EOL] } else { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, value); [EOL] } [EOL] } [EOL] } finally { [EOL] unregister(value); [EOL] } [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] appendFieldStart(buffer, fieldName); [EOL] appendDetail(buffer, fieldName, value); [EOL] appendFieldEnd(buffer, fieldName); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] buffer.append(value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] appendFieldStart(buffer, fieldName); [EOL] if (array == null) { [EOL] appendNullText(buffer, fieldName); [EOL] } else if (isFullDetail(fullDetail)) { [EOL] appendDetail(buffer, fieldName, array); [EOL] } else { [EOL] appendSummary(buffer, fieldName, array); [EOL] } [EOL] appendFieldEnd(buffer, fieldName); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] long serialVersionUID=-2587890625525655916L; [EOL] ToStringStyle DEFAULT_STYLE=new DefaultToStringStyle(); [EOL] ToStringStyle MULTI_LINE_STYLE=new MultiLineToStringStyle(); [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=new NoFieldNameToStringStyle(); [EOL] ToStringStyle SHORT_PREFIX_STYLE=new ShortPrefixToStringStyle(); [EOL] ToStringStyle SIMPLE_STYLE=new SimpleToStringStyle(); [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=new ThreadLocal<WeakHashMap<Object, Object>>(); [EOL] boolean useFieldNames=true; [EOL] boolean useClassName=true; [EOL] boolean useShortClassName=false; [EOL] boolean useIdentityHashCode=true; [EOL] String contentStart="["; [EOL] String contentEnd="]"; [EOL] String fieldNameValueSeparator="="; [EOL] boolean fieldSeparatorAtStart=false; [EOL] boolean fieldSeparatorAtEnd=false; [EOL] String fieldSeparator=","; [EOL] String arrayStart="{"; [EOL] String arraySeparator=","; [EOL] boolean arrayContentDetail=true; [EOL] String arrayEnd="}";
protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected String getArraySeparator() { [EOL] return arraySeparator; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setArraySeparator(String arraySeparator) { [EOL] if (arraySeparator == null) { [EOL] arraySeparator = ""; [EOL] } [EOL] this.arraySeparator = arraySeparator; [EOL] }
public void testBinaryToHexDigitWithNullArray() { [EOL] try { [EOL] char result = StringUtils.binaryToHexDigit(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToHexDigitWithEmptyArray() { [EOL] try { [EOL] char result = StringUtils.binaryToHexDigit(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToHexDigitWithValidArray() { [EOL] boolean[] src = new boolean[]{true, false, false, true}; // binary for '9' [EOL] char result = StringUtils.binaryToHexDigit(src); [EOL] assertEquals('9', result); [EOL] }
public void testBinaryToHexDigitEmptyArray() { [EOL] try { [EOL] boolean[] src = {}; [EOL] int srcPos = 0; [EOL] Lang3.binaryToHexDigit(src, srcPos); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Cannot convert an empty array.", e.getMessage()); [EOL] } [EOL] }
public void testBinaryToHexDigitAllFalse() { [EOL] boolean[] src = {false, false, false, false}; [EOL] int srcPos = 0; [EOL] char result = Lang3.binaryToHexDigit(src, srcPos); [EOL] assertEquals('0', result); [EOL] }
public void testBinaryToHexDigitAllTrue() { [EOL] boolean[] src = {true, true, true, true}; [EOL] int srcPos = 0; [EOL] char result = Lang3.binaryToHexDigit(src, srcPos); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitMixedValues() { [EOL] boolean[] src = {true, false, true, false}; [EOL] int srcPos = 0; [EOL] char result = Lang3.binaryToHexDigit(src, srcPos); [EOL] assertEquals('5', result); [EOL] }
public void testBinaryToHexDigitWithOffset() { [EOL] boolean[] src = {false, false, false, true, true, true, true}; [EOL] int srcPos = 3; [EOL] char result = Lang3.binaryToHexDigit(src, srcPos); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitInvalidPosition() { [EOL] try { [EOL] boolean[] src = {true, true, true, true}; [EOL] int srcPos = 4; // Invalid position, out of bounds for the given array [EOL] Lang3.binaryToHexDigit(src, srcPos); [EOL] fail("Expected ArrayIndexOutOfBoundsException for invalid position"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testIntToHexDigit_ValidLowerBound() { [EOL] char result = Lang3.intToHexDigit(0); [EOL] assertEquals('0', result); [EOL] } [EOL] public void testIntToHexDigit_ValidUpperBound() { [EOL] char result = Lang3.intToHexDigit(15); [EOL] assertEquals('f', result); [EOL] } [EOL] public void testIntToHexDigit_InvalidLowerBound() { [EOL] try { [EOL] Lang3.intToHexDigit(-1); [EOL] fail("Expected IllegalArgumentException for input less than 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIntToHexDigit_InvalidUpperBound() { [EOL] try { [EOL] Lang3.intToHexDigit(16); [EOL] fail("Expected IllegalArgumentException for input greater than 15"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntArrayToLong_EmptySource() { [EOL] int[] src = {}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nInts = 0; [EOL] long result = ArrayUtils.intArrayToLong(src, srcPos, dstInit, dstPos, nInts); [EOL] assertEquals(dstInit, result); [EOL] }
public void testIntArrayToLong_IllegalArgument() { [EOL] int[] src = {1, 2, 3, 4}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nInts = 3; // This will cause the IllegalArgumentException [EOL] try { [EOL] ArrayUtils.intArrayToLong(src, srcPos, dstInit, dstPos, nInts); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntArrayToLong_ValidInput() { [EOL] int[] src = {1, 2, 3, 4}; [EOL] int srcPos = 1; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nInts = 2; [EOL] long expected = ((long) src[srcPos] << dstPos) | ((long) src[srcPos + 1] << (32 + dstPos)); [EOL] long result = ArrayUtils.intArrayToLong(src, srcPos, dstInit, dstPos, nInts); [EOL] assertEquals(expected, result); [EOL] }
public void testByteArrayToLongEmptySourceAndZeroPosition() { [EOL] byte[] src = new byte[0]; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBytes = 0; [EOL] long result = byteArrayToLong(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(dstInit, result); [EOL] } [EOL] public void testByteArrayToLongInvalidNBytes() { [EOL] byte[] src = new byte[] {1, 2, 3, 4}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBytes = 9; // This should cause an IllegalArgumentException [EOL] try { [EOL] byteArrayToLong(src, srcPos, dstInit, dstPos, nBytes); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nBytes-1)*8+dstPos is greather or equal to than 64", e.getMessage()); [EOL] } [EOL] } [EOL] public void testByteArrayToLongValidConversion() { [EOL] byte[] src = new byte[] {1, 2, 3, 4}; [EOL] int srcPos = 1; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBytes = 3; [EOL] long expected = ((long) src[1] & 0xffL) | [EOL] (((long) src[2] & 0xffL) << 8) | [EOL] (((long) src[3] & 0xffL) << 16); [EOL] long result = byteArrayToLong(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(expected, result); [EOL] }
public void testByteArrayToLongWithDstPos() { [EOL] byte[] src = new byte[] {1, 2, 3, 4}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 4; [EOL] int nBytes = 2; [EOL] long expected = ((long) src[0] & 0xffL) << dstPos | [EOL] (((long) src[1] & 0xffL) << (8 + dstPos)); [EOL] long result = byteArrayToLong(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(expected, result); [EOL] }
public void testByteArrayToIntEmptySourceAndZeroNBytes() { [EOL] final byte[] src = {}; [EOL] final int srcPos = 0; [EOL] final int dstInit = 0; [EOL] final int dstPos = 0; [EOL] final int nBytes = 0; [EOL] int result = byteArrayToInt(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(dstInit, result); [EOL] }
public void testByteArrayToIntIllegalArgumentException() { [EOL] final byte[] src = {1, 2, 3, 4}; [EOL] final int srcPos = 0; [EOL] final int dstInit = 0; [EOL] final int dstPos = 0; [EOL] final int nBytes = 5; // This will cause the IllegalArgumentException [EOL] try { [EOL] byteArrayToInt(src, srcPos, dstInit, dstPos, nBytes); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nBytes-1)*8+dstPos is greather or equal to than 32", e.getMessage()); [EOL] } [EOL] }
public void testByteArrayToIntValidConversion() { [EOL] final byte[] src = {1, 2, 3, 4}; [EOL] final int srcPos = 1; [EOL] final int dstInit = 0; [EOL] final int dstPos = 0; [EOL] final int nBytes = 3; [EOL] int result = byteArrayToInt(src, srcPos, dstInit, dstPos, nBytes); [EOL] int expected = ((src[1] & 0xff)) | ((src[2] & 0xff) << 8) | ((src[3] & 0xff) << 16); [EOL] assertEquals(expected, result); [EOL] }
public void testHexToShortNoHex() { [EOL] short result = SomeClass.hexToShort("0", 0, (short)0, 0, 0); [EOL] assertEquals("Expected initial value for no hex input", (short)0, result); [EOL] } [EOL] public void testHexToShortIllegalArgumentException() { [EOL] try { [EOL] SomeClass.hexToShort("01234", 0, (short)0, 0, 5); [EOL] fail("Expected IllegalArgumentException for invalid input length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testHexToShortValidInput() { [EOL] short result = SomeClass.hexToShort("0123", 0, (short)0, 0, 2); [EOL] assertEquals("Expected conversion result for valid input", (short)0x0123, result); [EOL] } [EOL] public void testHexToShortWithDstInitAndDstPos() { [EOL] short result = SomeClass.hexToShort("89AB", 2, (short)0x1234, 8, 2); [EOL] assertEquals("Expected result with initial value and position offset", (short)0x9AB4, result); [EOL] }
public void testLongToIntArray_ZeroInts() { [EOL] int[] dst = new int[10]; [EOL] int[] result = ArrayUtils.longToIntArray(0L, 0, dst, 0, 0); [EOL] assertSame("The destination array should be returned as is", dst, result); [EOL] } [EOL] public void testLongToIntArray_IllegalArgumentException() { [EOL] int[] dst = new int[10]; [EOL] try { [EOL] ArrayUtils.longToIntArray(0L, 0, dst, 0, 3); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testLongToIntArray_ValidConversion() { [EOL] int[] dst = new int[10]; [EOL] long src = 0x00000001FFFFFFFFL; // 33 bits to ensure we're testing the conversion [EOL] int[] result = ArrayUtils.longToIntArray(src, 0, dst, 5, 2); [EOL] assertEquals("First int should be the least significant bits", 0xFFFFFFFF, dst[5]); [EOL] assertEquals("Second int should be the most significant bits", 0x00000001, dst[6]); [EOL] assertSame("The destination array should be returned", dst, result); [EOL] }
public void testLongToIntArray_ValidConversionWithOffset() { [EOL] int[] dst = new int[10]; [EOL] long src = 0x00000001FFFFFFFFL; // 33 bits to ensure we're testing the conversion [EOL] int[] result = ArrayUtils.longToIntArray(src, 16, dst, 5, 1); [EOL] assertEquals("Int should be the second set of 16 bits", 0x0000FFFF, dst[5]); [EOL] assertSame("The destination array should be returned", dst, result); [EOL] }
public void testLongToShortArray_ZeroNShorts() { [EOL] long src = 0x123456789ABCDEFL; [EOL] int srcPos = 0; [EOL] short[] dst = new short[10]; [EOL] int dstPos = 0; [EOL] int nShorts = 0; [EOL] short[] result = longToShortArray(src, srcPos, dst, dstPos, nShorts); [EOL] assertArrayEquals(dst, result); [EOL] }
public void testLongToShortArray_IllegalArgumentException() { [EOL] long src = 0x123456789ABCDEFL; [EOL] int srcPos = 0; [EOL] short[] dst = new short[10]; [EOL] int dstPos = 0; [EOL] int nShorts = 5; // This will cause the IllegalArgumentException [EOL] try { [EOL] longToShortArray(src, srcPos, dst, dstPos, nShorts); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nShorts-1)*16+srcPos is greather or equal to than 64", e.getMessage()); [EOL] } [EOL] }
public void testLongToShortArray_ValidInput() { [EOL] long src = 0x123456789ABCDEFL; [EOL] int srcPos = 0; [EOL] short[] dst = new short[10]; [EOL] int dstPos = 0; [EOL] int nShorts = 4; [EOL] short[] expected = {(short) 0xCDEF, (short) 0x89AB, (short) 0x4567, (short) 0x1234}; [EOL] short[] result = longToShortArray(src, srcPos, dst, dstPos, nShorts); [EOL] for (int i = 0; i < nShorts; i++) { [EOL] assertEquals(expected[i], result[dstPos + i]); [EOL] } [EOL] }
public void testIntToByteArrayWithZeroBytes() { [EOL] byte[] dst = new byte[10]; [EOL] int src = 123456; [EOL] int srcPos = 0; [EOL] int dstPos = 0; [EOL] int nBytes = 0; [EOL] byte[] result = YourClass.intToByteArray(src, srcPos, dst, dstPos, nBytes); [EOL] assertArrayEquals("The destination array should remain unchanged when nBytes is 0.", dst, result); [EOL] }
public void testIntToByteArrayWithInvalidNBytes() { [EOL] byte[] dst = new byte[10]; [EOL] int src = 123456; [EOL] int srcPos = 0; [EOL] int dstPos = 0; [EOL] int nBytes = 5; // This should cause an IllegalArgumentException [EOL] try { [EOL] YourClass.intToByteArray(src, srcPos, dst, dstPos, nBytes); [EOL] fail("An IllegalArgumentException should have been thrown for invalid nBytes."); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntToByteArrayWithValidInput() { [EOL] byte[] dst = new byte[10]; [EOL] int src = 0x12345678; [EOL] int srcPos = 0; [EOL] int dstPos = 2; [EOL] int nBytes = 4; [EOL] byte[] expected = {0, 0, 0x78, 0x56, 0x34, 0x12, 0, 0, 0, 0}; [EOL] byte[] result = YourClass.intToByteArray(src, srcPos, dst, dstPos, nBytes); [EOL] assertArrayEquals("The destination array should have the int value inserted starting at dstPos.", expected, result); [EOL] }
public void testByteToHex_ZeroHexs() { [EOL] String result = byteToHex((byte)0x0F, 0, "initial", 0, 0); [EOL] assertEquals("initial", result); [EOL] } [EOL] public void testByteToHex_IllegalArgumentException() { [EOL] try { [EOL] byteToHex((byte)0x0F, 0, "initial", 0, 3); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nHexs-1)*4+srcPos is greather or equal to than 8", e.getMessage()); [EOL] } [EOL] }
public void testByteToHex_AppendHexDigit() { [EOL] String result = byteToHex((byte)0x0F, 0, "initial", 7, 1); [EOL] assertEquals("initialf", result); [EOL] }
public void testByteToHex_SetCharAtHexDigit() { [EOL] String result = byteToHex((byte)0x0F, 0, "initia0", 6, 1); [EOL] assertEquals("initiaf", result); [EOL] }
public void testUuidToByteArray_ZeroBytes() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] byte[] dst = new byte[16]; [EOL] byte[] result = uuidToByteArray(uuid, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testUuidToByteArray_IllegalArgumentException() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] byte[] dst = new byte[16]; [EOL] try { [EOL] uuidToByteArray(uuid, dst, 0, 17); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBytes is greather than 16", e.getMessage()); [EOL] } [EOL] } [EOL] public void testUuidToByteArray_NBytesLessThanEight() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] byte[] dst = new byte[16]; [EOL] byte[] result = uuidToByteArray(uuid, dst, 0, 4); [EOL] assertNotEquals(0, result[0]); // Assuming the UUID is not leading with zeros [EOL] assertEquals(0, result[8]); // No bytes should be written here [EOL] } [EOL] public void testUuidToByteArray_NBytesExactlyEight() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] byte[] dst = new byte[16]; [EOL] byte[] result = uuidToByteArray(uuid, dst, 0, 8); [EOL] assertNotEquals(0, result[7]); // Assuming the UUID is not leading with zeros [EOL] assertEquals(0, result[8]); // No bytes should be written here [EOL] } [EOL] public void testUuidToByteArray_NBytesMoreThanEight() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] byte[] dst = new byte[16]; [EOL] byte[] result = uuidToByteArray(uuid, dst, 0, 12); [EOL] assertNotEquals(0, result[11]); // Assuming the UUID is not leading with zeros [EOL] assertEquals(0, result[12]); // No bytes should be written here [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL] if (index != 0) { [EOL] throw new IllegalStateException("CsvEscaper should never reach the [1] index"); [EOL] } [EOL] if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) { [EOL] out.write(input.toString()); [EOL] } else { [EOL] out.write(CSV_QUOTE); [EOL] out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR)); [EOL] out.write(CSV_QUOTE); [EOL] } [EOL] return input.length(); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL] if (index != 0) { [EOL] throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL] } [EOL] if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL] out.write(input.toString()); [EOL] return input.length(); [EOL] } [EOL] final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL] if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL] out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL] } else { [EOL] out.write(input.toString()); [EOL] } [EOL] return input.length(); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }])];
public void testEscapeHtml3_withNullInput() throws IOException { [EOL] String input = null; [EOL] String result = StringEscapeUtils.escapeHtml3(input); [EOL] assertNull(result); [EOL] } [EOL] public void testEscapeHtml3_withEmptyString() throws IOException { [EOL] String input = ""; [EOL] String result = StringEscapeUtils.escapeHtml3(input); [EOL] assertEquals("", result); [EOL] } [EOL] public void testEscapeHtml3_withPlainText() throws IOException { [EOL] String input = "plain text"; [EOL] String result = StringEscapeUtils.escapeHtml3(input); [EOL] assertEquals("plain text", result); [EOL] } [EOL] public void testEscapeHtml3_withSpecialChars() throws IOException { [EOL] String input = "<>&\"'"; [EOL] String result = StringEscapeUtils.escapeHtml3(input); [EOL] assertEquals("&lt;&gt;&amp;&quot;&#39;", result); [EOL] }
public void testEscapeHtml3_withIso8859_1Chars() throws IOException { [EOL] String input = "éèêë"; [EOL] String result = StringEscapeUtils.escapeHtml3(input); [EOL] assertEquals("&#233;&#232;&#234;&#235;", result); [EOL] }
public static final String escapeCsv(final String input) { [EOL] return ESCAPE_CSV.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
